dart_library.library('dart_sdk', null, /* Imports */[
], function(exports) {
  'use strict';
  const dart = Object.create(null);
  const dartx = Object.create(null);
  const _debugger = Object.create(null);
  const _foreign_helper = Object.create(null);
  const _interceptors = Object.create(null);
  const _internal = Object.create(null);
  const _isolate_helper = Object.create(null);
  const _js_embedded_names = Object.create(null);
  const _js_helper = Object.create(null);
  const _js_mirrors = Object.create(null);
  const _js_primitives = Object.create(null);
  const _metadata = Object.create(null);
  const _native_typed_data = Object.create(null);
  const async = Object.create(null);
  const collection = Object.create(null);
  const convert = Object.create(null);
  const core = Object.create(null);
  const isolate = Object.create(null);
  const js = Object.create(null);
  const math = Object.create(null);
  const mirrors = Object.create(null);
  const typed_data = Object.create(null);
  const indexed_db = Object.create(null);
  const html$ = Object.create(null);
  const html_common = Object.create(null);
  const svg$ = Object.create(null);
  const web_audio = Object.create(null);
  const web_gl = Object.create(null);
  const web_sql = Object.create(null);
  dart.mixin = function(base, ...mixins) {
    class Mixin extends base {
      [base.name](...args) {
        for (let i = mixins.length - 1; i >= 0; i--) {
          let mixin = mixins[i];
          let init = mixin.prototype[mixin.name];
          if (init) init.call(this);
        }
        let init = base.prototype[base.name];
        if (init) init.apply(this, args);
      }
    }
    for (let m of mixins) {
      dart.copyProperties(Mixin.prototype, m.prototype);
    }
    dart.setSignature(Mixin, {
      methods: () => {
        let s = {};
        for (let m of mixins) {
          dart.copyProperties(s, m[dart._methodSig]);
        }
        return s;
      }
    });
    Mixin[dart._mixins] = mixins;
    return Mixin;
  };
  dart.getMixins = function(clazz) {
    return clazz[dart._mixins];
  };
  dart.getImplements = function(clazz) {
    return clazz[dart.implements];
  };
  dart.generic = function(typeConstructor) {
    let length = typeConstructor.length;
    if (length < 1) {
      dart.throwInternalError('must have at least one generic type argument');
    }
    let resultMap = new Map();
    function makeGenericType(...args) {
      if (args.length != length && args.length != 0) {
        dart.throwInternalError('requires ' + length + ' or 0 type arguments');
      }
      while (args.length < length)
        args.push(dart.dynamic);
      let value = resultMap;
      for (let i = 0; i < length; i++) {
        let arg = args[i];
        if (arg == null) {
          dart.throwInternalError('type arguments should not be null: ' + typeConstructor);
        }
        let map = value;
        value = map.get(arg);
        if (value === void 0) {
          if (i + 1 == length) {
            value = typeConstructor.apply(null, args);
            if (value) {
              value[dart._typeArguments] = args;
              value[dart._originalDeclaration] = makeGenericType;
            }
          } else {
            value = new Map();
          }
          map.set(arg, value);
        }
      }
      return value;
    }
    return makeGenericType;
  };
  dart.getGenericClass = function(type) {
    return dart.safeGetOwnProperty(type, dart._originalDeclaration);
  };
  dart.getGenericArgs = function(type) {
    return dart.safeGetOwnProperty(type, dart._typeArguments);
  };
  dart.getMethodType = function(obj, name) {
    let type = obj == null ? core.Object : obj.__proto__.constructor;
    return dart.getMethodTypeFromType(type, name);
  };
  dart.getMethodTypeFromType = function(type, name) {
    let sigObj = type[dart._methodSig];
    if (sigObj === void 0) return void 0;
    let parts = sigObj[name];
    if (parts === void 0) return void 0;
    return dart.definiteFunctionType.apply(null, parts);
  };
  dart.classGetConstructorType = function(cls, name) {
    if (!name) name = cls.name;
    if (cls === void 0) return void 0;
    if (cls == null) return void 0;
    let sigCtor = cls[dart._constructorSig];
    if (sigCtor === void 0) return void 0;
    let parts = sigCtor[name];
    if (parts === void 0) return void 0;
    return dart.definiteFunctionType.apply(null, parts);
  };
  dart.bind = function(obj, name, f) {
    if (f === void 0) f = obj[name];
    f = f.bind(obj);
    let sig = dart.getMethodType(obj, name);
    dart.assert(sig);
    dart.tag(f, sig);
    return f;
  };
  dart.gbind = function(f, ...typeArgs) {
    let result = f.apply(null, typeArgs);
    let sig = dart._getRuntimeType(f).apply(null, typeArgs);
    dart.tag(result, sig);
    return result;
  };
  dart._setMethodSignature = function(f, sigF) {
    dart.defineMemoizedGetter(f, dart._methodSig, () => {
      let sigObj = sigF();
      sigObj.__proto__ = f.__proto__[dart._methodSig];
      return sigObj;
    });
  };
  dart._setConstructorSignature = function(f, sigF) {
    return dart.defineMemoizedGetter(f, dart._constructorSig, sigF);
  };
  dart._setStaticSignature = function(f, sigF) {
    return dart.defineMemoizedGetter(f, dart._staticSig, sigF);
  };
  dart._setStaticTypes = function(f, names) {
    for (let name of names) {
      if (!f[name]) continue;
      dart.tagLazy(f[name], function() {
        let parts = f[dart._staticSig][name];
        return dart.definiteFunctionType.apply(null, parts);
      });
    }
  };
  dart.setSignature = function(f, signature) {
    let constructors = 'constructors' in signature ? signature.constructors : () => ({});
    let methods = 'methods' in signature ? signature.methods : () => ({});
    let statics = 'statics' in signature ? signature.statics : () => ({});
    let names = 'names' in signature ? signature.names : [];
    dart._setConstructorSignature(f, constructors);
    dart._setMethodSignature(f, methods);
    dart._setStaticSignature(f, statics);
    dart._setStaticTypes(f, names);
    dart.tagLazy(f, () => core.Type);
  };
  dart.hasMethod = function(obj, name) {
    return dart.getMethodType(obj, name) !== void 0;
  };
  dart.defineNamedConstructor = function(clazz, name) {
    let proto = clazz.prototype;
    let initMethod = proto[name];
    let ctor = function() {
      return initMethod.apply(this, arguments);
    };
    ctor.prototype = proto;
    dart.defineProperty(clazz, name, {value: ctor, configurable: true});
  };
  dart.getExtensionType = function(obj) {
    return obj[dart._extensionType];
  };
  dart.getExtensionSymbol = function(name) {
    let sym = dartx[name];
    if (sym == null) {
      sym = Symbol("dartx." + name.toString());
      dartx[name] = sym;
    }
    return sym;
  };
  dart.defineExtensionNames = function(names) {
    return names.forEach(dart.getExtensionSymbol);
  };
  dart._installProperties = function(jsProto, extProto) {
    let coreObjProto = core.Object.prototype;
    if (extProto === coreObjProto) {
      let names = dart.getOwnPropertyNames(coreObjProto);
      for (let i = 0; i < names.length; ++i) {
        let name = names[i];
        let desc = dart.getOwnPropertyDescriptor(coreObjProto, name);
        dart.defineProperty(jsProto, dart.getExtensionSymbol(name), desc);
      }
      return;
    }
    if (jsProto !== extProto) {
      dart._installProperties(jsProto, extProto.__proto__);
    }
    dart.copyTheseProperties(jsProto, extProto, dart.getOwnPropertySymbols(extProto));
  };
  dart.registerExtension = function(jsType, dartExtType) {
    if (!jsType) return;
    let extProto = dartExtType.prototype;
    let jsProto = jsType.prototype;
    jsProto[dart._extensionType] = dartExtType;
    dart._installProperties(jsProto, extProto);
    let originalSigFn = dart.getOwnPropertyDescriptor(dartExtType, dart._methodSig).get;
    dart.assert(originalSigFn);
    dart.defineMemoizedGetter(jsType, dart._methodSig, originalSigFn);
  };
  dart.defineExtensionMembers = function(type, methodNames) {
    let proto = type.prototype;
    for (let name of methodNames) {
      let method = dart.getOwnPropertyDescriptor(proto, name);
      if (!method) continue;
      dart.defineProperty(proto, dart.getExtensionSymbol(name), method);
    }
    let originalSigFn = dart.getOwnPropertyDescriptor(type, dart._methodSig).get;
    dart.defineMemoizedGetter(type, dart._methodSig, function() {
      let sig = originalSigFn();
      for (let name of methodNames) {
        sig[dart.getExtensionSymbol(name)] = sig[name];
      }
      return sig;
    });
  };
  dart.canonicalMember = function(obj, name) {
    if (typeof name === 'symbol') return name;
    if (obj != null && obj[dart._extensionType]) return dart.dartx[name];
    if (name == 'constructor' || name == 'prototype') {
      name = '+' + name;
    }
    return name;
  };
  dart.setType = function(obj, type) {
    obj.__proto__ = type.prototype;
    obj.__proto__[dart._extensionType] = type;
    return obj;
  };
  dart.list = function(obj, elementType) {
    return dart.setType(obj, dart.getGenericClass(_interceptors.JSArray)(elementType));
  };
  dart.setBaseClass = function(derived, base) {
    derived.prototype.__proto__ = base.prototype;
  };
  dart.throwCastError = function(actual, type) {
    dart.throw(new _js_helper.CastErrorImplementation(dart.typeName(actual), dart.typeName(type)));
  };
  dart.throwAssertionError = function() {
    dart.throw(new core.AssertionError());
  };
  dart.throwNullValueError = function() {
    dart.throw(new core.NoSuchMethodError(null, new core.Symbol('<Unexpected Null Value>'), null, null, null));
  };
  dart.syncStar = function(gen, E, ...args) {
    const SyncIterable_E = dart.getGenericClass(_js_helper.SyncIterable)(E);
    return new SyncIterable_E(gen, args);
  };
  dart.async = function(gen, T, ...args) {
    let iter;
    function onValue(res) {
      if (res === void 0) res = null;
      return next(iter.next(res));
    }
    function onError(err) {
      return next(iter.throw(err));
    }
    function next(ret) {
      if (ret.done) return ret.value;
      let future = ret.value;
      if (!dart.is(future, dart.getGenericClass(async.Future))) {
        future = async.Future.value(future);
      }
      return future.then(dart.dynamic)(onValue, {onError: onError});
    }
    return dart.getGenericClass(async.Future)(T).new(function() {
      iter = gen.apply(null, args)[Symbol.iterator]();
      return onValue();
    });
  };
  dart.asyncStar = function(gen, T, ...args) {
    return new dart._AsyncStarStreamController(gen, T, args).controller.stream;
  };
  dart._canonicalFieldName = function(obj, name, args, displayName) {
    name = dart.canonicalMember(obj, name);
    if (name) return name;
    dart.throwNoSuchMethodFunc(obj, displayName, args);
  };
  dart.dload = function(obj, field) {
    field = dart._canonicalFieldName(obj, field, [], field);
    if (dart.hasMethod(obj, field)) {
      return dart.bind(obj, field);
    }
    let result = obj[field];
    return result;
  };
  dart.dput = function(obj, field, value) {
    field = dart._canonicalFieldName(obj, field, [value], field);
    obj[field] = value;
    return value;
  };
  dart._checkApply = function(type, actuals) {
    if (actuals.length < type.args.length) return false;
    let index = 0;
    for (let i = 0; i < type.args.length; ++i) {
      if (!dart.instanceOfOrNull(actuals[i], type.args[i])) return false;
      ++index;
    }
    if (actuals.length == type.args.length) return true;
    let extras = actuals.length - type.args.length;
    if (type.optionals.length > 0) {
      if (extras > type.optionals.length) return false;
      for (let i = 0, j = index; i < extras; ++i, ++j) {
        if (!dart.instanceOfOrNull(actuals[j], type.optionals[i])) return false;
      }
      return true;
    }
    if (extras != 1) return false;
    if (dart.getOwnPropertyNames(type.named).length == 0) return false;
    let opts = actuals[index];
    let names = dart.getOwnPropertyNames(opts);
    if (names.length == 0) return false;
    for (var name of names) {
      if (!dart.hasOwnProperty.call(type.named, name)) {
        return false;
      }
      if (!dart.instanceOfOrNull(opts[name], type.named[name])) return false;
    }
    return true;
  };
  dart._dartSymbol = function(name) {
    return dart.const(core.Symbol.new(name.toString()));
  };
  dart.throwNoSuchMethod = function(obj, name, pArgs, nArgs, extras) {
    dart.throw(new core.NoSuchMethodError(obj, dart._dartSymbol(name), pArgs, nArgs, extras));
  };
  dart.throwNoSuchMethodFunc = function(obj, name, pArgs, opt_func) {
    if (obj === void 0) obj = opt_func;
    dart.throwNoSuchMethod(obj, name, pArgs);
  };
  dart._checkAndCall = function(f, ftype, obj, typeArgs, args, name) {
    let originalFunction = f;
    if (!(f instanceof Function)) {
      if (f != null) {
        ftype = dart.getMethodType(f, 'call');
        f = f.call;
      }
      if (!(f instanceof Function)) {
        dart.throwNoSuchMethodFunc(obj, name, args, originalFunction);
      }
    }
    if (ftype === void 0) {
      ftype = dart._getRuntimeType(f);
    }
    if (!ftype) {
      if (typeArgs != null) {
        dart.throwStrongModeError('call to JS object `' + obj + '` with type arguments <' + typeArgs + '> is not supported.');
      }
      return f.apply(obj, args);
    }
    let formalCount = ftype[dart._typeFormalCount];
    if (formalCount != null) {
      if (typeArgs == null) {
        typeArgs = Array(formalCount).fill(dart.dynamic);
      } else if (typeArgs.length != formalCount) {
        dart.throwStrongModeError('incorrect number of arguments to generic function ' + dart.typeName(ftype) + ', got <' + typeArgs + '> expected ' + formalCount + '.');
      }
      ftype = ftype.apply(null, typeArgs);
    } else if (typeArgs != null) {
      dart.throwStrongModeError('got type arguments to non-generic function ' + dart.typeName(ftype) + ', got <' + typeArgs + '> expected none.');
    }
    if (dart._checkApply(ftype, args)) {
      if (typeArgs != null) {
        return f.apply(obj, typeArgs).apply(obj, args);
      }
      return f.apply(obj, args);
    }
    dart.throwNoSuchMethodFunc(obj, name, args, originalFunction);
  };
  dart.dcall = function(f, ...args) {
    return dart._checkAndCall(f, dart._getRuntimeType(f), void 0, null, args, 'call');
  };
  dart.dgcall = function(f, typeArgs, ...args) {
    return dart._checkAndCall(f, dart._getRuntimeType(f), void 0, typeArgs, args, 'call');
  };
  dart._callMethod = function(obj, name, typeArgs, args, displayName) {
    let symbol = dart._canonicalFieldName(obj, name, args, displayName);
    let f = obj != null ? obj[symbol] : null;
    let ftype = dart.getMethodType(obj, symbol);
    return dart._checkAndCall(f, ftype, obj, typeArgs, args, displayName);
  };
  dart.dsend = function(obj, method, ...args) {
    return dart._callMethod(obj, method, null, args, method);
  };
  dart.dgsend = function(obj, typeArgs, method, ...args) {
    return dart._callMethod(obj, method, typeArgs, args, method);
  };
  dart.dindex = function(obj, index) {
    return dart._callMethod(obj, 'get', null, [index], '[]');
  };
  dart.dsetindex = function(obj, index, value) {
    return dart._callMethod(obj, 'set', null, [index, value], '[]=');
  };
  dart._ignoreMemo = function(f) {
    let memo = new Map();
    return (t1, t2) => {
      let map = memo.get(t1);
      let result;
      if (map) {
        result = map.get(t2);
        if (result !== void 0) return result;
      } else {
        memo.set(t1, map = new Map());
      }
      result = f(t1, t2);
      map.set(t2, result);
      return result;
    };
  };
  dart.strongInstanceOf = function(obj, type, ignoreFromWhiteList) {
    let actual = dart.getReifiedType(obj);
    let result = dart.isSubtype(actual, type);
    if (result || actual == dart.jsobject || actual == core.int && type == core.double) return true;
    if (result === false) return false;
    if (ignoreFromWhiteList == void 0) return result;
    if (dart._ignoreTypeFailure(actual, type)) return true;
    return result;
  };
  dart.instanceOfOrNull = function(obj, type) {
    if (obj == null || dart.strongInstanceOf(obj, type, true)) return true;
    return false;
  };
  dart.is = function(obj, type) {
    let result = dart.strongInstanceOf(obj, type);
    if (result !== null) return result;
    let actual = dart.getReifiedType(obj);
    dart.throwStrongModeError('Strong mode is check failure: ' + dart.typeName(actual) + ' does not soundly subtype ' + dart.typeName(type));
  };
  dart.as = function(obj, type) {
    if (obj == null) return obj;
    let result = dart.strongInstanceOf(obj, type, true);
    if (result) return obj;
    dart._throwCastError(obj, type, result);
  };
  dart.test = function(obj) {
    if (typeof obj == "boolean") return obj;
    dart.throwCastError(dart.getReifiedType(obj), core.bool);
  };
  dart._throwCastError = function(obj, type, result) {
    let actual = dart.getReifiedType(obj);
    if (result == false) dart.throwCastError(actual, type);
    dart.throwStrongModeError('Strong mode cast failure from ' + dart.notNull(dart.as(dart.typeName(actual), core.String)) + ' to ' + dart.notNull(dart.as(dart.typeName(type), core.String)));
  };
  dart.asInt = function(obj) {
    if (obj == null) return null;
    if (Math.floor(obj) != obj) {
      dart.throwCastError(dart.getReifiedType(obj), core.int);
    }
    return obj;
  };
  dart.equals = function(x, y) {
    if (x == null || y == null) return x == y;
    let eq = x['=='];
    return eq ? eq.call(x, y) : x === y;
  };
  dart.notNull = function(x) {
    if (x == null) dart.throwNullValueError();
    return x;
  };
  dart.map = function(values, K, V) {
    if (K === void 0) K = null;
    if (V === void 0) V = null;
    return (() => {
      if (K == null) K = dart.dynamic;
      if (V == null) V = dart.dynamic;
      let map = dart.getGenericClass(collection.LinkedHashMap)(K, V).new();
      if (Array.isArray(values)) {
        for (let i = 0, end = values.length - 1; i < end; i += 2) {
          let key = values[i];
          let value = values[i + 1];
          map.set(key, value);
        }
      } else if (typeof values === 'object') {
        for (let key of dart.getOwnPropertyNames(values)) {
          map.set(key, values[key]);
        }
      }
      return map;
    })();
  };
  dart.assert = function(condition) {
    if (!condition) dart.throwAssertionError();
  };
  dart.throw = function(obj) {
    if (obj != null && (typeof obj == 'object' || typeof obj == 'function')) {
      dart._stack.set(obj, new Error());
    }
    throw obj;
  };
  dart.getError = function(exception) {
    var stack = dart._stack.get(exception);
    return stack !== void 0 ? stack : exception;
  };
  dart.stackPrint = function(exception) {
    var error = dart.getError(exception);
    console.log(error.stack ? error.stack : 'No stack trace for: ' + error);
  };
  dart.stackTrace = function(exception) {
    var error = dart.getError(exception);
    return _js_helper.getTraceFromException(error);
  };
  dart.nullSafe = function(obj, ...callbacks) {
    if (obj == null) return obj;
    for (const callback of callbacks) {
      obj = callback(obj);
      if (obj == null) break;
    }
    return obj;
  };
  dart.multiKeyPutIfAbsent = function(map, keys, valueFn) {
    for (let k of keys) {
      let value = map.get(k);
      if (!value) {
        map.set(k, value = new Map());
      }
      map = value;
    }
    if (map.has(dart._value)) return map.get(dart._value);
    let value = valueFn();
    map.set(dart._value, value);
    return value;
  };
  dart.const = function(obj) {
    let objectKey = [dart.getReifiedType(obj)];
    for (let name of dart.getOwnNamesAndSymbols(obj)) {
      objectKey.push(name);
      objectKey.push(obj[name]);
    }
    return dart.multiKeyPutIfAbsent(dart.constants, objectKey, () => obj);
  };
  dart.hashCode = function(obj) {
    if (obj == null) return 0;
    switch (typeof obj) {
      case "number":
      {
        return obj & 0x1FFFFFFF;
      }
      case "boolean":
      {
        return obj ? 2 * 3 * 23 * 3761 : 269 * 811;
      }
    }
    let extension = dart.getExtensionType(obj);
    if (extension != null) {
      return obj[dartx.hashCode];
    }
    return obj.hashCode;
  };
  dart.toString = function(obj) {
    if (obj == null) return "null";
    let extension = dart.getExtensionType(obj);
    if (extension != null) {
      return obj[dartx.toString]();
    }
    return obj.toString();
  };
  dart.noSuchMethod = function(obj, invocation) {
    if (obj == null) {
      dart.throw(new core.NoSuchMethodError(null, invocation.memberName, invocation.positionalArguments, invocation.namedArguments));
    }
    let extension = dart.getExtensionType(obj);
    if (extension != null) {
      return obj[dartx.noSuchMethod](invocation);
    }
    return obj.noSuchMethod(invocation);
  };
  dart.runtimeType = function(obj) {
    let result = dart._checkPrimitiveType(obj);
    if (result != null) return dart.wrapType(result);
    let extension = dart.getExtensionType(obj);
    if (extension != null) {
      return obj[dartx.runtimeType];
    }
    return obj.runtimeType;
  };
  dart.fn = function(closure, rType, argsT, extras) {
    let t = null;
    if (rType == null) {
      t = dart.definiteFunctionType(dart.dynamic, Array(closure.length).fill(dart.dynamic), void 0);
    } else {
      t = dart.definiteFunctionType(rType, argsT, extras);
    }
    dart.tag(closure, t);
    return closure;
  };
  dart.lazyFn = function(closure, computeTypeParts) {
    dart.tagLazy(closure, () => {
      let parts = computeTypeParts();
      return dart.definiteFunctionType(parts[0], parts[1], parts[2]);
    });
    return closure;
  };
  dart._checkPrimitiveType = function(obj) {
    if (obj == null) return core.Null;
    switch (typeof obj) {
      case "number":
      {
        return Math.floor(obj) == obj ? core.int : core.double;
      }
      case "boolean":
      {
        return core.bool;
      }
      case "string":
      {
        return core.String;
      }
      case "symbol":
      {
        return dart.jsobject;
      }
    }
    return null;
  };
  dart.getFunctionType = function(obj) {
    let args = Array(obj.length).fill(dart.dynamic);
    return dart.definiteFunctionType(dart.bottom, args, void 0);
  };
  dart.getReifiedType = function(obj) {
    let result = dart._checkPrimitiveType(obj);
    if (result != null) return result;
    return dart._nonPrimitiveRuntimeType(obj);
  };
  dart._nonPrimitiveRuntimeType = function(obj) {
    let result = dart._getRuntimeType(obj);
    if (result != null) return result;
    result = dart.getExtensionType(obj);
    if (result != null) return result;
    result = obj.constructor;
    if (result === Function) {
      return dart.jsobject;
    }
    return result;
  };
  dart.wrapType = function(type) {
    if (type.hasOwnProperty(dart._typeObject)) {
      return type[dart._typeObject];
    }
    return type[dart._typeObject] = new dart.WrappedType(type);
  };
  dart._getRuntimeType = function(value) {
    return value[dart._runtimeType];
  };
  dart.tag = function(value, t) {
    value[dart._runtimeType] = t;
  };
  dart.tagComputed = function(value, compute) {
    dart.defineProperty(value, dart._runtimeType, {get: compute});
  };
  dart.tagLazy = function(value, compute) {
    dart.defineLazyProperty(value, dart._runtimeType, {get: compute});
  };
  dart._functionType = function(definite, returnType, args, extra) {
    if (args === void 0 && extra === void 0) {
      const fnTypeParts = returnType;
      function makeGenericFnType(...types) {
        let parts = fnTypeParts.apply(null, types);
        return dart.FunctionType.create(definite, parts[0], parts[1], parts[2]);
      }
      makeGenericFnType[dart._typeFormalCount] = fnTypeParts.length;
      return makeGenericFnType;
    }
    return dart.FunctionType.create(definite, returnType, args, extra);
  };
  dart.functionType = function(returnType, args, extra) {
    return dart._functionType(false, returnType, args, extra);
  };
  dart.definiteFunctionType = function(returnType, args, extra) {
    return dart._functionType(true, returnType, args, extra);
  };
  dart.typedef = function(name, closure) {
    return new dart.Typedef(name, closure);
  };
  dart.isDartType = function(type) {
    return dart._getRuntimeType(type) === core.Type;
  };
  dart.typeName = function(type) {
    if (type === void 0) return "undefined type";
    if (type === null) return "null type";
    if (type instanceof dart.TypeRep) {
      if (type instanceof dart.Typedef) {
        return type.name + "(" + type.functionType.toString() + ")";
      }
      return type.toString();
    }
    let tag = dart._getRuntimeType(type);
    if (tag === core.Type) {
      let name = type.name;
      let args = dart.getGenericArgs(type);
      if (!args) return name;
      let result = name;
      let allDynamic = true;
      result += '<';
      for (let i = 0; i < args.length; ++i) {
        if (i > 0) result += ', ';
        let argName = dart.typeName(args[i]);
        if (argName != 'dynamic') allDynamic = false;
        result += argName;
      }
      result += '>';
      if (allDynamic) return name;
      return result;
    }
    if (tag) return "Not a type: " + tag.name;
    return "JSObject<" + type.name + ">";
  };
  dart.getImplicitFunctionType = function(type) {
    if (dart.notNull(dart.isFunctionType(type))) return type;
    return dart.getMethodTypeFromType(type, 'call');
  };
  dart.isFunctionType = function(type) {
    return type instanceof dart.AbstractFunctionType || type === core.Function;
  };
  dart.isFunctionSubtype = function(ft1, ft2, covariant) {
    if (ft2 === core.Function) {
      return true;
    }
    let ret1 = ft1.returnType;
    let ret2 = ft2.returnType;
    let args1 = ft1.args;
    let args2 = ft2.args;
    if (args1.length > args2.length) {
      return covariant ? false : null;
    }
    for (let i = 0; i < args1.length; ++i) {
      if (!dart._isSubtype(args2[i], args1[i], !covariant)) {
        return null;
      }
    }
    let optionals1 = ft1.optionals;
    let optionals2 = ft2.optionals;
    if (args1.length + optionals1.length < args2.length + optionals2.length) {
      return covariant ? false : null;
    }
    let j = 0;
    for (let i = args1.length; i < args2.length; ++i, ++j) {
      if (!dart._isSubtype(args2[i], optionals1[j], !covariant)) {
        return null;
      }
    }
    for (let i = 0; i < optionals2.length; ++i, ++j) {
      if (!dart._isSubtype(optionals2[i], optionals1[j], !covariant)) {
        return null;
      }
    }
    let named1 = ft1.named;
    let named2 = ft2.named;
    let names = dart.getOwnPropertyNames(named2);
    for (let i = 0; i < names.length; ++i) {
      let name = names[i];
      let n1 = named1[name];
      let n2 = named2[name];
      if (n1 === void 0) {
        return covariant ? false : null;
      }
      if (!dart._isSubtype(n2, n1, !covariant)) {
        return null;
      }
    }
    if (ret2 === dart.void) return true;
    if (ret1 === dart.void) return ret2 === dart.dynamic;
    if (!dart._isSubtype(ret1, ret2, covariant)) return null;
    return true;
  };
  dart._subtypeMemo = function(f) {
    let memo = new Map();
    return (t1, t2) => {
      let map = memo.get(t1);
      let result;
      if (map) {
        result = map.get(t2);
        if (result !== void 0) return result;
      } else {
        memo.set(t1, map = new Map());
      }
      result = f(t1, t2);
      map.set(t2, result);
      return result;
    };
  };
  dart._isBottom = function(type) {
    return type == dart.bottom;
  };
  dart._isTop = function(type) {
    return type == core.Object || type == dart.dynamic;
  };
  dart._isSubtype = function(t1, t2, covariant) {
    if (t1 === t2) return true;
    if (dart._isTop(t2) || dart._isBottom(t1)) {
      return true;
    }
    if (dart._isBottom(t2)) return null;
    if (dart._isTop(t1)) {
      if (t1 === dart.dynamic) return null;
      return false;
    }
    if (!(t1 instanceof dart.AbstractFunctionType) && !(t2 instanceof dart.AbstractFunctionType)) {
      let result = dart.isClassSubType(t1, t2, covariant);
      if (result === true || result === null) return result;
    }
    t1 = dart.getImplicitFunctionType(t1);
    if (!t1) return false;
    if (dart.isFunctionType(t1) && dart.isFunctionType(t2)) {
      return dart.isFunctionSubtype(t1, t2, covariant);
    }
    return false;
  };
  dart.isClassSubType = function(t1, t2, covariant) {
    if (t1 == t2) return true;
    if (t1 == core.Object) return false;
    if (t1 == null) return t2 == core.Object || t2 == dart.dynamic;
    let raw1 = dart.getGenericClass(t1);
    let raw2 = dart.getGenericClass(t2);
    if (raw1 != null && raw1 == raw2) {
      let typeArguments1 = dart.getGenericArgs(t1);
      let typeArguments2 = dart.getGenericArgs(t2);
      let length = typeArguments1.length;
      if (typeArguments2.length == 0) {
        return true;
      } else if (length == 0) {
        if (typeArguments2.every(dart._isTop)) return true;
        return null;
      }
      dart.assert(length == typeArguments2.length);
      for (let i = 0; i < length; ++i) {
        let result = dart._isSubtype(typeArguments1[i], typeArguments2[i], covariant);
        if (!result) {
          return result;
        }
      }
      return true;
    }
    let indefinite = false;
    function definitive(t1, t2) {
      let result = dart.isClassSubType(t1, t2, covariant);
      if (result == null) {
        indefinite = true;
        return false;
      }
      return result;
    }
    if (definitive(t1.__proto__, t2)) return true;
    let mixins = dart.getMixins(t1);
    if (mixins) {
      for (let m1 of mixins) {
        if (m1 != null && definitive(m1, t2)) return true;
      }
    }
    let getInterfaces = dart.getImplements(t1);
    if (getInterfaces) {
      for (let i1 of getInterfaces()) {
        if (i1 != null && definitive(i1, t2)) return true;
      }
    }
    if (indefinite) return null;
    return false;
  };
  dart.isGroundType = function(type) {
    if (type instanceof dart.AbstractFunctionType) {
      if (!dart._isTop(type.returnType)) return false;
      for (let i = 0; i < type.args.length; ++i) {
        if (!dart._isBottom(type.args[i])) return false;
      }
      for (let i = 0; i < type.optionals.length; ++i) {
        if (!dart._isBottom(type.optionals[i])) return false;
      }
      let names = dart.getOwnPropertyNames(type.named);
      for (let i = 0; i < names.length; ++i) {
        if (!dart._isBottom(type.named[names[i]])) return false;
      }
      return true;
    }
    let typeArgs = dart.getGenericArgs(type);
    if (!typeArgs) return true;
    for (let t of typeArgs) {
      if (t != core.Object && t != dart.dynamic) return false;
    }
    return true;
  };
  dart.defineProperty = function(obj, name, desc) {
    return Object.defineProperty(obj, name, desc);
  };
  dart.getOwnPropertyDescriptor = function(obj, name) {
    return Object.getOwnPropertyDescriptor(obj, name);
  };
  dart.getOwnPropertyNames = function(obj) {
    return Object.getOwnPropertyNames(obj);
  };
  dart.getOwnPropertySymbols = function(obj) {
    return Object.getOwnPropertySymbols(obj);
  };
  dart.throwStrongModeError = function(message) {
    throw new dart.StrongModeError(message);
  };
  dart.throwInternalError = function(message) {
    throw Error(message);
  };
  dart.getOwnNamesAndSymbols = function(obj) {
    let names = dart.getOwnPropertyNames(obj);
    let symbols = dart.getOwnPropertySymbols(obj);
    return names.concat(symbols);
  };
  dart.safeGetOwnProperty = function(obj, name) {
    let desc = dart.getOwnPropertyDescriptor(obj, name);
    if (desc != null) return desc.value;
  };
  dart.defineLazyProperty = function(to, name, desc) {
    let init = desc.get;
    let value = null;
    function lazySetter(x) {
      init = null;
      value = x;
    }
    function circularInitError() {
      dart.throwInternalError('circular initialization for field ' + name);
    }
    function lazyGetter() {
      if (init == null) return value;
      let f = init;
      init = circularInitError;
      lazySetter(f());
      return value;
    }
    desc.get = lazyGetter;
    desc.configurable = true;
    if (desc.set) desc.set = lazySetter;
    return dart.defineProperty(to, name, desc);
  };
  dart.defineLazy = function(to, from) {
    for (let name of dart.getOwnNamesAndSymbols(from)) {
      dart.defineLazyProperty(to, name, dart.getOwnPropertyDescriptor(from, name));
    }
  };
  dart.defineMemoizedGetter = function(obj, name, getter) {
    return dart.defineLazyProperty(obj, name, {get: getter});
  };
  dart.copyTheseProperties = function(to, from, names) {
    for (let i = 0; i < names.length; ++i) {
      dart.copyProperty(to, from, names[i]);
    }
    return to;
  };
  dart.copyProperty = function(to, from, name) {
    let desc = dart.getOwnPropertyDescriptor(from, name);
    if (name == Symbol.iterator) {
      let existing = dart.getOwnPropertyDescriptor(to, name);
      if (existing != null) {
        if (existing.writable) {
          to[name] = desc.value;
        }
        return;
      }
    }
    dart.defineProperty(to, name, desc);
  };
  dart.export = function(to, from, name) {
    return dart.copyProperty(to, from, name);
  };
  dart.copyProperties = function(to, from) {
    return dart.copyTheseProperties(to, from, dart.getOwnNamesAndSymbols(from));
  };
  dart.global = typeof window == "undefined" ? global : window;
  dart.JsSymbol = Symbol;
  dart._mixins = Symbol("mixins");
  dart.implements = Symbol("implements");
  dart._typeArguments = Symbol("typeArguments");
  dart._originalDeclaration = Symbol("originalDeclaration");
  dart._constructorSig = Symbol("sigCtor");
  dart._methodSig = Symbol("sig");
  dart._staticSig = Symbol("sigStatic");
  dart._extensionType = Symbol("extensionType");
  dart.dartx = dartx;
  dart._jsIterator = Symbol("_jsIterator");
  dart._current = Symbol("_current");
  dart._AsyncStarStreamController = class _AsyncStarStreamController {
    constructor(generator, T, args) {
      this.isAdding = false;
      this.isWaiting = false;
      this.isScheduled = false;
      this.isSuspendedAtYield = false;
      this.canceler = null;
      this.iterator = generator(this, ...args)[Symbol.iterator]();
      this.controller = dart.getGenericClass(async.StreamController)(T).new({
        onListen: () => this.scheduleGenerator(),
        onResume: () => this.onResume(),
        onCancel: () => this.onCancel()
      });
    }
    onResume() {
      if (this.isSuspendedAtYield) {
        this.scheduleGenerator();
      }
    }
    onCancel() {
      if (this.controller.isClosed) {
        return null;
      }
      if (this.canceler == null) {
        this.canceler = async.Completer.new();
        this.scheduleGenerator();
      }
      return this.canceler.future;
    }
    close() {
      if (this.canceler != null && !this.canceler.isCompleted) {
        this.canceler.complete();
      }
      this.controller.close();
    }
    scheduleGenerator() {
      if (this.isScheduled || this.controller.isPaused || this.isAdding || this.isWaiting) {
        return;
      }
      this.isScheduled = true;
      async.scheduleMicrotask(() => this.runBody());
    }
    runBody(opt_awaitValue) {
      this.isScheduled = false;
      this.isSuspendedAtYield = false;
      this.isWaiting = false;
      let iter;
      try {
        iter = this.iterator.next(opt_awaitValue);
      } catch (e) {
        this.addError(e, dart.stackTrace(e));
        this.close();
        return;
      }

      if (iter.done) {
        this.close();
        return;
      }
      if (this.isSuspendedAtYield || this.isAdding) return;
      this.isWaiting = true;
      let future = iter.value;
      if (!dart.is(future, dart.getGenericClass(async.Future))) {
        future = async.Future.value(future);
      }
      return future.then(dart.dynamic)(x => this.runBody(x), {
        onError: (e, s) => this.throwError(e, s)
      });
    }
    add(event) {
      if (!this.controller.hasListener) return true;
      this.controller.add(event);
      this.scheduleGenerator();
      this.isSuspendedAtYield = true;
      return false;
    }
    addStream(stream) {
      if (!this.controller.hasListener) return true;
      this.isAdding = true;
      this.controller.addStream(stream, {cancelOnError: false}).then(dart.dynamic)(() => {
        this.isAdding = false;
        this.scheduleGenerator();
      }, {
        onError: (e, s) => this.throwError(e, s)
      });
    }
    throwError(error, stackTrace) {
      try {
        this.iterator.throw(error);
      } catch (e) {
        this.addError(e, stackTrace);
      }

    }
    addError(error, stackTrace) {
      if (this.canceler != null && !this.canceler.isCompleted) {
        this.canceler.completeError(error, stackTrace);
        return;
      }
      if (!this.controller.hasListener) return;
      this.controller.addError(error, stackTrace);
    }
  };
  dart._ignoreTypeFailure = (() => {
    return dart._ignoreMemo((actual, type) => {
      if (!!dart.isSubtype(type, core.Iterable) && !!dart.isSubtype(actual, core.Iterable) || !!dart.isSubtype(type, async.Future) && !!dart.isSubtype(actual, async.Future) || !!dart.isSubtype(type, core.Map) && !!dart.isSubtype(actual, core.Map) || dart.isFunctionType(type) && dart.isFunctionType(actual) || !!dart.isSubtype(type, async.Stream) && !!dart.isSubtype(actual, async.Stream) || !!dart.isSubtype(type, async.StreamSubscription) && !!dart.isSubtype(actual, async.StreamSubscription)) {
        console.warn('Ignoring cast fail from ' + dart.typeName(actual) + ' to ' + dart.typeName(type));
        return true;
      }
      return false;
    });
  })();
  dart._stack = new WeakMap();
  dart._value = Symbol("_value");
  dart.constants = new Map();
  dart.JsIterator = class JsIterator {
    constructor(dartIterator) {
      this.dartIterator = dartIterator;
    }
    next() {
      let i = this.dartIterator;
      let done = !i.moveNext();
      return {done: done, value: done ? void 0 : i.current};
    }
  };
  dart._runtimeType = Symbol("_runtimeType");
  dart.metadata = Symbol("metadata");
  dart._typeObject = Symbol("typeObject");
  core.Object = class Object {
    constructor() {
      let name = this.constructor.name;
      let result = void 0;
      if (name in this) result = this[name].apply(this, arguments);
      return result === void 0 ? this : result;
    }
    ['=='](other) {
      return core.identical(this, other);
    }
    get hashCode() {
      return _js_helper.Primitives.objectHashCode(this);
    }
    toString() {
      return _js_helper.Primitives.objectToString(this);
    }
    noSuchMethod(invocation) {
      dart.throw(new core.NoSuchMethodError(this, invocation.memberName, invocation.positionalArguments, invocation.namedArguments));
    }
    get runtimeType() {
      return dart.wrapType(dart.getReifiedType(this));
    }
  };
  dart.setSignature(core.Object, {
    constructors: () => ({Object: [core.Object, []]}),
    methods: () => ({
      '==': [core.bool, [dart.dynamic]],
      toString: [core.String, []],
      noSuchMethod: [dart.dynamic, [core.Invocation]]
    })
  });
  dart.TypeRep = class TypeRep extends core.Object {
    get name() {
      return this.toString();
    }
  };
  dart.TypeRep[dart.implements] = () => [core.Type];
  dart.Dynamic = class Dynamic extends dart.TypeRep {
    toString() {
      return 'dynamic';
    }
  };
  dart.dynamic = new dart.Dynamic();
  dart.Void = class Void extends dart.TypeRep {
    toString() {
      return 'void';
    }
  };
  dart.void = new dart.Void();
  dart.Bottom = class Bottom extends dart.TypeRep {
    toString() {
      return 'bottom';
    }
  };
  dart.bottom = new dart.Bottom();
  dart.JSObject = class JSObject extends dart.TypeRep {
    toString() {
      return 'NativeJavaScriptObject';
    }
  };
  dart.jsobject = new dart.JSObject();
  const _runtimeType = Symbol('_runtimeType');
  dart.WrappedType = class WrappedType extends dart.TypeRep {
    WrappedType(runtimeType) {
      this[_runtimeType] = runtimeType;
    }
    toString() {
      return dart.as(dart.typeName(this[_runtimeType]), core.String);
    }
  };
  dart.setSignature(dart.WrappedType, {
    constructors: () => ({WrappedType: [dart.WrappedType, [dart.dynamic]]})
  });
  dart.AbstractFunctionType = class AbstractFunctionType extends dart.TypeRep {
    constructor() {
      super();
      this._stringValue = null;
    }
    toString() {
      return this.name;
    }
    get name() {
      if (this._stringValue) return this._stringValue;
      let buffer = '(';
      for (let i = 0; i < this.args.length; ++i) {
        if (i > 0) {
          buffer += ', ';
        }
        buffer += dart.typeName(this.args[i]);
      }
      if (this.optionals.length > 0) {
        if (this.args.length > 0) buffer += ', ';
        buffer += '[';
        for (let i = 0; i < this.optionals.length; ++i) {
          if (i > 0) {
            buffer += ', ';
          }
          buffer += dart.typeName(this.optionals[i]);
        }
        buffer += ']';
      } else if (Object.keys(this.named).length > 0) {
        if (this.args.length > 0) buffer += ', ';
        buffer += '{';
        let names = dart.getOwnPropertyNames(this.named).sort();
        for (let i = 0; i < names.length; ++i) {
          if (i > 0) {
            buffer += ', ';
          }
          buffer += names[i] + ': ' + dart.typeName(this.named[names[i]]);
        }
        buffer += '}';
      }
      buffer += ') -> ' + dart.typeName(this.returnType);
      this._stringValue = buffer;
      return buffer;
    }
  };
  dart._fnTypeNamedArgMap = new Map();
  dart._fnTypeArrayArgMap = new Map();
  dart._fnTypeTypeMap = new Map();
  dart._fnTypeSmallMap = [new Map(), new Map(), new Map()];
  dart.FunctionType = class FunctionType extends dart.AbstractFunctionType {
    static _memoizeArray(map, arr, create) {
      let len = arr.length;
      map = FunctionType._lookupNonTerminal(map, len);
      for (var i = 0; i < len - 1; ++i) {
        map = FunctionType._lookupNonTerminal(map, arr[i]);
      }
      let result = map.get(arr[len - 1]);
      if (result !== void 0) return result;
      map.set(arr[len - 1], result = create());
      return result;
    }
    static _normalizeParameter(a) {
      if (a instanceof Array) {
        let result = [];
        result.push(a[0] == dart.dynamic ? dart.bottom : a[0]);
        result.push(a.slice(1));
        return result;
      }
      return a == dart.dynamic ? dart.bottom : a;
    }
    static _canonicalizeArray(definite, array, map) {
      let arr = definite ? array : array.map(FunctionType._normalizeParameter);
      return FunctionType._memoizeArray(map, arr, () => arr);
    }
    static _canonicalizeNamed(definite, named, map) {
      let key = [];
      let names = dart.getOwnPropertyNames(named);
      let r = {};
      for (var i = 0; i < names.length; ++i) {
        let name = names[i];
        let type = named[name];
        if (!definite) r[name] = type = FunctionType._normalizeParameter(type);
        key.push(name);
        key.push(type);
      }
      if (!definite) named = r;
      return FunctionType._memoizeArray(map, key, () => named);
    }
    static _lookupNonTerminal(map, key) {
      let result = map.get(key);
      if (result !== void 0) return result;
      map.set(key, result = new Map());
      return result;
    }
    static _createSmall(count, definite, returnType, required) {
      let map = dart._fnTypeSmallMap[count];
      let args = definite ? required : required.map(FunctionType._normalizeParameter);
      for (var i = 0; i < count; ++i) {
        map = FunctionType._lookupNonTerminal(map, args[i]);
      }
      let result = map.get(returnType);
      if (result !== void 0) return result;
      result = new FunctionType(returnType, args, [], {});
      map.set(returnType, result);
      return result;
    }
    static create(definite, returnType, args, extra) {
      if (extra === void 0 && args.length < 3) {
        return FunctionType._createSmall(args.length, definite, returnType, args);
      }
      args = FunctionType._canonicalizeArray(definite, args, dart._fnTypeArrayArgMap);
      let keys;
      let create;
      if (extra === void 0) {
        keys = [returnType, args];
        create = () => new FunctionType(returnType, args, [], {});
      } else if (extra instanceof Array) {
        let optionals = FunctionType._canonicalizeArray(definite, extra, dart._fnTypeArrayArgMap);
        keys = [returnType, args, optionals];
        create = () => new FunctionType(returnType, args, optionals, {});
      } else {
        let named = FunctionType._canonicalizeNamed(definite, extra, dart._fnTypeNamedArgMap);
        keys = [returnType, args, named];
        create = () => new FunctionType(returnType, args, [], named);
      }
      return FunctionType._memoizeArray(dart._fnTypeTypeMap, keys, create);
    }
    constructor(returnType, args, optionals, named) {
      super();
      this.returnType = returnType;
      this.args = args;
      this.optionals = optionals;
      this.named = named;
      this.metadata = [];
      function process(array, metadata) {
        var result = [];
        for (var i = 0; i < array.length; ++i) {
          var arg = array[i];
          if (arg instanceof Array) {
            metadata.push(arg[1]);
            result.push(arg[0]);
          } else {
            metadata.push([]);
            result.push(arg);
          }
        }
        return result;
      }
      this.args = process(this.args, this.metadata);
      this.optionals = process(this.optionals, this.metadata);
    }
  };
  dart.Typedef = class Typedef extends dart.AbstractFunctionType {
    constructor(name, closure) {
      super();
      this._name = name;
      this._closure = closure;
      this._functionType = null;
    }
    get name() {
      return this._name;
    }
    get functionType() {
      if (!this._functionType) {
        this._functionType = this._closure();
      }
      return this._functionType;
    }
    get returnType() {
      return this.functionType.returnType;
    }
    get args() {
      return this.functionType.args;
    }
    get optionals() {
      return this.functionType.optionals;
    }
    get named() {
      return this.functionType.named;
    }
    get metadata() {
      return this.functionType.metadata;
    }
  };
  dart._typeFormalCount = Symbol("_typeFormalCount");
  dart.isSubtype = dart._subtypeMemo((t1, t2) => t1 === t2 || dart._isSubtype(t1, t2, true));
  dart.hasOwnProperty = Object.prototype.hasOwnProperty;
  dart.StrongModeError = (function() {
    function StrongModeError(message) {
      Error.call(this);
      this.message = message;
    }
    ;
    Object.setPrototypeOf(StrongModeError.prototype, Error.prototype);
    return StrongModeError;
  })();
  _debugger.skipDartConfig = dart.const(new core.Object());
  _debugger.maxIterableChildrenToDisplay = 50;
  dart.defineLazy(_debugger, {
    get _devtoolsFormatter() {
      return new _debugger.JsonMLFormatter(new _debugger.DartFormatter());
    },
    set _devtoolsFormatter(_) {}
  });
  _debugger._typeof = function(object) {
    return typeof object;
  };
  dart.lazyFn(_debugger._typeof, () => [core.String, [dart.dynamic]]);
  _debugger._instanceof = function(object, clazz) {
    return object instanceof clazz;
  };
  dart.lazyFn(_debugger._instanceof, () => [core.bool, [dart.dynamic, dart.dynamic]]);
  _debugger.getOwnPropertyNames = function(object) {
    return dart.list(Object.getOwnPropertyNames(object), core.String);
  };
  dart.lazyFn(_debugger.getOwnPropertyNames, () => [core.List$(core.String), [dart.dynamic]]);
  _debugger.getOwnPropertySymbols = function(object) {
    return Object.getOwnPropertySymbols(object);
  };
  dart.lazyFn(_debugger.getOwnPropertySymbols, () => [core.List, [dart.dynamic]]);
  _debugger.JSNative = class JSNative extends core.Object {
    static getProperty(object, name) {
      return object[name];
    }
    static setProperty(object, name, value) {
      return object[name] = value;
    }
  };
  dart.setSignature(_debugger.JSNative, {
    statics: () => ({
      getProperty: [dart.dynamic, [dart.dynamic, dart.dynamic]],
      setProperty: [dart.dynamic, [dart.dynamic, dart.dynamic, dart.dynamic]]
    }),
    names: ['getProperty', 'setProperty']
  });
  _debugger.isRegularDartObject = function(object) {
    if (_debugger._typeof(object) == 'function') return false;
    return _debugger._instanceof(object, core.Object);
  };
  dart.lazyFn(_debugger.isRegularDartObject, () => [core.bool, [dart.dynamic]]);
  _debugger.getObjectTypeName = function(object) {
    let reifiedType = dart.getReifiedType(object);
    if (reifiedType == null) {
      if (_debugger._typeof(object) == 'function') {
        return '[[Raw JavaScript Function]]';
      }
      return '<Error getting type name>';
    }
    return _debugger.getTypeName(dart.as(reifiedType, core.Type));
  };
  dart.lazyFn(_debugger.getObjectTypeName, () => [core.String, [dart.dynamic]]);
  _debugger.getTypeName = function(type) {
    let name = dart.typeName(type);
    if (dart.equals(name, 'JSArray<dynamic>') || dart.equals(name, 'JSObject<Array>')) return 'List<dynamic>';
    return dart.as(name, core.String);
  };
  dart.lazyFn(_debugger.getTypeName, () => [core.String, [core.Type]]);
  const _simpleFormatter = Symbol('_simpleFormatter');
  _debugger.safePreview = function(object) {
    try {
      let preview = _debugger._devtoolsFormatter[_simpleFormatter].preview(object);
      if (preview != null) return preview;
      return dart.toString(object);
    } catch (e) {
      return '<Exception thrown>';
    }

  };
  dart.lazyFn(_debugger.safePreview, () => [core.String, [dart.dynamic]]);
  _debugger.symbolName = function(symbol) {
    let name = dart.toString(symbol);
    dart.assert(name[dartx.startsWith]('Symbol('));
    return name[dartx.substring]('Symbol('[dartx.length], dart.notNull(name[dartx.length]) - 1);
  };
  dart.lazyFn(_debugger.symbolName, () => [core.String, [dart.dynamic]]);
  _debugger.hasMethod = function(object, name) {
    try {
      return dart.as(dart.hasMethod(object, name), core.bool);
    } catch (e) {
      return false;
    }

  };
  dart.lazyFn(_debugger.hasMethod, () => [core.bool, [dart.dynamic, core.String]]);
  _debugger.NameValuePair = class NameValuePair extends core.Object {
    NameValuePair(opts) {
      let name = opts && 'name' in opts ? opts.name : null;
      let value = opts && 'value' in opts ? opts.value : null;
      let skipDart = opts && 'skipDart' in opts ? opts.skipDart : null;
      this.name = name;
      this.value = value;
      this.skipDart = skipDart == true;
    }
  };
  dart.setSignature(_debugger.NameValuePair, {
    constructors: () => ({NameValuePair: [_debugger.NameValuePair, [], {name: core.String, value: core.Object, skipDart: core.bool}]})
  });
  _debugger.MapEntry = class MapEntry extends core.Object {
    MapEntry(opts) {
      let key = opts && 'key' in opts ? opts.key : null;
      let value = opts && 'value' in opts ? opts.value : null;
      this.key = key;
      this.value = value;
    }
  };
  dart.setSignature(_debugger.MapEntry, {
    constructors: () => ({MapEntry: [_debugger.MapEntry, [], {key: core.String, value: core.Object}]})
  });
  _debugger.ClassMetadata = class ClassMetadata extends core.Object {
    ClassMetadata(object) {
      this.object = object;
    }
  };
  dart.setSignature(_debugger.ClassMetadata, {
    constructors: () => ({ClassMetadata: [_debugger.ClassMetadata, [core.Object]]})
  });
  _debugger.HeritageClause = class HeritageClause extends core.Object {
    HeritageClause(name, types) {
      this.name = name;
      this.types = types;
    }
  };
  dart.setSignature(_debugger.HeritageClause, {
    constructors: () => ({HeritageClause: [_debugger.HeritageClause, [core.String, core.List]]})
  });
  const _attributes = Symbol('_attributes');
  const _jsonML = Symbol('_jsonML');
  _debugger.JsonMLElement = class JsonMLElement extends core.Object {
    JsonMLElement(tagName) {
      this[_attributes] = null;
      this[_jsonML] = null;
      this[_attributes] = {};
      this[_jsonML] = [tagName, this[_attributes]];
    }
    appendChild(element) {
      this[_jsonML][dartx.add](dart.dsend(element, 'toJsonML'));
    }
    createChild(tagName) {
      let c = new _debugger.JsonMLElement(tagName);
      this[_jsonML][dartx.add](c.toJsonML());
      return c;
    }
    createObjectTag(object) {
      return (() => {
        let _ = this.createChild('object');
        _.addAttribute('object', object);
        return _;
      })();
    }
    setStyle(style) {
      dart.dput(this[_attributes], 'style', style);
    }
    addStyle(style) {
      if (dart.dload(this[_attributes], 'style') == null) {
        dart.dput(this[_attributes], 'style', style);
      } else {
        let o = this[_attributes];
        dart.dput(o, 'style', dart.dsend(dart.dload(o, 'style'), '+', style));
      }
    }
    addAttribute(key, value) {
      _debugger.JSNative.setProperty(this[_attributes], key, value);
    }
    createTextChild(text) {
      this[_jsonML][dartx.add](text);
    }
    toJsonML() {
      return this[_jsonML];
    }
  };
  dart.setSignature(_debugger.JsonMLElement, {
    constructors: () => ({JsonMLElement: [_debugger.JsonMLElement, [dart.dynamic]]}),
    methods: () => ({
      appendChild: [dart.dynamic, [dart.dynamic]],
      createChild: [_debugger.JsonMLElement, [core.String]],
      createObjectTag: [_debugger.JsonMLElement, [dart.dynamic]],
      setStyle: [dart.void, [core.String]],
      addStyle: [dart.dynamic, [core.String]],
      addAttribute: [dart.dynamic, [dart.dynamic, dart.dynamic]],
      createTextChild: [dart.dynamic, [core.String]],
      toJsonML: [dart.dynamic, []]
    })
  });
  _debugger.JsonMLFormatter = class JsonMLFormatter extends core.Object {
    JsonMLFormatter(simpleFormatter) {
      this[_simpleFormatter] = simpleFormatter;
    }
    header(object, config) {
      if (core.identical(config, _debugger.skipDartConfig)) return null;
      let c = this[_simpleFormatter].preview(object);
      if (c == null) return null;
      let element = new _debugger.JsonMLElement('span');
      element.setStyle('background-color: #d9edf7');
      element.createTextChild(c);
      return element.toJsonML();
    }
    hasBody(object) {
      return this[_simpleFormatter].hasChildren(object);
    }
    body(object) {
      let body = new _debugger.JsonMLElement('ol');
      body.setStyle('list-style-type: none;' + 'padding-left: 0px;' + 'margin-top: 0px;' + 'margin-bottom: 0px;' + 'margin-left: 12px');
      let children = this[_simpleFormatter].children(object);
      for (let child of children) {
        let li = body.createChild('li');
        let nameSpan = new _debugger.JsonMLElement('span');
        nameSpan.createTextChild(child.name != null ? dart.notNull(child.name) + ': ' : '');
        nameSpan.setStyle('color: rgb(136, 19, 145);');
        if (_debugger._typeof(child.value) == 'object' || _debugger._typeof(child.value) == 'function') {
          nameSpan.addStyle("padding-left: 13px;");
          li.appendChild(nameSpan);
          let objectTag = li.createObjectTag(child.value);
          if (dart.notNull(child.skipDart)) {
            objectTag.addAttribute('config', _debugger.skipDartConfig);
          }
          if (!dart.notNull(this[_simpleFormatter].hasChildren(child.value))) {
            li.setStyle("padding-left: 13px;");
          }
        } else {
          li.setStyle("padding-left: 13px;");
          let _ = li.createChild('span');
          _.appendChild(nameSpan);
          _.createTextChild(_debugger.safePreview(child.value));
        }
      }
      return body.toJsonML();
    }
  };
  dart.setSignature(_debugger.JsonMLFormatter, {
    constructors: () => ({JsonMLFormatter: [_debugger.JsonMLFormatter, [_debugger.DartFormatter]]}),
    methods: () => ({
      header: [dart.dynamic, [dart.dynamic, dart.dynamic]],
      hasBody: [core.bool, [dart.dynamic]],
      body: [dart.dynamic, [dart.dynamic]]
    })
  });
  _debugger.Formatter = class Formatter extends core.Object {};
  const _formatters = Symbol('_formatters');
  _debugger.DartFormatter = class DartFormatter extends core.Object {
    DartFormatter() {
      this[_formatters] = null;
      this[_formatters] = dart.list([new _debugger.FunctionFormatter(), new _debugger.MapFormatter(), new _debugger.IterableFormatter(), new _debugger.MapEntryFormatter(), new _debugger.ClassMetadataFormatter(), new _debugger.HeritageClauseFormatter(), new _debugger.ObjectFormatter()], _debugger.Formatter);
    }
    preview(object) {
      if (object == null) return 'null';
      if (typeof object == 'number') return dart.toString(object);
      if (typeof object == 'string') return `"${object}"`;
      for (let formatter of this[_formatters]) {
        if (dart.notNull(formatter.accept(object))) return formatter.preview(object);
      }
      return null;
    }
    hasChildren(object) {
      if (object == null) return false;
      for (let formatter of this[_formatters]) {
        if (dart.notNull(formatter.accept(object))) return formatter.hasChildren(object);
      }
      return false;
    }
    children(object) {
      if (object != null) {
        for (let formatter of this[_formatters]) {
          if (dart.notNull(formatter.accept(object))) return formatter.children(object);
        }
      }
      return dart.list([], _debugger.NameValuePair);
    }
  };
  dart.setSignature(_debugger.DartFormatter, {
    constructors: () => ({DartFormatter: [_debugger.DartFormatter, []]}),
    methods: () => ({
      preview: [core.String, [dart.dynamic]],
      hasChildren: [core.bool, [dart.dynamic]],
      children: [core.List$(_debugger.NameValuePair), [dart.dynamic]]
    })
  });
  const _addMembers = Symbol('_addMembers');
  _debugger.ObjectFormatter = class ObjectFormatter extends _debugger.Formatter {
    accept(object) {
      return _debugger.isRegularDartObject(object);
    }
    preview(object) {
      return _debugger.getObjectTypeName(object);
    }
    hasChildren(object) {
      return true;
    }
    [_addMembers](current, object, properties) {
      let className = dart.dload(dart.getReifiedType(current), 'name');
      for (let name of _debugger.getOwnPropertyNames(current)) {
        if (name == 'constructor' || name == '__proto__' || dart.equals(name, className)) continue;
        if (dart.notNull(_debugger.hasMethod(object, name))) {
          continue;
        }
        let value = null;
        try {
          value = _debugger.JSNative.getProperty(object, name);
        } catch (e) {
          value = '<Exception thrown>';
        }

        properties[dartx.add](new _debugger.NameValuePair({name: name, value: value}));
      }
      for (let symbol of _debugger.getOwnPropertySymbols(current)) {
        let dartName = _debugger.symbolName(symbol);
        if (dart.notNull(_debugger.hasMethod(object, dartName))) {
          continue;
        }
        let value = null;
        try {
          value = _debugger.JSNative.getProperty(object, symbol);
        } catch (e) {
          value = '<Exception thrown>';
        }

        properties[dartx.add](new _debugger.NameValuePair({name: dartName, value: value}));
      }
      let base = _debugger.JSNative.getProperty(current, '__proto__');
      if (base == null) return;
      if (dart.notNull(_debugger.isRegularDartObject(base))) {
        this[_addMembers](base, object, properties);
      }
    }
    children(object) {
      let properties = dart.list([], _debugger.NameValuePair);
      this.addMetadataChildren(object, properties);
      this[_addMembers](object, object, properties);
      return properties;
    }
    addMetadataChildren(object, ret) {
      ret[dartx.add](new _debugger.NameValuePair({name: '[[class]]', value: new _debugger.ClassMetadata(object)}));
    }
  };
  dart.setSignature(_debugger.ObjectFormatter, {
    methods: () => ({
      accept: [core.bool, [dart.dynamic]],
      preview: [core.String, [dart.dynamic]],
      hasChildren: [core.bool, [dart.dynamic]],
      [_addMembers]: [dart.dynamic, [dart.dynamic, dart.dynamic, core.List$(_debugger.NameValuePair)]],
      children: [core.List$(_debugger.NameValuePair), [dart.dynamic]],
      addMetadataChildren: [dart.dynamic, [dart.dynamic, core.List$(_debugger.NameValuePair)]]
    })
  });
  _debugger.FunctionFormatter = class FunctionFormatter extends _debugger.Formatter {
    accept(object) {
      if (_debugger._typeof(object) != 'function') return false;
      return dart.getReifiedType(object) != null;
    }
    hasChildren(object) {
      return true;
    }
    preview(object) {
      return dart.as(dart.typeName(dart.getReifiedType(object)), core.String);
    }
    children(object) {
      return dart.list([new _debugger.NameValuePair({name: 'signature', value: this.preview(object)}), new _debugger.NameValuePair({name: 'JavaScript Function', value: object, skipDart: true})], _debugger.NameValuePair);
    }
  };
  dart.setSignature(_debugger.FunctionFormatter, {
    methods: () => ({
      accept: [core.bool, [dart.dynamic]],
      hasChildren: [core.bool, [dart.dynamic]],
      preview: [core.String, [dart.dynamic]],
      children: [core.List$(_debugger.NameValuePair), [dart.dynamic]]
    })
  });
  _debugger.MapFormatter = class MapFormatter extends _debugger.ObjectFormatter {
    accept(object) {
      return dart.is(object, core.Map);
    }
    hasChildren(object) {
      return true;
    }
    preview(object) {
      let map = dart.as(object, core.Map);
      return `${_debugger.getObjectTypeName(map)} length ${map[dartx.length]}`;
    }
    children(object) {
      let map = dart.as(object, core.Map);
      let keys = map[dartx.keys][dartx.toList]();
      let entries = dart.list([], _debugger.NameValuePair);
      map[dartx.forEach](dart.fn((key, value) => {
        let entryWrapper = new _debugger.MapEntry({key: dart.as(key, core.String), value: value});
        entries[dartx.add](new _debugger.NameValuePair({name: dart.toString(entries[dartx.length]), value: entryWrapper}));
      }, dart.void, [dart.dynamic, dart.dynamic]));
      this.addMetadataChildren(object, entries);
      return entries;
    }
  };
  _debugger.IterableFormatter = class IterableFormatter extends _debugger.ObjectFormatter {
    accept(object) {
      return dart.is(object, core.Iterable);
    }
    preview(object) {
      let iterable = dart.as(object, core.Iterable);
      try {
        let length = iterable[dartx.length];
        return `${_debugger.getObjectTypeName(iterable)} length ${length}`;
      } catch (_) {
        return `${_debugger.getObjectTypeName(iterable)}`;
      }

    }
    hasChildren(object) {
      return true;
    }
    children(object) {
      let iterable = dart.as(object, core.Iterable);
      let ret = dart.list([], _debugger.NameValuePair);
      let i = 0;
      for (let entry of iterable) {
        if (i > dart.notNull(_debugger.maxIterableChildrenToDisplay)) {
          ret[dartx.add](new _debugger.NameValuePair({name: 'Warning', value: 'Truncated Iterable display'}));
          break;
        }
        ret[dartx.add](new _debugger.NameValuePair({name: dart.toString(i), value: entry}));
        i++;
      }
      this.addMetadataChildren(object, ret);
      return ret;
    }
  };
  const _getType = Symbol('_getType');
  _debugger.ClassMetadataFormatter = class ClassMetadataFormatter extends core.Object {
    accept(object) {
      return dart.is(object, _debugger.ClassMetadata);
    }
    [_getType](object) {
      if (dart.is(object, core.Type)) return object;
      return dart.getReifiedType(object);
    }
    preview(object) {
      let entry = dart.as(object, _debugger.ClassMetadata);
      return _debugger.getTypeName(dart.as(this[_getType](entry.object), core.Type));
    }
    hasChildren(object) {
      return true;
    }
    children(object) {
      let entry = dart.as(object, _debugger.ClassMetadata);
      let type = this[_getType](entry.object);
      let ret = dart.list([], _debugger.NameValuePair);
      let implements$ = dart.getImplements(type);
      if (implements$ != null) {
        ret[dartx.add](new _debugger.NameValuePair({name: '[[Implements]]', value: new _debugger.HeritageClause('implements', dart.as(dart.dcall(implements$), core.List))}));
      }
      let mixins = dart.getMixins(type);
      if (mixins != null) {
        ret[dartx.add](new _debugger.NameValuePair({name: '[[Mixins]]', value: new _debugger.HeritageClause('mixins', dart.as(dart.dcall(mixins), core.List))}));
      }
      ret[dartx.add](new _debugger.NameValuePair({name: '[[JavaScript View]]', value: entry.object, skipDart: true}));
      if (!dart.is(entry.object, core.Type)) {
        ret[dartx.add](new _debugger.NameValuePair({name: '[[JavaScript Constructor]]', value: _debugger.JSNative.getProperty(entry.object, 'constructor'), skipDart: true}));
      }
      return ret;
    }
  };
  _debugger.ClassMetadataFormatter[dart.implements] = () => [_debugger.Formatter];
  dart.setSignature(_debugger.ClassMetadataFormatter, {
    methods: () => ({
      accept: [core.bool, [dart.dynamic]],
      [_getType]: [dart.dynamic, [dart.dynamic]],
      preview: [core.String, [dart.dynamic]],
      hasChildren: [core.bool, [dart.dynamic]],
      children: [core.List$(_debugger.NameValuePair), [dart.dynamic]]
    })
  });
  _debugger.MapEntryFormatter = class MapEntryFormatter extends core.Object {
    accept(object) {
      return dart.is(object, _debugger.MapEntry);
    }
    preview(object) {
      let entry = dart.as(object, _debugger.MapEntry);
      return `${_debugger.safePreview(entry.key)} => ${_debugger.safePreview(entry.value)}`;
    }
    hasChildren(object) {
      return true;
    }
    children(object) {
      return dart.list([new _debugger.NameValuePair({name: 'key', value: dart.dload(object, 'key')}), new _debugger.NameValuePair({name: 'value', value: dart.dload(object, 'value')})], _debugger.NameValuePair);
    }
  };
  _debugger.MapEntryFormatter[dart.implements] = () => [_debugger.Formatter];
  dart.setSignature(_debugger.MapEntryFormatter, {
    methods: () => ({
      accept: [core.bool, [dart.dynamic]],
      preview: [core.String, [dart.dynamic]],
      hasChildren: [core.bool, [dart.dynamic]],
      children: [core.List$(_debugger.NameValuePair), [dart.dynamic]]
    })
  });
  _debugger.HeritageClauseFormatter = class HeritageClauseFormatter extends core.Object {
    accept(object) {
      return dart.is(object, _debugger.HeritageClause);
    }
    preview(object) {
      let clause = dart.as(object, _debugger.HeritageClause);
      let typeNames = clause.types[dartx.map](core.String)(dart.fn(type => _debugger.getTypeName(dart.as(type, core.Type)), core.String, [dart.dynamic]));
      return `${clause.name} ${typeNames[dartx.join](", ")}`;
    }
    hasChildren(object) {
      return true;
    }
    children(object) {
      let clause = dart.as(object, _debugger.HeritageClause);
      let ret = dart.list([], _debugger.NameValuePair);
      for (let type of clause.types) {
        ret[dartx.add](new _debugger.NameValuePair({value: new _debugger.ClassMetadata(type)}));
      }
      return ret;
    }
  };
  _debugger.HeritageClauseFormatter[dart.implements] = () => [_debugger.Formatter];
  dart.setSignature(_debugger.HeritageClauseFormatter, {
    methods: () => ({
      accept: [core.bool, [dart.dynamic]],
      preview: [core.String, [dart.dynamic]],
      hasChildren: [core.bool, [dart.dynamic]],
      children: [core.List$(_debugger.NameValuePair), [dart.dynamic]]
    })
  });
  _debugger.registerDevtoolsFormatter = function() {
    let formatters = dart.list([_debugger._devtoolsFormatter], _debugger.JsonMLFormatter);
    dart.global.devtoolsFormatters = formatters;
  };
  dart.fn(_debugger.registerDevtoolsFormatter);
  _foreign_helper.JS = function(typeDescription, codeTemplate, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11) {
    if (arg0 === void 0) arg0 = null;
    if (arg1 === void 0) arg1 = null;
    if (arg2 === void 0) arg2 = null;
    if (arg3 === void 0) arg3 = null;
    if (arg4 === void 0) arg4 = null;
    if (arg5 === void 0) arg5 = null;
    if (arg6 === void 0) arg6 = null;
    if (arg7 === void 0) arg7 = null;
    if (arg8 === void 0) arg8 = null;
    if (arg9 === void 0) arg9 = null;
    if (arg10 === void 0) arg10 = null;
    if (arg11 === void 0) arg11 = null;
  };
  dart.lazyFn(_foreign_helper.JS, () => [dart.dynamic, [core.String, core.String], [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]]);
  _foreign_helper.JSExportName = class JSExportName extends core.Object {
    JSExportName(name) {
      this.name = name;
    }
  };
  dart.setSignature(_foreign_helper.JSExportName, {
    constructors: () => ({JSExportName: [_foreign_helper.JSExportName, [core.String]]})
  });
  _foreign_helper.JS_CURRENT_ISOLATE_CONTEXT = function() {
  };
  dart.lazyFn(_foreign_helper.JS_CURRENT_ISOLATE_CONTEXT, () => [_foreign_helper.IsolateContext, []]);
  _foreign_helper.IsolateContext = class IsolateContext extends core.Object {};
  _foreign_helper.JS_CALL_IN_ISOLATE = function(isolate, func) {
  };
  dart.lazyFn(_foreign_helper.JS_CALL_IN_ISOLATE, () => [dart.dynamic, [dart.dynamic, core.Function]]);
  _foreign_helper.JS_SET_CURRENT_ISOLATE = function(isolate) {
  };
  dart.fn(_foreign_helper.JS_SET_CURRENT_ISOLATE, dart.void, [dart.dynamic]);
  _foreign_helper.JS_CREATE_ISOLATE = function() {
  };
  dart.fn(_foreign_helper.JS_CREATE_ISOLATE);
  _foreign_helper.JS_DART_OBJECT_CONSTRUCTOR = function() {
  };
  dart.fn(_foreign_helper.JS_DART_OBJECT_CONSTRUCTOR);
  _foreign_helper.JS_INTERCEPTOR_CONSTANT = function(type) {
  };
  dart.lazyFn(_foreign_helper.JS_INTERCEPTOR_CONSTANT, () => [dart.dynamic, [core.Type]]);
  _foreign_helper.JS_OPERATOR_IS_PREFIX = function() {
  };
  dart.lazyFn(_foreign_helper.JS_OPERATOR_IS_PREFIX, () => [core.String, []]);
  _foreign_helper.JS_OPERATOR_AS_PREFIX = function() {
  };
  dart.lazyFn(_foreign_helper.JS_OPERATOR_AS_PREFIX, () => [core.String, []]);
  _foreign_helper.JS_OBJECT_CLASS_NAME = function() {
  };
  dart.lazyFn(_foreign_helper.JS_OBJECT_CLASS_NAME, () => [core.String, []]);
  _foreign_helper.JS_NULL_CLASS_NAME = function() {
  };
  dart.lazyFn(_foreign_helper.JS_NULL_CLASS_NAME, () => [core.String, []]);
  _foreign_helper.JS_FUNCTION_CLASS_NAME = function() {
  };
  dart.lazyFn(_foreign_helper.JS_FUNCTION_CLASS_NAME, () => [core.String, []]);
  _foreign_helper.JS_IS_INDEXABLE_FIELD_NAME = function() {
  };
  dart.lazyFn(_foreign_helper.JS_IS_INDEXABLE_FIELD_NAME, () => [core.String, []]);
  _foreign_helper.JS_CURRENT_ISOLATE = function() {
  };
  dart.fn(_foreign_helper.JS_CURRENT_ISOLATE);
  _foreign_helper.JS_SIGNATURE_NAME = function() {
  };
  dart.lazyFn(_foreign_helper.JS_SIGNATURE_NAME, () => [core.String, []]);
  _foreign_helper.JS_TYPEDEF_TAG = function() {
  };
  dart.lazyFn(_foreign_helper.JS_TYPEDEF_TAG, () => [core.String, []]);
  _foreign_helper.JS_FUNCTION_TYPE_TAG = function() {
  };
  dart.lazyFn(_foreign_helper.JS_FUNCTION_TYPE_TAG, () => [core.String, []]);
  _foreign_helper.JS_FUNCTION_TYPE_VOID_RETURN_TAG = function() {
  };
  dart.lazyFn(_foreign_helper.JS_FUNCTION_TYPE_VOID_RETURN_TAG, () => [core.String, []]);
  _foreign_helper.JS_FUNCTION_TYPE_RETURN_TYPE_TAG = function() {
  };
  dart.lazyFn(_foreign_helper.JS_FUNCTION_TYPE_RETURN_TYPE_TAG, () => [core.String, []]);
  _foreign_helper.JS_FUNCTION_TYPE_REQUIRED_PARAMETERS_TAG = function() {
  };
  dart.lazyFn(_foreign_helper.JS_FUNCTION_TYPE_REQUIRED_PARAMETERS_TAG, () => [core.String, []]);
  _foreign_helper.JS_FUNCTION_TYPE_OPTIONAL_PARAMETERS_TAG = function() {
  };
  dart.lazyFn(_foreign_helper.JS_FUNCTION_TYPE_OPTIONAL_PARAMETERS_TAG, () => [core.String, []]);
  _foreign_helper.JS_FUNCTION_TYPE_NAMED_PARAMETERS_TAG = function() {
  };
  dart.lazyFn(_foreign_helper.JS_FUNCTION_TYPE_NAMED_PARAMETERS_TAG, () => [core.String, []]);
  _foreign_helper.JS_GET_NAME = function(name) {
  };
  dart.lazyFn(_foreign_helper.JS_GET_NAME, () => [core.String, [core.String]]);
  _foreign_helper.JS_EMBEDDED_GLOBAL = function(typeDescription, name) {
  };
  dart.lazyFn(_foreign_helper.JS_EMBEDDED_GLOBAL, () => [dart.dynamic, [core.String, core.String]]);
  _foreign_helper.JS_GET_FLAG = function(name) {
  };
  dart.lazyFn(_foreign_helper.JS_GET_FLAG, () => [core.bool, [core.String]]);
  _foreign_helper.JS_EFFECT = function(code) {
    dart.dcall(code, null);
  };
  dart.lazyFn(_foreign_helper.JS_EFFECT, () => [dart.void, [core.Function]]);
  _foreign_helper.JS_CONST = class JS_CONST extends core.Object {
    JS_CONST(code) {
      this.code = code;
    }
  };
  dart.setSignature(_foreign_helper.JS_CONST, {
    constructors: () => ({JS_CONST: [_foreign_helper.JS_CONST, [core.String]]})
  });
  _foreign_helper.JS_STRING_CONCAT = function(a, b) {
    return a + b;
  };
  dart.lazyFn(_foreign_helper.JS_STRING_CONCAT, () => [core.String, [core.String, core.String]]);
  _foreign_helper._Rest = class _Rest extends core.Object {
    _Rest() {
    }
  };
  dart.setSignature(_foreign_helper._Rest, {
    constructors: () => ({_Rest: [_foreign_helper._Rest, []]})
  });
  _foreign_helper.rest = dart.const(new _foreign_helper._Rest());
  _foreign_helper.spread = function(args) {
    dart.throw(new core.StateError('The spread function cannot be called, ' + 'it should be compiled away.'));
  };
  dart.fn(_foreign_helper.spread);
  _interceptors.Interceptor = class Interceptor extends core.Object {
    Interceptor() {
    }
  };
  dart.setSignature(_interceptors.Interceptor, {
    constructors: () => ({Interceptor: [_interceptors.Interceptor, []]})
  });
  _interceptors.getInterceptor = function(obj) {
    return obj;
  };
  dart.fn(_interceptors.getInterceptor);
  dart.defineExtensionNames([
    'toString',
    'hashCode',
    'runtimeType'
  ]);
  _interceptors.JSBool = class JSBool extends _interceptors.Interceptor {
    JSBool() {
      super.Interceptor();
    }
    [dartx.toString]() {
      return String(this);
    }
    get [dartx.hashCode]() {
      return this ? 2 * 3 * 23 * 3761 : 269 * 811;
    }
    get [dartx.runtimeType]() {
      return dart.wrapType(core.bool);
    }
  };
  _interceptors.JSBool[dart.implements] = () => [core.bool];
  dart.setSignature(_interceptors.JSBool, {
    constructors: () => ({JSBool: [_interceptors.JSBool, []]})
  });
  _interceptors.JSBool[dart.metadata] = () => [dart.const(new _js_helper.JsPeerInterface({name: 'Boolean'}))];
  dart.registerExtension(dart.global.Boolean, _interceptors.JSBool);
  _interceptors.JSIndexable = class JSIndexable extends core.Object {};
  _interceptors.JSMutableIndexable = class JSMutableIndexable extends _interceptors.JSIndexable {};
  _interceptors.JSObject = class JSObject extends core.Object {};
  _interceptors.JavaScriptObject = class JavaScriptObject extends _interceptors.Interceptor {
    JavaScriptObject() {
      super.Interceptor();
    }
    get hashCode() {
      return 0;
    }
    get runtimeType() {
      return dart.wrapType(_interceptors.JSObject);
    }
  };
  _interceptors.JavaScriptObject[dart.implements] = () => [_interceptors.JSObject];
  dart.setSignature(_interceptors.JavaScriptObject, {
    constructors: () => ({JavaScriptObject: [_interceptors.JavaScriptObject, []]})
  });
  _interceptors.PlainJavaScriptObject = class PlainJavaScriptObject extends _interceptors.JavaScriptObject {
    PlainJavaScriptObject() {
      super.JavaScriptObject();
    }
  };
  dart.setSignature(_interceptors.PlainJavaScriptObject, {
    constructors: () => ({PlainJavaScriptObject: [_interceptors.PlainJavaScriptObject, []]})
  });
  _interceptors.UnknownJavaScriptObject = class UnknownJavaScriptObject extends _interceptors.JavaScriptObject {
    UnknownJavaScriptObject() {
      super.JavaScriptObject();
    }
    toString() {
      return String(this);
    }
  };
  dart.setSignature(_interceptors.UnknownJavaScriptObject, {
    constructors: () => ({UnknownJavaScriptObject: [_interceptors.UnknownJavaScriptObject, []]})
  });
  _interceptors.findInterceptorConstructorForType = function(type) {
  };
  dart.lazyFn(_interceptors.findInterceptorConstructorForType, () => [dart.dynamic, [core.Type]]);
  _interceptors.findConstructorForNativeSubclassType = function(type, name) {
  };
  dart.lazyFn(_interceptors.findConstructorForNativeSubclassType, () => [dart.dynamic, [core.Type, core.String]]);
  _interceptors.getNativeInterceptor = function(object) {
  };
  dart.fn(_interceptors.getNativeInterceptor);
  _interceptors.setDispatchProperty = function(object, value) {
  };
  dart.fn(_interceptors.setDispatchProperty);
  const _removeWhere = Symbol('_removeWhere');
  _interceptors.JSArray$ = dart.generic(E => {
    dart.defineExtensionNames([
      'checkMutable',
      'checkGrowable',
      'add',
      'removeAt',
      'insert',
      'insertAll',
      'setAll',
      'removeLast',
      'remove',
      'removeWhere',
      'retainWhere',
      'where',
      'expand',
      'addAll',
      'clear',
      'forEach',
      'map',
      'join',
      'take',
      'takeWhile',
      'skip',
      'skipWhile',
      'reduce',
      'fold',
      'firstWhere',
      'lastWhere',
      'singleWhere',
      'elementAt',
      'sublist',
      'getRange',
      'first',
      'last',
      'single',
      'removeRange',
      'setRange',
      'fillRange',
      'replaceRange',
      'any',
      'every',
      'reversed',
      'sort',
      'shuffle',
      'indexOf',
      'lastIndexOf',
      'contains',
      'isEmpty',
      'isNotEmpty',
      'toString',
      'toList',
      'toSet',
      'iterator',
      'hashCode',
      'length',
      'length',
      'get',
      'set',
      'asMap'
    ]);
    class JSArray extends core.Object {
      JSArray() {
      }
      static typed(allocation) {
        return dart.list(allocation, E);
      }
      static markFixed(allocation) {
        return _interceptors.JSArray$(E).typed(_interceptors.JSArray.markFixedList(dart.as(allocation, core.List)));
      }
      static markGrowable(allocation) {
        return _interceptors.JSArray$(E).typed(allocation);
      }
      static markFixedList(list) {
        list.fixed$length = Array;
        return list;
      }
      static markUnmodifiableList(list) {
        list.fixed$length = Array;
        list.immutable$list = Array;
        return list;
      }
      [dartx.checkMutable](reason) {
        if (this.immutable$list) {
          dart.throw(new core.UnsupportedError(dart.as(reason, core.String)));
        }
      }
      [dartx.checkGrowable](reason) {
        if (this.fixed$length) {
          dart.throw(new core.UnsupportedError(dart.as(reason, core.String)));
        }
      }
      [dartx.add](value) {
        dart.as(value, E);
        this[dartx.checkGrowable]('add');
        this.push(value);
      }
      [dartx.removeAt](index) {
        this[dartx.checkGrowable]('removeAt');
        if (!(typeof index == 'number')) dart.throw(_js_helper.argumentErrorValue(index));
        if (dart.notNull(index) < 0 || dart.notNull(index) >= dart.notNull(this[dartx.length])) {
          dart.throw(new core.RangeError.value(index));
        }
        return this.splice(index, 1)[0];
      }
      [dartx.insert](index, value) {
        dart.as(value, E);
        this[dartx.checkGrowable]('insert');
        if (!(typeof index == 'number')) dart.throw(_js_helper.argumentErrorValue(index));
        if (dart.notNull(index) < 0 || dart.notNull(index) > dart.notNull(this[dartx.length])) {
          dart.throw(new core.RangeError.value(index));
        }
        this.splice(index, 0, value);
      }
      [dartx.insertAll](index, iterable) {
        dart.as(iterable, core.Iterable$(E));
        this[dartx.checkGrowable]('insertAll');
        core.RangeError.checkValueInInterval(index, 0, this[dartx.length], "index");
        if (!dart.is(iterable, _internal.EfficientLength)) {
          iterable = iterable[dartx.toList]();
        }
        let insertionLength = iterable[dartx.length];
        this[dartx.length] = dart.notNull(this[dartx.length]) + dart.notNull(insertionLength);
        let end = dart.notNull(index) + dart.notNull(insertionLength);
        this[dartx.setRange](end, this[dartx.length], this, index);
        this[dartx.setRange](index, end, iterable);
      }
      [dartx.setAll](index, iterable) {
        dart.as(iterable, core.Iterable$(E));
        this[dartx.checkMutable]('setAll');
        core.RangeError.checkValueInInterval(index, 0, this[dartx.length], "index");
        for (let element of iterable) {
          this[dartx.set]((() => {
            let x = index;
            index = dart.notNull(x) + 1;
            return x;
          })(), element);
        }
      }
      [dartx.removeLast]() {
        this[dartx.checkGrowable]('removeLast');
        if (this[dartx.length] == 0) dart.throw(_js_helper.diagnoseIndexError(this, -1));
        return this.pop();
      }
      [dartx.remove](element) {
        this[dartx.checkGrowable]('remove');
        for (let i = 0; i < dart.notNull(this[dartx.length]); i++) {
          if (dart.equals(this[dartx.get](i), element)) {
            this.splice(i, 1);
            return true;
          }
        }
        return false;
      }
      [dartx.removeWhere](test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        this[dartx.checkGrowable]('removeWhere');
        this[_removeWhere](test, true);
      }
      [dartx.retainWhere](test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        this[dartx.checkGrowable]('retainWhere');
        this[_removeWhere](test, false);
      }
      [_removeWhere](test, removeMatching) {
        dart.as(test, dart.functionType(core.bool, [E]));
        let retained = [];
        let end = this[dartx.length];
        for (let i = 0; i < dart.notNull(end); i++) {
          let element = this[i];
          if (!dart.notNull(test(dart.as(element, E))) == removeMatching) {
            retained[dartx.add](element);
          }
          if (this[dartx.length] != end) dart.throw(new core.ConcurrentModificationError(this));
        }
        if (retained[dartx.length] == end) return;
        this[dartx.length] = retained[dartx.length];
        for (let i = 0; i < dart.notNull(retained[dartx.length]); i++) {
          this[dartx.set](i, dart.as(retained[dartx.get](i), E));
        }
      }
      [dartx.where](f) {
        dart.as(f, dart.functionType(core.bool, [E]));
        return new (_internal.WhereIterable$(E))(this, f);
      }
      [dartx.expand](T) {
        return f => {
          dart.as(f, dart.functionType(core.Iterable$(T), [E]));
          return new (_internal.ExpandIterable$(E, T))(this, f);
        };
      }
      [dartx.addAll](collection) {
        dart.as(collection, core.Iterable$(E));
        let i = this[dartx.length];
        this[dartx.checkGrowable]('addAll');
        for (let e of collection) {
          dart.assert(i == this[dartx.length] || dart.notNull(dart.throw(new core.ConcurrentModificationError(this))));
          i = dart.notNull(i) + 1;
          this.push(e);
        }
      }
      [dartx.clear]() {
        this[dartx.length] = 0;
      }
      [dartx.forEach](f) {
        dart.as(f, dart.functionType(dart.void, [E]));
        let end = this[dartx.length];
        for (let i = 0; i < dart.notNull(end); i++) {
          let element = this[i];
          f(element);
          if (this[dartx.length] != end) dart.throw(new core.ConcurrentModificationError(this));
        }
      }
      [dartx.map](T) {
        return f => {
          dart.as(f, dart.functionType(T, [E]));
          return new (_internal.MappedListIterable$(E, T))(this, f);
        };
      }
      [dartx.join](separator) {
        if (separator === void 0) separator = "";
        let list = core.List.new(this[dartx.length]);
        for (let i = 0; i < dart.notNull(this[dartx.length]); i++) {
          list[dartx.set](i, `${this[dartx.get](i)}`);
        }
        return list.join(separator);
      }
      [dartx.take](n) {
        return new (_internal.SubListIterable$(E))(this, 0, n);
      }
      [dartx.takeWhile](test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        return new (_internal.TakeWhileIterable$(E))(this, test);
      }
      [dartx.skip](n) {
        return new (_internal.SubListIterable$(E))(this, n, null);
      }
      [dartx.skipWhile](test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        return new (_internal.SkipWhileIterable$(E))(this, test);
      }
      [dartx.reduce](combine) {
        dart.as(combine, dart.functionType(E, [E, E]));
        let length = this[dartx.length];
        if (length == 0) dart.throw(_internal.IterableElementError.noElement());
        let value = this[dartx.get](0);
        for (let i = 1; i < dart.notNull(length); i++) {
          let element = this[i];
          value = combine(value, element);
          if (length != this[dartx.length]) dart.throw(new core.ConcurrentModificationError(this));
        }
        return value;
      }
      [dartx.fold](T) {
        return (initialValue, combine) => {
          dart.as(combine, dart.functionType(T, [T, E]));
          let value = initialValue;
          let length = this[dartx.length];
          for (let i = 0; i < dart.notNull(length); i++) {
            let element = this[i];
            value = combine(value, element);
            if (this[dartx.length] != length) dart.throw(new core.ConcurrentModificationError(this));
          }
          return value;
        };
      }
      [dartx.firstWhere](test, opts) {
        dart.as(test, dart.functionType(core.bool, [E]));
        let orElse = opts && 'orElse' in opts ? opts.orElse : null;
        dart.as(orElse, dart.functionType(E, []));
        let end = this[dartx.length];
        for (let i = 0; i < dart.notNull(end); ++i) {
          let element = this[i];
          if (dart.notNull(test(element))) return element;
          if (this[dartx.length] != end) dart.throw(new core.ConcurrentModificationError(this));
        }
        if (orElse != null) return orElse();
        dart.throw(_internal.IterableElementError.noElement());
      }
      [dartx.lastWhere](test, opts) {
        dart.as(test, dart.functionType(core.bool, [E]));
        let orElse = opts && 'orElse' in opts ? opts.orElse : null;
        dart.as(orElse, dart.functionType(E, []));
        let length = this[dartx.length];
        for (let i = dart.notNull(length) - 1; i >= 0; i--) {
          let element = this[i];
          if (dart.notNull(test(element))) return element;
          if (length != this[dartx.length]) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
        }
        if (orElse != null) return orElse();
        dart.throw(_internal.IterableElementError.noElement());
      }
      [dartx.singleWhere](test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        let length = this[dartx.length];
        let match = null;
        let matchFound = false;
        for (let i = 0; i < dart.notNull(length); i++) {
          let element = this[i];
          if (dart.notNull(test(dart.as(element, E)))) {
            if (matchFound) {
              dart.throw(_internal.IterableElementError.tooMany());
            }
            matchFound = true;
            match = dart.as(element, E);
          }
          if (length != this[dartx.length]) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
        }
        if (matchFound) return match;
        dart.throw(_internal.IterableElementError.noElement());
      }
      [dartx.elementAt](index) {
        return this[dartx.get](index);
      }
      [dartx.sublist](start, end) {
        if (end === void 0) end = null;
        _js_helper.checkNull(start);
        if (!(typeof start == 'number')) dart.throw(_js_helper.argumentErrorValue(start));
        if (dart.notNull(start) < 0 || dart.notNull(start) > dart.notNull(this[dartx.length])) {
          dart.throw(new core.RangeError.range(start, 0, this[dartx.length], "start"));
        }
        if (end == null) {
          end = this[dartx.length];
        } else {
          if (!(typeof end == 'number')) dart.throw(_js_helper.argumentErrorValue(end));
          if (dart.notNull(end) < dart.notNull(start) || dart.notNull(end) > dart.notNull(this[dartx.length])) {
            dart.throw(new core.RangeError.range(end, start, this[dartx.length], "end"));
          }
        }
        if (start == end) return dart.list([], E);
        return _interceptors.JSArray$(E).typed(this.slice(start, end));
      }
      [dartx.getRange](start, end) {
        core.RangeError.checkValidRange(start, end, this[dartx.length]);
        return new (_internal.SubListIterable$(E))(this, start, end);
      }
      get [dartx.first]() {
        if (dart.notNull(this[dartx.length]) > 0) return this[dartx.get](0);
        dart.throw(_internal.IterableElementError.noElement());
      }
      get [dartx.last]() {
        if (dart.notNull(this[dartx.length]) > 0) return this[dartx.get](dart.notNull(this[dartx.length]) - 1);
        dart.throw(_internal.IterableElementError.noElement());
      }
      get [dartx.single]() {
        if (this[dartx.length] == 1) return this[dartx.get](0);
        if (this[dartx.length] == 0) dart.throw(_internal.IterableElementError.noElement());
        dart.throw(_internal.IterableElementError.tooMany());
      }
      [dartx.removeRange](start, end) {
        this[dartx.checkGrowable]('removeRange');
        core.RangeError.checkValidRange(start, end, this[dartx.length]);
        let deleteCount = dart.notNull(end) - dart.notNull(start);
        this.splice(start, deleteCount);
      }
      [dartx.setRange](start, end, iterable, skipCount) {
        dart.as(iterable, core.Iterable$(E));
        if (skipCount === void 0) skipCount = 0;
        this[dartx.checkMutable]('set range');
        core.RangeError.checkValidRange(start, end, this[dartx.length]);
        let length = dart.notNull(end) - dart.notNull(start);
        if (length == 0) return;
        core.RangeError.checkNotNegative(skipCount, "skipCount");
        let otherList = null;
        let otherStart = null;
        if (dart.is(iterable, core.List)) {
          otherList = dart.as(iterable, core.List$(E));
          otherStart = skipCount;
        } else {
          otherList = iterable[dartx.skip](skipCount)[dartx.toList]({growable: false});
          otherStart = 0;
        }
        if (dart.notNull(otherStart) + length > dart.notNull(otherList[dartx.length])) {
          dart.throw(_internal.IterableElementError.tooFew());
        }
        if (dart.notNull(otherStart) < dart.notNull(start)) {
          for (let i = length - 1; i >= 0; i--) {
            let element = otherList[dartx.get](dart.notNull(otherStart) + i);
            this[dart.notNull(start) + i] = element;
          }
        } else {
          for (let i = 0; i < length; i++) {
            let element = otherList[dartx.get](dart.notNull(otherStart) + i);
            this[dart.notNull(start) + i] = element;
          }
        }
      }
      [dartx.fillRange](start, end, fillValue) {
        if (fillValue === void 0) fillValue = null;
        dart.as(fillValue, E);
        this[dartx.checkMutable]('fill range');
        core.RangeError.checkValidRange(start, end, this[dartx.length]);
        for (let i = start; dart.notNull(i) < dart.notNull(end); i = dart.notNull(i) + 1) {
          this[i] = fillValue;
        }
      }
      [dartx.replaceRange](start, end, replacement) {
        dart.as(replacement, core.Iterable$(E));
        this[dartx.checkGrowable]('replace range');
        core.RangeError.checkValidRange(start, end, this[dartx.length]);
        if (!dart.is(replacement, _internal.EfficientLength)) {
          replacement = replacement[dartx.toList]();
        }
        let removeLength = dart.notNull(end) - dart.notNull(start);
        let insertLength = replacement[dartx.length];
        if (removeLength >= dart.notNull(insertLength)) {
          let delta = removeLength - dart.notNull(insertLength);
          let insertEnd = dart.notNull(start) + dart.notNull(insertLength);
          let newLength = dart.notNull(this[dartx.length]) - delta;
          this[dartx.setRange](start, insertEnd, replacement);
          if (delta != 0) {
            this[dartx.setRange](insertEnd, newLength, this, end);
            this[dartx.length] = newLength;
          }
        } else {
          let delta = dart.notNull(insertLength) - removeLength;
          let newLength = dart.notNull(this[dartx.length]) + delta;
          let insertEnd = dart.notNull(start) + dart.notNull(insertLength);
          this[dartx.length] = newLength;
          this[dartx.setRange](insertEnd, newLength, this, end);
          this[dartx.setRange](start, insertEnd, replacement);
        }
      }
      [dartx.any](test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        let end = this[dartx.length];
        for (let i = 0; i < dart.notNull(end); i++) {
          let element = this[i];
          if (dart.notNull(test(element))) return true;
          if (this[dartx.length] != end) dart.throw(new core.ConcurrentModificationError(this));
        }
        return false;
      }
      [dartx.every](test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        let end = this[dartx.length];
        for (let i = 0; i < dart.notNull(end); i++) {
          let element = this[i];
          if (!dart.notNull(test(element))) return false;
          if (this[dartx.length] != end) dart.throw(new core.ConcurrentModificationError(this));
        }
        return true;
      }
      get [dartx.reversed]() {
        return new (_internal.ReversedListIterable$(E))(this);
      }
      [dartx.sort](compare) {
        if (compare === void 0) compare = null;
        dart.as(compare, dart.functionType(core.int, [E, E]));
        this[dartx.checkMutable]('sort');
        _internal.Sort.sort(this, compare == null ? core.Comparable.compare : compare);
      }
      [dartx.shuffle](random) {
        if (random === void 0) random = null;
        this[dartx.checkMutable]('shuffle');
        if (random == null) random = math.Random.new();
        let length = this[dartx.length];
        while (dart.notNull(length) > 1) {
          let pos = random.nextInt(length);
          length = dart.notNull(length) - 1;
          let tmp = this[dartx.get](length);
          this[dartx.set](length, this[dartx.get](pos));
          this[dartx.set](pos, tmp);
        }
      }
      [dartx.indexOf](element, start) {
        if (start === void 0) start = 0;
        if (dart.notNull(start) >= dart.notNull(this[dartx.length])) {
          return -1;
        }
        if (dart.notNull(start) < 0) {
          start = 0;
        }
        for (let i = start; dart.notNull(i) < dart.notNull(this[dartx.length]); i = dart.notNull(i) + 1) {
          if (dart.equals(this[dartx.get](i), element)) {
            return i;
          }
        }
        return -1;
      }
      [dartx.lastIndexOf](element, startIndex) {
        if (startIndex === void 0) startIndex = null;
        if (startIndex == null) {
          startIndex = dart.notNull(this[dartx.length]) - 1;
        } else {
          if (dart.notNull(startIndex) < 0) {
            return -1;
          }
          if (dart.notNull(startIndex) >= dart.notNull(this[dartx.length])) {
            startIndex = dart.notNull(this[dartx.length]) - 1;
          }
        }
        for (let i = startIndex; dart.notNull(i) >= 0; i = dart.notNull(i) - 1) {
          if (dart.equals(this[dartx.get](i), element)) {
            return i;
          }
        }
        return -1;
      }
      [dartx.contains](other) {
        for (let i = 0; i < dart.notNull(this[dartx.length]); i++) {
          if (dart.equals(this[dartx.get](i), other)) return true;
        }
        return false;
      }
      get [dartx.isEmpty]() {
        return this[dartx.length] == 0;
      }
      get [dartx.isNotEmpty]() {
        return !dart.notNull(this[dartx.isEmpty]);
      }
      [dartx.toString]() {
        return collection.ListBase.listToString(this);
      }
      [dartx.toList](opts) {
        let growable = opts && 'growable' in opts ? opts.growable : true;
        let list = this.slice();
        if (!dart.notNull(growable)) _interceptors.JSArray.markFixedList(dart.as(list, core.List));
        return _interceptors.JSArray$(E).typed(list);
      }
      [dartx.toSet]() {
        return core.Set$(E).from(this);
      }
      get [dartx.iterator]() {
        return new (_interceptors.ArrayIterator$(E))(this);
      }
      get [dartx.hashCode]() {
        return _js_helper.Primitives.objectHashCode(this);
      }
      get [dartx.length]() {
        return this.length;
      }
      set [dartx.length](newLength) {
        this[dartx.checkGrowable]('set length');
        if (!(typeof newLength == 'number')) {
          dart.throw(new core.ArgumentError.value(newLength, 'newLength'));
        }
        if (dart.notNull(newLength) < 0) {
          dart.throw(new core.RangeError.range(newLength, 0, null, 'newLength'));
        }
        this.length = newLength;
      }
      [dartx.get](index) {
        if (!(typeof index == 'number')) dart.throw(_js_helper.diagnoseIndexError(this, index));
        if (dart.notNull(index) >= dart.notNull(this[dartx.length]) || dart.notNull(index) < 0) dart.throw(_js_helper.diagnoseIndexError(this, index));
        return this[index];
      }
      [dartx.set](index, value) {
        dart.as(value, E);
        this[dartx.checkMutable]('indexed set');
        if (!(typeof index == 'number')) dart.throw(_js_helper.diagnoseIndexError(this, index));
        if (dart.notNull(index) >= dart.notNull(this[dartx.length]) || dart.notNull(index) < 0) dart.throw(_js_helper.diagnoseIndexError(this, index));
        this[index] = value;
        return value;
      }
      [dartx.asMap]() {
        return new (_internal.ListMapView$(E))(this);
      }
    }
    dart.setBaseClass(JSArray, dart.global.Array);
    JSArray[dart.implements] = () => [core.List$(E), _interceptors.JSIndexable];
    dart.setSignature(JSArray, {
      constructors: () => ({
        JSArray: [_interceptors.JSArray$(E), []],
        typed: [_interceptors.JSArray$(E), [dart.dynamic]],
        markFixed: [_interceptors.JSArray$(E), [dart.dynamic]],
        markGrowable: [_interceptors.JSArray$(E), [dart.dynamic]]
      }),
      methods: () => ({
        [dartx.checkMutable]: [dart.dynamic, [dart.dynamic]],
        [dartx.checkGrowable]: [dart.dynamic, [dart.dynamic]],
        [dartx.add]: [dart.void, [E]],
        [dartx.removeAt]: [E, [core.int]],
        [dartx.insert]: [dart.void, [core.int, E]],
        [dartx.insertAll]: [dart.void, [core.int, core.Iterable$(E)]],
        [dartx.setAll]: [dart.void, [core.int, core.Iterable$(E)]],
        [dartx.removeLast]: [E, []],
        [dartx.remove]: [core.bool, [core.Object]],
        [dartx.removeWhere]: [dart.void, [dart.functionType(core.bool, [E])]],
        [dartx.retainWhere]: [dart.void, [dart.functionType(core.bool, [E])]],
        [_removeWhere]: [dart.void, [dart.functionType(core.bool, [E]), core.bool]],
        [dartx.where]: [core.Iterable$(E), [dart.functionType(core.bool, [E])]],
        [dartx.expand]: [T => [core.Iterable$(T), [dart.functionType(core.Iterable$(T), [E])]]],
        [dartx.addAll]: [dart.void, [core.Iterable$(E)]],
        [dartx.clear]: [dart.void, []],
        [dartx.forEach]: [dart.void, [dart.functionType(dart.void, [E])]],
        [dartx.map]: [T => [core.Iterable$(T), [dart.functionType(T, [E])]]],
        [dartx.join]: [core.String, [], [core.String]],
        [dartx.take]: [core.Iterable$(E), [core.int]],
        [dartx.takeWhile]: [core.Iterable$(E), [dart.functionType(core.bool, [E])]],
        [dartx.skip]: [core.Iterable$(E), [core.int]],
        [dartx.skipWhile]: [core.Iterable$(E), [dart.functionType(core.bool, [E])]],
        [dartx.reduce]: [E, [dart.functionType(E, [E, E])]],
        [dartx.fold]: [T => [T, [T, dart.functionType(T, [T, E])]]],
        [dartx.firstWhere]: [E, [dart.functionType(core.bool, [E])], {orElse: dart.functionType(E, [])}],
        [dartx.lastWhere]: [E, [dart.functionType(core.bool, [E])], {orElse: dart.functionType(E, [])}],
        [dartx.singleWhere]: [E, [dart.functionType(core.bool, [E])]],
        [dartx.elementAt]: [E, [core.int]],
        [dartx.sublist]: [core.List$(E), [core.int], [core.int]],
        [dartx.getRange]: [core.Iterable$(E), [core.int, core.int]],
        [dartx.removeRange]: [dart.void, [core.int, core.int]],
        [dartx.setRange]: [dart.void, [core.int, core.int, core.Iterable$(E)], [core.int]],
        [dartx.fillRange]: [dart.void, [core.int, core.int], [E]],
        [dartx.replaceRange]: [dart.void, [core.int, core.int, core.Iterable$(E)]],
        [dartx.any]: [core.bool, [dart.functionType(core.bool, [E])]],
        [dartx.every]: [core.bool, [dart.functionType(core.bool, [E])]],
        [dartx.sort]: [dart.void, [], [dart.functionType(core.int, [E, E])]],
        [dartx.shuffle]: [dart.void, [], [math.Random]],
        [dartx.indexOf]: [core.int, [core.Object], [core.int]],
        [dartx.lastIndexOf]: [core.int, [core.Object], [core.int]],
        [dartx.contains]: [core.bool, [core.Object]],
        [dartx.toList]: [core.List$(E), [], {growable: core.bool}],
        [dartx.toSet]: [core.Set$(E), []],
        [dartx.get]: [E, [core.int]],
        [dartx.set]: [dart.void, [core.int, E]],
        [dartx.asMap]: [core.Map$(core.int, E), []]
      }),
      statics: () => ({
        markFixedList: [core.List, [core.List]],
        markUnmodifiableList: [core.List, [core.List]]
      }),
      names: ['markFixedList', 'markUnmodifiableList']
    });
    JSArray[dart.metadata] = () => [dart.const(new _js_helper.JsPeerInterface({name: 'Array'}))];
    return JSArray;
  });
  _interceptors.JSArray = _interceptors.JSArray$();
  dart.registerExtension(dart.global.Array, _interceptors.JSArray);
  _interceptors.JSMutableArray$ = dart.generic(E => {
    class JSMutableArray extends _interceptors.JSArray$(E) {
      JSMutableArray() {
        super.JSArray();
      }
    }
    JSMutableArray[dart.implements] = () => [_interceptors.JSMutableIndexable];
    return JSMutableArray;
  });
  _interceptors.JSMutableArray = _interceptors.JSMutableArray$();
  _interceptors.JSFixedArray$ = dart.generic(E => {
    class JSFixedArray extends _interceptors.JSMutableArray$(E) {}
    return JSFixedArray;
  });
  _interceptors.JSFixedArray = _interceptors.JSFixedArray$();
  _interceptors.JSExtendableArray$ = dart.generic(E => {
    class JSExtendableArray extends _interceptors.JSMutableArray$(E) {}
    return JSExtendableArray;
  });
  _interceptors.JSExtendableArray = _interceptors.JSExtendableArray$();
  _interceptors.JSUnmodifiableArray$ = dart.generic(E => {
    class JSUnmodifiableArray extends _interceptors.JSArray$(E) {
      JSUnmodifiableArray() {
        super.JSArray();
      }
    }
    return JSUnmodifiableArray;
  });
  _interceptors.JSUnmodifiableArray = _interceptors.JSUnmodifiableArray$();
  const _iterable = Symbol('_iterable');
  const _length = Symbol('_length');
  const _index = Symbol('_index');
  const _current = Symbol('_current');
  _interceptors.ArrayIterator$ = dart.generic(E => {
    class ArrayIterator extends core.Object {
      ArrayIterator(iterable) {
        this[_iterable] = iterable;
        this[_length] = iterable[dartx.length];
        this[_index] = 0;
        this[_current] = null;
      }
      get current() {
        return this[_current];
      }
      moveNext() {
        let length = this[_iterable][dartx.length];
        if (this[_length] != length) {
          dart.throw(_js_helper.throwConcurrentModificationError(this[_iterable]));
        }
        if (dart.notNull(this[_index]) >= dart.notNull(length)) {
          this[_current] = null;
          return false;
        }
        this[_current] = this[_iterable][dartx.get](this[_index]);
        this[_index] = dart.notNull(this[_index]) + 1;
        return true;
      }
    }
    ArrayIterator[dart.implements] = () => [core.Iterator$(E)];
    dart.setSignature(ArrayIterator, {
      constructors: () => ({ArrayIterator: [_interceptors.ArrayIterator$(E), [_interceptors.JSArray$(E)]]}),
      methods: () => ({moveNext: [core.bool, []]})
    });
    return ArrayIterator;
  });
  _interceptors.ArrayIterator = _interceptors.ArrayIterator$();
  const _isInt32 = Symbol('_isInt32');
  const _tdivSlow = Symbol('_tdivSlow');
  const _shlPositive = Symbol('_shlPositive');
  const _shrOtherPositive = Symbol('_shrOtherPositive');
  const _shrBothPositive = Symbol('_shrBothPositive');
  dart.defineExtensionNames([
    'compareTo',
    'isNegative',
    'isNaN',
    'isInfinite',
    'isFinite',
    'remainder',
    'abs',
    'sign',
    'toInt',
    'truncate',
    'ceil',
    'floor',
    'round',
    'ceilToDouble',
    'floorToDouble',
    'roundToDouble',
    'truncateToDouble',
    'clamp',
    'toDouble',
    'toStringAsFixed',
    'toStringAsExponential',
    'toStringAsPrecision',
    'toRadixString',
    'toString',
    'hashCode',
    'unary-',
    '+',
    '-',
    '/',
    '*',
    '%',
    '~/',
    '<<',
    '>>',
    '&',
    '|',
    '^',
    '<',
    '>',
    '<=',
    '>=',
    'isEven',
    'isOdd',
    'toUnsigned',
    'toSigned',
    'bitLength',
    'modPow',
    'modInverse',
    'gcd',
    '~'
  ]);
  _interceptors.JSNumber = class JSNumber extends _interceptors.Interceptor {
    JSNumber() {
      super.Interceptor();
    }
    [dartx.compareTo](b) {
      if (this < dart.notNull(b)) {
        return -1;
      } else if (this > dart.notNull(b)) {
        return 1;
      } else if (this == b) {
        if (this == 0) {
          let bIsNegative = b[dartx.isNegative];
          if (this[dartx.isNegative] == bIsNegative) return 0;
          if (dart.notNull(this[dartx.isNegative])) return -1;
          return 1;
        }
        return 0;
      } else if (dart.notNull(this[dartx.isNaN])) {
        if (dart.notNull(b[dartx.isNaN])) {
          return 0;
        }
        return 1;
      } else {
        return -1;
      }
    }
    get [dartx.isNegative]() {
      return this == 0 ? 1 / this < 0 : this < 0;
    }
    get [dartx.isNaN]() {
      return isNaN(this);
    }
    get [dartx.isInfinite]() {
      return this == 1 / 0 || this == -1 / 0;
    }
    get [dartx.isFinite]() {
      return isFinite(this);
    }
    [dartx.remainder](b) {
      if (!(typeof b == 'number')) dart.throw(_js_helper.argumentErrorValue(b));
      return this % b;
    }
    [dartx.abs]() {
      return Math.abs(this);
    }
    get [dartx.sign]() {
      return this > 0 ? 1 : this < 0 ? -1 : this;
    }
    [dartx.toInt]() {
      if (this >= dart.notNull(_interceptors.JSNumber._MIN_INT32) && this <= dart.notNull(_interceptors.JSNumber._MAX_INT32)) {
        return this | 0;
      }
      if (isFinite(this)) {
        return this[dartx.truncateToDouble]() + 0;
      }
      dart.throw(new core.UnsupportedError("" + this));
    }
    [dartx.truncate]() {
      return this[dartx.toInt]();
    }
    [dartx.ceil]() {
      return this[dartx.ceilToDouble]()[dartx.toInt]();
    }
    [dartx.floor]() {
      return this[dartx.floorToDouble]()[dartx.toInt]();
    }
    [dartx.round]() {
      if (this > 0) {
        if (this !== 1 / 0) {
          return Math.round(this);
        }
      } else if (this > -1 / 0) {
        return 0 - Math.round(0 - this);
      }
      dart.throw(new core.UnsupportedError("" + this));
    }
    [dartx.ceilToDouble]() {
      return Math.ceil(this);
    }
    [dartx.floorToDouble]() {
      return Math.floor(this);
    }
    [dartx.roundToDouble]() {
      if (this < 0) {
        return -Math.round(-this);
      } else {
        return Math.round(this);
      }
    }
    [dartx.truncateToDouble]() {
      return this < 0 ? this[dartx.ceilToDouble]() : this[dartx.floorToDouble]();
    }
    [dartx.clamp](lowerLimit, upperLimit) {
      if (dart.notNull(lowerLimit[dartx.compareTo](upperLimit)) > 0) {
        dart.throw(_js_helper.argumentErrorValue(lowerLimit));
      }
      if (dart.notNull(this[dartx.compareTo](lowerLimit)) < 0) return lowerLimit;
      if (dart.notNull(this[dartx.compareTo](upperLimit)) > 0) return upperLimit;
      return this;
    }
    [dartx.toDouble]() {
      return this;
    }
    [dartx.toStringAsFixed](fractionDigits) {
      _js_helper.checkInt(fractionDigits);
      if (dart.notNull(fractionDigits) < 0 || dart.notNull(fractionDigits) > 20) {
        dart.throw(new core.RangeError.range(fractionDigits, 0, 20, "fractionDigits"));
      }
      let result = this.toFixed(fractionDigits);
      if (this == 0 && dart.notNull(this[dartx.isNegative])) return `-${result}`;
      return result;
    }
    [dartx.toStringAsExponential](fractionDigits) {
      if (fractionDigits === void 0) fractionDigits = null;
      let result = null;
      if (fractionDigits != null) {
        _js_helper.checkInt(fractionDigits);
        if (dart.notNull(fractionDigits) < 0 || dart.notNull(fractionDigits) > 20) {
          dart.throw(new core.RangeError.range(fractionDigits, 0, 20, "fractionDigits"));
        }
        result = this.toExponential(fractionDigits);
      } else {
        result = this.toExponential();
      }
      if (this == 0 && dart.notNull(this[dartx.isNegative])) return `-${result}`;
      return result;
    }
    [dartx.toStringAsPrecision](precision) {
      _js_helper.checkInt(precision);
      if (dart.notNull(precision) < 1 || dart.notNull(precision) > 21) {
        dart.throw(new core.RangeError.range(precision, 1, 21, "precision"));
      }
      let result = this.toPrecision(precision);
      if (this == 0 && dart.notNull(this[dartx.isNegative])) return `-${result}`;
      return result;
    }
    [dartx.toRadixString](radix) {
      _js_helper.checkInt(radix);
      if (dart.notNull(radix) < 2 || dart.notNull(radix) > 36) {
        dart.throw(new core.RangeError.range(radix, 2, 36, "radix"));
      }
      let result = this.toString(radix);
      let rightParenCode = 41;
      if (result[dartx.codeUnitAt](dart.notNull(result[dartx.length]) - 1) != rightParenCode) {
        return result;
      }
      return _interceptors.JSNumber._handleIEtoString(result);
    }
    static _handleIEtoString(result) {
      let match = /^([\da-z]+)(?:\.([\da-z]+))?\(e\+(\d+)\)$/.exec(result);
      if (match == null) {
        dart.throw(new core.UnsupportedError(`Unexpected toString result: ${result}`));
      }
      result = dart.dindex(match, 1);
      let exponent = +dart.dindex(match, 3);
      if (dart.dindex(match, 2) != null) {
        result = result + dart.dindex(match, 2);
        exponent = exponent - dart.dindex(match, 2).length;
      }
      return dart.notNull(result) + "0"[dartx['*']](exponent);
    }
    [dartx.toString]() {
      if (this == 0 && 1 / this < 0) {
        return '-0.0';
      } else {
        return "" + this;
      }
    }
    get [dartx.hashCode]() {
      return this & 0x1FFFFFFF;
    }
    [dartx['unary-']]() {
      return -this;
    }
    [dartx['+']](other) {
      if (!(typeof other == 'number')) dart.throw(_js_helper.argumentErrorValue(other));
      return this + other;
    }
    [dartx['-']](other) {
      if (!(typeof other == 'number')) dart.throw(_js_helper.argumentErrorValue(other));
      return this - other;
    }
    [dartx['/']](other) {
      if (!(typeof other == 'number')) dart.throw(_js_helper.argumentErrorValue(other));
      return this / other;
    }
    [dartx['*']](other) {
      if (!(typeof other == 'number')) dart.throw(_js_helper.argumentErrorValue(other));
      return this * other;
    }
    [dartx['%']](other) {
      if (!(typeof other == 'number')) dart.throw(_js_helper.argumentErrorValue(other));
      let result = this % other;
      if (result == 0) return 0;
      if (result > 0) return result;
      if (other < 0) {
        return result - other;
      } else {
        return result + other;
      }
    }
    [_isInt32](value) {
      return (value | 0) === value;
    }
    [dartx['~/']](other) {
      if (dart.notNull(this[_isInt32](this)) && dart.notNull(this[_isInt32](other)) && 0 != other && -1 != other) {
        return this / other | 0;
      } else {
        return this[_tdivSlow](other);
      }
    }
    [_tdivSlow](other) {
      if (!(typeof other == 'number')) dart.throw(_js_helper.argumentErrorValue(other));
      return (this / other)[dartx.toInt]();
    }
    [dartx['<<']](other) {
      if (!(typeof other == 'number')) dart.throw(_js_helper.argumentErrorValue(other));
      if (other < 0) dart.throw(_js_helper.argumentErrorValue(other));
      return this[_shlPositive](other);
    }
    [_shlPositive](other) {
      return other > 31 ? 0 : this << other >>> 0;
    }
    [dartx['>>']](other) {
      if (!(typeof other == 'number')) dart.throw(_js_helper.argumentErrorValue(other));
      if (other < 0) dart.throw(_js_helper.argumentErrorValue(other));
      return this[_shrOtherPositive](other);
    }
    [_shrOtherPositive](other) {
      return this > 0 ? this[_shrBothPositive](other) : this >> (dart.notNull(other) > 31 ? 31 : other) >>> 0;
    }
    [_shrBothPositive](other) {
      return other > 31 ? 0 : this >>> other;
    }
    [dartx['&']](other) {
      if (!(typeof other == 'number')) dart.throw(_js_helper.argumentErrorValue(other));
      return (this & other) >>> 0;
    }
    [dartx['|']](other) {
      if (!(typeof other == 'number')) dart.throw(_js_helper.argumentErrorValue(other));
      return (this | other) >>> 0;
    }
    [dartx['^']](other) {
      if (!(typeof other == 'number')) dart.throw(_js_helper.argumentErrorValue(other));
      return (this ^ other) >>> 0;
    }
    [dartx['<']](other) {
      if (!(typeof other == 'number')) dart.throw(_js_helper.argumentErrorValue(other));
      return this < other;
    }
    [dartx['>']](other) {
      if (!(typeof other == 'number')) dart.throw(_js_helper.argumentErrorValue(other));
      return this > other;
    }
    [dartx['<=']](other) {
      if (!(typeof other == 'number')) dart.throw(_js_helper.argumentErrorValue(other));
      return this <= other;
    }
    [dartx['>=']](other) {
      if (!(typeof other == 'number')) dart.throw(_js_helper.argumentErrorValue(other));
      return this >= other;
    }
    get [dartx.isEven]() {
      return (this & 1) == 0;
    }
    get [dartx.isOdd]() {
      return (this & 1) == 1;
    }
    [dartx.toUnsigned](width) {
      return (this & (1)[dartx['<<']](width) - 1) >>> 0;
    }
    [dartx.toSigned](width) {
      let signMask = (1)[dartx['<<']](dart.notNull(width) - 1);
      return ((this & signMask - 1) >>> 0) - ((this & signMask) >>> 0);
    }
    get [dartx.bitLength]() {
      let nonneg = this < 0 ? -this - 1 : this;
      if (nonneg >= 4294967296) {
        nonneg = (nonneg / 4294967296)[dartx.truncate]();
        return dart.notNull(_interceptors.JSNumber._bitCount(_interceptors.JSNumber._spread(nonneg))) + 32;
      }
      return _interceptors.JSNumber._bitCount(_interceptors.JSNumber._spread(nonneg));
    }
    [dartx.modPow](e, m) {
      if (!(typeof e == 'number')) {
        dart.throw(new core.ArgumentError.value(e, "exponent", "not an integer"));
      }
      if (!(typeof m == 'number')) {
        dart.throw(new core.ArgumentError.value(m, "modulus", "not an integer"));
      }
      if (dart.notNull(e) < 0) dart.throw(new core.RangeError.range(e, 0, null, "exponent"));
      if (dart.notNull(m) <= 0) dart.throw(new core.RangeError.range(m, 1, null, "modulus"));
      if (e == 0) return 1;
      let b = this;
      if (dart.notNull(b) < 0 || dart.notNull(b) > dart.notNull(m)) {
        b = b[dartx['%']](m);
      }
      let r = 1;
      while (dart.notNull(e) > 0) {
        if (dart.notNull(e[dartx.isOdd])) {
          r = (r * dart.notNull(b))[dartx['%']](m);
        }
        e = (dart.notNull(e) / 2)[dartx.truncate]();
        b = (dart.notNull(b) * dart.notNull(b))[dartx['%']](m);
      }
      return r;
    }
    static _binaryGcd(x, y, inv) {
      let s = 1;
      if (!dart.notNull(inv)) {
        while (dart.notNull(x[dartx.isEven]) && dart.notNull(y[dartx.isEven])) {
          x = (dart.notNull(x) / 2)[dartx.truncate]();
          y = (dart.notNull(y) / 2)[dartx.truncate]();
          s = s * 2;
        }
        if (dart.notNull(y[dartx.isOdd])) {
          let t = x;
          x = y;
          y = t;
        }
      }
      let ac = x[dartx.isEven];
      let u = x;
      let v = y;
      let a = 1, b = 0, c = 0, d = 1;
      do {
        while (dart.notNull(u[dartx.isEven])) {
          u = (dart.notNull(u) / 2)[dartx.truncate]();
          if (dart.notNull(ac)) {
            if (!dart.notNull(a[dartx.isEven]) || !dart.notNull(b[dartx.isEven])) {
              a = dart.notNull(a) + dart.notNull(y);
              b = dart.notNull(b) - dart.notNull(x);
            }
            a = (dart.notNull(a) / 2)[dartx.truncate]();
          } else if (!dart.notNull(b[dartx.isEven])) {
            b = dart.notNull(b) - dart.notNull(x);
          }
          b = (dart.notNull(b) / 2)[dartx.truncate]();
        }
        while (dart.notNull(v[dartx.isEven])) {
          v = (dart.notNull(v) / 2)[dartx.truncate]();
          if (dart.notNull(ac)) {
            if (!dart.notNull(c[dartx.isEven]) || !dart.notNull(d[dartx.isEven])) {
              c = dart.notNull(c) + dart.notNull(y);
              d = dart.notNull(d) - dart.notNull(x);
            }
            c = (dart.notNull(c) / 2)[dartx.truncate]();
          } else if (!dart.notNull(d[dartx.isEven])) {
            d = dart.notNull(d) - dart.notNull(x);
          }
          d = (dart.notNull(d) / 2)[dartx.truncate]();
        }
        if (dart.notNull(u) >= dart.notNull(v)) {
          u = dart.notNull(u) - dart.notNull(v);
          if (dart.notNull(ac)) {
            a = dart.notNull(a) - dart.notNull(c);
          }
          b = dart.notNull(b) - dart.notNull(d);
        } else {
          v = dart.notNull(v) - dart.notNull(u);
          if (dart.notNull(ac)) {
            c = dart.notNull(c) - dart.notNull(a);
          }
          d = dart.notNull(d) - dart.notNull(b);
        }
      } while (u != 0);
      if (!dart.notNull(inv)) return s * dart.notNull(v);
      if (v != 1) dart.throw(core.Exception.new("Not coprime"));
      if (dart.notNull(d) < 0) {
        d = dart.notNull(d) + dart.notNull(x);
        if (dart.notNull(d) < 0) {
          d = dart.notNull(d) + dart.notNull(x);
        }
      } else if (dart.notNull(d) > dart.notNull(x)) {
        d = dart.notNull(d) - dart.notNull(x);
        if (dart.notNull(d) > dart.notNull(x)) {
          d = dart.notNull(d) - dart.notNull(x);
        }
      }
      return d;
    }
    [dartx.modInverse](m) {
      if (!(typeof m == 'number')) {
        dart.throw(new core.ArgumentError.value(m, "modulus", "not an integer"));
      }
      if (dart.notNull(m) <= 0) dart.throw(new core.RangeError.range(m, 1, null, "modulus"));
      if (m == 1) return 0;
      let t = this;
      if (dart.notNull(t) < 0 || dart.notNull(t) >= dart.notNull(m)) {
        t = t[dartx['%']](m);
      }
      if (t == 1) return 1;
      if (t == 0 || dart.notNull(t[dartx.isEven]) && dart.notNull(m[dartx.isEven])) {
        dart.throw(core.Exception.new("Not coprime"));
      }
      return _interceptors.JSNumber._binaryGcd(m, t, true);
    }
    [dartx.gcd](other) {
      if (!(typeof other == 'number')) {
        dart.throw(new core.ArgumentError.value(other, "other", "not an integer"));
      }
      let x = this[dartx.abs]();
      let y = other[dartx.abs]();
      if (x == 0) return y;
      if (y == 0) return x;
      if (x == 1 || y == 1) return 1;
      return _interceptors.JSNumber._binaryGcd(x, y, false);
    }
    static _bitCount(i) {
      i = dart.notNull(_interceptors.JSNumber._shru(i, 0)) - (dart.notNull(_interceptors.JSNumber._shru(i, 1)) & 1431655765);
      i = (dart.notNull(i) & 858993459) + (dart.notNull(_interceptors.JSNumber._shru(i, 2)) & 858993459);
      i = 252645135 & dart.notNull(i) + dart.notNull(_interceptors.JSNumber._shru(i, 4));
      i = dart.notNull(i) + dart.notNull(_interceptors.JSNumber._shru(i, 8));
      i = dart.notNull(i) + dart.notNull(_interceptors.JSNumber._shru(i, 16));
      return dart.notNull(i) & 63;
    }
    static _shru(value, shift) {
      return value >>> shift;
    }
    static _shrs(value, shift) {
      return value >> shift;
    }
    static _ors(a, b) {
      return a | b;
    }
    static _spread(i) {
      i = _interceptors.JSNumber._ors(i, _interceptors.JSNumber._shrs(i, 1));
      i = _interceptors.JSNumber._ors(i, _interceptors.JSNumber._shrs(i, 2));
      i = _interceptors.JSNumber._ors(i, _interceptors.JSNumber._shrs(i, 4));
      i = _interceptors.JSNumber._ors(i, _interceptors.JSNumber._shrs(i, 8));
      i = _interceptors.JSNumber._shru(_interceptors.JSNumber._ors(i, _interceptors.JSNumber._shrs(i, 16)), 0);
      return i;
    }
    [dartx['~']]() {
      return ~this >>> 0;
    }
  };
  _interceptors.JSNumber[dart.implements] = () => [core.int, core.double];
  dart.setSignature(_interceptors.JSNumber, {
    constructors: () => ({JSNumber: [_interceptors.JSNumber, []]}),
    methods: () => ({
      [dartx.compareTo]: [core.int, [core.num]],
      [dartx.remainder]: [_interceptors.JSNumber, [core.num]],
      [dartx.abs]: [_interceptors.JSNumber, []],
      [dartx.toInt]: [core.int, []],
      [dartx.truncate]: [core.int, []],
      [dartx.ceil]: [core.int, []],
      [dartx.floor]: [core.int, []],
      [dartx.round]: [core.int, []],
      [dartx.ceilToDouble]: [core.double, []],
      [dartx.floorToDouble]: [core.double, []],
      [dartx.roundToDouble]: [core.double, []],
      [dartx.truncateToDouble]: [core.double, []],
      [dartx.clamp]: [core.num, [core.num, core.num]],
      [dartx.toDouble]: [core.double, []],
      [dartx.toStringAsFixed]: [core.String, [core.int]],
      [dartx.toStringAsExponential]: [core.String, [], [core.int]],
      [dartx.toStringAsPrecision]: [core.String, [core.int]],
      [dartx.toRadixString]: [core.String, [core.int]],
      [dartx['unary-']]: [_interceptors.JSNumber, []],
      [dartx['+']]: [_interceptors.JSNumber, [core.num]],
      [dartx['-']]: [_interceptors.JSNumber, [core.num]],
      [dartx['/']]: [core.double, [core.num]],
      [dartx['*']]: [_interceptors.JSNumber, [core.num]],
      [dartx['%']]: [_interceptors.JSNumber, [core.num]],
      [_isInt32]: [core.bool, [dart.dynamic]],
      [dartx['~/']]: [core.int, [core.num]],
      [_tdivSlow]: [core.int, [core.num]],
      [dartx['<<']]: [core.int, [core.num]],
      [_shlPositive]: [core.int, [core.num]],
      [dartx['>>']]: [core.int, [core.num]],
      [_shrOtherPositive]: [core.int, [core.num]],
      [_shrBothPositive]: [core.int, [core.num]],
      [dartx['&']]: [core.int, [core.num]],
      [dartx['|']]: [core.int, [core.num]],
      [dartx['^']]: [core.int, [core.num]],
      [dartx['<']]: [core.bool, [core.num]],
      [dartx['>']]: [core.bool, [core.num]],
      [dartx['<=']]: [core.bool, [core.num]],
      [dartx['>=']]: [core.bool, [core.num]],
      [dartx.toUnsigned]: [core.int, [core.int]],
      [dartx.toSigned]: [core.int, [core.int]],
      [dartx.modPow]: [core.int, [core.int, core.int]],
      [dartx.modInverse]: [core.int, [core.int]],
      [dartx.gcd]: [core.int, [core.int]],
      [dartx['~']]: [core.int, []]
    }),
    statics: () => ({
      _handleIEtoString: [core.String, [core.String]],
      _binaryGcd: [core.int, [core.int, core.int, core.bool]],
      _bitCount: [core.int, [core.int]],
      _shru: [core.int, [core.int, core.int]],
      _shrs: [core.int, [core.int, core.int]],
      _ors: [core.int, [core.int, core.int]],
      _spread: [core.int, [core.int]]
    }),
    names: ['_handleIEtoString', '_binaryGcd', '_bitCount', '_shru', '_shrs', '_ors', '_spread']
  });
  _interceptors.JSNumber[dart.metadata] = () => [dart.const(new _js_helper.JsPeerInterface({name: 'Number'}))];
  _interceptors.JSNumber._MIN_INT32 = -2147483648;
  _interceptors.JSNumber._MAX_INT32 = 2147483647;
  dart.registerExtension(dart.global.Number, _interceptors.JSNumber);
  const _defaultSplit = Symbol('_defaultSplit');
  dart.defineExtensionNames([
    'codeUnitAt',
    'allMatches',
    'matchAsPrefix',
    '+',
    'endsWith',
    'replaceAll',
    'replaceAllMapped',
    'splitMapJoin',
    'replaceFirst',
    'replaceFirstMapped',
    'split',
    'replaceRange',
    'startsWith',
    'substring',
    'toLowerCase',
    'toUpperCase',
    'trim',
    'trimLeft',
    'trimRight',
    '*',
    'padLeft',
    'padRight',
    'codeUnits',
    'runes',
    'indexOf',
    'lastIndexOf',
    'contains',
    'isEmpty',
    'isNotEmpty',
    'compareTo',
    'toString',
    'hashCode',
    'runtimeType',
    'length',
    'get'
  ]);
  _interceptors.JSString = class JSString extends _interceptors.Interceptor {
    JSString() {
      super.Interceptor();
    }
    [dartx.codeUnitAt](index) {
      if (!(typeof index == 'number')) dart.throw(_js_helper.diagnoseIndexError(this, index));
      if (dart.notNull(index) < 0) dart.throw(_js_helper.diagnoseIndexError(this, index));
      if (dart.notNull(index) >= dart.notNull(this[dartx.length])) dart.throw(_js_helper.diagnoseIndexError(this, index));
      return this.charCodeAt(index);
    }
    [dartx.allMatches](string, start) {
      if (start === void 0) start = 0;
      _js_helper.checkString(string);
      _js_helper.checkInt(start);
      if (0 > dart.notNull(start) || dart.notNull(start) > dart.notNull(string[dartx.length])) {
        dart.throw(new core.RangeError.range(start, 0, string[dartx.length]));
      }
      return _js_helper.allMatchesInStringUnchecked(this, string, start);
    }
    [dartx.matchAsPrefix](string, start) {
      if (start === void 0) start = 0;
      if (dart.notNull(start) < 0 || dart.notNull(start) > dart.notNull(string[dartx.length])) {
        dart.throw(new core.RangeError.range(start, 0, string[dartx.length]));
      }
      if (dart.notNull(start) + dart.notNull(this[dartx.length]) > dart.notNull(string[dartx.length])) return null;
      for (let i = 0; i < dart.notNull(this[dartx.length]); i++) {
        if (string[dartx.codeUnitAt](dart.notNull(start) + i) != this[dartx.codeUnitAt](i)) {
          return null;
        }
      }
      return new _js_helper.StringMatch(start, string, this);
    }
    [dartx['+']](other) {
      if (!(typeof other == 'string')) dart.throw(new core.ArgumentError.value(other));
      return this + other;
    }
    [dartx.endsWith](other) {
      _js_helper.checkString(other);
      let otherLength = other[dartx.length];
      if (dart.notNull(otherLength) > dart.notNull(this[dartx.length])) return false;
      return other == this[dartx.substring](dart.notNull(this[dartx.length]) - dart.notNull(otherLength));
    }
    [dartx.replaceAll](from, to) {
      _js_helper.checkString(to);
      return _js_helper.stringReplaceAllUnchecked(this, from, to);
    }
    [dartx.replaceAllMapped](from, convert) {
      return this[dartx.splitMapJoin](from, {onMatch: convert});
    }
    [dartx.splitMapJoin](from, opts) {
      let onMatch = opts && 'onMatch' in opts ? opts.onMatch : null;
      let onNonMatch = opts && 'onNonMatch' in opts ? opts.onNonMatch : null;
      return _js_helper.stringReplaceAllFuncUnchecked(this, from, onMatch, onNonMatch);
    }
    [dartx.replaceFirst](from, to, startIndex) {
      if (startIndex === void 0) startIndex = 0;
      _js_helper.checkString(to);
      _js_helper.checkInt(startIndex);
      core.RangeError.checkValueInInterval(startIndex, 0, this[dartx.length], "startIndex");
      return _js_helper.stringReplaceFirstUnchecked(this, from, to, startIndex);
    }
    [dartx.replaceFirstMapped](from, replace, startIndex) {
      if (startIndex === void 0) startIndex = 0;
      _js_helper.checkNull(replace);
      _js_helper.checkInt(startIndex);
      core.RangeError.checkValueInInterval(startIndex, 0, this[dartx.length], "startIndex");
      return _js_helper.stringReplaceFirstMappedUnchecked(this, from, replace, startIndex);
    }
    [dartx.split](pattern) {
      _js_helper.checkNull(pattern);
      if (typeof pattern == 'string') {
        return this.split(pattern);
      } else if (dart.is(pattern, _js_helper.JSSyntaxRegExp) && _js_helper.regExpCaptureCount(pattern) == 0) {
        let re = _js_helper.regExpGetNative(pattern);
        return this.split(re);
      } else {
        return this[_defaultSplit](pattern);
      }
    }
    [dartx.replaceRange](start, end, replacement) {
      _js_helper.checkString(replacement);
      _js_helper.checkInt(start);
      end = core.RangeError.checkValidRange(start, end, this[dartx.length]);
      _js_helper.checkInt(end);
      return _js_helper.stringReplaceRangeUnchecked(this, start, end, replacement);
    }
    [_defaultSplit](pattern) {
      let result = dart.list([], core.String);
      let start = 0;
      let length = 1;
      for (let match of pattern[dartx.allMatches](this)) {
        let matchStart = match.start;
        let matchEnd = match.end;
        length = dart.notNull(matchEnd) - dart.notNull(matchStart);
        if (length == 0 && start == matchStart) {
          continue;
        }
        let end = matchStart;
        result[dartx.add](this[dartx.substring](start, end));
        start = matchEnd;
      }
      if (dart.notNull(start) < dart.notNull(this[dartx.length]) || length > 0) {
        result[dartx.add](this[dartx.substring](start));
      }
      return result;
    }
    [dartx.startsWith](pattern, index) {
      if (index === void 0) index = 0;
      _js_helper.checkInt(index);
      if (dart.notNull(index) < 0 || dart.notNull(index) > dart.notNull(this[dartx.length])) {
        dart.throw(new core.RangeError.range(index, 0, this[dartx.length]));
      }
      if (typeof pattern == 'string') {
        let other = pattern;
        let otherLength = other[dartx.length];
        let endIndex = dart.notNull(index) + dart.notNull(otherLength);
        if (endIndex > dart.notNull(this[dartx.length])) return false;
        return other == this.substring(index, endIndex);
      }
      return pattern[dartx.matchAsPrefix](this, index) != null;
    }
    [dartx.substring](startIndex, endIndex) {
      if (endIndex === void 0) endIndex = null;
      _js_helper.checkInt(startIndex);
      if (endIndex == null) endIndex = this[dartx.length];
      _js_helper.checkInt(endIndex);
      if (dart.notNull(startIndex) < 0) dart.throw(new core.RangeError.value(startIndex));
      if (dart.notNull(startIndex) > dart.notNull(endIndex)) dart.throw(new core.RangeError.value(startIndex));
      if (dart.notNull(endIndex) > dart.notNull(this[dartx.length])) dart.throw(new core.RangeError.value(endIndex));
      return this.substring(startIndex, endIndex);
    }
    [dartx.toLowerCase]() {
      return this.toLowerCase();
    }
    [dartx.toUpperCase]() {
      return this.toUpperCase();
    }
    static _isWhitespace(codeUnit) {
      if (dart.notNull(codeUnit) < 256) {
        switch (codeUnit) {
          case 9:
          case 10:
          case 11:
          case 12:
          case 13:
          case 32:
          case 133:
          case 160:
          {
            return true;
          }
          default:
          {
            return false;
          }
        }
      }
      switch (codeUnit) {
        case 5760:
        case 6158:
        case 8192:
        case 8193:
        case 8194:
        case 8195:
        case 8196:
        case 8197:
        case 8198:
        case 8199:
        case 8200:
        case 8201:
        case 8202:
        case 8232:
        case 8233:
        case 8239:
        case 8287:
        case 12288:
        case 65279:
        {
          return true;
        }
        default:
        {
          return false;
        }
      }
    }
    static _skipLeadingWhitespace(string, index) {
      let SPACE = 32;
      let CARRIAGE_RETURN = 13;
      while (dart.notNull(index) < dart.notNull(string[dartx.length])) {
        let codeUnit = string[dartx.codeUnitAt](index);
        if (codeUnit != SPACE && codeUnit != CARRIAGE_RETURN && !dart.notNull(_interceptors.JSString._isWhitespace(codeUnit))) {
          break;
        }
        index = dart.notNull(index) + 1;
      }
      return index;
    }
    static _skipTrailingWhitespace(string, index) {
      let SPACE = 32;
      let CARRIAGE_RETURN = 13;
      while (dart.notNull(index) > 0) {
        let codeUnit = string[dartx.codeUnitAt](dart.notNull(index) - 1);
        if (codeUnit != SPACE && codeUnit != CARRIAGE_RETURN && !dart.notNull(_interceptors.JSString._isWhitespace(codeUnit))) {
          break;
        }
        index = dart.notNull(index) - 1;
      }
      return index;
    }
    [dartx.trim]() {
      let NEL = 133;
      let result = this.trim();
      if (result[dartx.length] == 0) return result;
      let firstCode = result[dartx.codeUnitAt](0);
      let startIndex = 0;
      if (firstCode == NEL) {
        startIndex = _interceptors.JSString._skipLeadingWhitespace(result, 1);
        if (startIndex == result[dartx.length]) return "";
      }
      let endIndex = result[dartx.length];
      let lastCode = result[dartx.codeUnitAt](dart.notNull(endIndex) - 1);
      if (lastCode == NEL) {
        endIndex = _interceptors.JSString._skipTrailingWhitespace(result, dart.notNull(endIndex) - 1);
      }
      if (startIndex == 0 && endIndex == result[dartx.length]) return result;
      return result.substring(startIndex, endIndex);
    }
    [dartx.trimLeft]() {
      let NEL = 133;
      let result = null;
      let startIndex = 0;
      if (typeof this.trimLeft != "undefined") {
        result = this.trimLeft();
        if (result[dartx.length] == 0) return result;
        let firstCode = result[dartx.codeUnitAt](0);
        if (firstCode == NEL) {
          startIndex = _interceptors.JSString._skipLeadingWhitespace(result, 1);
        }
      } else {
        result = this;
        startIndex = _interceptors.JSString._skipLeadingWhitespace(this, 0);
      }
      if (startIndex == 0) return result;
      if (startIndex == result[dartx.length]) return "";
      return result.substring(startIndex);
    }
    [dartx.trimRight]() {
      let NEL = 133;
      let result = null;
      let endIndex = null;
      if (typeof this.trimRight != "undefined") {
        result = this.trimRight();
        endIndex = result[dartx.length];
        if (endIndex == 0) return result;
        let lastCode = result[dartx.codeUnitAt](dart.notNull(endIndex) - 1);
        if (lastCode == NEL) {
          endIndex = _interceptors.JSString._skipTrailingWhitespace(result, dart.notNull(endIndex) - 1);
        }
      } else {
        result = this;
        endIndex = _interceptors.JSString._skipTrailingWhitespace(this, this[dartx.length]);
      }
      if (endIndex == result[dartx.length]) return result;
      if (endIndex == 0) return "";
      return result.substring(0, endIndex);
    }
    [dartx['*']](times) {
      if (0 >= dart.notNull(times)) return '';
      if (times == 1 || this[dartx.length] == 0) return this;
      if (times != times >>> 0) {
        dart.throw(dart.const(new core.OutOfMemoryError()));
      }
      let result = '';
      let s = this;
      while (true) {
        if ((dart.notNull(times) & 1) == 1) result = s + result;
        times = times >>> 1;
        if (times == 0) break;
        s = s + s;
      }
      return result;
    }
    [dartx.padLeft](width, padding) {
      if (padding === void 0) padding = ' ';
      let delta = dart.notNull(width) - dart.notNull(this[dartx.length]);
      if (delta <= 0) return this;
      return padding[dartx['*']](delta) + this;
    }
    [dartx.padRight](width, padding) {
      if (padding === void 0) padding = ' ';
      let delta = dart.notNull(width) - dart.notNull(this[dartx.length]);
      if (delta <= 0) return this;
      return this[dartx['+']](padding[dartx['*']](delta));
    }
    get [dartx.codeUnits]() {
      return new _internal.CodeUnits(this);
    }
    get [dartx.runes]() {
      return new core.Runes(this);
    }
    [dartx.indexOf](pattern, start) {
      if (start === void 0) start = 0;
      _js_helper.checkNull(pattern);
      if (!(typeof start == 'number')) dart.throw(_js_helper.argumentErrorValue(start));
      if (dart.notNull(start) < 0 || dart.notNull(start) > dart.notNull(this[dartx.length])) {
        dart.throw(new core.RangeError.range(start, 0, this[dartx.length]));
      }
      if (typeof pattern == 'string') {
        return _js_helper.stringIndexOfStringUnchecked(this, pattern, start);
      }
      if (dart.is(pattern, _js_helper.JSSyntaxRegExp)) {
        let re = pattern;
        let match = _js_helper.firstMatchAfter(re, this, start);
        return match == null ? -1 : match.start;
      }
      for (let i = start; dart.notNull(i) <= dart.notNull(this[dartx.length]); i = dart.notNull(i) + 1) {
        if (pattern[dartx.matchAsPrefix](this, i) != null) return i;
      }
      return -1;
    }
    [dartx.lastIndexOf](pattern, start) {
      if (start === void 0) start = null;
      _js_helper.checkNull(pattern);
      if (start == null) {
        start = this[dartx.length];
      } else if (!(typeof start == 'number')) {
        dart.throw(_js_helper.argumentErrorValue(start));
      } else if (dart.notNull(start) < 0 || dart.notNull(start) > dart.notNull(this[dartx.length])) {
        dart.throw(new core.RangeError.range(start, 0, this[dartx.length]));
      }
      if (typeof pattern == 'string') {
        let other = pattern;
        if (dart.notNull(start) + dart.notNull(other[dartx.length]) > dart.notNull(this[dartx.length])) {
          start = dart.notNull(this[dartx.length]) - dart.notNull(other[dartx.length]);
        }
        return dart.as(_js_helper.stringLastIndexOfUnchecked(this, other, start), core.int);
      }
      for (let i = start; dart.notNull(i) >= 0; i = dart.notNull(i) - 1) {
        if (pattern[dartx.matchAsPrefix](this, i) != null) return i;
      }
      return -1;
    }
    [dartx.contains](other, startIndex) {
      if (startIndex === void 0) startIndex = 0;
      _js_helper.checkNull(other);
      if (dart.notNull(startIndex) < 0 || dart.notNull(startIndex) > dart.notNull(this[dartx.length])) {
        dart.throw(new core.RangeError.range(startIndex, 0, this[dartx.length]));
      }
      return _js_helper.stringContainsUnchecked(this, other, startIndex);
    }
    get [dartx.isEmpty]() {
      return this[dartx.length] == 0;
    }
    get [dartx.isNotEmpty]() {
      return !dart.notNull(this[dartx.isEmpty]);
    }
    [dartx.compareTo](other) {
      if (!(typeof other == 'string')) dart.throw(_js_helper.argumentErrorValue(other));
      return dart.equals(this, other) ? 0 : this < other ? -1 : 1;
    }
    [dartx.toString]() {
      return this;
    }
    get [dartx.hashCode]() {
      let hash = 0;
      for (let i = 0; i < dart.notNull(this[dartx.length]); i++) {
        hash = 536870911 & hash + this.charCodeAt(i);
        hash = 536870911 & hash + ((524287 & hash) << 10);
        hash = hash ^ hash >> 6;
      }
      hash = 536870911 & hash + ((67108863 & hash) << 3);
      hash = hash ^ hash >> 11;
      return 536870911 & hash + ((16383 & hash) << 15);
    }
    get [dartx.runtimeType]() {
      return dart.wrapType(core.String);
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (!(typeof index == 'number')) dart.throw(_js_helper.diagnoseIndexError(this, index));
      if (dart.notNull(index) >= dart.notNull(this[dartx.length]) || dart.notNull(index) < 0) dart.throw(_js_helper.diagnoseIndexError(this, index));
      return this[index];
    }
  };
  _interceptors.JSString[dart.implements] = () => [core.String, _interceptors.JSIndexable];
  dart.setSignature(_interceptors.JSString, {
    constructors: () => ({JSString: [_interceptors.JSString, []]}),
    methods: () => ({
      [dartx.codeUnitAt]: [core.int, [core.int]],
      [dartx.allMatches]: [core.Iterable$(core.Match), [core.String], [core.int]],
      [dartx.matchAsPrefix]: [core.Match, [core.String], [core.int]],
      [dartx['+']]: [core.String, [core.String]],
      [dartx.endsWith]: [core.bool, [core.String]],
      [dartx.replaceAll]: [core.String, [core.Pattern, core.String]],
      [dartx.replaceAllMapped]: [core.String, [core.Pattern, dart.functionType(core.String, [core.Match])]],
      [dartx.splitMapJoin]: [core.String, [core.Pattern], {onMatch: dart.functionType(core.String, [core.Match]), onNonMatch: dart.functionType(core.String, [core.String])}],
      [dartx.replaceFirst]: [core.String, [core.Pattern, core.String], [core.int]],
      [dartx.replaceFirstMapped]: [core.String, [core.Pattern, dart.functionType(core.String, [core.Match])], [core.int]],
      [dartx.split]: [core.List$(core.String), [core.Pattern]],
      [dartx.replaceRange]: [core.String, [core.int, core.int, core.String]],
      [_defaultSplit]: [core.List$(core.String), [core.Pattern]],
      [dartx.startsWith]: [core.bool, [core.Pattern], [core.int]],
      [dartx.substring]: [core.String, [core.int], [core.int]],
      [dartx.toLowerCase]: [core.String, []],
      [dartx.toUpperCase]: [core.String, []],
      [dartx.trim]: [core.String, []],
      [dartx.trimLeft]: [core.String, []],
      [dartx.trimRight]: [core.String, []],
      [dartx['*']]: [core.String, [core.int]],
      [dartx.padLeft]: [core.String, [core.int], [core.String]],
      [dartx.padRight]: [core.String, [core.int], [core.String]],
      [dartx.indexOf]: [core.int, [core.Pattern], [core.int]],
      [dartx.lastIndexOf]: [core.int, [core.Pattern], [core.int]],
      [dartx.contains]: [core.bool, [core.Pattern], [core.int]],
      [dartx.compareTo]: [core.int, [core.String]],
      [dartx.get]: [core.String, [core.int]]
    }),
    statics: () => ({
      _isWhitespace: [core.bool, [core.int]],
      _skipLeadingWhitespace: [core.int, [core.String, core.int]],
      _skipTrailingWhitespace: [core.int, [core.String, core.int]]
    }),
    names: ['_isWhitespace', '_skipLeadingWhitespace', '_skipTrailingWhitespace']
  });
  _interceptors.JSString[dart.metadata] = () => [dart.const(new _js_helper.JsPeerInterface({name: 'String'}))];
  dart.registerExtension(dart.global.String, _interceptors.JSString);
  core.num = class num extends core.Object {
    static parse(input, onError) {
      if (onError === void 0) onError = null;
      let source = input[dartx.trim]();
      let result = core.int.parse(source, {onError: core.num._returnIntNull});
      if (result != null) return result;
      result = core.double.parse(source, core.num._returnDoubleNull);
      if (result != null) return result;
      if (onError == null) dart.throw(new core.FormatException(input));
      return onError(input);
    }
    static _returnIntNull(_) {
      return null;
    }
    static _returnDoubleNull(_) {
      return null;
    }
  };
  core.num[dart.implements] = () => [core.Comparable$(core.num)];
  dart.setSignature(core.num, {
    statics: () => ({
      parse: [core.num, [core.String], [dart.functionType(core.num, [core.String])]],
      _returnIntNull: [core.int, [core.String]],
      _returnDoubleNull: [core.double, [core.String]]
    }),
    names: ['parse', '_returnIntNull', '_returnDoubleNull']
  });
  core.double = class double extends core.num {
    static parse(source, onError) {
      if (onError === void 0) onError = null;
      return _js_helper.Primitives.parseDouble(source, onError);
    }
  };
  dart.setSignature(core.double, {
    statics: () => ({parse: [core.double, [core.String], [dart.functionType(core.double, [core.String])]]}),
    names: ['parse']
  });
  core.double.NAN = 0.0 / 0.0;
  core.double.INFINITY = 1.0 / 0.0;
  core.double.MIN_POSITIVE = 5e-324;
  core.double.MAX_FINITE = 1.7976931348623157e+308;
  dart.defineLazy(core.double, {
    get NEGATIVE_INFINITY() {
      return -dart.notNull(core.double.INFINITY);
    }
  });
  _internal.POWERS_OF_TEN = dart.const(dart.list([1.0, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, 10000000.0, 100000000.0, 1000000000.0, 10000000000.0, 100000000000.0, 1000000000000.0, 10000000000000.0, 100000000000000.0, 1000000000000000.0, 10000000000000000.0, 100000000000000000.0, 1000000000000000000.0, 10000000000000000000.0, 100000000000000000000.0, 1e+21, 1e+22], core.double));
  const _string = Symbol('_string');
  collection.ListMixin$ = dart.generic(E => {
    dart.defineExtensionNames([
      'iterator',
      'elementAt',
      'forEach',
      'isEmpty',
      'isNotEmpty',
      'first',
      'last',
      'single',
      'contains',
      'every',
      'any',
      'firstWhere',
      'lastWhere',
      'singleWhere',
      'join',
      'where',
      'map',
      'expand',
      'reduce',
      'fold',
      'skip',
      'skipWhile',
      'take',
      'takeWhile',
      'toList',
      'toSet',
      'add',
      'addAll',
      'remove',
      'removeWhere',
      'retainWhere',
      'clear',
      'removeLast',
      'sort',
      'shuffle',
      'asMap',
      'sublist',
      'getRange',
      'removeRange',
      'fillRange',
      'setRange',
      'replaceRange',
      'indexOf',
      'lastIndexOf',
      'insert',
      'removeAt',
      'insertAll',
      'setAll',
      'reversed',
      'toString'
    ]);
    class ListMixin extends core.Object {
      get iterator() {
        return new (_internal.ListIterator$(E))(this);
      }
      [Symbol.iterator]() {
        return new dart.JsIterator(this[dartx.iterator]);
      }
      elementAt(index) {
        return this[dartx.get](index);
      }
      forEach(action) {
        dart.as(action, dart.functionType(dart.void, [E]));
        let length = this[dartx.length];
        for (let i = 0; i < dart.notNull(length); i++) {
          action(this[dartx.get](i));
          if (length != this[dartx.length]) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
        }
      }
      get isEmpty() {
        return this[dartx.length] == 0;
      }
      get isNotEmpty() {
        return !dart.notNull(this[dartx.isEmpty]);
      }
      get first() {
        if (this[dartx.length] == 0) dart.throw(_internal.IterableElementError.noElement());
        return this[dartx.get](0);
      }
      get last() {
        if (this[dartx.length] == 0) dart.throw(_internal.IterableElementError.noElement());
        return this[dartx.get](dart.notNull(this[dartx.length]) - 1);
      }
      get single() {
        if (this[dartx.length] == 0) dart.throw(_internal.IterableElementError.noElement());
        if (dart.notNull(this[dartx.length]) > 1) dart.throw(_internal.IterableElementError.tooMany());
        return this[dartx.get](0);
      }
      contains(element) {
        let length = this[dartx.length];
        for (let i = 0; i < dart.notNull(this[dartx.length]); i++) {
          if (dart.equals(this[dartx.get](i), element)) return true;
          if (length != this[dartx.length]) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
        }
        return false;
      }
      every(test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        let length = this[dartx.length];
        for (let i = 0; i < dart.notNull(length); i++) {
          if (!dart.notNull(test(this[dartx.get](i)))) return false;
          if (length != this[dartx.length]) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
        }
        return true;
      }
      any(test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        let length = this[dartx.length];
        for (let i = 0; i < dart.notNull(length); i++) {
          if (dart.notNull(test(this[dartx.get](i)))) return true;
          if (length != this[dartx.length]) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
        }
        return false;
      }
      firstWhere(test, opts) {
        dart.as(test, dart.functionType(core.bool, [E]));
        let orElse = opts && 'orElse' in opts ? opts.orElse : null;
        dart.as(orElse, dart.functionType(E, []));
        let length = this[dartx.length];
        for (let i = 0; i < dart.notNull(length); i++) {
          let element = this[dartx.get](i);
          if (dart.notNull(test(element))) return element;
          if (length != this[dartx.length]) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
        }
        if (orElse != null) return orElse();
        dart.throw(_internal.IterableElementError.noElement());
      }
      lastWhere(test, opts) {
        dart.as(test, dart.functionType(core.bool, [E]));
        let orElse = opts && 'orElse' in opts ? opts.orElse : null;
        dart.as(orElse, dart.functionType(E, []));
        let length = this[dartx.length];
        for (let i = dart.notNull(length) - 1; i >= 0; i--) {
          let element = this[dartx.get](i);
          if (dart.notNull(test(element))) return element;
          if (length != this[dartx.length]) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
        }
        if (orElse != null) return orElse();
        dart.throw(_internal.IterableElementError.noElement());
      }
      singleWhere(test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        let length = this[dartx.length];
        let match = null;
        let matchFound = false;
        for (let i = 0; i < dart.notNull(length); i++) {
          let element = this[dartx.get](i);
          if (dart.notNull(test(element))) {
            if (matchFound) {
              dart.throw(_internal.IterableElementError.tooMany());
            }
            matchFound = true;
            match = element;
          }
          if (length != this[dartx.length]) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
        }
        if (matchFound) return match;
        dart.throw(_internal.IterableElementError.noElement());
      }
      join(separator) {
        if (separator === void 0) separator = "";
        if (this[dartx.length] == 0) return "";
        let buffer = new core.StringBuffer();
        buffer.writeAll(this, separator);
        return buffer.toString();
      }
      where(test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        return new (_internal.WhereIterable$(E))(this, test);
      }
      map(T) {
        return f => {
          dart.as(f, dart.functionType(T, [E]));
          return new (_internal.MappedListIterable$(E, T))(this, f);
        };
      }
      expand(T) {
        return f => {
          dart.as(f, dart.functionType(core.Iterable$(T), [E]));
          return new (_internal.ExpandIterable$(E, T))(this, f);
        };
      }
      reduce(combine) {
        dart.as(combine, dart.functionType(E, [E, E]));
        let length = this[dartx.length];
        if (length == 0) dart.throw(_internal.IterableElementError.noElement());
        let value = this[dartx.get](0);
        for (let i = 1; i < dart.notNull(length); i++) {
          value = combine(value, this[dartx.get](i));
          if (length != this[dartx.length]) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
        }
        return value;
      }
      fold(T) {
        return (initialValue, combine) => {
          dart.as(combine, dart.functionType(T, [T, E]));
          let value = initialValue;
          let length = this[dartx.length];
          for (let i = 0; i < dart.notNull(length); i++) {
            value = combine(value, this[dartx.get](i));
            if (length != this[dartx.length]) {
              dart.throw(new core.ConcurrentModificationError(this));
            }
          }
          return value;
        };
      }
      skip(count) {
        return new (_internal.SubListIterable$(E))(this, count, null);
      }
      skipWhile(test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        return new (_internal.SkipWhileIterable$(E))(this, test);
      }
      take(count) {
        return new (_internal.SubListIterable$(E))(this, 0, count);
      }
      takeWhile(test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        return new (_internal.TakeWhileIterable$(E))(this, test);
      }
      toList(opts) {
        let growable = opts && 'growable' in opts ? opts.growable : true;
        let result = null;
        if (dart.notNull(growable)) {
          result = core.List$(E).new();
          result[dartx.length] = this[dartx.length];
        } else {
          result = core.List$(E).new(this[dartx.length]);
        }
        for (let i = 0; i < dart.notNull(this[dartx.length]); i++) {
          result[dartx.set](i, this[dartx.get](i));
        }
        return result;
      }
      toSet() {
        let result = core.Set$(E).new();
        for (let i = 0; i < dart.notNull(this[dartx.length]); i++) {
          result.add(this[dartx.get](i));
        }
        return result;
      }
      add(element) {
        dart.as(element, E);
        this[dartx.set]((() => {
          let x = this[dartx.length];
          this[dartx.length] = dart.notNull(x) + 1;
          return x;
        })(), element);
      }
      addAll(iterable) {
        dart.as(iterable, core.Iterable$(E));
        let i = this[dartx.length];
        for (let element of iterable) {
          dart.assert(this[dartx.length] == i || dart.notNull(dart.throw(new core.ConcurrentModificationError(this))));
          this[dartx.length] = dart.notNull(i) + 1;
          this[dartx.set](i, element);
          i = dart.notNull(i) + 1;
        }
      }
      remove(element) {
        for (let i = 0; i < dart.notNull(this[dartx.length]); i++) {
          if (dart.equals(this[dartx.get](i), element)) {
            this[dartx.setRange](i, dart.notNull(this[dartx.length]) - 1, this, i + 1);
            this[dartx.length] = dart.notNull(this[dartx.length]) - 1;
            return true;
          }
        }
        return false;
      }
      removeWhere(test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        collection.ListMixin._filter(this, test, false);
      }
      retainWhere(test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        collection.ListMixin._filter(this, test, true);
      }
      static _filter(source, test, retainMatching) {
        let retained = [];
        let length = source[dartx.length];
        for (let i = 0; i < dart.notNull(length); i++) {
          let element = source[dartx.get](i);
          if (dart.dcall(test, element) == retainMatching) {
            retained[dartx.add](element);
          }
          if (length != source[dartx.length]) {
            dart.throw(new core.ConcurrentModificationError(source));
          }
        }
        if (retained[dartx.length] != source[dartx.length]) {
          source[dartx.setRange](0, retained[dartx.length], retained);
          source[dartx.length] = retained[dartx.length];
        }
      }
      clear() {
        this[dartx.length] = 0;
      }
      removeLast() {
        if (this[dartx.length] == 0) {
          dart.throw(_internal.IterableElementError.noElement());
        }
        let result = this[dartx.get](dart.notNull(this[dartx.length]) - 1);
        this[dartx.length] = dart.notNull(this[dartx.length]) - 1;
        return result;
      }
      sort(compare) {
        if (compare === void 0) compare = null;
        dart.as(compare, dart.functionType(core.int, [E, E]));
        if (compare == null) {
          _internal.Sort.sort(this, core.Comparable.compare);
        } else {
          _internal.Sort.sort(this, compare);
        }
      }
      shuffle(random) {
        if (random === void 0) random = null;
        if (random == null) random = math.Random.new();
        let length = this[dartx.length];
        while (dart.notNull(length) > 1) {
          let pos = random.nextInt(length);
          length = dart.notNull(length) - 1;
          let tmp = this[dartx.get](length);
          this[dartx.set](length, this[dartx.get](pos));
          this[dartx.set](pos, tmp);
        }
      }
      asMap() {
        return new (_internal.ListMapView$(E))(this);
      }
      sublist(start, end) {
        if (end === void 0) end = null;
        let listLength = this[dartx.length];
        if (end == null) end = listLength;
        core.RangeError.checkValidRange(start, end, listLength);
        let length = dart.notNull(end) - dart.notNull(start);
        let result = core.List$(E).new();
        result[dartx.length] = length;
        for (let i = 0; i < length; i++) {
          result[dartx.set](i, this[dartx.get](dart.notNull(start) + i));
        }
        return result;
      }
      getRange(start, end) {
        core.RangeError.checkValidRange(start, end, this[dartx.length]);
        return new (_internal.SubListIterable$(E))(this, start, end);
      }
      removeRange(start, end) {
        core.RangeError.checkValidRange(start, end, this[dartx.length]);
        let length = dart.notNull(end) - dart.notNull(start);
        this[dartx.setRange](start, dart.notNull(this[dartx.length]) - length, this, end);
        this[dartx.length] = dart.notNull(this[dartx.length]) - length;
      }
      fillRange(start, end, fill) {
        if (fill === void 0) fill = null;
        dart.as(fill, E);
        core.RangeError.checkValidRange(start, end, this[dartx.length]);
        for (let i = start; dart.notNull(i) < dart.notNull(end); i = dart.notNull(i) + 1) {
          this[dartx.set](i, fill);
        }
      }
      setRange(start, end, iterable, skipCount) {
        dart.as(iterable, core.Iterable$(E));
        if (skipCount === void 0) skipCount = 0;
        core.RangeError.checkValidRange(start, end, this[dartx.length]);
        let length = dart.notNull(end) - dart.notNull(start);
        if (length == 0) return;
        core.RangeError.checkNotNegative(skipCount, "skipCount");
        let otherList = null;
        let otherStart = null;
        if (dart.is(iterable, core.List$(E))) {
          otherList = iterable;
          otherStart = skipCount;
        } else {
          otherList = iterable[dartx.skip](skipCount)[dartx.toList]({growable: false});
          otherStart = 0;
        }
        if (dart.notNull(otherStart) + length > dart.notNull(otherList[dartx.length])) {
          dart.throw(_internal.IterableElementError.tooFew());
        }
        if (dart.notNull(otherStart) < dart.notNull(start)) {
          for (let i = length - 1; i >= 0; i--) {
            this[dartx.set](dart.notNull(start) + i, otherList[dartx.get](dart.notNull(otherStart) + i));
          }
        } else {
          for (let i = 0; i < length; i++) {
            this[dartx.set](dart.notNull(start) + i, otherList[dartx.get](dart.notNull(otherStart) + i));
          }
        }
      }
      replaceRange(start, end, newContents) {
        dart.as(newContents, core.Iterable$(E));
        core.RangeError.checkValidRange(start, end, this[dartx.length]);
        if (!dart.is(newContents, _internal.EfficientLength)) {
          newContents = newContents[dartx.toList]();
        }
        let removeLength = dart.notNull(end) - dart.notNull(start);
        let insertLength = newContents[dartx.length];
        if (removeLength >= dart.notNull(insertLength)) {
          let delta = removeLength - dart.notNull(insertLength);
          let insertEnd = dart.notNull(start) + dart.notNull(insertLength);
          let newLength = dart.notNull(this[dartx.length]) - delta;
          this[dartx.setRange](start, insertEnd, newContents);
          if (delta != 0) {
            this[dartx.setRange](insertEnd, newLength, this, end);
            this[dartx.length] = newLength;
          }
        } else {
          let delta = dart.notNull(insertLength) - removeLength;
          let newLength = dart.notNull(this[dartx.length]) + delta;
          let insertEnd = dart.notNull(start) + dart.notNull(insertLength);
          this[dartx.length] = newLength;
          this[dartx.setRange](insertEnd, newLength, this, end);
          this[dartx.setRange](start, insertEnd, newContents);
        }
      }
      indexOf(element, startIndex) {
        if (startIndex === void 0) startIndex = 0;
        if (dart.notNull(startIndex) >= dart.notNull(this[dartx.length])) {
          return -1;
        }
        if (dart.notNull(startIndex) < 0) {
          startIndex = 0;
        }
        for (let i = startIndex; dart.notNull(i) < dart.notNull(this[dartx.length]); i = dart.notNull(i) + 1) {
          if (dart.equals(this[dartx.get](i), element)) {
            return i;
          }
        }
        return -1;
      }
      lastIndexOf(element, startIndex) {
        if (startIndex === void 0) startIndex = null;
        if (startIndex == null) {
          startIndex = dart.notNull(this[dartx.length]) - 1;
        } else {
          if (dart.notNull(startIndex) < 0) {
            return -1;
          }
          if (dart.notNull(startIndex) >= dart.notNull(this[dartx.length])) {
            startIndex = dart.notNull(this[dartx.length]) - 1;
          }
        }
        for (let i = startIndex; dart.notNull(i) >= 0; i = dart.notNull(i) - 1) {
          if (dart.equals(this[dartx.get](i), element)) {
            return i;
          }
        }
        return -1;
      }
      insert(index, element) {
        dart.as(element, E);
        core.RangeError.checkValueInInterval(index, 0, this[dartx.length], "index");
        if (index == this[dartx.length]) {
          this[dartx.add](element);
          return;
        }
        if (!(typeof index == 'number')) dart.throw(new core.ArgumentError(index));
        this[dartx.length] = dart.notNull(this[dartx.length]) + 1;
        this[dartx.setRange](dart.notNull(index) + 1, this[dartx.length], this, index);
        this[dartx.set](index, element);
      }
      removeAt(index) {
        let result = this[dartx.get](index);
        this[dartx.setRange](index, dart.notNull(this[dartx.length]) - 1, this, dart.notNull(index) + 1);
        this[dartx.length] = dart.notNull(this[dartx.length]) - 1;
        return result;
      }
      insertAll(index, iterable) {
        dart.as(iterable, core.Iterable$(E));
        core.RangeError.checkValueInInterval(index, 0, this[dartx.length], "index");
        if (!dart.is(iterable, _internal.EfficientLength) || core.identical(iterable, this)) {
          iterable = iterable[dartx.toList]();
        }
        let insertionLength = iterable[dartx.length];
        this[dartx.length] = dart.notNull(this[dartx.length]) + dart.notNull(insertionLength);
        if (iterable[dartx.length] != insertionLength) {
          this[dartx.length] = dart.notNull(this[dartx.length]) - dart.notNull(insertionLength);
          dart.throw(new core.ConcurrentModificationError(iterable));
        }
        this[dartx.setRange](dart.notNull(index) + dart.notNull(insertionLength), this[dartx.length], this, index);
        this[dartx.setAll](index, iterable);
      }
      setAll(index, iterable) {
        dart.as(iterable, core.Iterable$(E));
        if (dart.is(iterable, core.List)) {
          this[dartx.setRange](index, dart.notNull(index) + dart.notNull(iterable[dartx.length]), iterable);
        } else {
          for (let element of iterable) {
            this[dartx.set]((() => {
              let x = index;
              index = dart.notNull(x) + 1;
              return x;
            })(), element);
          }
        }
      }
      get reversed() {
        return new (_internal.ReversedListIterable$(E))(this);
      }
      toString() {
        return collection.IterableBase.iterableToFullString(this, '[', ']');
      }
    }
    ListMixin[dart.implements] = () => [core.List$(E)];
    dart.setSignature(ListMixin, {
      methods: () => ({
        elementAt: [E, [core.int]],
        forEach: [dart.void, [dart.functionType(dart.void, [E])]],
        contains: [core.bool, [core.Object]],
        every: [core.bool, [dart.functionType(core.bool, [E])]],
        any: [core.bool, [dart.functionType(core.bool, [E])]],
        firstWhere: [E, [dart.functionType(core.bool, [E])], {orElse: dart.functionType(E, [])}],
        lastWhere: [E, [dart.functionType(core.bool, [E])], {orElse: dart.functionType(E, [])}],
        singleWhere: [E, [dart.functionType(core.bool, [E])]],
        join: [core.String, [], [core.String]],
        where: [core.Iterable$(E), [dart.functionType(core.bool, [E])]],
        map: [T => [core.Iterable$(T), [dart.functionType(T, [E])]]],
        expand: [T => [core.Iterable$(T), [dart.functionType(core.Iterable$(T), [E])]]],
        reduce: [E, [dart.functionType(E, [E, E])]],
        fold: [T => [T, [T, dart.functionType(T, [T, E])]]],
        skip: [core.Iterable$(E), [core.int]],
        skipWhile: [core.Iterable$(E), [dart.functionType(core.bool, [E])]],
        take: [core.Iterable$(E), [core.int]],
        takeWhile: [core.Iterable$(E), [dart.functionType(core.bool, [E])]],
        toList: [core.List$(E), [], {growable: core.bool}],
        toSet: [core.Set$(E), []],
        add: [dart.void, [E]],
        addAll: [dart.void, [core.Iterable$(E)]],
        remove: [core.bool, [core.Object]],
        removeWhere: [dart.void, [dart.functionType(core.bool, [E])]],
        retainWhere: [dart.void, [dart.functionType(core.bool, [E])]],
        clear: [dart.void, []],
        removeLast: [E, []],
        sort: [dart.void, [], [dart.functionType(core.int, [E, E])]],
        shuffle: [dart.void, [], [math.Random]],
        asMap: [core.Map$(core.int, E), []],
        sublist: [core.List$(E), [core.int], [core.int]],
        getRange: [core.Iterable$(E), [core.int, core.int]],
        removeRange: [dart.void, [core.int, core.int]],
        fillRange: [dart.void, [core.int, core.int], [E]],
        setRange: [dart.void, [core.int, core.int, core.Iterable$(E)], [core.int]],
        replaceRange: [dart.void, [core.int, core.int, core.Iterable$(E)]],
        indexOf: [core.int, [core.Object], [core.int]],
        lastIndexOf: [core.int, [core.Object], [core.int]],
        insert: [dart.void, [core.int, E]],
        removeAt: [E, [core.int]],
        insertAll: [dart.void, [core.int, core.Iterable$(E)]],
        setAll: [dart.void, [core.int, core.Iterable$(E)]]
      }),
      statics: () => ({_filter: [dart.void, [core.List, dart.functionType(core.bool, [dart.dynamic]), core.bool]]}),
      names: ['_filter']
    });
    dart.defineExtensionMembers(ListMixin, [
      'elementAt',
      'forEach',
      'contains',
      'every',
      'any',
      'firstWhere',
      'lastWhere',
      'singleWhere',
      'join',
      'where',
      'map',
      'expand',
      'reduce',
      'fold',
      'skip',
      'skipWhile',
      'take',
      'takeWhile',
      'toList',
      'toSet',
      'add',
      'addAll',
      'remove',
      'removeWhere',
      'retainWhere',
      'clear',
      'removeLast',
      'sort',
      'shuffle',
      'asMap',
      'sublist',
      'getRange',
      'removeRange',
      'fillRange',
      'setRange',
      'replaceRange',
      'indexOf',
      'lastIndexOf',
      'insert',
      'removeAt',
      'insertAll',
      'setAll',
      'toString',
      'iterator',
      'isEmpty',
      'isNotEmpty',
      'first',
      'last',
      'single',
      'reversed'
    ]);
    return ListMixin;
  });
  collection.ListMixin = collection.ListMixin$();
  collection.ListBase$ = dart.generic(E => {
    class ListBase extends dart.mixin(core.Object, collection.ListMixin$(E)) {
      static listToString(list) {
        return collection.IterableBase.iterableToFullString(list, '[', ']');
      }
    }
    dart.setSignature(ListBase, {
      statics: () => ({listToString: [core.String, [core.List]]}),
      names: ['listToString']
    });
    return ListBase;
  });
  collection.ListBase = collection.ListBase$();
  _internal.UnmodifiableListMixin$ = dart.generic(E => {
    class UnmodifiableListMixin extends core.Object {
      set(index, value) {
        dart.as(value, E);
        dart.throw(new core.UnsupportedError("Cannot modify an unmodifiable list"));
        return value;
      }
      set length(newLength) {
        dart.throw(new core.UnsupportedError("Cannot change the length of an unmodifiable list"));
      }
      setAll(at, iterable) {
        dart.as(iterable, core.Iterable$(E));
        dart.throw(new core.UnsupportedError("Cannot modify an unmodifiable list"));
      }
      add(value) {
        dart.as(value, E);
        dart.throw(new core.UnsupportedError("Cannot add to an unmodifiable list"));
      }
      insert(index, element) {
        dart.as(element, E);
        dart.throw(new core.UnsupportedError("Cannot add to an unmodifiable list"));
      }
      insertAll(at, iterable) {
        dart.as(iterable, core.Iterable$(E));
        dart.throw(new core.UnsupportedError("Cannot add to an unmodifiable list"));
      }
      addAll(iterable) {
        dart.as(iterable, core.Iterable$(E));
        dart.throw(new core.UnsupportedError("Cannot add to an unmodifiable list"));
      }
      remove(element) {
        dart.throw(new core.UnsupportedError("Cannot remove from an unmodifiable list"));
      }
      removeWhere(test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        dart.throw(new core.UnsupportedError("Cannot remove from an unmodifiable list"));
      }
      retainWhere(test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        dart.throw(new core.UnsupportedError("Cannot remove from an unmodifiable list"));
      }
      sort(compare) {
        if (compare === void 0) compare = null;
        dart.as(compare, core.Comparator$(E));
        dart.throw(new core.UnsupportedError("Cannot modify an unmodifiable list"));
      }
      shuffle(random) {
        if (random === void 0) random = null;
        dart.throw(new core.UnsupportedError("Cannot modify an unmodifiable list"));
      }
      clear() {
        dart.throw(new core.UnsupportedError("Cannot clear an unmodifiable list"));
      }
      removeAt(index) {
        dart.throw(new core.UnsupportedError("Cannot remove from an unmodifiable list"));
      }
      removeLast() {
        dart.throw(new core.UnsupportedError("Cannot remove from an unmodifiable list"));
      }
      setRange(start, end, iterable, skipCount) {
        dart.as(iterable, core.Iterable$(E));
        if (skipCount === void 0) skipCount = 0;
        dart.throw(new core.UnsupportedError("Cannot modify an unmodifiable list"));
      }
      removeRange(start, end) {
        dart.throw(new core.UnsupportedError("Cannot remove from an unmodifiable list"));
      }
      replaceRange(start, end, iterable) {
        dart.as(iterable, core.Iterable$(E));
        dart.throw(new core.UnsupportedError("Cannot remove from an unmodifiable list"));
      }
      fillRange(start, end, fillValue) {
        if (fillValue === void 0) fillValue = null;
        dart.as(fillValue, E);
        dart.throw(new core.UnsupportedError("Cannot modify an unmodifiable list"));
      }
    }
    UnmodifiableListMixin[dart.implements] = () => [core.List$(E)];
    dart.setSignature(UnmodifiableListMixin, {
      methods: () => ({
        set: [dart.void, [core.int, E]],
        setAll: [dart.void, [core.int, core.Iterable$(E)]],
        add: [dart.void, [E]],
        insert: [dart.void, [core.int, E]],
        insertAll: [dart.void, [core.int, core.Iterable$(E)]],
        addAll: [dart.void, [core.Iterable$(E)]],
        remove: [core.bool, [core.Object]],
        removeWhere: [dart.void, [dart.functionType(core.bool, [E])]],
        retainWhere: [dart.void, [dart.functionType(core.bool, [E])]],
        sort: [dart.void, [], [core.Comparator$(E)]],
        shuffle: [dart.void, [], [math.Random]],
        clear: [dart.void, []],
        removeAt: [E, [core.int]],
        removeLast: [E, []],
        setRange: [dart.void, [core.int, core.int, core.Iterable$(E)], [core.int]],
        removeRange: [dart.void, [core.int, core.int]],
        replaceRange: [dart.void, [core.int, core.int, core.Iterable$(E)]],
        fillRange: [dart.void, [core.int, core.int], [E]]
      })
    });
    dart.defineExtensionMembers(UnmodifiableListMixin, [
      'set',
      'setAll',
      'add',
      'insert',
      'insertAll',
      'addAll',
      'remove',
      'removeWhere',
      'retainWhere',
      'sort',
      'shuffle',
      'clear',
      'removeAt',
      'removeLast',
      'setRange',
      'removeRange',
      'replaceRange',
      'fillRange',
      'length'
    ]);
    return UnmodifiableListMixin;
  });
  _internal.UnmodifiableListMixin = _internal.UnmodifiableListMixin$();
  _internal.UnmodifiableListBase$ = dart.generic(E => {
    class UnmodifiableListBase extends dart.mixin(collection.ListBase$(E), _internal.UnmodifiableListMixin$(E)) {
      UnmodifiableListBase() {
        super.ListBase();
      }
    }
    return UnmodifiableListBase;
  });
  _internal.UnmodifiableListBase = _internal.UnmodifiableListBase$();
  core.int = class int extends core.num {
    static fromEnvironment(name, opts) {
      let defaultValue = opts && 'defaultValue' in opts ? opts.defaultValue : null;
      dart.throw(new core.UnsupportedError('int.fromEnvironment can only be used as a const constructor'));
    }
    static parse(source, opts) {
      let radix = opts && 'radix' in opts ? opts.radix : null;
      let onError = opts && 'onError' in opts ? opts.onError : null;
      return _js_helper.Primitives.parseInt(source, radix, onError);
    }
  };
  dart.setSignature(core.int, {
    constructors: () => ({fromEnvironment: [core.int, [core.String], {defaultValue: core.int}]}),
    statics: () => ({parse: [core.int, [core.String], {radix: core.int, onError: dart.functionType(core.int, [core.String])}]}),
    names: ['parse']
  });
  _internal.CodeUnits = class CodeUnits extends _internal.UnmodifiableListBase$(core.int) {
    CodeUnits(string) {
      this[_string] = string;
    }
    get length() {
      return this[_string][dartx.length];
    }
    set length(value) {
      super.length = value;
    }
    get(i) {
      return this[_string][dartx.codeUnitAt](i);
    }
    static stringOf(u) {
      return u[_string];
    }
  };
  dart.setSignature(_internal.CodeUnits, {
    constructors: () => ({CodeUnits: [_internal.CodeUnits, [core.String]]}),
    methods: () => ({get: [core.int, [core.int]]}),
    statics: () => ({stringOf: [core.String, [_internal.CodeUnits]]}),
    names: ['stringOf']
  });
  dart.defineExtensionMembers(_internal.CodeUnits, ['get', 'length']);
  _internal.EfficientLength = class EfficientLength extends core.Object {};
  core.Iterable$ = dart.generic(E => {
    dart.defineExtensionNames([
      'map',
      'where',
      'expand',
      'contains',
      'forEach',
      'reduce',
      'fold',
      'every',
      'join',
      'any',
      'toList',
      'toSet',
      'length',
      'isEmpty',
      'isNotEmpty',
      'take',
      'takeWhile',
      'skip',
      'skipWhile',
      'first',
      'last',
      'single',
      'firstWhere',
      'lastWhere',
      'singleWhere',
      'elementAt',
      'toString'
    ]);
    class Iterable extends core.Object {
      Iterable() {
      }
      static generate(count, generator) {
        if (generator === void 0) generator = null;
        if (dart.notNull(count) <= 0) return new (_internal.EmptyIterable$(E))();
        return new (core._GeneratorIterable$(E))(count, generator);
      }
      static empty() {
        return new (_internal.EmptyIterable$(E))();
      }
      [Symbol.iterator]() {
        return new dart.JsIterator(this[dartx.iterator]);
      }
      map(T) {
        return f => {
          dart.as(f, dart.functionType(T, [E]));
          return _internal.MappedIterable$(E, T).new(this, f);
        };
      }
      where(f) {
        dart.as(f, dart.functionType(core.bool, [E]));
        return new (_internal.WhereIterable$(E))(this, f);
      }
      expand(T) {
        return f => {
          dart.as(f, dart.functionType(core.Iterable$(T), [E]));
          return new (_internal.ExpandIterable$(E, T))(this, f);
        };
      }
      contains(element) {
        for (let e of this) {
          if (dart.equals(e, element)) return true;
        }
        return false;
      }
      forEach(f) {
        dart.as(f, dart.functionType(dart.void, [E]));
        for (let element of this)
          f(element);
      }
      reduce(combine) {
        dart.as(combine, dart.functionType(E, [E, E]));
        let iterator = this[dartx.iterator];
        if (!dart.notNull(iterator.moveNext())) {
          dart.throw(_internal.IterableElementError.noElement());
        }
        let value = iterator.current;
        while (dart.notNull(iterator.moveNext())) {
          value = combine(value, iterator.current);
        }
        return value;
      }
      fold(T) {
        return (initialValue, combine) => {
          dart.as(combine, dart.functionType(T, [T, E]));
          let value = initialValue;
          for (let element of this)
            value = combine(value, element);
          return value;
        };
      }
      every(f) {
        dart.as(f, dart.functionType(core.bool, [E]));
        for (let element of this) {
          if (!dart.notNull(f(element))) return false;
        }
        return true;
      }
      join(separator) {
        if (separator === void 0) separator = "";
        let iterator = this[dartx.iterator];
        if (!dart.notNull(iterator.moveNext())) return "";
        let buffer = new core.StringBuffer();
        if (separator == null || separator == "") {
          do {
            buffer.write(`${iterator.current}`);
          } while (dart.notNull(iterator.moveNext()));
        } else {
          buffer.write(`${iterator.current}`);
          while (dart.notNull(iterator.moveNext())) {
            buffer.write(separator);
            buffer.write(`${iterator.current}`);
          }
        }
        return buffer.toString();
      }
      any(f) {
        dart.as(f, dart.functionType(core.bool, [E]));
        for (let element of this) {
          if (dart.notNull(f(element))) return true;
        }
        return false;
      }
      toList(opts) {
        let growable = opts && 'growable' in opts ? opts.growable : true;
        return core.List$(E).from(this, {growable: growable});
      }
      toSet() {
        return core.Set$(E).from(this);
      }
      get length() {
        dart.assert(!dart.is(this, _internal.EfficientLength));
        let count = 0;
        let it = this[dartx.iterator];
        while (dart.notNull(it.moveNext())) {
          count++;
        }
        return count;
      }
      get isEmpty() {
        return !dart.notNull(this[dartx.iterator].moveNext());
      }
      get isNotEmpty() {
        return !dart.notNull(this[dartx.isEmpty]);
      }
      take(count) {
        return _internal.TakeIterable$(E).new(this, count);
      }
      takeWhile(test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        return new (_internal.TakeWhileIterable$(E))(this, test);
      }
      skip(count) {
        return _internal.SkipIterable$(E).new(this, count);
      }
      skipWhile(test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        return new (_internal.SkipWhileIterable$(E))(this, test);
      }
      get first() {
        let it = this[dartx.iterator];
        if (!dart.notNull(it.moveNext())) {
          dart.throw(_internal.IterableElementError.noElement());
        }
        return it.current;
      }
      get last() {
        let it = this[dartx.iterator];
        if (!dart.notNull(it.moveNext())) {
          dart.throw(_internal.IterableElementError.noElement());
        }
        let result = null;
        do {
          result = it.current;
        } while (dart.notNull(it.moveNext()));
        return result;
      }
      get single() {
        let it = this[dartx.iterator];
        if (!dart.notNull(it.moveNext())) dart.throw(_internal.IterableElementError.noElement());
        let result = it.current;
        if (dart.notNull(it.moveNext())) dart.throw(_internal.IterableElementError.tooMany());
        return result;
      }
      firstWhere(test, opts) {
        dart.as(test, dart.functionType(core.bool, [E]));
        let orElse = opts && 'orElse' in opts ? opts.orElse : null;
        dart.as(orElse, dart.functionType(E, []));
        for (let element of this) {
          if (dart.notNull(test(element))) return element;
        }
        if (orElse != null) return orElse();
        dart.throw(_internal.IterableElementError.noElement());
      }
      lastWhere(test, opts) {
        dart.as(test, dart.functionType(core.bool, [E]));
        let orElse = opts && 'orElse' in opts ? opts.orElse : null;
        dart.as(orElse, dart.functionType(E, []));
        let result = null;
        let foundMatching = false;
        for (let element of this) {
          if (dart.notNull(test(element))) {
            result = element;
            foundMatching = true;
          }
        }
        if (foundMatching) return result;
        if (orElse != null) return orElse();
        dart.throw(_internal.IterableElementError.noElement());
      }
      singleWhere(test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        let result = null;
        let foundMatching = false;
        for (let element of this) {
          if (dart.notNull(test(element))) {
            if (foundMatching) {
              dart.throw(_internal.IterableElementError.tooMany());
            }
            result = element;
            foundMatching = true;
          }
        }
        if (foundMatching) return result;
        dart.throw(_internal.IterableElementError.noElement());
      }
      elementAt(index) {
        if (!(typeof index == 'number')) dart.throw(new core.ArgumentError.notNull("index"));
        core.RangeError.checkNotNegative(index, "index");
        let elementIndex = 0;
        for (let element of this) {
          if (index == elementIndex) return element;
          elementIndex++;
        }
        dart.throw(core.RangeError.index(index, this, "index", null, elementIndex));
      }
      toString() {
        return collection.IterableBase.iterableToShortString(this, '(', ')');
      }
    }
    dart.setSignature(Iterable, {
      constructors: () => ({
        Iterable: [core.Iterable$(E), []],
        generate: [core.Iterable$(E), [core.int], [dart.functionType(E, [core.int])]],
        empty: [core.Iterable$(E), []]
      }),
      methods: () => ({
        map: [T => [core.Iterable$(T), [dart.functionType(T, [E])]]],
        where: [core.Iterable$(E), [dart.functionType(core.bool, [E])]],
        expand: [T => [core.Iterable$(T), [dart.functionType(core.Iterable$(T), [E])]]],
        contains: [core.bool, [core.Object]],
        forEach: [dart.void, [dart.functionType(dart.void, [E])]],
        reduce: [E, [dart.functionType(E, [E, E])]],
        fold: [T => [T, [T, dart.functionType(T, [T, E])]]],
        every: [core.bool, [dart.functionType(core.bool, [E])]],
        join: [core.String, [], [core.String]],
        any: [core.bool, [dart.functionType(core.bool, [E])]],
        toList: [core.List$(E), [], {growable: core.bool}],
        toSet: [core.Set$(E), []],
        take: [core.Iterable$(E), [core.int]],
        takeWhile: [core.Iterable$(E), [dart.functionType(core.bool, [E])]],
        skip: [core.Iterable$(E), [core.int]],
        skipWhile: [core.Iterable$(E), [dart.functionType(core.bool, [E])]],
        firstWhere: [E, [dart.functionType(core.bool, [E])], {orElse: dart.functionType(E, [])}],
        lastWhere: [E, [dart.functionType(core.bool, [E])], {orElse: dart.functionType(E, [])}],
        singleWhere: [E, [dart.functionType(core.bool, [E])]],
        elementAt: [E, [core.int]]
      })
    });
    dart.defineExtensionMembers(Iterable, [
      'map',
      'where',
      'expand',
      'contains',
      'forEach',
      'reduce',
      'fold',
      'every',
      'join',
      'any',
      'toList',
      'toSet',
      'take',
      'takeWhile',
      'skip',
      'skipWhile',
      'firstWhere',
      'lastWhere',
      'singleWhere',
      'elementAt',
      'toString',
      'length',
      'isEmpty',
      'isNotEmpty',
      'first',
      'last',
      'single'
    ]);
    return Iterable;
  });
  core.Iterable = core.Iterable$();
  _internal.ListIterable$ = dart.generic(E => {
    class ListIterable extends core.Iterable$(E) {
      ListIterable() {
        super.Iterable();
      }
      get iterator() {
        return new (_internal.ListIterator$(E))(this);
      }
      forEach(action) {
        dart.as(action, dart.functionType(dart.void, [E]));
        let length = this.length;
        for (let i = 0; i < dart.notNull(length); i++) {
          action(this.elementAt(i));
          if (length != this.length) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
        }
      }
      get isEmpty() {
        return this.length == 0;
      }
      get first() {
        if (this.length == 0) dart.throw(_internal.IterableElementError.noElement());
        return this.elementAt(0);
      }
      get last() {
        if (this.length == 0) dart.throw(_internal.IterableElementError.noElement());
        return this.elementAt(dart.notNull(this.length) - 1);
      }
      get single() {
        if (this.length == 0) dart.throw(_internal.IterableElementError.noElement());
        if (dart.notNull(this.length) > 1) dart.throw(_internal.IterableElementError.tooMany());
        return this.elementAt(0);
      }
      contains(element) {
        let length = this.length;
        for (let i = 0; i < dart.notNull(length); i++) {
          if (dart.equals(this.elementAt(i), element)) return true;
          if (length != this.length) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
        }
        return false;
      }
      every(test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        let length = this.length;
        for (let i = 0; i < dart.notNull(length); i++) {
          if (!dart.notNull(test(this.elementAt(i)))) return false;
          if (length != this.length) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
        }
        return true;
      }
      any(test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        let length = this.length;
        for (let i = 0; i < dart.notNull(length); i++) {
          if (dart.notNull(test(this.elementAt(i)))) return true;
          if (length != this.length) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
        }
        return false;
      }
      firstWhere(test, opts) {
        dart.as(test, dart.functionType(core.bool, [E]));
        let orElse = opts && 'orElse' in opts ? opts.orElse : null;
        dart.as(orElse, dart.functionType(E, []));
        let length = this.length;
        for (let i = 0; i < dart.notNull(length); i++) {
          let element = this.elementAt(i);
          if (dart.notNull(test(element))) return element;
          if (length != this.length) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
        }
        if (orElse != null) return orElse();
        dart.throw(_internal.IterableElementError.noElement());
      }
      lastWhere(test, opts) {
        dart.as(test, dart.functionType(core.bool, [E]));
        let orElse = opts && 'orElse' in opts ? opts.orElse : null;
        dart.as(orElse, dart.functionType(E, []));
        let length = this.length;
        for (let i = dart.notNull(length) - 1; i >= 0; i--) {
          let element = this.elementAt(i);
          if (dart.notNull(test(element))) return element;
          if (length != this.length) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
        }
        if (orElse != null) return orElse();
        dart.throw(_internal.IterableElementError.noElement());
      }
      singleWhere(test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        let length = this.length;
        let match = null;
        let matchFound = false;
        for (let i = 0; i < dart.notNull(length); i++) {
          let element = this.elementAt(i);
          if (dart.notNull(test(element))) {
            if (matchFound) {
              dart.throw(_internal.IterableElementError.tooMany());
            }
            matchFound = true;
            match = element;
          }
          if (length != this.length) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
        }
        if (matchFound) return match;
        dart.throw(_internal.IterableElementError.noElement());
      }
      join(separator) {
        if (separator === void 0) separator = "";
        let length = this.length;
        if (!dart.notNull(separator[dartx.isEmpty])) {
          if (length == 0) return "";
          let first = `${this.elementAt(0)}`;
          if (length != this.length) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
          let buffer = new core.StringBuffer(first);
          for (let i = 1; i < dart.notNull(length); i++) {
            buffer.write(separator);
            buffer.write(this.elementAt(i));
            if (length != this.length) {
              dart.throw(new core.ConcurrentModificationError(this));
            }
          }
          return buffer.toString();
        } else {
          let buffer = new core.StringBuffer();
          for (let i = 0; i < dart.notNull(length); i++) {
            buffer.write(this.elementAt(i));
            if (length != this.length) {
              dart.throw(new core.ConcurrentModificationError(this));
            }
          }
          return buffer.toString();
        }
      }
      where(test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        return super.where(test);
      }
      map(T) {
        return f => {
          dart.as(f, dart.functionType(T, [E]));
          return new (_internal.MappedListIterable$(E, T))(this, f);
        };
      }
      reduce(combine) {
        dart.as(combine, dart.functionType(E, [dart.dynamic, E]));
        let length = this.length;
        if (length == 0) dart.throw(_internal.IterableElementError.noElement());
        let value = this.elementAt(0);
        for (let i = 1; i < dart.notNull(length); i++) {
          value = dart.dcall(combine, value, this.elementAt(i));
          if (length != this.length) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
        }
        return value;
      }
      fold(T) {
        return (initialValue, combine) => {
          dart.as(combine, dart.functionType(T, [T, E]));
          let value = initialValue;
          let length = this.length;
          for (let i = 0; i < dart.notNull(length); i++) {
            value = combine(value, this.elementAt(i));
            if (length != this.length) {
              dart.throw(new core.ConcurrentModificationError(this));
            }
          }
          return value;
        };
      }
      skip(count) {
        return new (_internal.SubListIterable$(E))(this, count, null);
      }
      skipWhile(test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        return super.skipWhile(test);
      }
      take(count) {
        return new (_internal.SubListIterable$(E))(this, 0, count);
      }
      takeWhile(test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        return super.takeWhile(test);
      }
      toList(opts) {
        let growable = opts && 'growable' in opts ? opts.growable : true;
        let result = null;
        if (dart.notNull(growable)) {
          result = core.List$(E).new();
          result[dartx.length] = this.length;
        } else {
          result = core.List$(E).new(this.length);
        }
        for (let i = 0; i < dart.notNull(this.length); i++) {
          result[dartx.set](i, this.elementAt(i));
        }
        return result;
      }
      toSet() {
        let result = core.Set$(E).new();
        for (let i = 0; i < dart.notNull(this.length); i++) {
          result.add(this.elementAt(i));
        }
        return result;
      }
    }
    ListIterable[dart.implements] = () => [_internal.EfficientLength];
    dart.setSignature(ListIterable, {
      constructors: () => ({ListIterable: [_internal.ListIterable$(E), []]}),
      methods: () => ({
        forEach: [dart.void, [dart.functionType(dart.void, [E])]],
        every: [core.bool, [dart.functionType(core.bool, [E])]],
        any: [core.bool, [dart.functionType(core.bool, [E])]],
        firstWhere: [E, [dart.functionType(core.bool, [E])], {orElse: dart.functionType(E, [])}],
        lastWhere: [E, [dart.functionType(core.bool, [E])], {orElse: dart.functionType(E, [])}],
        singleWhere: [E, [dart.functionType(core.bool, [E])]],
        where: [core.Iterable$(E), [dart.functionType(core.bool, [E])]],
        map: [T => [core.Iterable$(T), [dart.functionType(T, [E])]]],
        reduce: [E, [dart.functionType(E, [dart.dynamic, E])]],
        fold: [T => [T, [T, dart.functionType(T, [T, E])]]],
        skip: [core.Iterable$(E), [core.int]],
        skipWhile: [core.Iterable$(E), [dart.functionType(core.bool, [E])]],
        take: [core.Iterable$(E), [core.int]],
        takeWhile: [core.Iterable$(E), [dart.functionType(core.bool, [E])]],
        toList: [core.List$(E), [], {growable: core.bool}],
        toSet: [core.Set$(E), []]
      })
    });
    dart.defineExtensionMembers(ListIterable, [
      'forEach',
      'contains',
      'every',
      'any',
      'firstWhere',
      'lastWhere',
      'singleWhere',
      'join',
      'where',
      'map',
      'reduce',
      'fold',
      'skip',
      'skipWhile',
      'take',
      'takeWhile',
      'toList',
      'toSet',
      'iterator',
      'isEmpty',
      'first',
      'last',
      'single'
    ]);
    return ListIterable;
  });
  _internal.ListIterable = _internal.ListIterable$();
  const _iterable$ = Symbol('_iterable');
  const _start = Symbol('_start');
  const _endOrLength = Symbol('_endOrLength');
  const _endIndex = Symbol('_endIndex');
  const _startIndex = Symbol('_startIndex');
  _internal.SubListIterable$ = dart.generic(E => {
    class SubListIterable extends _internal.ListIterable$(E) {
      SubListIterable(iterable, start, endOrLength) {
        this[_iterable$] = iterable;
        this[_start] = start;
        this[_endOrLength] = endOrLength;
        super.ListIterable();
        core.RangeError.checkNotNegative(this[_start], "start");
        if (this[_endOrLength] != null) {
          core.RangeError.checkNotNegative(this[_endOrLength], "end");
          if (dart.notNull(this[_start]) > dart.notNull(this[_endOrLength])) {
            dart.throw(new core.RangeError.range(this[_start], 0, this[_endOrLength], "start"));
          }
        }
      }
      get [_endIndex]() {
        let length = this[_iterable$][dartx.length];
        if (this[_endOrLength] == null || dart.notNull(this[_endOrLength]) > dart.notNull(length)) return length;
        return this[_endOrLength];
      }
      get [_startIndex]() {
        let length = this[_iterable$][dartx.length];
        if (dart.notNull(this[_start]) > dart.notNull(length)) return length;
        return this[_start];
      }
      get length() {
        let length = this[_iterable$][dartx.length];
        if (dart.notNull(this[_start]) >= dart.notNull(length)) return 0;
        if (this[_endOrLength] == null || dart.notNull(this[_endOrLength]) >= dart.notNull(length)) {
          return dart.notNull(length) - dart.notNull(this[_start]);
        }
        return dart.notNull(this[_endOrLength]) - dart.notNull(this[_start]);
      }
      elementAt(index) {
        let realIndex = dart.notNull(this[_startIndex]) + dart.notNull(index);
        if (dart.notNull(index) < 0 || realIndex >= dart.notNull(this[_endIndex])) {
          dart.throw(core.RangeError.index(index, this, "index"));
        }
        return this[_iterable$][dartx.elementAt](realIndex);
      }
      skip(count) {
        core.RangeError.checkNotNegative(count, "count");
        let newStart = dart.notNull(this[_start]) + dart.notNull(count);
        if (this[_endOrLength] != null && newStart >= dart.notNull(this[_endOrLength])) {
          return new (_internal.EmptyIterable$(E))();
        }
        return new (_internal.SubListIterable$(E))(this[_iterable$], newStart, this[_endOrLength]);
      }
      take(count) {
        core.RangeError.checkNotNegative(count, "count");
        if (this[_endOrLength] == null) {
          return new (_internal.SubListIterable$(E))(this[_iterable$], this[_start], dart.notNull(this[_start]) + dart.notNull(count));
        } else {
          let newEnd = dart.notNull(this[_start]) + dart.notNull(count);
          if (dart.notNull(this[_endOrLength]) < newEnd) return this;
          return new (_internal.SubListIterable$(E))(this[_iterable$], this[_start], newEnd);
        }
      }
      toList(opts) {
        let growable = opts && 'growable' in opts ? opts.growable : true;
        let start = this[_start];
        let end = this[_iterable$][dartx.length];
        if (this[_endOrLength] != null && dart.notNull(this[_endOrLength]) < dart.notNull(end)) end = this[_endOrLength];
        let length = dart.notNull(end) - dart.notNull(start);
        if (length < 0) length = 0;
        let result = dart.notNull(growable) ? (() => {
          let _ = core.List$(E).new();
          _[dartx.length] = length;
          return _;
        })() : core.List$(E).new(length);
        for (let i = 0; i < length; i++) {
          result[dartx.set](i, this[_iterable$][dartx.elementAt](dart.notNull(start) + i));
          if (dart.notNull(this[_iterable$][dartx.length]) < dart.notNull(end)) dart.throw(new core.ConcurrentModificationError(this));
        }
        return result;
      }
    }
    dart.setSignature(SubListIterable, {
      constructors: () => ({SubListIterable: [_internal.SubListIterable$(E), [core.Iterable$(E), core.int, core.int]]}),
      methods: () => ({
        elementAt: [E, [core.int]],
        skip: [core.Iterable$(E), [core.int]],
        take: [core.Iterable$(E), [core.int]],
        toList: [core.List$(E), [], {growable: core.bool}]
      })
    });
    dart.defineExtensionMembers(SubListIterable, [
      'elementAt',
      'skip',
      'take',
      'toList',
      'length'
    ]);
    return SubListIterable;
  });
  _internal.SubListIterable = _internal.SubListIterable$();
  const _length$ = Symbol('_length');
  const _index$ = Symbol('_index');
  const _current$ = Symbol('_current');
  _internal.ListIterator$ = dart.generic(E => {
    class ListIterator extends core.Object {
      ListIterator(iterable) {
        this[_iterable$] = iterable;
        this[_length$] = iterable[dartx.length];
        this[_index$] = 0;
        this[_current$] = null;
      }
      get current() {
        return this[_current$];
      }
      moveNext() {
        let length = this[_iterable$][dartx.length];
        if (this[_length$] != length) {
          dart.throw(new core.ConcurrentModificationError(this[_iterable$]));
        }
        if (dart.notNull(this[_index$]) >= dart.notNull(length)) {
          this[_current$] = null;
          return false;
        }
        this[_current$] = this[_iterable$][dartx.elementAt](this[_index$]);
        this[_index$] = dart.notNull(this[_index$]) + 1;
        return true;
      }
    }
    ListIterator[dart.implements] = () => [core.Iterator$(E)];
    dart.setSignature(ListIterator, {
      constructors: () => ({ListIterator: [_internal.ListIterator$(E), [core.Iterable$(E)]]}),
      methods: () => ({moveNext: [core.bool, []]})
    });
    return ListIterator;
  });
  _internal.ListIterator = _internal.ListIterator$();
  _internal._Transformation$ = dart.generic((S, T) => {
    const _Transformation = dart.typedef('_Transformation', () => dart.functionType(T, [S]));
    return _Transformation;
  });
  _internal._Transformation = _internal._Transformation$();
  const _f = Symbol('_f');
  _internal.MappedIterable$ = dart.generic((S, T) => {
    class MappedIterable extends core.Iterable$(T) {
      static new(iterable, func) {
        if (dart.is(iterable, _internal.EfficientLength)) {
          return new (_internal.EfficientLengthMappedIterable$(S, T))(iterable, func);
        }
        return new (_internal.MappedIterable$(S, T))._(iterable, func);
      }
      _(iterable, f) {
        this[_iterable$] = iterable;
        this[_f] = f;
        super.Iterable();
      }
      get iterator() {
        return new (_internal.MappedIterator$(S, T))(this[_iterable$][dartx.iterator], this[_f]);
      }
      get length() {
        return this[_iterable$][dartx.length];
      }
      get isEmpty() {
        return this[_iterable$][dartx.isEmpty];
      }
      get first() {
        return this[_f](this[_iterable$][dartx.first]);
      }
      get last() {
        return this[_f](this[_iterable$][dartx.last]);
      }
      get single() {
        return this[_f](this[_iterable$][dartx.single]);
      }
      elementAt(index) {
        return this[_f](this[_iterable$][dartx.elementAt](index));
      }
    }
    dart.defineNamedConstructor(MappedIterable, '_');
    dart.setSignature(MappedIterable, {
      constructors: () => ({
        new: [_internal.MappedIterable$(S, T), [core.Iterable$(S), dart.functionType(T, [S])]],
        _: [_internal.MappedIterable$(S, T), [core.Iterable$(S), dart.functionType(T, [S])]]
      }),
      methods: () => ({elementAt: [T, [core.int]]})
    });
    dart.defineExtensionMembers(MappedIterable, [
      'elementAt',
      'iterator',
      'length',
      'isEmpty',
      'first',
      'last',
      'single'
    ]);
    return MappedIterable;
  });
  _internal.MappedIterable = _internal.MappedIterable$();
  _internal.EfficientLengthMappedIterable$ = dart.generic((S, T) => {
    class EfficientLengthMappedIterable extends _internal.MappedIterable$(S, T) {
      EfficientLengthMappedIterable(iterable, func) {
        super._(iterable, func);
      }
    }
    EfficientLengthMappedIterable[dart.implements] = () => [_internal.EfficientLength];
    dart.setSignature(EfficientLengthMappedIterable, {
      constructors: () => ({EfficientLengthMappedIterable: [_internal.EfficientLengthMappedIterable$(S, T), [core.Iterable$(S), dart.functionType(T, [S])]]})
    });
    return EfficientLengthMappedIterable;
  });
  _internal.EfficientLengthMappedIterable = _internal.EfficientLengthMappedIterable$();
  const _iterator = Symbol('_iterator');
  core.Iterator$ = dart.generic(E => {
    class Iterator extends core.Object {}
    return Iterator;
  });
  core.Iterator = core.Iterator$();
  _internal.MappedIterator$ = dart.generic((S, T) => {
    class MappedIterator extends core.Iterator$(T) {
      MappedIterator(iterator, f) {
        this[_iterator] = iterator;
        this[_f] = f;
        this[_current$] = null;
      }
      moveNext() {
        if (dart.notNull(this[_iterator].moveNext())) {
          this[_current$] = this[_f](this[_iterator].current);
          return true;
        }
        this[_current$] = null;
        return false;
      }
      get current() {
        return this[_current$];
      }
    }
    dart.setSignature(MappedIterator, {
      constructors: () => ({MappedIterator: [_internal.MappedIterator$(S, T), [core.Iterator$(S), dart.functionType(T, [S])]]}),
      methods: () => ({moveNext: [core.bool, []]})
    });
    return MappedIterator;
  });
  _internal.MappedIterator = _internal.MappedIterator$();
  const _source = Symbol('_source');
  _internal.MappedListIterable$ = dart.generic((S, T) => {
    class MappedListIterable extends _internal.ListIterable$(T) {
      MappedListIterable(source, f) {
        this[_source] = source;
        this[_f] = f;
        super.ListIterable();
      }
      get length() {
        return this[_source][dartx.length];
      }
      elementAt(index) {
        return this[_f](this[_source][dartx.elementAt](index));
      }
    }
    MappedListIterable[dart.implements] = () => [_internal.EfficientLength];
    dart.setSignature(MappedListIterable, {
      constructors: () => ({MappedListIterable: [_internal.MappedListIterable$(S, T), [core.Iterable$(S), dart.functionType(T, [S])]]}),
      methods: () => ({elementAt: [T, [core.int]]})
    });
    dart.defineExtensionMembers(MappedListIterable, ['elementAt', 'length']);
    return MappedListIterable;
  });
  _internal.MappedListIterable = _internal.MappedListIterable$();
  _internal._ElementPredicate$ = dart.generic(E => {
    const _ElementPredicate = dart.typedef('_ElementPredicate', () => dart.functionType(core.bool, [E]));
    return _ElementPredicate;
  });
  _internal._ElementPredicate = _internal._ElementPredicate$();
  _internal.WhereIterable$ = dart.generic(E => {
    class WhereIterable extends core.Iterable$(E) {
      WhereIterable(iterable, f) {
        this[_iterable$] = iterable;
        this[_f] = f;
        super.Iterable();
      }
      get iterator() {
        return new (_internal.WhereIterator$(E))(this[_iterable$][dartx.iterator], this[_f]);
      }
    }
    dart.setSignature(WhereIterable, {
      constructors: () => ({WhereIterable: [_internal.WhereIterable$(E), [core.Iterable$(E), dart.functionType(core.bool, [E])]]})
    });
    dart.defineExtensionMembers(WhereIterable, ['iterator']);
    return WhereIterable;
  });
  _internal.WhereIterable = _internal.WhereIterable$();
  _internal.WhereIterator$ = dart.generic(E => {
    class WhereIterator extends core.Iterator$(E) {
      WhereIterator(iterator, f) {
        this[_iterator] = iterator;
        this[_f] = f;
      }
      moveNext() {
        while (dart.notNull(this[_iterator].moveNext())) {
          if (dart.notNull(this[_f](this[_iterator].current))) {
            return true;
          }
        }
        return false;
      }
      get current() {
        return this[_iterator].current;
      }
    }
    dart.setSignature(WhereIterator, {
      constructors: () => ({WhereIterator: [_internal.WhereIterator$(E), [core.Iterator$(E), dart.functionType(core.bool, [E])]]}),
      methods: () => ({moveNext: [core.bool, []]})
    });
    return WhereIterator;
  });
  _internal.WhereIterator = _internal.WhereIterator$();
  _internal._ExpandFunction$ = dart.generic((S, T) => {
    const _ExpandFunction = dart.typedef('_ExpandFunction', () => dart.functionType(core.Iterable$(T), [S]));
    return _ExpandFunction;
  });
  _internal._ExpandFunction = _internal._ExpandFunction$();
  _internal.ExpandIterable$ = dart.generic((S, T) => {
    class ExpandIterable extends core.Iterable$(T) {
      ExpandIterable(iterable, f) {
        this[_iterable$] = iterable;
        this[_f] = f;
        super.Iterable();
      }
      get iterator() {
        return new (_internal.ExpandIterator$(S, T))(this[_iterable$][dartx.iterator], this[_f]);
      }
    }
    dart.setSignature(ExpandIterable, {
      constructors: () => ({ExpandIterable: [_internal.ExpandIterable$(S, T), [core.Iterable$(S), dart.functionType(core.Iterable$(T), [S])]]})
    });
    dart.defineExtensionMembers(ExpandIterable, ['iterator']);
    return ExpandIterable;
  });
  _internal.ExpandIterable = _internal.ExpandIterable$();
  const _currentExpansion = Symbol('_currentExpansion');
  _internal.ExpandIterator$ = dart.generic((S, T) => {
    class ExpandIterator extends core.Object {
      ExpandIterator(iterator, f) {
        this[_iterator] = iterator;
        this[_f] = f;
        this[_currentExpansion] = dart.const(new (_internal.EmptyIterator$(T))());
        this[_current$] = null;
      }
      get current() {
        return this[_current$];
      }
      moveNext() {
        if (this[_currentExpansion] == null) return false;
        while (!dart.notNull(this[_currentExpansion].moveNext())) {
          this[_current$] = null;
          if (dart.notNull(this[_iterator].moveNext())) {
            this[_currentExpansion] = null;
            this[_currentExpansion] = this[_f](this[_iterator].current)[dartx.iterator];
          } else {
            return false;
          }
        }
        this[_current$] = this[_currentExpansion].current;
        return true;
      }
    }
    ExpandIterator[dart.implements] = () => [core.Iterator$(T)];
    dart.setSignature(ExpandIterator, {
      constructors: () => ({ExpandIterator: [_internal.ExpandIterator$(S, T), [core.Iterator$(S), dart.functionType(core.Iterable$(T), [S])]]}),
      methods: () => ({moveNext: [core.bool, []]})
    });
    return ExpandIterator;
  });
  _internal.ExpandIterator = _internal.ExpandIterator$();
  const _takeCount = Symbol('_takeCount');
  _internal.TakeIterable$ = dart.generic(E => {
    class TakeIterable extends core.Iterable$(E) {
      static new(iterable, takeCount) {
        if (!(typeof takeCount == 'number') || dart.notNull(takeCount) < 0) {
          dart.throw(new core.ArgumentError(takeCount));
        }
        if (dart.is(iterable, _internal.EfficientLength)) {
          return new (_internal.EfficientLengthTakeIterable$(E))(iterable, takeCount);
        }
        return new (_internal.TakeIterable$(E))._(iterable, takeCount);
      }
      _(iterable, takeCount) {
        this[_iterable$] = iterable;
        this[_takeCount] = takeCount;
        super.Iterable();
      }
      get iterator() {
        return new (_internal.TakeIterator$(E))(this[_iterable$][dartx.iterator], this[_takeCount]);
      }
    }
    dart.defineNamedConstructor(TakeIterable, '_');
    dart.setSignature(TakeIterable, {
      constructors: () => ({
        new: [_internal.TakeIterable$(E), [core.Iterable$(E), core.int]],
        _: [_internal.TakeIterable$(E), [core.Iterable$(E), core.int]]
      })
    });
    dart.defineExtensionMembers(TakeIterable, ['iterator']);
    return TakeIterable;
  });
  _internal.TakeIterable = _internal.TakeIterable$();
  _internal.EfficientLengthTakeIterable$ = dart.generic(E => {
    class EfficientLengthTakeIterable extends _internal.TakeIterable$(E) {
      EfficientLengthTakeIterable(iterable, takeCount) {
        super._(iterable, takeCount);
      }
      get length() {
        let iterableLength = this[_iterable$][dartx.length];
        if (dart.notNull(iterableLength) > dart.notNull(this[_takeCount])) return this[_takeCount];
        return iterableLength;
      }
    }
    EfficientLengthTakeIterable[dart.implements] = () => [_internal.EfficientLength];
    dart.setSignature(EfficientLengthTakeIterable, {
      constructors: () => ({EfficientLengthTakeIterable: [_internal.EfficientLengthTakeIterable$(E), [core.Iterable$(E), core.int]]})
    });
    dart.defineExtensionMembers(EfficientLengthTakeIterable, ['length']);
    return EfficientLengthTakeIterable;
  });
  _internal.EfficientLengthTakeIterable = _internal.EfficientLengthTakeIterable$();
  const _remaining = Symbol('_remaining');
  _internal.TakeIterator$ = dart.generic(E => {
    class TakeIterator extends core.Iterator$(E) {
      TakeIterator(iterator, remaining) {
        this[_iterator] = iterator;
        this[_remaining] = remaining;
        dart.assert(typeof this[_remaining] == 'number' && dart.notNull(this[_remaining]) >= 0);
      }
      moveNext() {
        this[_remaining] = dart.notNull(this[_remaining]) - 1;
        if (dart.notNull(this[_remaining]) >= 0) {
          return this[_iterator].moveNext();
        }
        this[_remaining] = -1;
        return false;
      }
      get current() {
        if (dart.notNull(this[_remaining]) < 0) return null;
        return this[_iterator].current;
      }
    }
    dart.setSignature(TakeIterator, {
      constructors: () => ({TakeIterator: [_internal.TakeIterator$(E), [core.Iterator$(E), core.int]]}),
      methods: () => ({moveNext: [core.bool, []]})
    });
    return TakeIterator;
  });
  _internal.TakeIterator = _internal.TakeIterator$();
  _internal.TakeWhileIterable$ = dart.generic(E => {
    class TakeWhileIterable extends core.Iterable$(E) {
      TakeWhileIterable(iterable, f) {
        this[_iterable$] = iterable;
        this[_f] = f;
        super.Iterable();
      }
      get iterator() {
        return new (_internal.TakeWhileIterator$(E))(this[_iterable$][dartx.iterator], this[_f]);
      }
    }
    dart.setSignature(TakeWhileIterable, {
      constructors: () => ({TakeWhileIterable: [_internal.TakeWhileIterable$(E), [core.Iterable$(E), dart.functionType(core.bool, [E])]]})
    });
    dart.defineExtensionMembers(TakeWhileIterable, ['iterator']);
    return TakeWhileIterable;
  });
  _internal.TakeWhileIterable = _internal.TakeWhileIterable$();
  const _isFinished = Symbol('_isFinished');
  _internal.TakeWhileIterator$ = dart.generic(E => {
    class TakeWhileIterator extends core.Iterator$(E) {
      TakeWhileIterator(iterator, f) {
        this[_iterator] = iterator;
        this[_f] = f;
        this[_isFinished] = false;
      }
      moveNext() {
        if (dart.notNull(this[_isFinished])) return false;
        if (!dart.notNull(this[_iterator].moveNext()) || !dart.notNull(this[_f](this[_iterator].current))) {
          this[_isFinished] = true;
          return false;
        }
        return true;
      }
      get current() {
        if (dart.notNull(this[_isFinished])) return null;
        return this[_iterator].current;
      }
    }
    dart.setSignature(TakeWhileIterator, {
      constructors: () => ({TakeWhileIterator: [_internal.TakeWhileIterator$(E), [core.Iterator$(E), dart.functionType(core.bool, [E])]]}),
      methods: () => ({moveNext: [core.bool, []]})
    });
    return TakeWhileIterator;
  });
  _internal.TakeWhileIterator = _internal.TakeWhileIterator$();
  const _skipCount = Symbol('_skipCount');
  _internal.SkipIterable$ = dart.generic(E => {
    class SkipIterable extends core.Iterable$(E) {
      static new(iterable, count) {
        if (dart.is(iterable, _internal.EfficientLength)) {
          return new (_internal.EfficientLengthSkipIterable$(E))(iterable, count);
        }
        return new (_internal.SkipIterable$(E))._(iterable, count);
      }
      _(iterable, skipCount) {
        this[_iterable$] = iterable;
        this[_skipCount] = skipCount;
        super.Iterable();
        if (!(typeof this[_skipCount] == 'number')) {
          dart.throw(new core.ArgumentError.value(this[_skipCount], "count is not an integer"));
        }
        core.RangeError.checkNotNegative(this[_skipCount], "count");
      }
      skip(count) {
        if (!(typeof this[_skipCount] == 'number')) {
          dart.throw(new core.ArgumentError.value(this[_skipCount], "count is not an integer"));
        }
        core.RangeError.checkNotNegative(this[_skipCount], "count");
        return new (_internal.SkipIterable$(E))._(this[_iterable$], dart.notNull(this[_skipCount]) + dart.notNull(count));
      }
      get iterator() {
        return new (_internal.SkipIterator$(E))(this[_iterable$][dartx.iterator], this[_skipCount]);
      }
    }
    dart.defineNamedConstructor(SkipIterable, '_');
    dart.setSignature(SkipIterable, {
      constructors: () => ({
        new: [_internal.SkipIterable$(E), [core.Iterable$(E), core.int]],
        _: [_internal.SkipIterable$(E), [core.Iterable$(E), core.int]]
      }),
      methods: () => ({skip: [core.Iterable$(E), [core.int]]})
    });
    dart.defineExtensionMembers(SkipIterable, ['skip', 'iterator']);
    return SkipIterable;
  });
  _internal.SkipIterable = _internal.SkipIterable$();
  _internal.EfficientLengthSkipIterable$ = dart.generic(E => {
    class EfficientLengthSkipIterable extends _internal.SkipIterable$(E) {
      EfficientLengthSkipIterable(iterable, skipCount) {
        super._(iterable, skipCount);
      }
      get length() {
        let length = dart.notNull(this[_iterable$][dartx.length]) - dart.notNull(this[_skipCount]);
        if (length >= 0) return length;
        return 0;
      }
    }
    EfficientLengthSkipIterable[dart.implements] = () => [_internal.EfficientLength];
    dart.setSignature(EfficientLengthSkipIterable, {
      constructors: () => ({EfficientLengthSkipIterable: [_internal.EfficientLengthSkipIterable$(E), [core.Iterable$(E), core.int]]})
    });
    dart.defineExtensionMembers(EfficientLengthSkipIterable, ['length']);
    return EfficientLengthSkipIterable;
  });
  _internal.EfficientLengthSkipIterable = _internal.EfficientLengthSkipIterable$();
  _internal.SkipIterator$ = dart.generic(E => {
    class SkipIterator extends core.Iterator$(E) {
      SkipIterator(iterator, skipCount) {
        this[_iterator] = iterator;
        this[_skipCount] = skipCount;
        dart.assert(typeof this[_skipCount] == 'number' && dart.notNull(this[_skipCount]) >= 0);
      }
      moveNext() {
        for (let i = 0; i < dart.notNull(this[_skipCount]); i++)
          this[_iterator].moveNext();
        this[_skipCount] = 0;
        return this[_iterator].moveNext();
      }
      get current() {
        return this[_iterator].current;
      }
    }
    dart.setSignature(SkipIterator, {
      constructors: () => ({SkipIterator: [_internal.SkipIterator$(E), [core.Iterator$(E), core.int]]}),
      methods: () => ({moveNext: [core.bool, []]})
    });
    return SkipIterator;
  });
  _internal.SkipIterator = _internal.SkipIterator$();
  _internal.SkipWhileIterable$ = dart.generic(E => {
    class SkipWhileIterable extends core.Iterable$(E) {
      SkipWhileIterable(iterable, f) {
        this[_iterable$] = iterable;
        this[_f] = f;
        super.Iterable();
      }
      get iterator() {
        return new (_internal.SkipWhileIterator$(E))(this[_iterable$][dartx.iterator], this[_f]);
      }
    }
    dart.setSignature(SkipWhileIterable, {
      constructors: () => ({SkipWhileIterable: [_internal.SkipWhileIterable$(E), [core.Iterable$(E), dart.functionType(core.bool, [E])]]})
    });
    dart.defineExtensionMembers(SkipWhileIterable, ['iterator']);
    return SkipWhileIterable;
  });
  _internal.SkipWhileIterable = _internal.SkipWhileIterable$();
  const _hasSkipped = Symbol('_hasSkipped');
  _internal.SkipWhileIterator$ = dart.generic(E => {
    class SkipWhileIterator extends core.Iterator$(E) {
      SkipWhileIterator(iterator, f) {
        this[_iterator] = iterator;
        this[_f] = f;
        this[_hasSkipped] = false;
      }
      moveNext() {
        if (!dart.notNull(this[_hasSkipped])) {
          this[_hasSkipped] = true;
          while (dart.notNull(this[_iterator].moveNext())) {
            if (!dart.notNull(this[_f](this[_iterator].current))) return true;
          }
        }
        return this[_iterator].moveNext();
      }
      get current() {
        return this[_iterator].current;
      }
    }
    dart.setSignature(SkipWhileIterator, {
      constructors: () => ({SkipWhileIterator: [_internal.SkipWhileIterator$(E), [core.Iterator$(E), dart.functionType(core.bool, [E])]]}),
      methods: () => ({moveNext: [core.bool, []]})
    });
    return SkipWhileIterator;
  });
  _internal.SkipWhileIterator = _internal.SkipWhileIterator$();
  _internal.EmptyIterable$ = dart.generic(E => {
    class EmptyIterable extends core.Iterable$(E) {
      EmptyIterable() {
        super.Iterable();
      }
      get iterator() {
        return dart.const(new (_internal.EmptyIterator$(E))());
      }
      forEach(action) {
        dart.as(action, dart.functionType(dart.void, [E]));
      }
      get isEmpty() {
        return true;
      }
      get length() {
        return 0;
      }
      get first() {
        dart.throw(_internal.IterableElementError.noElement());
      }
      get last() {
        dart.throw(_internal.IterableElementError.noElement());
      }
      get single() {
        dart.throw(_internal.IterableElementError.noElement());
      }
      elementAt(index) {
        dart.throw(new core.RangeError.range(index, 0, 0, "index"));
      }
      contains(element) {
        return false;
      }
      every(test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        return true;
      }
      any(test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        return false;
      }
      firstWhere(test, opts) {
        dart.as(test, dart.functionType(core.bool, [E]));
        let orElse = opts && 'orElse' in opts ? opts.orElse : null;
        dart.as(orElse, dart.functionType(E, []));
        if (orElse != null) return orElse();
        dart.throw(_internal.IterableElementError.noElement());
      }
      lastWhere(test, opts) {
        dart.as(test, dart.functionType(core.bool, [E]));
        let orElse = opts && 'orElse' in opts ? opts.orElse : null;
        dart.as(orElse, dart.functionType(E, []));
        if (orElse != null) return orElse();
        dart.throw(_internal.IterableElementError.noElement());
      }
      singleWhere(test, opts) {
        dart.as(test, dart.functionType(core.bool, [E]));
        let orElse = opts && 'orElse' in opts ? opts.orElse : null;
        dart.as(orElse, dart.functionType(E, []));
        if (orElse != null) return orElse();
        dart.throw(_internal.IterableElementError.noElement());
      }
      join(separator) {
        if (separator === void 0) separator = "";
        return "";
      }
      where(test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        return this;
      }
      map(T) {
        return f => {
          dart.as(f, dart.functionType(T, [E]));
          return dart.const(new (_internal.EmptyIterable$(T))());
        };
      }
      reduce(combine) {
        dart.as(combine, dart.functionType(E, [E, E]));
        dart.throw(_internal.IterableElementError.noElement());
      }
      fold(T) {
        return (initialValue, combine) => {
          dart.as(combine, dart.functionType(T, [T, E]));
          return initialValue;
        };
      }
      skip(count) {
        core.RangeError.checkNotNegative(count, "count");
        return this;
      }
      skipWhile(test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        return this;
      }
      take(count) {
        core.RangeError.checkNotNegative(count, "count");
        return this;
      }
      takeWhile(test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        return this;
      }
      toList(opts) {
        let growable = opts && 'growable' in opts ? opts.growable : true;
        return dart.notNull(growable) ? dart.list([], E) : core.List$(E).new(0);
      }
      toSet() {
        return core.Set$(E).new();
      }
    }
    EmptyIterable[dart.implements] = () => [_internal.EfficientLength];
    dart.setSignature(EmptyIterable, {
      constructors: () => ({EmptyIterable: [_internal.EmptyIterable$(E), []]}),
      methods: () => ({
        forEach: [dart.void, [dart.functionType(dart.void, [E])]],
        elementAt: [E, [core.int]],
        every: [core.bool, [dart.functionType(core.bool, [E])]],
        any: [core.bool, [dart.functionType(core.bool, [E])]],
        firstWhere: [E, [dart.functionType(core.bool, [E])], {orElse: dart.functionType(E, [])}],
        lastWhere: [E, [dart.functionType(core.bool, [E])], {orElse: dart.functionType(E, [])}],
        singleWhere: [E, [dart.functionType(core.bool, [E])], {orElse: dart.functionType(E, [])}],
        where: [core.Iterable$(E), [dart.functionType(core.bool, [E])]],
        map: [T => [core.Iterable$(T), [dart.functionType(T, [E])]]],
        reduce: [E, [dart.functionType(E, [E, E])]],
        fold: [T => [T, [T, dart.functionType(T, [T, E])]]],
        skip: [core.Iterable$(E), [core.int]],
        skipWhile: [core.Iterable$(E), [dart.functionType(core.bool, [E])]],
        take: [core.Iterable$(E), [core.int]],
        takeWhile: [core.Iterable$(E), [dart.functionType(core.bool, [E])]],
        toList: [core.List$(E), [], {growable: core.bool}],
        toSet: [core.Set$(E), []]
      })
    });
    dart.defineExtensionMembers(EmptyIterable, [
      'forEach',
      'elementAt',
      'contains',
      'every',
      'any',
      'firstWhere',
      'lastWhere',
      'singleWhere',
      'join',
      'where',
      'map',
      'reduce',
      'fold',
      'skip',
      'skipWhile',
      'take',
      'takeWhile',
      'toList',
      'toSet',
      'iterator',
      'isEmpty',
      'length',
      'first',
      'last',
      'single'
    ]);
    return EmptyIterable;
  });
  _internal.EmptyIterable = _internal.EmptyIterable$();
  _internal.EmptyIterator$ = dart.generic(E => {
    class EmptyIterator extends core.Object {
      EmptyIterator() {
      }
      moveNext() {
        return false;
      }
      get current() {
        return null;
      }
    }
    EmptyIterator[dart.implements] = () => [core.Iterator$(E)];
    dart.setSignature(EmptyIterator, {
      constructors: () => ({EmptyIterator: [_internal.EmptyIterator$(E), []]}),
      methods: () => ({moveNext: [core.bool, []]})
    });
    return EmptyIterator;
  });
  _internal.EmptyIterator = _internal.EmptyIterator$();
  _internal.IterableElementError = class IterableElementError extends core.Object {
    static noElement() {
      return new core.StateError("No element");
    }
    static tooMany() {
      return new core.StateError("Too many elements");
    }
    static tooFew() {
      return new core.StateError("Too few elements");
    }
  };
  dart.setSignature(_internal.IterableElementError, {
    statics: () => ({
      noElement: [core.StateError, []],
      tooMany: [core.StateError, []],
      tooFew: [core.StateError, []]
    }),
    names: ['noElement', 'tooMany', 'tooFew']
  });
  _internal.FixedLengthListMixin$ = dart.generic(E => {
    dart.defineExtensionNames([
      'length',
      'add',
      'insert',
      'insertAll',
      'addAll',
      'remove',
      'removeWhere',
      'retainWhere',
      'clear',
      'removeAt',
      'removeLast',
      'removeRange',
      'replaceRange'
    ]);
    class FixedLengthListMixin extends core.Object {
      set length(newLength) {
        dart.throw(new core.UnsupportedError("Cannot change the length of a fixed-length list"));
      }
      add(value) {
        dart.as(value, E);
        dart.throw(new core.UnsupportedError("Cannot add to a fixed-length list"));
      }
      insert(index, value) {
        dart.as(value, E);
        dart.throw(new core.UnsupportedError("Cannot add to a fixed-length list"));
      }
      insertAll(at, iterable) {
        dart.as(iterable, core.Iterable$(E));
        dart.throw(new core.UnsupportedError("Cannot add to a fixed-length list"));
      }
      addAll(iterable) {
        dart.as(iterable, core.Iterable$(E));
        dart.throw(new core.UnsupportedError("Cannot add to a fixed-length list"));
      }
      remove(element) {
        dart.throw(new core.UnsupportedError("Cannot remove from a fixed-length list"));
      }
      removeWhere(test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        dart.throw(new core.UnsupportedError("Cannot remove from a fixed-length list"));
      }
      retainWhere(test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        dart.throw(new core.UnsupportedError("Cannot remove from a fixed-length list"));
      }
      clear() {
        dart.throw(new core.UnsupportedError("Cannot clear a fixed-length list"));
      }
      removeAt(index) {
        dart.throw(new core.UnsupportedError("Cannot remove from a fixed-length list"));
      }
      removeLast() {
        dart.throw(new core.UnsupportedError("Cannot remove from a fixed-length list"));
      }
      removeRange(start, end) {
        dart.throw(new core.UnsupportedError("Cannot remove from a fixed-length list"));
      }
      replaceRange(start, end, iterable) {
        dart.as(iterable, core.Iterable$(E));
        dart.throw(new core.UnsupportedError("Cannot remove from a fixed-length list"));
      }
    }
    dart.setSignature(FixedLengthListMixin, {
      methods: () => ({
        add: [dart.void, [E]],
        insert: [dart.void, [core.int, E]],
        insertAll: [dart.void, [core.int, core.Iterable$(E)]],
        addAll: [dart.void, [core.Iterable$(E)]],
        remove: [core.bool, [core.Object]],
        removeWhere: [dart.void, [dart.functionType(core.bool, [E])]],
        retainWhere: [dart.void, [dart.functionType(core.bool, [E])]],
        clear: [dart.void, []],
        removeAt: [E, [core.int]],
        removeLast: [E, []],
        removeRange: [dart.void, [core.int, core.int]],
        replaceRange: [dart.void, [core.int, core.int, core.Iterable$(E)]]
      })
    });
    dart.defineExtensionMembers(FixedLengthListMixin, [
      'add',
      'insert',
      'insertAll',
      'addAll',
      'remove',
      'removeWhere',
      'retainWhere',
      'clear',
      'removeAt',
      'removeLast',
      'removeRange',
      'replaceRange',
      'length'
    ]);
    return FixedLengthListMixin;
  });
  _internal.FixedLengthListMixin = _internal.FixedLengthListMixin$();
  _internal.FixedLengthListBase$ = dart.generic(E => {
    class FixedLengthListBase extends dart.mixin(collection.ListBase$(E), _internal.FixedLengthListMixin$(E)) {
      FixedLengthListBase() {
        super.ListBase();
      }
    }
    return FixedLengthListBase;
  });
  _internal.FixedLengthListBase = _internal.FixedLengthListBase$();
  const _backedList = Symbol('_backedList');
  _internal._ListIndicesIterable = class _ListIndicesIterable extends _internal.ListIterable$(core.int) {
    _ListIndicesIterable(backedList) {
      this[_backedList] = backedList;
      super.ListIterable();
    }
    get length() {
      return this[_backedList][dartx.length];
    }
    elementAt(index) {
      core.RangeError.checkValidIndex(index, this);
      return index;
    }
  };
  dart.setSignature(_internal._ListIndicesIterable, {
    constructors: () => ({_ListIndicesIterable: [_internal._ListIndicesIterable, [core.List]]}),
    methods: () => ({elementAt: [core.int, [core.int]]})
  });
  dart.defineExtensionMembers(_internal._ListIndicesIterable, ['elementAt', 'length']);
  const _values = Symbol('_values');
  _internal.ListMapView$ = dart.generic(E => {
    class ListMapView extends core.Object {
      ListMapView(values) {
        this[_values] = values;
      }
      get(key) {
        return dart.notNull(this.containsKey(key)) ? this[_values][dartx.get](dart.as(key, core.int)) : null;
      }
      get length() {
        return this[_values][dartx.length];
      }
      get values() {
        return new (_internal.SubListIterable$(E))(this[_values], 0, null);
      }
      get keys() {
        return new _internal._ListIndicesIterable(this[_values]);
      }
      get isEmpty() {
        return this[_values][dartx.isEmpty];
      }
      get isNotEmpty() {
        return this[_values][dartx.isNotEmpty];
      }
      containsValue(value) {
        return this[_values][dartx.contains](value);
      }
      containsKey(key) {
        return typeof key == 'number' && dart.notNull(key) >= 0 && dart.notNull(key) < dart.notNull(this.length);
      }
      forEach(f) {
        dart.as(f, dart.functionType(dart.void, [core.int, E]));
        let length = this[_values][dartx.length];
        for (let i = 0; i < dart.notNull(length); i++) {
          f(i, this[_values][dartx.get](i));
          if (length != this[_values][dartx.length]) {
            dart.throw(new core.ConcurrentModificationError(this[_values]));
          }
        }
      }
      set(key, value) {
        dart.as(value, E);
        dart.throw(new core.UnsupportedError("Cannot modify an unmodifiable map"));
        return value;
      }
      putIfAbsent(key, ifAbsent) {
        dart.as(ifAbsent, dart.functionType(E, []));
        dart.throw(new core.UnsupportedError("Cannot modify an unmodifiable map"));
      }
      remove(key) {
        dart.throw(new core.UnsupportedError("Cannot modify an unmodifiable map"));
      }
      clear() {
        dart.throw(new core.UnsupportedError("Cannot modify an unmodifiable map"));
      }
      addAll(other) {
        dart.as(other, core.Map$(core.int, E));
        dart.throw(new core.UnsupportedError("Cannot modify an unmodifiable map"));
      }
      toString() {
        return collection.Maps.mapToString(this);
      }
    }
    ListMapView[dart.implements] = () => [core.Map$(core.int, E)];
    dart.setSignature(ListMapView, {
      constructors: () => ({ListMapView: [_internal.ListMapView$(E), [core.List$(E)]]}),
      methods: () => ({
        get: [E, [core.Object]],
        containsValue: [core.bool, [core.Object]],
        containsKey: [core.bool, [core.Object]],
        forEach: [dart.void, [dart.functionType(dart.void, [core.int, E])]],
        set: [dart.void, [core.int, E]],
        putIfAbsent: [E, [core.int, dart.functionType(E, [])]],
        remove: [E, [core.Object]],
        clear: [dart.void, []],
        addAll: [dart.void, [core.Map$(core.int, E)]]
      })
    });
    dart.defineExtensionMembers(ListMapView, [
      'get',
      'containsValue',
      'containsKey',
      'forEach',
      'set',
      'putIfAbsent',
      'remove',
      'clear',
      'addAll',
      'length',
      'values',
      'keys',
      'isEmpty',
      'isNotEmpty'
    ]);
    return ListMapView;
  });
  _internal.ListMapView = _internal.ListMapView$();
  _internal.ReversedListIterable$ = dart.generic(E => {
    class ReversedListIterable extends _internal.ListIterable$(E) {
      ReversedListIterable(source) {
        this[_source] = source;
        super.ListIterable();
      }
      get length() {
        return this[_source][dartx.length];
      }
      elementAt(index) {
        return this[_source][dartx.elementAt](dart.notNull(this[_source][dartx.length]) - 1 - dart.notNull(index));
      }
    }
    dart.setSignature(ReversedListIterable, {
      constructors: () => ({ReversedListIterable: [_internal.ReversedListIterable$(E), [core.Iterable$(E)]]}),
      methods: () => ({elementAt: [E, [core.int]]})
    });
    dart.defineExtensionMembers(ReversedListIterable, ['elementAt', 'length']);
    return ReversedListIterable;
  });
  _internal.ReversedListIterable = _internal.ReversedListIterable$();
  _internal.UnmodifiableListError = class UnmodifiableListError extends core.Object {
    static add() {
      return new core.UnsupportedError("Cannot add to unmodifiable List");
    }
    static change() {
      return new core.UnsupportedError("Cannot change the content of an unmodifiable List");
    }
    static length() {
      return new core.UnsupportedError("Cannot change length of unmodifiable List");
    }
    static remove() {
      return new core.UnsupportedError("Cannot remove from unmodifiable List");
    }
  };
  dart.setSignature(_internal.UnmodifiableListError, {
    statics: () => ({
      add: [core.UnsupportedError, []],
      change: [core.UnsupportedError, []],
      length: [core.UnsupportedError, []],
      remove: [core.UnsupportedError, []]
    }),
    names: ['add', 'change', 'length', 'remove']
  });
  _internal.NonGrowableListError = class NonGrowableListError extends core.Object {
    static add() {
      return new core.UnsupportedError("Cannot add to non-growable List");
    }
    static length() {
      return new core.UnsupportedError("Cannot change length of non-growable List");
    }
    static remove() {
      return new core.UnsupportedError("Cannot remove from non-growable List");
    }
  };
  dart.setSignature(_internal.NonGrowableListError, {
    statics: () => ({
      add: [core.UnsupportedError, []],
      length: [core.UnsupportedError, []],
      remove: [core.UnsupportedError, []]
    }),
    names: ['add', 'length', 'remove']
  });
  _internal.makeListFixedLength = function(E) {
    return growableList => {
      _interceptors.JSArray.markFixedList(growableList);
      return growableList;
    };
  };
  dart.lazyFn(_internal.makeListFixedLength, () => [E => [core.List$(E), [core.List$(E)]]]);
  _internal.makeFixedListUnmodifiable = function(E) {
    return fixedLengthList => {
      _interceptors.JSArray.markUnmodifiableList(fixedLengthList);
      return fixedLengthList;
    };
  };
  dart.lazyFn(_internal.makeFixedListUnmodifiable, () => [E => [core.List$(E), [core.List$(E)]]]);
  _internal.Lists = class Lists extends core.Object {
    static copy(src, srcStart, dst, dstStart, count) {
      if (dart.notNull(srcStart) < dart.notNull(dstStart)) {
        for (let i = dart.notNull(srcStart) + dart.notNull(count) - 1, j = dart.notNull(dstStart) + dart.notNull(count) - 1; i >= dart.notNull(srcStart); i--, j--) {
          dst[dartx.set](j, src[dartx.get](i));
        }
      } else {
        for (let i = srcStart, j = dstStart; dart.notNull(i) < dart.notNull(srcStart) + dart.notNull(count); i = dart.notNull(i) + 1, j = dart.notNull(j) + 1) {
          dst[dartx.set](j, src[dartx.get](i));
        }
      }
    }
    static areEqual(a, b) {
      if (core.identical(a, b)) return true;
      if (!dart.is(b, core.List)) return false;
      let length = a[dartx.length];
      if (!dart.equals(length, dart.dload(b, 'length'))) return false;
      for (let i = 0; i < dart.notNull(length); i++) {
        if (!core.identical(a[dartx.get](i), dart.dindex(b, i))) return false;
      }
      return true;
    }
    static indexOf(a, element, startIndex, endIndex) {
      if (dart.notNull(startIndex) >= dart.notNull(a[dartx.length])) {
        return -1;
      }
      if (dart.notNull(startIndex) < 0) {
        startIndex = 0;
      }
      for (let i = startIndex; dart.notNull(i) < dart.notNull(endIndex); i = dart.notNull(i) + 1) {
        if (dart.equals(a[dartx.get](i), element)) {
          return i;
        }
      }
      return -1;
    }
    static lastIndexOf(a, element, startIndex) {
      if (dart.notNull(startIndex) < 0) {
        return -1;
      }
      if (dart.notNull(startIndex) >= dart.notNull(a[dartx.length])) {
        startIndex = dart.notNull(a[dartx.length]) - 1;
      }
      for (let i = startIndex; dart.notNull(i) >= 0; i = dart.notNull(i) - 1) {
        if (dart.equals(a[dartx.get](i), element)) {
          return i;
        }
      }
      return -1;
    }
    static indicesCheck(a, start, end) {
      core.RangeError.checkValidRange(start, end, a[dartx.length]);
    }
    static rangeCheck(a, start, length) {
      core.RangeError.checkNotNegative(length);
      core.RangeError.checkNotNegative(start);
      if (dart.notNull(start) + dart.notNull(length) > dart.notNull(a[dartx.length])) {
        let message = `${start} + ${length} must be in the range [0..${a[dartx.length]}]`;
        dart.throw(new core.RangeError.range(length, 0, dart.notNull(a[dartx.length]) - dart.notNull(start), "length", message));
      }
    }
  };
  dart.setSignature(_internal.Lists, {
    statics: () => ({
      copy: [dart.void, [core.List, core.int, core.List, core.int, core.int]],
      areEqual: [core.bool, [core.List, dart.dynamic]],
      indexOf: [core.int, [core.List, core.Object, core.int, core.int]],
      lastIndexOf: [core.int, [core.List, core.Object, core.int]],
      indicesCheck: [dart.void, [core.List, core.int, core.int]],
      rangeCheck: [dart.void, [core.List, core.int, core.int]]
    }),
    names: ['copy', 'areEqual', 'indexOf', 'lastIndexOf', 'indicesCheck', 'rangeCheck']
  });
  _internal.printToZone = null;
  _internal.printToConsole = function(line) {
    _js_primitives.printString(`${line}`);
  };
  dart.lazyFn(_internal.printToConsole, () => [dart.void, [core.String]]);
  _internal.Sort = class Sort extends core.Object {
    static sort(a, compare) {
      _internal.Sort._doSort(a, 0, dart.notNull(a[dartx.length]) - 1, compare);
    }
    static sortRange(a, from, to, compare) {
      if (dart.notNull(from) < 0 || dart.notNull(to) > dart.notNull(a[dartx.length]) || dart.notNull(to) < dart.notNull(from)) {
        dart.throw("OutOfRange");
      }
      _internal.Sort._doSort(a, from, dart.notNull(to) - 1, compare);
    }
    static _doSort(a, left, right, compare) {
      if (dart.notNull(right) - dart.notNull(left) <= dart.notNull(_internal.Sort._INSERTION_SORT_THRESHOLD)) {
        _internal.Sort._insertionSort(a, left, right, compare);
      } else {
        _internal.Sort._dualPivotQuicksort(a, left, right, compare);
      }
    }
    static _insertionSort(a, left, right, compare) {
      for (let i = dart.notNull(left) + 1; i <= dart.notNull(right); i++) {
        let el = a[dartx.get](i);
        let j = i;
        while (j > dart.notNull(left) && dart.notNull(dart.dcall(compare, a[dartx.get](j - 1), el)) > 0) {
          a[dartx.set](j, a[dartx.get](j - 1));
          j--;
        }
        a[dartx.set](j, el);
      }
    }
    static _dualPivotQuicksort(a, left, right, compare) {
      dart.assert(dart.notNull(right) - dart.notNull(left) > dart.notNull(_internal.Sort._INSERTION_SORT_THRESHOLD));
      let sixth = ((dart.notNull(right) - dart.notNull(left) + 1) / 6)[dartx.truncate]();
      let index1 = dart.notNull(left) + sixth;
      let index5 = dart.notNull(right) - sixth;
      let index3 = ((dart.notNull(left) + dart.notNull(right)) / 2)[dartx.truncate]();
      let index2 = index3 - sixth;
      let index4 = index3 + sixth;
      let el1 = a[dartx.get](index1);
      let el2 = a[dartx.get](index2);
      let el3 = a[dartx.get](index3);
      let el4 = a[dartx.get](index4);
      let el5 = a[dartx.get](index5);
      if (dart.notNull(dart.dcall(compare, el1, el2)) > 0) {
        let t = el1;
        el1 = el2;
        el2 = t;
      }
      if (dart.notNull(dart.dcall(compare, el4, el5)) > 0) {
        let t = el4;
        el4 = el5;
        el5 = t;
      }
      if (dart.notNull(dart.dcall(compare, el1, el3)) > 0) {
        let t = el1;
        el1 = el3;
        el3 = t;
      }
      if (dart.notNull(dart.dcall(compare, el2, el3)) > 0) {
        let t = el2;
        el2 = el3;
        el3 = t;
      }
      if (dart.notNull(dart.dcall(compare, el1, el4)) > 0) {
        let t = el1;
        el1 = el4;
        el4 = t;
      }
      if (dart.notNull(dart.dcall(compare, el3, el4)) > 0) {
        let t = el3;
        el3 = el4;
        el4 = t;
      }
      if (dart.notNull(dart.dcall(compare, el2, el5)) > 0) {
        let t = el2;
        el2 = el5;
        el5 = t;
      }
      if (dart.notNull(dart.dcall(compare, el2, el3)) > 0) {
        let t = el2;
        el2 = el3;
        el3 = t;
      }
      if (dart.notNull(dart.dcall(compare, el4, el5)) > 0) {
        let t = el4;
        el4 = el5;
        el5 = t;
      }
      let pivot1 = el2;
      let pivot2 = el4;
      a[dartx.set](index1, el1);
      a[dartx.set](index3, el3);
      a[dartx.set](index5, el5);
      a[dartx.set](index2, a[dartx.get](left));
      a[dartx.set](index4, a[dartx.get](right));
      let less = dart.notNull(left) + 1;
      let great = dart.notNull(right) - 1;
      let pivots_are_equal = dart.dcall(compare, pivot1, pivot2) == 0;
      if (pivots_are_equal) {
        let pivot = pivot1;
        for (let k = less; k <= great; k++) {
          let ak = a[dartx.get](k);
          let comp = dart.dcall(compare, ak, pivot);
          if (comp == 0) continue;
          if (dart.notNull(comp) < 0) {
            if (k != less) {
              a[dartx.set](k, a[dartx.get](less));
              a[dartx.set](less, ak);
            }
            less++;
          } else {
            while (true) {
              comp = dart.dcall(compare, a[dartx.get](great), pivot);
              if (dart.notNull(comp) > 0) {
                great--;
                continue;
              } else if (dart.notNull(comp) < 0) {
                a[dartx.set](k, a[dartx.get](less));
                a[dartx.set](less++, a[dartx.get](great));
                a[dartx.set](great--, ak);
                break;
              } else {
                a[dartx.set](k, a[dartx.get](great));
                a[dartx.set](great--, ak);
                break;
              }
            }
          }
        }
      } else {
        for (let k = less; k <= great; k++) {
          let ak = a[dartx.get](k);
          let comp_pivot1 = dart.dcall(compare, ak, pivot1);
          if (dart.notNull(comp_pivot1) < 0) {
            if (k != less) {
              a[dartx.set](k, a[dartx.get](less));
              a[dartx.set](less, ak);
            }
            less++;
          } else {
            let comp_pivot2 = dart.dcall(compare, ak, pivot2);
            if (dart.notNull(comp_pivot2) > 0) {
              while (true) {
                let comp = dart.dcall(compare, a[dartx.get](great), pivot2);
                if (dart.notNull(comp) > 0) {
                  great--;
                  if (great < k) break;
                  continue;
                } else {
                  comp = dart.dcall(compare, a[dartx.get](great), pivot1);
                  if (dart.notNull(comp) < 0) {
                    a[dartx.set](k, a[dartx.get](less));
                    a[dartx.set](less++, a[dartx.get](great));
                    a[dartx.set](great--, ak);
                  } else {
                    a[dartx.set](k, a[dartx.get](great));
                    a[dartx.set](great--, ak);
                  }
                  break;
                }
              }
            }
          }
        }
      }
      a[dartx.set](left, a[dartx.get](less - 1));
      a[dartx.set](less - 1, pivot1);
      a[dartx.set](right, a[dartx.get](great + 1));
      a[dartx.set](great + 1, pivot2);
      _internal.Sort._doSort(a, left, less - 2, compare);
      _internal.Sort._doSort(a, great + 2, right, compare);
      if (pivots_are_equal) {
        return;
      }
      if (less < index1 && great > index5) {
        while (dart.dcall(compare, a[dartx.get](less), pivot1) == 0) {
          less++;
        }
        while (dart.dcall(compare, a[dartx.get](great), pivot2) == 0) {
          great--;
        }
        for (let k = less; k <= great; k++) {
          let ak = a[dartx.get](k);
          let comp_pivot1 = dart.dcall(compare, ak, pivot1);
          if (comp_pivot1 == 0) {
            if (k != less) {
              a[dartx.set](k, a[dartx.get](less));
              a[dartx.set](less, ak);
            }
            less++;
          } else {
            let comp_pivot2 = dart.dcall(compare, ak, pivot2);
            if (comp_pivot2 == 0) {
              while (true) {
                let comp = dart.dcall(compare, a[dartx.get](great), pivot2);
                if (comp == 0) {
                  great--;
                  if (great < k) break;
                  continue;
                } else {
                  comp = dart.dcall(compare, a[dartx.get](great), pivot1);
                  if (dart.notNull(comp) < 0) {
                    a[dartx.set](k, a[dartx.get](less));
                    a[dartx.set](less++, a[dartx.get](great));
                    a[dartx.set](great--, ak);
                  } else {
                    a[dartx.set](k, a[dartx.get](great));
                    a[dartx.set](great--, ak);
                  }
                  break;
                }
              }
            }
          }
        }
        _internal.Sort._doSort(a, less, great, compare);
      } else {
        _internal.Sort._doSort(a, less, great, compare);
      }
    }
  };
  dart.setSignature(_internal.Sort, {
    statics: () => ({
      sort: [dart.void, [core.List, dart.functionType(core.int, [dart.dynamic, dart.dynamic])]],
      sortRange: [dart.void, [core.List, core.int, core.int, dart.functionType(core.int, [dart.dynamic, dart.dynamic])]],
      _doSort: [dart.void, [core.List, core.int, core.int, dart.functionType(core.int, [dart.dynamic, dart.dynamic])]],
      _insertionSort: [dart.void, [core.List, core.int, core.int, dart.functionType(core.int, [dart.dynamic, dart.dynamic])]],
      _dualPivotQuicksort: [dart.void, [core.List, core.int, core.int, dart.functionType(core.int, [dart.dynamic, dart.dynamic])]]
    }),
    names: ['sort', 'sortRange', '_doSort', '_insertionSort', '_dualPivotQuicksort']
  });
  _internal.Sort._INSERTION_SORT_THRESHOLD = 32;
  const _name = Symbol('_name');
  _internal.Symbol = class Symbol extends core.Object {
    Symbol(name) {
      this[_name] = name;
    }
    unvalidated(name) {
      this[_name] = name;
    }
    validated(name) {
      this[_name] = _internal.Symbol.validatePublicSymbol(name);
    }
    ['=='](other) {
      return dart.is(other, _internal.Symbol) && this[_name] == other[_name];
    }
    get hashCode() {
      let arbitraryPrime = 664597;
      return 536870911 & arbitraryPrime * dart.notNull(dart.hashCode(this[_name]));
    }
    toString() {
      return `Symbol("${this[_name]}")`;
    }
    static getName(symbol) {
      return symbol[_name];
    }
    static validatePublicSymbol(name) {
      if (dart.notNull(name[dartx.isEmpty]) || dart.notNull(_internal.Symbol.publicSymbolPattern.hasMatch(name))) return name;
      if (dart.notNull(name[dartx.startsWith]('_'))) {
        dart.throw(new core.ArgumentError(`"${name}" is a private identifier`));
      }
      dart.throw(new core.ArgumentError(`"${name}" is not a valid (qualified) symbol name`));
    }
    static isValidSymbol(name) {
      return dart.notNull(name[dartx.isEmpty]) || dart.notNull(_internal.Symbol.symbolPattern.hasMatch(name));
    }
  };
  dart.defineNamedConstructor(_internal.Symbol, 'unvalidated');
  dart.defineNamedConstructor(_internal.Symbol, 'validated');
  _internal.Symbol[dart.implements] = () => [core.Symbol];
  dart.setSignature(_internal.Symbol, {
    constructors: () => ({
      Symbol: [_internal.Symbol, [core.String]],
      unvalidated: [_internal.Symbol, [core.String]],
      validated: [_internal.Symbol, [core.String]]
    }),
    methods: () => ({'==': [core.bool, [core.Object]]}),
    statics: () => ({
      getName: [core.String, [_internal.Symbol]],
      validatePublicSymbol: [core.String, [core.String]],
      isValidSymbol: [core.bool, [core.String]]
    }),
    names: ['getName', 'validatePublicSymbol', 'isValidSymbol']
  });
  _internal.Symbol.reservedWordRE = '(?:assert|break|c(?:a(?:se|tch)|lass|on(?:st|tinue))|d(?:efault|o)|' + 'e(?:lse|num|xtends)|f(?:alse|inal(?:ly)?|or)|i[fns]|n(?:ew|ull)|' + 'ret(?:hrow|urn)|s(?:uper|witch)|t(?:h(?:is|row)|r(?:ue|y))|' + 'v(?:ar|oid)|w(?:hile|ith))';
  _internal.Symbol.operatorRE = '(?:[\\-+*/%&|^]|\\[\\]=?|==|~/?|<[<=]?|>[>=]?|unary-)';
  dart.defineLazy(_internal.Symbol, {
    get publicIdentifierRE() {
      return '(?!' + `${_internal.Symbol.reservedWordRE}` + '\\b(?!\\$))[a-zA-Z$][\\w$]*';
    },
    get identifierRE() {
      return '(?!' + `${_internal.Symbol.reservedWordRE}` + '\\b(?!\\$))[a-zA-Z$_][\\w$]*';
    },
    get publicSymbolPattern() {
      return core.RegExp.new(`^(?:${_internal.Symbol.operatorRE}\$|${_internal.Symbol.publicIdentifierRE}(?:=?\$|[.](?!\$)))+?\$`);
    },
    get symbolPattern() {
      return core.RegExp.new(`^(?:${_internal.Symbol.operatorRE}\$|${_internal.Symbol.identifierRE}(?:=?\$|[.](?!\$)))+?\$`);
    }
  });
  _isolate_helper._callInIsolate = function(isolate, func) {
    let result = isolate.eval(func);
    _isolate_helper._globalState.topEventLoop.run();
    return result;
  };
  dart.lazyFn(_isolate_helper._callInIsolate, () => [dart.dynamic, [_isolate_helper._IsolateContext, core.Function]]);
  const _activeJsAsyncCount = Symbol('_activeJsAsyncCount');
  _isolate_helper.enterJsAsync = function() {
    let o = _isolate_helper._globalState.topEventLoop;
    o[_activeJsAsyncCount] = dart.notNull(o[_activeJsAsyncCount]) + 1;
  };
  dart.fn(_isolate_helper.enterJsAsync);
  _isolate_helper.leaveJsAsync = function() {
    let o = _isolate_helper._globalState.topEventLoop;
    o[_activeJsAsyncCount] = dart.notNull(o[_activeJsAsyncCount]) - 1;
    dart.assert(dart.notNull(_isolate_helper._globalState.topEventLoop[_activeJsAsyncCount]) >= 0);
  };
  dart.fn(_isolate_helper.leaveJsAsync);
  _isolate_helper.isWorker = function() {
    return _isolate_helper._globalState.isWorker;
  };
  dart.lazyFn(_isolate_helper.isWorker, () => [core.bool, []]);
  _isolate_helper._currentIsolate = function() {
    return _isolate_helper._globalState.currentContext;
  };
  dart.lazyFn(_isolate_helper._currentIsolate, () => [_isolate_helper._IsolateContext, []]);
  _isolate_helper.startRootIsolate = function(entry, args) {
    args = args;
    if (args == null) args = [];
    if (!dart.is(args, core.List)) {
      dart.throw(new core.ArgumentError(`Arguments to main must be a List: ${args}`));
    }
    _isolate_helper._globalState = new _isolate_helper._Manager(dart.as(entry, core.Function));
    if (dart.notNull(_isolate_helper._globalState.isWorker)) return;
    let rootContext = new _isolate_helper._IsolateContext();
    _isolate_helper._globalState.rootContext = rootContext;
    _isolate_helper._globalState.currentContext = rootContext;
    if (dart.is(entry, _isolate_helper._MainFunctionArgs)) {
      rootContext.eval(dart.fn(() => {
        dart.dcall(entry, args);
      }));
    } else if (dart.is(entry, _isolate_helper._MainFunctionArgsMessage)) {
      rootContext.eval(dart.fn(() => {
        dart.dcall(entry, args, null);
      }));
    } else {
      rootContext.eval(dart.as(entry, core.Function));
    }
    _isolate_helper._globalState.topEventLoop.run();
  };
  dart.fn(_isolate_helper.startRootIsolate, dart.void, [dart.dynamic, dart.dynamic]);
  dart.copyProperties(_isolate_helper, {
    get _globalState() {
      return dart.globalState;
    },
    set _globalState(val) {
      dart.globalState = val;
    }
  });
  const _nativeDetectEnvironment = Symbol('_nativeDetectEnvironment');
  const _nativeInitWorkerMessageHandler = Symbol('_nativeInitWorkerMessageHandler');
  _isolate_helper._Manager = class _Manager extends core.Object {
    get useWorkers() {
      return this.supportsWorkers;
    }
    _Manager(entry) {
      this.entry = entry;
      this.nextIsolateId = 0;
      this.currentManagerId = 0;
      this.nextManagerId = 1;
      this.currentContext = null;
      this.rootContext = null;
      this.topEventLoop = null;
      this.fromCommandLine = null;
      this.isWorker = null;
      this.supportsWorkers = null;
      this.isolates = null;
      this.mainManager = null;
      this.managers = null;
      this[_nativeDetectEnvironment]();
      this.topEventLoop = new _isolate_helper._EventLoop();
      this.isolates = core.Map$(core.int, _isolate_helper._IsolateContext).new();
      this.managers = core.Map$(core.int, dart.dynamic).new();
      if (dart.notNull(this.isWorker)) {
        this.mainManager = new _isolate_helper._MainManagerStub();
        this[_nativeInitWorkerMessageHandler]();
      }
    }
    [_nativeDetectEnvironment]() {
      let isWindowDefined = _isolate_helper.globalWindow != null;
      let isWorkerDefined = _isolate_helper.globalWorker != null;
      this.isWorker = !isWindowDefined && dart.notNull(_isolate_helper.globalPostMessageDefined);
      this.supportsWorkers = dart.notNull(this.isWorker) || isWorkerDefined && _isolate_helper.IsolateNatives.thisScript != null;
      this.fromCommandLine = !isWindowDefined && !dart.notNull(this.isWorker);
    }
    [_nativeInitWorkerMessageHandler]() {
      let func = (function(f, a) {
        return function(e) {
          f(a, e);
        };
      })(_isolate_helper.IsolateNatives._processWorkerMessage, this.mainManager);
      self.onmessage = func;
      self.dartPrint = self.dartPrint || (function(serialize) {
        return function(object) {
          if (self.console && self.console.log) {
            self.console.log(object);
          } else {
            self.postMessage(serialize(object));
          }
        };
      })(_isolate_helper._Manager._serializePrintMessage);
    }
    static _serializePrintMessage(object) {
      return _isolate_helper._serializeMessage(dart.map({command: "print", msg: object}));
    }
    maybeCloseWorker() {
      if (dart.notNull(this.isWorker) && dart.notNull(this.isolates[dartx.isEmpty]) && this.topEventLoop[_activeJsAsyncCount] == 0) {
        this.mainManager.postMessage(_isolate_helper._serializeMessage(dart.map({command: 'close'})));
      }
    }
  };
  dart.setSignature(_isolate_helper._Manager, {
    constructors: () => ({_Manager: [_isolate_helper._Manager, [core.Function]]}),
    methods: () => ({
      [_nativeDetectEnvironment]: [dart.void, []],
      [_nativeInitWorkerMessageHandler]: [dart.void, []],
      maybeCloseWorker: [dart.void, []]
    }),
    statics: () => ({_serializePrintMessage: [dart.dynamic, [dart.dynamic]]}),
    names: ['_serializePrintMessage']
  });
  const _scheduledControlEvents = Symbol('_scheduledControlEvents');
  const _isExecutingEvent = Symbol('_isExecutingEvent');
  const _id = Symbol('_id');
  const _updateGlobalState = Symbol('_updateGlobalState');
  const _setGlobals = Symbol('_setGlobals');
  const _addRegistration = Symbol('_addRegistration');
  const _close = Symbol('_close');
  _isolate_helper._IsolateContext = class _IsolateContext extends core.Object {
    _IsolateContext() {
      this.id = (() => {
        let o = _isolate_helper._globalState, x = o.nextIsolateId;
        o.nextIsolateId = dart.notNull(x) + 1;
        return x;
      })();
      this.ports = core.Map$(core.int, _isolate_helper.RawReceivePortImpl).new();
      this.weakPorts = core.Set$(core.int).new();
      this.isolateStatics = _foreign_helper.JS_CREATE_ISOLATE();
      this.controlPort = new _isolate_helper.RawReceivePortImpl._controlPort();
      this.pauseCapability = isolate.Capability.new();
      this.terminateCapability = isolate.Capability.new();
      this.delayedEvents = dart.list([], _isolate_helper._IsolateEvent);
      this.pauseTokens = core.Set$(isolate.Capability).new();
      this.errorPorts = core.Set$(isolate.SendPort).new();
      this.initialized = false;
      this.isPaused = false;
      this.doneHandlers = null;
      this[_scheduledControlEvents] = null;
      this[_isExecutingEvent] = false;
      this.errorsAreFatal = true;
      this.registerWeak(this.controlPort[_id], this.controlPort);
    }
    addPause(authentification, resume) {
      if (!dart.equals(this.pauseCapability, authentification)) return;
      if (dart.notNull(this.pauseTokens.add(resume)) && !dart.notNull(this.isPaused)) {
        this.isPaused = true;
      }
      this[_updateGlobalState]();
    }
    removePause(resume) {
      if (!dart.notNull(this.isPaused)) return;
      this.pauseTokens.remove(resume);
      if (dart.notNull(this.pauseTokens.isEmpty)) {
        while (dart.notNull(this.delayedEvents[dartx.isNotEmpty])) {
          let event = this.delayedEvents[dartx.removeLast]();
          _isolate_helper._globalState.topEventLoop.prequeue(event);
        }
        this.isPaused = false;
      }
      this[_updateGlobalState]();
    }
    addDoneListener(responsePort) {
      if (this.doneHandlers == null) {
        this.doneHandlers = [];
      }
      if (dart.test(dart.dsend(this.doneHandlers, 'contains', responsePort))) return;
      dart.dsend(this.doneHandlers, 'add', responsePort);
    }
    removeDoneListener(responsePort) {
      if (this.doneHandlers == null) return;
      dart.dsend(this.doneHandlers, 'remove', responsePort);
    }
    setErrorsFatal(authentification, errorsAreFatal) {
      if (!dart.equals(this.terminateCapability, authentification)) return;
      this.errorsAreFatal = errorsAreFatal;
    }
    handlePing(responsePort, pingType) {
      if (pingType == isolate.Isolate.IMMEDIATE || pingType == isolate.Isolate.BEFORE_NEXT_EVENT && !dart.notNull(this[_isExecutingEvent])) {
        responsePort.send(null);
        return;
      }
      function respond() {
        responsePort.send(null);
      }
      dart.fn(respond, dart.void, []);
      if (pingType == isolate.Isolate.AS_EVENT) {
        _isolate_helper._globalState.topEventLoop.enqueue(this, respond, "ping");
        return;
      }
      dart.assert(pingType == isolate.Isolate.BEFORE_NEXT_EVENT);
      if (this[_scheduledControlEvents] == null) {
        this[_scheduledControlEvents] = collection.Queue.new();
      }
      dart.dsend(this[_scheduledControlEvents], 'addLast', respond);
    }
    handleKill(authentification, priority) {
      if (!dart.equals(this.terminateCapability, authentification)) return;
      if (priority == isolate.Isolate.IMMEDIATE || priority == isolate.Isolate.BEFORE_NEXT_EVENT && !dart.notNull(this[_isExecutingEvent])) {
        this.kill();
        return;
      }
      if (priority == isolate.Isolate.AS_EVENT) {
        _isolate_helper._globalState.topEventLoop.enqueue(this, dart.bind(this, 'kill'), "kill");
        return;
      }
      dart.assert(priority == isolate.Isolate.BEFORE_NEXT_EVENT);
      if (this[_scheduledControlEvents] == null) {
        this[_scheduledControlEvents] = collection.Queue.new();
      }
      dart.dsend(this[_scheduledControlEvents], 'addLast', dart.bind(this, 'kill'));
    }
    addErrorListener(port) {
      this.errorPorts.add(port);
    }
    removeErrorListener(port) {
      this.errorPorts.remove(port);
    }
    handleUncaughtError(error, stackTrace) {
      if (dart.notNull(this.errorPorts.isEmpty)) {
        if (dart.notNull(this.errorsAreFatal) && core.identical(this, _isolate_helper._globalState.rootContext)) {
          return;
        }
        if (self.console && self.console.error) {
          self.console.error(error, stackTrace);
        } else {
          core.print(error);
          if (stackTrace != null) core.print(stackTrace);
        }
        return;
      }
      let message = core.List.new(2);
      message[dartx.set](0, dart.toString(error));
      message[dartx.set](1, stackTrace == null ? null : dart.toString(stackTrace));
      for (let port of this.errorPorts)
        port.send(message);
    }
    eval(code) {
      let old = _isolate_helper._globalState.currentContext;
      _isolate_helper._globalState.currentContext = this;
      this[_setGlobals]();
      let result = null;
      this[_isExecutingEvent] = true;
      try {
        result = dart.dcall(code);
      } catch (e) {
        let s = dart.stackTrace(e);
        this.handleUncaughtError(e, s);
        if (dart.notNull(this.errorsAreFatal)) {
          this.kill();
          if (core.identical(this, _isolate_helper._globalState.rootContext)) {
            throw e;
          }
        }
      }
 finally {
        this[_isExecutingEvent] = false;
        _isolate_helper._globalState.currentContext = old;
        if (old != null) old[_setGlobals]();
        if (this[_scheduledControlEvents] != null) {
          while (dart.test(dart.dload(this[_scheduledControlEvents], 'isNotEmpty'))) {
            dart.dcall(dart.dsend(this[_scheduledControlEvents], 'removeFirst'));
          }
        }
      }
      return result;
    }
    [_setGlobals]() {
      _foreign_helper.JS_SET_CURRENT_ISOLATE(this.isolateStatics);
    }
    handleControlMessage(message) {
      switch (dart.dindex(message, 0)) {
        case "pause":
        {
          this.addPause(dart.as(dart.dindex(message, 1), isolate.Capability), dart.as(dart.dindex(message, 2), isolate.Capability));
          break;
        }
        case "resume":
        {
          this.removePause(dart.as(dart.dindex(message, 1), isolate.Capability));
          break;
        }
        case 'add-ondone':
        {
          this.addDoneListener(dart.as(dart.dindex(message, 1), isolate.SendPort));
          break;
        }
        case 'remove-ondone':
        {
          this.removeDoneListener(dart.as(dart.dindex(message, 1), isolate.SendPort));
          break;
        }
        case 'set-errors-fatal':
        {
          this.setErrorsFatal(dart.as(dart.dindex(message, 1), isolate.Capability), dart.as(dart.dindex(message, 2), core.bool));
          break;
        }
        case "ping":
        {
          this.handlePing(dart.as(dart.dindex(message, 1), isolate.SendPort), dart.as(dart.dindex(message, 2), core.int));
          break;
        }
        case "kill":
        {
          this.handleKill(dart.as(dart.dindex(message, 1), isolate.Capability), dart.as(dart.dindex(message, 2), core.int));
          break;
        }
        case "getErrors":
        {
          this.addErrorListener(dart.as(dart.dindex(message, 1), isolate.SendPort));
          break;
        }
        case "stopErrors":
        {
          this.removeErrorListener(dart.as(dart.dindex(message, 1), isolate.SendPort));
          break;
        }
        default:
      }
    }
    lookup(portId) {
      return this.ports[dartx.get](portId);
    }
    [_addRegistration](portId, port) {
      if (dart.notNull(this.ports[dartx.containsKey](portId))) {
        dart.throw(core.Exception.new("Registry: ports must be registered only once."));
      }
      this.ports[dartx.set](portId, port);
    }
    register(portId, port) {
      this[_addRegistration](portId, port);
      this[_updateGlobalState]();
    }
    registerWeak(portId, port) {
      this.weakPorts.add(portId);
      this[_addRegistration](portId, port);
    }
    [_updateGlobalState]() {
      if (dart.notNull(this.ports[dartx.length]) - dart.notNull(this.weakPorts.length) > 0 || dart.notNull(this.isPaused) || !dart.notNull(this.initialized)) {
        _isolate_helper._globalState.isolates[dartx.set](this.id, this);
      } else {
        this.kill();
      }
    }
    kill() {
      if (this[_scheduledControlEvents] != null) {
        dart.dsend(this[_scheduledControlEvents], 'clear');
      }
      for (let port of this.ports[dartx.values]) {
        port[_close]();
      }
      this.ports[dartx.clear]();
      this.weakPorts.clear();
      _isolate_helper._globalState.isolates[dartx.remove](this.id);
      this.errorPorts.clear();
      if (this.doneHandlers != null) {
        for (let port of dart.as(this.doneHandlers, core.Iterable)) {
          dart.as(port, isolate.SendPort);
          port.send(null);
        }
        this.doneHandlers = null;
      }
    }
    unregister(portId) {
      this.ports[dartx.remove](portId);
      this.weakPorts.remove(portId);
      this[_updateGlobalState]();
    }
  };
  _isolate_helper._IsolateContext[dart.implements] = () => [_foreign_helper.IsolateContext];
  dart.setSignature(_isolate_helper._IsolateContext, {
    constructors: () => ({_IsolateContext: [_isolate_helper._IsolateContext, []]}),
    methods: () => ({
      addPause: [dart.void, [isolate.Capability, isolate.Capability]],
      removePause: [dart.void, [isolate.Capability]],
      addDoneListener: [dart.void, [isolate.SendPort]],
      removeDoneListener: [dart.void, [isolate.SendPort]],
      setErrorsFatal: [dart.void, [isolate.Capability, core.bool]],
      handlePing: [dart.void, [isolate.SendPort, core.int]],
      handleKill: [dart.void, [isolate.Capability, core.int]],
      addErrorListener: [dart.void, [isolate.SendPort]],
      removeErrorListener: [dart.void, [isolate.SendPort]],
      handleUncaughtError: [dart.void, [dart.dynamic, core.StackTrace]],
      eval: [dart.dynamic, [core.Function]],
      [_setGlobals]: [dart.void, []],
      handleControlMessage: [dart.void, [dart.dynamic]],
      lookup: [_isolate_helper.RawReceivePortImpl, [core.int]],
      [_addRegistration]: [dart.void, [core.int, _isolate_helper.RawReceivePortImpl]],
      register: [dart.void, [core.int, _isolate_helper.RawReceivePortImpl]],
      registerWeak: [dart.void, [core.int, _isolate_helper.RawReceivePortImpl]],
      [_updateGlobalState]: [dart.void, []],
      kill: [dart.void, []],
      unregister: [dart.void, [core.int]]
    })
  });
  const _runHelper = Symbol('_runHelper');
  _isolate_helper._EventLoop = class _EventLoop extends core.Object {
    _EventLoop() {
      this.events = collection.Queue$(_isolate_helper._IsolateEvent).new();
      this[_activeJsAsyncCount] = 0;
    }
    enqueue(isolate, fn, msg) {
      this.events.addLast(new _isolate_helper._IsolateEvent(dart.as(isolate, _isolate_helper._IsolateContext), dart.as(fn, core.Function), dart.as(msg, core.String)));
    }
    prequeue(event) {
      this.events.addFirst(event);
    }
    dequeue() {
      if (dart.notNull(this.events.isEmpty)) return null;
      return this.events.removeFirst();
    }
    checkOpenReceivePortsFromCommandLine() {
      if (_isolate_helper._globalState.rootContext != null && dart.notNull(_isolate_helper._globalState.isolates[dartx.containsKey](_isolate_helper._globalState.rootContext.id)) && dart.notNull(_isolate_helper._globalState.fromCommandLine) && dart.notNull(_isolate_helper._globalState.rootContext.ports[dartx.isEmpty])) {
        dart.throw(core.Exception.new("Program exited with open ReceivePorts."));
      }
    }
    runIteration() {
      let event = this.dequeue();
      if (event == null) {
        this.checkOpenReceivePortsFromCommandLine();
        _isolate_helper._globalState.maybeCloseWorker();
        return false;
      }
      event.process();
      return true;
    }
    [_runHelper]() {
      if (_isolate_helper.globalWindow != null) {
        const next = (function() {
          if (!dart.notNull(this.runIteration())) return;
          async.Timer.run(next);
        }).bind(this);
        dart.fn(next);
        next();
      } else {
        while (dart.notNull(this.runIteration())) {
        }
      }
    }
    run() {
      if (!dart.notNull(_isolate_helper._globalState.isWorker)) {
        this[_runHelper]();
      } else {
        try {
          this[_runHelper]();
        } catch (e) {
          let trace = dart.stackTrace(e);
          _isolate_helper._globalState.mainManager.postMessage(_isolate_helper._serializeMessage(dart.map({command: 'error', msg: `${e}\n${trace}`})));
        }

      }
    }
  };
  dart.setSignature(_isolate_helper._EventLoop, {
    constructors: () => ({_EventLoop: [_isolate_helper._EventLoop, []]}),
    methods: () => ({
      enqueue: [dart.void, [dart.dynamic, dart.dynamic, dart.dynamic]],
      prequeue: [dart.void, [_isolate_helper._IsolateEvent]],
      dequeue: [_isolate_helper._IsolateEvent, []],
      checkOpenReceivePortsFromCommandLine: [dart.void, []],
      runIteration: [core.bool, []],
      [_runHelper]: [dart.void, []],
      run: [dart.void, []]
    })
  });
  _isolate_helper._IsolateEvent = class _IsolateEvent extends core.Object {
    _IsolateEvent(isolate, fn, message) {
      this.isolate = isolate;
      this.fn = fn;
      this.message = message;
    }
    process() {
      if (dart.notNull(this.isolate.isPaused)) {
        this.isolate.delayedEvents[dartx.add](this);
        return;
      }
      this.isolate.eval(this.fn);
    }
  };
  dart.setSignature(_isolate_helper._IsolateEvent, {
    constructors: () => ({_IsolateEvent: [_isolate_helper._IsolateEvent, [_isolate_helper._IsolateContext, core.Function, core.String]]}),
    methods: () => ({process: [dart.void, []]})
  });
  dart.defineLazy(_isolate_helper, {
    get _global() {
      return typeof global == 'undefined' ? self : global;
    }
  });
  _isolate_helper._MainManagerStub = class _MainManagerStub extends core.Object {
    postMessage(msg) {
      _isolate_helper._global.postMessage(msg);
    }
  };
  dart.setSignature(_isolate_helper._MainManagerStub, {
    methods: () => ({postMessage: [dart.void, [dart.dynamic]]})
  });
  _isolate_helper._SPAWNED_SIGNAL = "spawned";
  _isolate_helper._SPAWN_FAILED_SIGNAL = "spawn failed";
  dart.copyProperties(_isolate_helper, {
    get globalWindow() {
      return _isolate_helper._global.window;
    }
  });
  dart.copyProperties(_isolate_helper, {
    get globalWorker() {
      return _isolate_helper._global.Worker;
    }
  });
  dart.copyProperties(_isolate_helper, {
    get globalPostMessageDefined() {
      return !!_isolate_helper._global.postMessage;
    }
  });
  _isolate_helper._MainFunction = dart.typedef('_MainFunction', () => dart.functionType(dart.dynamic, []));
  _isolate_helper._MainFunctionArgs = dart.typedef('_MainFunctionArgs', () => dart.functionType(dart.dynamic, [dart.dynamic]));
  _isolate_helper._MainFunctionArgsMessage = dart.typedef('_MainFunctionArgsMessage', () => dart.functionType(dart.dynamic, [dart.dynamic, dart.dynamic]));
  _isolate_helper.IsolateNatives = class IsolateNatives extends core.Object {
    static computeThisScript() {
      let currentScript = document.currentScript;
      if (currentScript != null) {
        return String(currentScript.src);
      }
      if (dart.notNull(_js_helper.Primitives.isD8)) return _isolate_helper.IsolateNatives.computeThisScriptD8();
      if (dart.notNull(_js_helper.Primitives.isJsshell)) return _isolate_helper.IsolateNatives.computeThisScriptJsshell();
      if (_isolate_helper._globalState != null && dart.notNull(_isolate_helper._globalState.isWorker)) {
        return _isolate_helper.IsolateNatives.computeThisScriptFromTrace();
      }
      return null;
    }
    static computeThisScriptJsshell() {
      return thisFilename();
    }
    static computeThisScriptD8() {
      return _isolate_helper.IsolateNatives.computeThisScriptFromTrace();
    }
    static computeThisScriptFromTrace() {
      let stack = new Error().stack;
      if (stack == null) {
        stack = (function() {
          try {
            throw new Error();
          } catch (e) {
            return e.stack;
          }

        })();
        if (stack == null) dart.throw(new core.UnsupportedError('No stack trace'));
      }
      let pattern = null, matches = null;
      pattern = new RegExp("^ *at [^(]*\\((.*):[0-9]*:[0-9]*\\)$", "m");
      matches = stack.match(pattern);
      if (matches != null) return matches[1];
      pattern = new RegExp("^[^@]*@(.*):[0-9]*$", "m");
      matches = stack.match(pattern);
      if (matches != null) return matches[1];
      dart.throw(new core.UnsupportedError(`Cannot extract URI from "${stack}"`));
    }
    static _getEventData(e) {
      return e.data;
    }
    static _processWorkerMessage(sender, e) {
      let msg = _isolate_helper._deserializeMessage(_isolate_helper.IsolateNatives._getEventData(e));
      switch (dart.dindex(msg, 'command')) {
        case 'start':
        {
          _isolate_helper._globalState.currentManagerId = dart.as(dart.dindex(msg, 'id'), core.int);
          let functionName = dart.as(dart.dindex(msg, 'functionName'), core.String);
          let entryPoint = dart.as(functionName == null ? _isolate_helper._globalState.entry : _isolate_helper.IsolateNatives._getJSFunctionFromName(functionName), core.Function);
          let args = dart.dindex(msg, 'args');
          let message = _isolate_helper._deserializeMessage(dart.dindex(msg, 'msg'));
          let isSpawnUri = dart.dindex(msg, 'isSpawnUri');
          let startPaused = dart.dindex(msg, 'startPaused');
          let replyTo = _isolate_helper._deserializeMessage(dart.dindex(msg, 'replyTo'));
          let context = new _isolate_helper._IsolateContext();
          _isolate_helper._globalState.topEventLoop.enqueue(context, dart.fn(() => {
            _isolate_helper.IsolateNatives._startIsolate(entryPoint, dart.as(args, core.List$(core.String)), message, dart.as(isSpawnUri, core.bool), dart.as(startPaused, core.bool), dart.as(replyTo, isolate.SendPort));
          }), 'worker-start');
          _isolate_helper._globalState.currentContext = context;
          _isolate_helper._globalState.topEventLoop.run();
          break;
        }
        case 'spawn-worker':
        {
          if (_isolate_helper.IsolateNatives.enableSpawnWorker != null) _isolate_helper.IsolateNatives.handleSpawnWorkerRequest(msg);
          break;
        }
        case 'message':
        {
          let port = dart.as(dart.dindex(msg, 'port'), isolate.SendPort);
          if (port != null) {
            dart.dsend(dart.dindex(msg, 'port'), 'send', dart.dindex(msg, 'msg'));
          }
          _isolate_helper._globalState.topEventLoop.run();
          break;
        }
        case 'close':
        {
          _isolate_helper._globalState.managers[dartx.remove](_isolate_helper.IsolateNatives.workerIds.get(sender));
          sender.terminate();
          _isolate_helper._globalState.topEventLoop.run();
          break;
        }
        case 'log':
        {
          _isolate_helper.IsolateNatives._log(dart.dindex(msg, 'msg'));
          break;
        }
        case 'print':
        {
          if (dart.notNull(_isolate_helper._globalState.isWorker)) {
            _isolate_helper._globalState.mainManager.postMessage(_isolate_helper._serializeMessage(dart.map({command: 'print', msg: msg})));
          } else {
            core.print(dart.dindex(msg, 'msg'));
          }
          break;
        }
        case 'error':
        {
          dart.throw(dart.dindex(msg, 'msg'));
        }
      }
    }
    static handleSpawnWorkerRequest(msg) {
      let replyPort = dart.dindex(msg, 'replyPort');
      _isolate_helper.IsolateNatives.spawn(dart.as(dart.dindex(msg, 'functionName'), core.String), dart.as(dart.dindex(msg, 'uri'), core.String), dart.as(dart.dindex(msg, 'args'), core.List$(core.String)), dart.dindex(msg, 'msg'), false, dart.as(dart.dindex(msg, 'isSpawnUri'), core.bool), dart.as(dart.dindex(msg, 'startPaused'), core.bool)).then(dart.dynamic)(dart.fn(msg => {
        dart.dsend(replyPort, 'send', msg);
      }, dart.dynamic, [core.List]), {onError: dart.fn(errorMessage => {
          dart.dsend(replyPort, 'send', dart.list([_isolate_helper._SPAWN_FAILED_SIGNAL, errorMessage], core.String));
        }, dart.dynamic, [core.String])});
    }
    static _log(msg) {
      if (dart.notNull(_isolate_helper._globalState.isWorker)) {
        _isolate_helper._globalState.mainManager.postMessage(_isolate_helper._serializeMessage(dart.map({command: 'log', msg: msg})));
      } else {
        try {
          _isolate_helper.IsolateNatives._consoleLog(msg);
        } catch (e) {
          let trace = dart.stackTrace(e);
          dart.throw(core.Exception.new(trace));
        }

      }
    }
    static _consoleLog(msg) {
      self.console.log(msg);
    }
    static _getJSFunctionFromName(functionName) {
      let globalFunctionsContainer = _foreign_helper.JS_EMBEDDED_GLOBAL("", _js_embedded_names.GLOBAL_FUNCTIONS);
      return globalFunctionsContainer[functionName]();
    }
    static _getJSFunctionName(f) {
      return f.$name;
    }
    static _allocate(ctor) {
      return new ctor();
    }
    static spawnFunction(topLevelFunction, message, startPaused) {
      _isolate_helper.IsolateNatives.enableSpawnWorker = true;
      let name = _isolate_helper.IsolateNatives._getJSFunctionName(topLevelFunction);
      if (name == null) {
        dart.throw(new core.UnsupportedError("only top-level functions can be spawned."));
      }
      let isLight = false;
      let isSpawnUri = false;
      return _isolate_helper.IsolateNatives.spawn(name, null, null, message, isLight, isSpawnUri, startPaused);
    }
    static spawnUri(uri, args, message, startPaused) {
      _isolate_helper.IsolateNatives.enableSpawnWorker = true;
      let isLight = false;
      let isSpawnUri = true;
      return _isolate_helper.IsolateNatives.spawn(null, dart.toString(uri), args, message, isLight, isSpawnUri, startPaused);
    }
    static spawn(functionName, uri, args, message, isLight, isSpawnUri, startPaused) {
      if (uri != null && dart.notNull(uri[dartx.endsWith](".dart"))) {
        uri = dart.notNull(uri) + ".js";
      }
      let port = isolate.ReceivePort.new();
      let completer = async.Completer$(core.List).new();
      port.first.then(dart.dynamic)(dart.fn(msg => {
        if (dart.equals(dart.dindex(msg, 0), _isolate_helper._SPAWNED_SIGNAL)) {
          completer.complete(msg);
        } else {
          dart.assert(dart.equals(dart.dindex(msg, 0), _isolate_helper._SPAWN_FAILED_SIGNAL));
          completer.completeError(dart.dindex(msg, 1));
        }
      }));
      let signalReply = port.sendPort;
      if (dart.notNull(_isolate_helper._globalState.useWorkers) && !dart.notNull(isLight)) {
        _isolate_helper.IsolateNatives._startWorker(functionName, uri, args, message, isSpawnUri, startPaused, signalReply, dart.fn(message => completer.completeError(message), dart.void, [core.String]));
      } else {
        _isolate_helper.IsolateNatives._startNonWorker(functionName, uri, args, message, isSpawnUri, startPaused, signalReply);
      }
      return completer.future;
    }
    static _startWorker(functionName, uri, args, message, isSpawnUri, startPaused, replyPort, onError) {
      if (args != null) args = core.List$(core.String).from(args);
      if (dart.notNull(_isolate_helper._globalState.isWorker)) {
        _isolate_helper._globalState.mainManager.postMessage(_isolate_helper._serializeMessage(dart.map({command: 'spawn-worker', functionName: functionName, args: args, msg: message, uri: uri, isSpawnUri: isSpawnUri, startPaused: startPaused, replyPort: replyPort})));
      } else {
        _isolate_helper.IsolateNatives._spawnWorker(functionName, uri, args, message, isSpawnUri, startPaused, replyPort, onError);
      }
    }
    static _startNonWorker(functionName, uri, args, message, isSpawnUri, startPaused, replyPort) {
      if (uri != null) {
        dart.throw(new core.UnsupportedError("Currently spawnUri is not supported without web workers."));
      }
      message = _isolate_helper._clone(message);
      if (args != null) args = core.List$(core.String).from(args);
      _isolate_helper._globalState.topEventLoop.enqueue(new _isolate_helper._IsolateContext(), dart.fn(() => {
        let func = _isolate_helper.IsolateNatives._getJSFunctionFromName(functionName);
        _isolate_helper.IsolateNatives._startIsolate(dart.as(func, core.Function), args, message, isSpawnUri, startPaused, replyPort);
      }), 'nonworker start');
    }
    static get currentIsolate() {
      let context = dart.as(_foreign_helper.JS_CURRENT_ISOLATE_CONTEXT(), _isolate_helper._IsolateContext);
      return new isolate.Isolate(context.controlPort.sendPort, {pauseCapability: context.pauseCapability, terminateCapability: context.terminateCapability});
    }
    static _startIsolate(topLevel, args, message, isSpawnUri, startPaused, replyTo) {
      let context = dart.as(_foreign_helper.JS_CURRENT_ISOLATE_CONTEXT(), _isolate_helper._IsolateContext);
      _js_helper.Primitives.initializeStatics(context.id);
      replyTo.send(dart.list([_isolate_helper._SPAWNED_SIGNAL, context.controlPort.sendPort, context.pauseCapability, context.terminateCapability], core.Object));
      function runStartFunction() {
        context.initialized = true;
        if (!dart.notNull(isSpawnUri)) {
          dart.dcall(topLevel, message);
        } else if (dart.is(topLevel, _isolate_helper._MainFunctionArgsMessage)) {
          dart.dcall(topLevel, args, message);
        } else if (dart.is(topLevel, _isolate_helper._MainFunctionArgs)) {
          dart.dcall(topLevel, args);
        } else {
          dart.dcall(topLevel);
        }
      }
      dart.fn(runStartFunction, dart.void, []);
      if (dart.notNull(startPaused)) {
        context.addPause(context.pauseCapability, context.pauseCapability);
        _isolate_helper._globalState.topEventLoop.enqueue(context, runStartFunction, 'start isolate');
      } else {
        runStartFunction();
      }
    }
    static _spawnWorker(functionName, uri, args, message, isSpawnUri, startPaused, replyPort, onError) {
      if (uri == null) uri = _isolate_helper.IsolateNatives.thisScript;
      let worker = new Worker(uri);
      let onerrorTrampoline = (function(f, u, c) {
        return function(e) {
          return f(e, u, c);
        };
      })(_isolate_helper.IsolateNatives.workerOnError, uri, onError);
      worker.onerror = onerrorTrampoline;
      let processWorkerMessageTrampoline = (function(f, a) {
        return function(e) {
          e.onerror = null;
          return f(a, e);
        };
      })(_isolate_helper.IsolateNatives._processWorkerMessage, worker);
      worker.onmessage = processWorkerMessageTrampoline;
      let o = _isolate_helper._globalState;
      let workerId = o.nextManagerId;
      o.nextManagerId = dart.notNull(workerId) + 1;
      _isolate_helper.IsolateNatives.workerIds.set(worker, workerId);
      _isolate_helper._globalState.managers[dartx.set](workerId, worker);
      worker.postMessage(_isolate_helper._serializeMessage(dart.map({command: 'start', id: workerId, replyTo: _isolate_helper._serializeMessage(replyPort), args: args, msg: _isolate_helper._serializeMessage(message), isSpawnUri: isSpawnUri, startPaused: startPaused, functionName: functionName})));
    }
    static workerOnError(event, uri, onError) {
      event.preventDefault();
      let message = event.message;
      if (message == null) {
        message = `Error spawning worker for ${uri}`;
      } else {
        message = `Error spawning worker for ${uri} (${message})`;
      }
      onError(message);
      return true;
    }
  };
  dart.setSignature(_isolate_helper.IsolateNatives, {
    statics: () => ({
      computeThisScript: [core.String, []],
      computeThisScriptJsshell: [core.String, []],
      computeThisScriptD8: [core.String, []],
      computeThisScriptFromTrace: [core.String, []],
      _getEventData: [dart.dynamic, [dart.dynamic]],
      _processWorkerMessage: [dart.void, [dart.dynamic, dart.dynamic]],
      handleSpawnWorkerRequest: [dart.dynamic, [dart.dynamic]],
      _log: [dart.dynamic, [dart.dynamic]],
      _consoleLog: [dart.void, [dart.dynamic]],
      _getJSFunctionFromName: [dart.dynamic, [core.String]],
      _getJSFunctionName: [core.String, [core.Function]],
      _allocate: [dart.dynamic, [dart.dynamic]],
      spawnFunction: [async.Future$(core.List), [dart.functionType(dart.void, [dart.dynamic]), dart.dynamic, core.bool]],
      spawnUri: [async.Future$(core.List), [core.Uri, core.List$(core.String), dart.dynamic, core.bool]],
      spawn: [async.Future$(core.List), [core.String, core.String, core.List$(core.String), dart.dynamic, core.bool, core.bool, core.bool]],
      _startWorker: [dart.void, [core.String, core.String, core.List$(core.String), dart.dynamic, core.bool, core.bool, isolate.SendPort, dart.functionType(dart.void, [core.String])]],
      _startNonWorker: [dart.void, [core.String, core.String, core.List$(core.String), dart.dynamic, core.bool, core.bool, isolate.SendPort]],
      _startIsolate: [dart.void, [core.Function, core.List$(core.String), dart.dynamic, core.bool, core.bool, isolate.SendPort]],
      _spawnWorker: [dart.void, [dart.dynamic, core.String, core.List$(core.String), dart.dynamic, core.bool, core.bool, isolate.SendPort, dart.functionType(dart.void, [core.String])]],
      workerOnError: [core.bool, [dart.dynamic, core.String, dart.functionType(dart.void, [core.String])]]
    }),
    names: ['computeThisScript', 'computeThisScriptJsshell', 'computeThisScriptD8', 'computeThisScriptFromTrace', '_getEventData', '_processWorkerMessage', 'handleSpawnWorkerRequest', '_log', '_consoleLog', '_getJSFunctionFromName', '_getJSFunctionName', '_allocate', 'spawnFunction', 'spawnUri', 'spawn', '_startWorker', '_startNonWorker', '_startIsolate', '_spawnWorker', 'workerOnError']
  });
  _isolate_helper.IsolateNatives.enableSpawnWorker = null;
  dart.defineLazy(_isolate_helper.IsolateNatives, {
    get thisScript() {
      return _isolate_helper.IsolateNatives.computeThisScript();
    },
    set thisScript(_) {},
    get workerIds() {
      return new (core.Expando$(core.int))();
    }
  });
  const _isolateId = Symbol('_isolateId');
  const _checkReplyTo = Symbol('_checkReplyTo');
  _isolate_helper._BaseSendPort = class _BaseSendPort extends core.Object {
    _BaseSendPort(isolateId) {
      this[_isolateId] = isolateId;
    }
    [_checkReplyTo](replyTo) {
      if (replyTo != null && !dart.is(replyTo, _isolate_helper._NativeJsSendPort) && !dart.is(replyTo, _isolate_helper._WorkerSendPort)) {
        dart.throw(core.Exception.new("SendPort.send: Illegal replyTo port type"));
      }
    }
  };
  _isolate_helper._BaseSendPort[dart.implements] = () => [isolate.SendPort];
  dart.setSignature(_isolate_helper._BaseSendPort, {
    constructors: () => ({_BaseSendPort: [_isolate_helper._BaseSendPort, [core.int]]}),
    methods: () => ({[_checkReplyTo]: [dart.void, [isolate.SendPort]]})
  });
  const _receivePort = Symbol('_receivePort');
  const _isClosed = Symbol('_isClosed');
  const _add = Symbol('_add');
  _isolate_helper._NativeJsSendPort = class _NativeJsSendPort extends _isolate_helper._BaseSendPort {
    _NativeJsSendPort(receivePort, isolateId) {
      this[_receivePort] = receivePort;
      super._BaseSendPort(isolateId);
    }
    send(message) {
      let isolate = _isolate_helper._globalState.isolates[dartx.get](this[_isolateId]);
      if (isolate == null) return;
      if (dart.notNull(this[_receivePort][_isClosed])) return;
      let msg = _isolate_helper._clone(message);
      if (dart.equals(isolate.controlPort, this[_receivePort])) {
        isolate.handleControlMessage(msg);
        return;
      }
      _isolate_helper._globalState.topEventLoop.enqueue(isolate, dart.fn(() => {
        if (!dart.notNull(this[_receivePort][_isClosed])) {
          this[_receivePort][_add](msg);
        }
      }), `receive ${message}`);
    }
    ['=='](other) {
      return dart.is(other, _isolate_helper._NativeJsSendPort) && dart.equals(this[_receivePort], other[_receivePort]);
    }
    get hashCode() {
      return this[_receivePort][_id];
    }
  };
  _isolate_helper._NativeJsSendPort[dart.implements] = () => [isolate.SendPort];
  dart.setSignature(_isolate_helper._NativeJsSendPort, {
    constructors: () => ({_NativeJsSendPort: [_isolate_helper._NativeJsSendPort, [_isolate_helper.RawReceivePortImpl, core.int]]}),
    methods: () => ({send: [dart.void, [dart.dynamic]]})
  });
  const _workerId = Symbol('_workerId');
  const _receivePortId = Symbol('_receivePortId');
  _isolate_helper._WorkerSendPort = class _WorkerSendPort extends _isolate_helper._BaseSendPort {
    _WorkerSendPort(workerId, isolateId, receivePortId) {
      this[_workerId] = workerId;
      this[_receivePortId] = receivePortId;
      super._BaseSendPort(isolateId);
    }
    send(message) {
      let workerMessage = _isolate_helper._serializeMessage(dart.map({command: 'message', port: this, msg: message}));
      if (dart.notNull(_isolate_helper._globalState.isWorker)) {
        _isolate_helper._globalState.mainManager.postMessage(workerMessage);
      } else {
        let manager = _isolate_helper._globalState.managers[dartx.get](this[_workerId]);
        if (manager != null) {
          manager.postMessage(workerMessage);
        }
      }
    }
    ['=='](other) {
      return dart.is(other, _isolate_helper._WorkerSendPort) && this[_workerId] == other[_workerId] && this[_isolateId] == other[_isolateId] && this[_receivePortId] == other[_receivePortId];
    }
    get hashCode() {
      return (dart.notNull(this[_workerId]) << 16 ^ dart.notNull(this[_isolateId]) << 8 ^ dart.notNull(this[_receivePortId])) >>> 0;
    }
  };
  _isolate_helper._WorkerSendPort[dart.implements] = () => [isolate.SendPort];
  dart.setSignature(_isolate_helper._WorkerSendPort, {
    constructors: () => ({_WorkerSendPort: [_isolate_helper._WorkerSendPort, [core.int, core.int, core.int]]}),
    methods: () => ({send: [dart.void, [dart.dynamic]]})
  });
  const _handler = Symbol('_handler');
  _isolate_helper.RawReceivePortImpl = class RawReceivePortImpl extends core.Object {
    RawReceivePortImpl(handler) {
      this[_handler] = handler;
      this[_id] = (() => {
        let x = _isolate_helper.RawReceivePortImpl._nextFreeId;
        _isolate_helper.RawReceivePortImpl._nextFreeId = dart.notNull(x) + 1;
        return x;
      })();
      this[_isClosed] = false;
      _isolate_helper._globalState.currentContext.register(this[_id], this);
    }
    weak(handler) {
      this[_handler] = handler;
      this[_id] = (() => {
        let x = _isolate_helper.RawReceivePortImpl._nextFreeId;
        _isolate_helper.RawReceivePortImpl._nextFreeId = dart.notNull(x) + 1;
        return x;
      })();
      this[_isClosed] = false;
      _isolate_helper._globalState.currentContext.registerWeak(this[_id], this);
    }
    _controlPort() {
      this[_handler] = null;
      this[_id] = 0;
      this[_isClosed] = false;
    }
    set handler(newHandler) {
      this[_handler] = newHandler;
    }
    [_close]() {
      this[_isClosed] = true;
      this[_handler] = null;
    }
    close() {
      if (dart.notNull(this[_isClosed])) return;
      this[_isClosed] = true;
      this[_handler] = null;
      _isolate_helper._globalState.currentContext.unregister(this[_id]);
    }
    [_add](dataEvent) {
      if (dart.notNull(this[_isClosed])) return;
      dart.dcall(this[_handler], dataEvent);
    }
    get sendPort() {
      return new _isolate_helper._NativeJsSendPort(this, _isolate_helper._globalState.currentContext.id);
    }
  };
  dart.defineNamedConstructor(_isolate_helper.RawReceivePortImpl, 'weak');
  dart.defineNamedConstructor(_isolate_helper.RawReceivePortImpl, '_controlPort');
  _isolate_helper.RawReceivePortImpl[dart.implements] = () => [isolate.RawReceivePort];
  dart.setSignature(_isolate_helper.RawReceivePortImpl, {
    constructors: () => ({
      RawReceivePortImpl: [_isolate_helper.RawReceivePortImpl, [core.Function]],
      weak: [_isolate_helper.RawReceivePortImpl, [core.Function]],
      _controlPort: [_isolate_helper.RawReceivePortImpl, []]
    }),
    methods: () => ({
      [_close]: [dart.void, []],
      close: [dart.void, []],
      [_add]: [dart.void, [dart.dynamic]]
    })
  });
  _isolate_helper.RawReceivePortImpl._nextFreeId = 1;
  const _rawPort = Symbol('_rawPort');
  const _controller = Symbol('_controller');
  const _add$ = Symbol('_add');
  const _closeUnchecked = Symbol('_closeUnchecked');
  const _addError = Symbol('_addError');
  const _completeError = Symbol('_completeError');
  const _complete = Symbol('_complete');
  const _sink = Symbol('_sink');
  async.Stream$ = dart.generic(T => {
    class Stream extends core.Object {
      Stream() {
      }
      _internal() {
      }
      static empty() {
        return new (async._EmptyStream$(T))();
      }
      static fromFuture(future) {
        let controller = dart.as(async.StreamController$(T).new({sync: true}), async._StreamController$(T));
        future.then(dart.dynamic)(dart.fn(value => {
          dart.as(value, T);
          controller[_add$](value);
          controller[_closeUnchecked]();
        }, dart.dynamic, [T]), {onError: dart.fn((error, stackTrace) => {
            controller[_addError](error, dart.as(stackTrace, core.StackTrace));
            controller[_closeUnchecked]();
          })});
        return controller.stream;
      }
      static fromFutures(futures) {
        let controller = dart.as(async.StreamController$(T).new({sync: true}), async._StreamController$(T));
        let count = 0;
        let onValue = dart.fn(value => {
          dart.as(value, T);
          if (!dart.notNull(controller.isClosed)) {
            controller[_add$](value);
            if (--count == 0) controller[_closeUnchecked]();
          }
        }, dart.dynamic, [T]);
        let onError = dart.fn((error, stack) => {
          if (!dart.notNull(controller.isClosed)) {
            controller[_addError](error, dart.as(stack, core.StackTrace));
            if (--count == 0) controller[_closeUnchecked]();
          }
        });
        for (let future of futures) {
          count++;
          future.then(dart.dynamic)(onValue, {onError: onError});
        }
        if (count == 0) async.scheduleMicrotask(dart.bind(controller, 'close'));
        return controller.stream;
      }
      static fromIterable(data) {
        return new (async._GeneratedStreamImpl$(T))(dart.fn(() => new (async._IterablePendingEvents$(T))(data), async._IterablePendingEvents$(T), []));
      }
      static periodic(period, computation) {
        if (computation === void 0) computation = null;
        let timer = null;
        let computationCount = 0;
        let controller = null;
        let watch = new core.Stopwatch();
        function sendEvent() {
          watch.reset();
          let data = null;
          if (computation != null) {
            try {
              data = computation(computationCount++);
            } catch (e) {
              let s = dart.stackTrace(e);
              controller.addError(e, s);
              return;
            }

          }
          controller.add(data);
        }
        dart.fn(sendEvent, dart.void, []);
        function startPeriodicTimer() {
          dart.assert(timer == null);
          timer = async.Timer.periodic(period, dart.fn(timer => {
            sendEvent();
          }, dart.void, [async.Timer]));
        }
        dart.fn(startPeriodicTimer, dart.void, []);
        controller = async.StreamController$(T).new({sync: true, onListen: dart.fn(() => {
            watch.start();
            startPeriodicTimer();
          }, dart.void, []), onPause: dart.fn(() => {
            timer.cancel();
            timer = null;
            watch.stop();
          }, dart.void, []), onResume: dart.fn(() => {
            dart.assert(timer == null);
            let elapsed = watch.elapsed;
            watch.start();
            timer = async.Timer.new(period['-'](elapsed), dart.fn(() => {
              timer = null;
              startPeriodicTimer();
              sendEvent();
            }, dart.void, []));
          }, dart.void, []), onCancel: dart.fn(() => {
            if (timer != null) timer.cancel();
            timer = null;
          })});
        return controller.stream;
      }
      static eventTransformed(source, mapSink) {
        return new (async._BoundSinkStream$(dart.dynamic, T))(source, mapSink);
      }
      get isBroadcast() {
        return false;
      }
      asBroadcastStream(opts) {
        let onListen = opts && 'onListen' in opts ? opts.onListen : null;
        dart.as(onListen, dart.functionType(dart.void, [async.StreamSubscription$(T)]));
        let onCancel = opts && 'onCancel' in opts ? opts.onCancel : null;
        dart.as(onCancel, dart.functionType(dart.void, [async.StreamSubscription$(T)]));
        return new (async._AsBroadcastStream$(T))(this, onListen, onCancel);
      }
      where(test) {
        dart.as(test, dart.functionType(core.bool, [T]));
        return new (async._WhereStream$(T))(this, test);
      }
      map(S) {
        return convert => {
          dart.as(convert, dart.functionType(S, [T]));
          return new (async._MapStream$(T, S))(this, convert);
        };
      }
      asyncMap(E) {
        return convert => {
          dart.as(convert, dart.functionType(dart.dynamic, [T]));
          let controller = null;
          let subscription = null;
          const onListen = (function() {
            let add = dart.bind(controller, 'add');
            dart.assert(dart.is(controller, async._StreamController) || dart.is(controller, async._BroadcastStreamController));
            let eventSink = dart.as(controller, async._EventSink$(E));
            let addError = dart.bind(eventSink, _addError);
            subscription = this.listen(dart.fn(event => {
              dart.as(event, T);
              let newValue = null;
              try {
                newValue = convert(event);
              } catch (e) {
                let s = dart.stackTrace(e);
                controller.addError(e, s);
                return;
              }

              if (dart.is(newValue, async.Future)) {
                subscription.pause();
                newValue.then(dart.dynamic)(add, {onError: addError}).whenComplete(dart.bind(subscription, 'resume'));
              } else {
                controller.add(dart.as(newValue, E));
              }
            }, dart.void, [T]), {onError: addError, onDone: dart.bind(controller, 'close')});
          }).bind(this);
          dart.fn(onListen, dart.void, []);
          if (dart.notNull(this.isBroadcast)) {
            controller = async.StreamController$(E).broadcast({onListen: onListen, onCancel: dart.fn(() => {
                subscription.cancel();
              }, dart.void, []), sync: true});
          } else {
            controller = async.StreamController$(E).new({onListen: onListen, onPause: dart.fn(() => {
                subscription.pause();
              }, dart.void, []), onResume: dart.fn(() => {
                subscription.resume();
              }, dart.void, []), onCancel: dart.fn(() => {
                subscription.cancel();
              }), sync: true});
          }
          return controller.stream;
        };
      }
      asyncExpand(E) {
        return convert => {
          dart.as(convert, dart.functionType(async.Stream$(E), [T]));
          let controller = null;
          let subscription = null;
          const onListen = (function() {
            dart.assert(dart.is(controller, async._StreamController) || dart.is(controller, async._BroadcastStreamController));
            let eventSink = dart.as(controller, async._EventSink$(E));
            subscription = this.listen(dart.fn(event => {
              dart.as(event, T);
              let newStream = null;
              try {
                newStream = convert(event);
              } catch (e) {
                let s = dart.stackTrace(e);
                controller.addError(e, s);
                return;
              }

              if (newStream != null) {
                subscription.pause();
                controller.addStream(newStream).whenComplete(dart.bind(subscription, 'resume'));
              }
            }, dart.void, [T]), {onError: dart.bind(eventSink, _addError), onDone: dart.bind(controller, 'close')});
          }).bind(this);
          dart.fn(onListen, dart.void, []);
          if (dart.notNull(this.isBroadcast)) {
            controller = async.StreamController$(E).broadcast({onListen: onListen, onCancel: dart.fn(() => {
                subscription.cancel();
              }, dart.void, []), sync: true});
          } else {
            controller = async.StreamController$(E).new({onListen: onListen, onPause: dart.fn(() => {
                subscription.pause();
              }, dart.void, []), onResume: dart.fn(() => {
                subscription.resume();
              }, dart.void, []), onCancel: dart.fn(() => {
                subscription.cancel();
              }), sync: true});
          }
          return controller.stream;
        };
      }
      handleError(onError, opts) {
        let test = opts && 'test' in opts ? opts.test : null;
        dart.as(test, dart.functionType(core.bool, [dart.dynamic]));
        return new (async._HandleErrorStream$(T))(this, onError, test);
      }
      expand(S) {
        return convert => {
          dart.as(convert, dart.functionType(core.Iterable$(S), [T]));
          return new (async._ExpandStream$(T, S))(this, convert);
        };
      }
      pipe(streamConsumer) {
        dart.as(streamConsumer, async.StreamConsumer$(T));
        return streamConsumer.addStream(this).then(async.Future)(dart.fn(_ => streamConsumer.close(), async.Future, [dart.dynamic]));
      }
      transform(S) {
        return streamTransformer => {
          dart.as(streamTransformer, async.StreamTransformer$(T, S));
          return streamTransformer.bind(this);
        };
      }
      reduce(combine) {
        dart.as(combine, dart.functionType(T, [T, T]));
        let result = new (async._Future$(T))();
        let seenFirst = false;
        let value = null;
        let subscription = null;
        subscription = this.listen(dart.fn(element => {
          dart.as(element, T);
          if (seenFirst) {
            async._runUserCode(dart.fn(() => combine(value, element), T, []), dart.fn(newValue => {
              dart.as(newValue, T);
              value = newValue;
            }, dart.dynamic, [T]), async._cancelAndErrorClosure(subscription, result));
          } else {
            value = element;
            seenFirst = true;
          }
        }, dart.void, [T]), {onError: dart.bind(result, _completeError), onDone: dart.fn(() => {
            if (!seenFirst) {
              try {
                dart.throw(_internal.IterableElementError.noElement());
              } catch (e) {
                let s = dart.stackTrace(e);
                async._completeWithErrorCallback(result, e, s);
              }

            } else {
              result[_complete](value);
            }
          }, dart.void, []), cancelOnError: true});
        return result;
      }
      fold(S) {
        return (initialValue, combine) => {
          dart.as(combine, dart.functionType(S, [S, T]));
          let result = new (async._Future$(S))();
          let value = initialValue;
          let subscription = null;
          subscription = this.listen(dart.fn(element => {
            dart.as(element, T);
            async._runUserCode(dart.fn(() => combine(value, element), S, []), dart.fn(newValue => {
              value = newValue;
            }, dart.dynamic, [S]), async._cancelAndErrorClosure(subscription, result));
          }, dart.void, [T]), {onError: dart.fn((e, st) => {
              result[_completeError](e, dart.as(st, core.StackTrace));
            }), onDone: dart.fn(() => {
              result[_complete](value);
            }, dart.void, []), cancelOnError: true});
          return result;
        };
      }
      join(separator) {
        if (separator === void 0) separator = "";
        let result = new (async._Future$(core.String))();
        let buffer = new core.StringBuffer();
        let subscription = null;
        let first = true;
        subscription = this.listen(dart.fn(element => {
          dart.as(element, T);
          if (!first) {
            buffer.write(separator);
          }
          first = false;
          try {
            buffer.write(element);
          } catch (e) {
            let s = dart.stackTrace(e);
            async._cancelAndErrorWithReplacement(subscription, result, e, s);
          }

        }, dart.void, [T]), {onError: dart.fn(e => {
            result[_completeError](e);
          }), onDone: dart.fn(() => {
            result[_complete](buffer.toString());
          }, dart.void, []), cancelOnError: true});
        return result;
      }
      contains(needle) {
        let future = new (async._Future$(core.bool))();
        let subscription = null;
        subscription = this.listen(dart.fn(element => {
          dart.as(element, T);
          async._runUserCode(dart.fn(() => dart.equals(element, needle), core.bool, []), dart.fn(isMatch => {
            if (dart.notNull(isMatch)) {
              async._cancelAndValue(subscription, future, true);
            }
          }, dart.dynamic, [core.bool]), async._cancelAndErrorClosure(subscription, future));
        }, dart.void, [T]), {onError: dart.bind(future, _completeError), onDone: dart.fn(() => {
            future[_complete](false);
          }, dart.void, []), cancelOnError: true});
        return future;
      }
      forEach(action) {
        dart.as(action, dart.functionType(dart.void, [T]));
        let future = new async._Future();
        let subscription = null;
        subscription = this.listen(dart.fn(element => {
          dart.as(element, T);
          async._runUserCode(dart.fn(() => action(element), dart.void, []), dart.fn(_ => {
          }), async._cancelAndErrorClosure(subscription, future));
        }, dart.void, [T]), {onError: dart.bind(future, _completeError), onDone: dart.fn(() => {
            future[_complete](null);
          }, dart.void, []), cancelOnError: true});
        return future;
      }
      every(test) {
        dart.as(test, dart.functionType(core.bool, [T]));
        let future = new (async._Future$(core.bool))();
        let subscription = null;
        subscription = this.listen(dart.fn(element => {
          dart.as(element, T);
          async._runUserCode(dart.fn(() => test(element), core.bool, []), dart.fn(isMatch => {
            if (!dart.notNull(isMatch)) {
              async._cancelAndValue(subscription, future, false);
            }
          }, dart.dynamic, [core.bool]), async._cancelAndErrorClosure(subscription, future));
        }, dart.void, [T]), {onError: dart.bind(future, _completeError), onDone: dart.fn(() => {
            future[_complete](true);
          }, dart.void, []), cancelOnError: true});
        return future;
      }
      any(test) {
        dart.as(test, dart.functionType(core.bool, [T]));
        let future = new (async._Future$(core.bool))();
        let subscription = null;
        subscription = this.listen(dart.fn(element => {
          dart.as(element, T);
          async._runUserCode(dart.fn(() => test(element), core.bool, []), dart.fn(isMatch => {
            if (dart.notNull(isMatch)) {
              async._cancelAndValue(subscription, future, true);
            }
          }, dart.dynamic, [core.bool]), async._cancelAndErrorClosure(subscription, future));
        }, dart.void, [T]), {onError: dart.bind(future, _completeError), onDone: dart.fn(() => {
            future[_complete](false);
          }, dart.void, []), cancelOnError: true});
        return future;
      }
      get length() {
        let future = new (async._Future$(core.int))();
        let count = 0;
        this.listen(dart.fn(_ => {
          dart.as(_, T);
          count++;
        }, dart.void, [T]), {onError: dart.bind(future, _completeError), onDone: dart.fn(() => {
            future[_complete](count);
          }, dart.void, []), cancelOnError: true});
        return future;
      }
      get isEmpty() {
        let future = new (async._Future$(core.bool))();
        let subscription = null;
        subscription = this.listen(dart.fn(_ => {
          dart.as(_, T);
          async._cancelAndValue(subscription, future, false);
        }, dart.void, [T]), {onError: dart.bind(future, _completeError), onDone: dart.fn(() => {
            future[_complete](true);
          }, dart.void, []), cancelOnError: true});
        return future;
      }
      toList() {
        let result = dart.list([], T);
        let future = new (async._Future$(core.List$(T)))();
        this.listen(dart.fn(data => {
          dart.as(data, T);
          result[dartx.add](data);
        }, dart.void, [T]), {onError: dart.bind(future, _completeError), onDone: dart.fn(() => {
            future[_complete](result);
          }, dart.void, []), cancelOnError: true});
        return future;
      }
      toSet() {
        let result = core.Set$(T).new();
        let future = new (async._Future$(core.Set$(T)))();
        this.listen(dart.fn(data => {
          dart.as(data, T);
          result.add(data);
        }, dart.void, [T]), {onError: dart.bind(future, _completeError), onDone: dart.fn(() => {
            future[_complete](result);
          }, dart.void, []), cancelOnError: true});
        return future;
      }
      drain(E) {
        return futureValue => {
          if (futureValue === void 0) futureValue = null;
          return this.listen(null, {cancelOnError: true}).asFuture(E)(futureValue);
        };
      }
      take(count) {
        return new (async._TakeStream$(T))(this, count);
      }
      takeWhile(test) {
        dart.as(test, dart.functionType(core.bool, [T]));
        return new (async._TakeWhileStream$(T))(this, test);
      }
      skip(count) {
        return new (async._SkipStream$(T))(this, count);
      }
      skipWhile(test) {
        dart.as(test, dart.functionType(core.bool, [T]));
        return new (async._SkipWhileStream$(T))(this, test);
      }
      distinct(equals) {
        if (equals === void 0) equals = null;
        dart.as(equals, dart.functionType(core.bool, [T, T]));
        return new (async._DistinctStream$(T))(this, equals);
      }
      get first() {
        let future = new (async._Future$(T))();
        let subscription = null;
        subscription = this.listen(dart.fn(value => {
          dart.as(value, T);
          async._cancelAndValue(subscription, future, value);
        }, dart.void, [T]), {onError: dart.bind(future, _completeError), onDone: dart.fn(() => {
            try {
              dart.throw(_internal.IterableElementError.noElement());
            } catch (e) {
              let s = dart.stackTrace(e);
              async._completeWithErrorCallback(future, e, s);
            }

          }, dart.void, []), cancelOnError: true});
        return future;
      }
      get last() {
        let future = new (async._Future$(T))();
        let result = null;
        let foundResult = false;
        this.listen(dart.fn(value => {
          dart.as(value, T);
          foundResult = true;
          result = value;
        }, dart.void, [T]), {onError: dart.bind(future, _completeError), onDone: dart.fn(() => {
            if (foundResult) {
              future[_complete](result);
              return;
            }
            try {
              dart.throw(_internal.IterableElementError.noElement());
            } catch (e) {
              let s = dart.stackTrace(e);
              async._completeWithErrorCallback(future, e, s);
            }

          }, dart.void, []), cancelOnError: true});
        return future;
      }
      get single() {
        let future = new (async._Future$(T))();
        let result = null;
        let foundResult = false;
        let subscription = null;
        subscription = this.listen(dart.fn(value => {
          dart.as(value, T);
          if (foundResult) {
            try {
              dart.throw(_internal.IterableElementError.tooMany());
            } catch (e) {
              let s = dart.stackTrace(e);
              async._cancelAndErrorWithReplacement(subscription, future, e, s);
            }

            return;
          }
          foundResult = true;
          result = value;
        }, dart.void, [T]), {onError: dart.bind(future, _completeError), onDone: dart.fn(() => {
            if (foundResult) {
              future[_complete](result);
              return;
            }
            try {
              dart.throw(_internal.IterableElementError.noElement());
            } catch (e) {
              let s = dart.stackTrace(e);
              async._completeWithErrorCallback(future, e, s);
            }

          }, dart.void, []), cancelOnError: true});
        return future;
      }
      firstWhere(test, opts) {
        dart.as(test, dart.functionType(core.bool, [T]));
        let defaultValue = opts && 'defaultValue' in opts ? opts.defaultValue : null;
        dart.as(defaultValue, dart.functionType(core.Object, []));
        let future = new async._Future();
        let subscription = null;
        subscription = this.listen(dart.fn(value => {
          dart.as(value, T);
          async._runUserCode(dart.fn(() => test(value), core.bool, []), dart.fn(isMatch => {
            if (dart.notNull(isMatch)) {
              async._cancelAndValue(subscription, future, value);
            }
          }, dart.dynamic, [core.bool]), async._cancelAndErrorClosure(subscription, future));
        }, dart.void, [T]), {onError: dart.bind(future, _completeError), onDone: dart.fn(() => {
            if (defaultValue != null) {
              async._runUserCode(defaultValue, dart.bind(future, _complete), dart.bind(future, _completeError));
              return;
            }
            try {
              dart.throw(_internal.IterableElementError.noElement());
            } catch (e) {
              let s = dart.stackTrace(e);
              async._completeWithErrorCallback(future, e, s);
            }

          }, dart.void, []), cancelOnError: true});
        return future;
      }
      lastWhere(test, opts) {
        dart.as(test, dart.functionType(core.bool, [T]));
        let defaultValue = opts && 'defaultValue' in opts ? opts.defaultValue : null;
        dart.as(defaultValue, dart.functionType(core.Object, []));
        let future = new async._Future();
        let result = null;
        let foundResult = false;
        let subscription = null;
        subscription = this.listen(dart.fn(value => {
          dart.as(value, T);
          async._runUserCode(dart.fn(() => true == test(value), core.bool, []), dart.fn(isMatch => {
            if (dart.notNull(isMatch)) {
              foundResult = true;
              result = value;
            }
          }, dart.dynamic, [core.bool]), async._cancelAndErrorClosure(subscription, future));
        }, dart.void, [T]), {onError: dart.bind(future, _completeError), onDone: dart.fn(() => {
            if (foundResult) {
              future[_complete](result);
              return;
            }
            if (defaultValue != null) {
              async._runUserCode(defaultValue, dart.bind(future, _complete), dart.bind(future, _completeError));
              return;
            }
            try {
              dart.throw(_internal.IterableElementError.noElement());
            } catch (e) {
              let s = dart.stackTrace(e);
              async._completeWithErrorCallback(future, e, s);
            }

          }, dart.void, []), cancelOnError: true});
        return future;
      }
      singleWhere(test) {
        dart.as(test, dart.functionType(core.bool, [T]));
        let future = new (async._Future$(T))();
        let result = null;
        let foundResult = false;
        let subscription = null;
        subscription = this.listen(dart.fn(value => {
          dart.as(value, T);
          async._runUserCode(dart.fn(() => true == test(value), core.bool, []), dart.fn(isMatch => {
            if (dart.notNull(isMatch)) {
              if (foundResult) {
                try {
                  dart.throw(_internal.IterableElementError.tooMany());
                } catch (e) {
                  let s = dart.stackTrace(e);
                  async._cancelAndErrorWithReplacement(subscription, future, e, s);
                }

                return;
              }
              foundResult = true;
              result = value;
            }
          }, dart.dynamic, [core.bool]), async._cancelAndErrorClosure(subscription, future));
        }, dart.void, [T]), {onError: dart.bind(future, _completeError), onDone: dart.fn(() => {
            if (foundResult) {
              future[_complete](result);
              return;
            }
            try {
              dart.throw(_internal.IterableElementError.noElement());
            } catch (e) {
              let s = dart.stackTrace(e);
              async._completeWithErrorCallback(future, e, s);
            }

          }, dart.void, []), cancelOnError: true});
        return future;
      }
      elementAt(index) {
        if (!(typeof index == 'number') || dart.notNull(index) < 0) dart.throw(new core.ArgumentError(index));
        let future = new (async._Future$(T))();
        let subscription = null;
        let elementIndex = 0;
        subscription = this.listen(dart.fn(value => {
          dart.as(value, T);
          if (index == elementIndex) {
            async._cancelAndValue(subscription, future, value);
            return;
          }
          elementIndex = elementIndex + 1;
        }, dart.void, [T]), {onError: dart.bind(future, _completeError), onDone: dart.fn(() => {
            future[_completeError](core.RangeError.index(index, this, "index", null, elementIndex));
          }, dart.void, []), cancelOnError: true});
        return future;
      }
      timeout(timeLimit, opts) {
        let onTimeout = opts && 'onTimeout' in opts ? opts.onTimeout : null;
        dart.as(onTimeout, dart.functionType(dart.void, [async.EventSink$(T)]));
        let controller = null;
        let subscription = null;
        let timer = null;
        let zone = null;
        let timeout = null;
        function onData(event) {
          dart.as(event, T);
          timer.cancel();
          controller.add(event);
          timer = zone.createTimer(timeLimit, timeout);
        }
        dart.fn(onData, dart.void, [T]);
        function onError(error, stackTrace) {
          timer.cancel();
          dart.assert(dart.is(controller, async._StreamController) || dart.is(controller, async._BroadcastStreamController));
          let eventSink = controller;
          dart.dsend(eventSink, _addError, error, stackTrace);
          timer = zone.createTimer(timeLimit, timeout);
        }
        dart.fn(onError, dart.void, [dart.dynamic, core.StackTrace]);
        function onDone() {
          timer.cancel();
          controller.close();
        }
        dart.fn(onDone, dart.void, []);
        const onListen = (function() {
          zone = async.Zone.current;
          if (onTimeout == null) {
            timeout = dart.fn(() => {
              controller.addError(new async.TimeoutException("No stream event", timeLimit), null);
            }, dart.void, []);
          } else {
            let registeredOnTimeout = zone.registerUnaryCallback(dart.dynamic, async.EventSink$(T))(onTimeout);
            let wrapper = new async._ControllerEventSinkWrapper(null);
            timeout = dart.fn(() => {
              wrapper[_sink] = controller;
              zone.runUnaryGuarded(dart.dynamic, dart.dynamic)(registeredOnTimeout, wrapper);
              wrapper[_sink] = null;
            }, dart.void, []);
          }
          subscription = this.listen(onData, {onError: onError, onDone: onDone});
          timer = zone.createTimer(timeLimit, timeout);
        }).bind(this);
        dart.fn(onListen, dart.void, []);
        function onCancel() {
          timer.cancel();
          let result = subscription.cancel();
          subscription = null;
          return result;
        }
        dart.fn(onCancel, async.Future, []);
        controller = dart.notNull(this.isBroadcast) ? new (async._SyncBroadcastStreamController$(T))(onListen, onCancel) : new (async._SyncStreamController$(T))(onListen, dart.fn(() => {
          timer.cancel();
          subscription.pause();
        }, dart.void, []), dart.fn(() => {
          subscription.resume();
          timer = zone.createTimer(timeLimit, timeout);
        }, dart.void, []), onCancel);
        return controller.stream;
      }
    }
    dart.defineNamedConstructor(Stream, '_internal');
    dart.setSignature(Stream, {
      constructors: () => ({
        Stream: [async.Stream$(T), []],
        _internal: [async.Stream$(T), []],
        empty: [async.Stream$(T), []],
        fromFuture: [async.Stream$(T), [async.Future$(T)]],
        fromFutures: [async.Stream$(T), [core.Iterable$(async.Future$(T))]],
        fromIterable: [async.Stream$(T), [core.Iterable$(T)]],
        periodic: [async.Stream$(T), [core.Duration], [dart.functionType(T, [core.int])]],
        eventTransformed: [async.Stream$(T), [async.Stream, dart.functionType(async.EventSink, [async.EventSink$(T)])]]
      }),
      methods: () => ({
        asBroadcastStream: [async.Stream$(T), [], {onListen: dart.functionType(dart.void, [async.StreamSubscription$(T)]), onCancel: dart.functionType(dart.void, [async.StreamSubscription$(T)])}],
        where: [async.Stream$(T), [dart.functionType(core.bool, [T])]],
        map: [S => [async.Stream$(S), [dart.functionType(S, [T])]]],
        asyncMap: [E => [async.Stream$(E), [dart.functionType(dart.dynamic, [T])]]],
        asyncExpand: [E => [async.Stream$(E), [dart.functionType(async.Stream$(E), [T])]]],
        handleError: [async.Stream$(T), [core.Function], {test: dart.functionType(core.bool, [dart.dynamic])}],
        expand: [S => [async.Stream$(S), [dart.functionType(core.Iterable$(S), [T])]]],
        pipe: [async.Future, [async.StreamConsumer$(T)]],
        transform: [S => [async.Stream$(S), [async.StreamTransformer$(T, S)]]],
        reduce: [async.Future$(T), [dart.functionType(T, [T, T])]],
        fold: [S => [async.Future$(S), [S, dart.functionType(S, [S, T])]]],
        join: [async.Future$(core.String), [], [core.String]],
        contains: [async.Future$(core.bool), [core.Object]],
        forEach: [async.Future, [dart.functionType(dart.void, [T])]],
        every: [async.Future$(core.bool), [dart.functionType(core.bool, [T])]],
        any: [async.Future$(core.bool), [dart.functionType(core.bool, [T])]],
        toList: [async.Future$(core.List$(T)), []],
        toSet: [async.Future$(core.Set$(T)), []],
        drain: [E => [async.Future$(E), [], [E]]],
        take: [async.Stream$(T), [core.int]],
        takeWhile: [async.Stream$(T), [dart.functionType(core.bool, [T])]],
        skip: [async.Stream$(T), [core.int]],
        skipWhile: [async.Stream$(T), [dart.functionType(core.bool, [T])]],
        distinct: [async.Stream$(T), [], [dart.functionType(core.bool, [T, T])]],
        firstWhere: [async.Future, [dart.functionType(core.bool, [T])], {defaultValue: dart.functionType(core.Object, [])}],
        lastWhere: [async.Future, [dart.functionType(core.bool, [T])], {defaultValue: dart.functionType(core.Object, [])}],
        singleWhere: [async.Future$(T), [dart.functionType(core.bool, [T])]],
        elementAt: [async.Future$(T), [core.int]],
        timeout: [async.Stream$(T), [core.Duration], {onTimeout: dart.functionType(dart.void, [async.EventSink$(T)])}]
      })
    });
    return Stream;
  });
  async.Stream = async.Stream$();
  _isolate_helper.ReceivePortImpl = class ReceivePortImpl extends async.Stream {
    ReceivePortImpl() {
      this.fromRawReceivePort(new _isolate_helper.RawReceivePortImpl(null));
    }
    weak() {
      this.fromRawReceivePort(new _isolate_helper.RawReceivePortImpl.weak(null));
    }
    fromRawReceivePort(rawPort) {
      this[_rawPort] = rawPort;
      this[_controller] = null;
      super.Stream();
      this[_controller] = async.StreamController.new({onCancel: dart.bind(this, 'close'), sync: true});
      this[_rawPort].handler = dart.bind(this[_controller], 'add');
    }
    listen(onData, opts) {
      let onError = opts && 'onError' in opts ? opts.onError : null;
      let onDone = opts && 'onDone' in opts ? opts.onDone : null;
      let cancelOnError = opts && 'cancelOnError' in opts ? opts.cancelOnError : null;
      return this[_controller].stream.listen(onData, {onError: onError, onDone: onDone, cancelOnError: cancelOnError});
    }
    close() {
      this[_rawPort].close();
      this[_controller].close();
    }
    get sendPort() {
      return this[_rawPort].sendPort;
    }
  };
  dart.defineNamedConstructor(_isolate_helper.ReceivePortImpl, 'weak');
  dart.defineNamedConstructor(_isolate_helper.ReceivePortImpl, 'fromRawReceivePort');
  _isolate_helper.ReceivePortImpl[dart.implements] = () => [isolate.ReceivePort];
  dart.setSignature(_isolate_helper.ReceivePortImpl, {
    constructors: () => ({
      ReceivePortImpl: [_isolate_helper.ReceivePortImpl, []],
      weak: [_isolate_helper.ReceivePortImpl, []],
      fromRawReceivePort: [_isolate_helper.ReceivePortImpl, [isolate.RawReceivePort]]
    }),
    methods: () => ({
      listen: [async.StreamSubscription, [dart.functionType(dart.void, [dart.dynamic])], {onError: core.Function, onDone: dart.functionType(dart.void, []), cancelOnError: core.bool}],
      close: [dart.void, []]
    })
  });
  const _once = Symbol('_once');
  const _inEventLoop = Symbol('_inEventLoop');
  const _handle = Symbol('_handle');
  _isolate_helper.TimerImpl = class TimerImpl extends core.Object {
    TimerImpl(milliseconds, callback) {
      this[_once] = true;
      this[_inEventLoop] = false;
      this[_handle] = null;
      if (milliseconds == 0 && (!dart.notNull(_isolate_helper.hasTimer()) || dart.notNull(_isolate_helper._globalState.isWorker))) {
        const internalCallback = (function() {
          this[_handle] = null;
          callback();
        }).bind(this);
        dart.fn(internalCallback, dart.void, []);
        this[_handle] = 1;
        _isolate_helper._globalState.topEventLoop.enqueue(_isolate_helper._globalState.currentContext, internalCallback, 'timer');
        this[_inEventLoop] = true;
      } else if (dart.notNull(_isolate_helper.hasTimer())) {
        const internalCallback = (function() {
          this[_handle] = null;
          _isolate_helper.leaveJsAsync();
          callback();
        }).bind(this);
        dart.fn(internalCallback, dart.void, []);
        _isolate_helper.enterJsAsync();
        this[_handle] = self.setTimeout(internalCallback, milliseconds);
      } else {
        dart.assert(dart.notNull(milliseconds) > 0);
        dart.throw(new core.UnsupportedError("Timer greater than 0."));
      }
    }
    periodic(milliseconds, callback) {
      this[_once] = false;
      this[_inEventLoop] = false;
      this[_handle] = null;
      if (dart.notNull(_isolate_helper.hasTimer())) {
        _isolate_helper.enterJsAsync();
        this[_handle] = self.setInterval(dart.fn(() => {
          callback(this);
        }), milliseconds);
      } else {
        dart.throw(new core.UnsupportedError("Periodic timer."));
      }
    }
    cancel() {
      if (dart.notNull(_isolate_helper.hasTimer())) {
        if (dart.notNull(this[_inEventLoop])) {
          dart.throw(new core.UnsupportedError("Timer in event loop cannot be canceled."));
        }
        if (this[_handle] == null) return;
        _isolate_helper.leaveJsAsync();
        if (dart.notNull(this[_once])) {
          self.clearTimeout(this[_handle]);
        } else {
          self.clearInterval(this[_handle]);
        }
        this[_handle] = null;
      } else {
        dart.throw(new core.UnsupportedError("Canceling a timer."));
      }
    }
    get isActive() {
      return this[_handle] != null;
    }
  };
  dart.defineNamedConstructor(_isolate_helper.TimerImpl, 'periodic');
  _isolate_helper.TimerImpl[dart.implements] = () => [async.Timer];
  dart.setSignature(_isolate_helper.TimerImpl, {
    constructors: () => ({
      TimerImpl: [_isolate_helper.TimerImpl, [core.int, dart.functionType(dart.void, [])]],
      periodic: [_isolate_helper.TimerImpl, [core.int, dart.functionType(dart.void, [async.Timer])]]
    }),
    methods: () => ({cancel: [dart.void, []]})
  });
  _isolate_helper.hasTimer = function() {
    return self.setTimeout != null;
  };
  dart.lazyFn(_isolate_helper.hasTimer, () => [core.bool, []]);
  _isolate_helper.CapabilityImpl = class CapabilityImpl extends core.Object {
    CapabilityImpl() {
      this._internal(_js_helper.random64());
    }
    _internal(id) {
      this[_id] = id;
    }
    get hashCode() {
      let hash = this[_id];
      hash = (hash[dartx['>>']](0) ^ (dart.notNull(hash) / 4294967296)[dartx.truncate]()) >>> 0;
      hash = ((~dart.notNull(hash) >>> 0) + (dart.notNull(hash) << 15 >>> 0) & 4294967295) >>> 0;
      hash = (dart.notNull(hash) ^ hash[dartx['>>']](12)) >>> 0;
      hash = (dart.notNull(hash) * 5 & 4294967295) >>> 0;
      hash = (dart.notNull(hash) ^ hash[dartx['>>']](4)) >>> 0;
      hash = (dart.notNull(hash) * 2057 & 4294967295) >>> 0;
      hash = (dart.notNull(hash) ^ hash[dartx['>>']](16)) >>> 0;
      return hash;
    }
    ['=='](other) {
      if (core.identical(other, this)) return true;
      if (dart.is(other, _isolate_helper.CapabilityImpl)) {
        return core.identical(this[_id], other[_id]);
      }
      return false;
    }
  };
  dart.defineNamedConstructor(_isolate_helper.CapabilityImpl, '_internal');
  _isolate_helper.CapabilityImpl[dart.implements] = () => [isolate.Capability];
  dart.setSignature(_isolate_helper.CapabilityImpl, {
    constructors: () => ({
      CapabilityImpl: [_isolate_helper.CapabilityImpl, []],
      _internal: [_isolate_helper.CapabilityImpl, [core.int]]
    }),
    methods: () => ({'==': [core.bool, [core.Object]]})
  });
  _isolate_helper._serializeMessage = function(message) {
    return new _isolate_helper._Serializer().serialize(message);
  };
  dart.fn(_isolate_helper._serializeMessage);
  _isolate_helper._deserializeMessage = function(message) {
    return new _isolate_helper._Deserializer().deserialize(message);
  };
  dart.fn(_isolate_helper._deserializeMessage);
  _isolate_helper._clone = function(message) {
    let serializer = new _isolate_helper._Serializer({serializeSendPorts: false});
    let deserializer = new _isolate_helper._Deserializer();
    return deserializer.deserialize(serializer.serialize(message));
  };
  dart.fn(_isolate_helper._clone);
  const _serializeSendPorts = Symbol('_serializeSendPorts');
  _isolate_helper._Serializer = class _Serializer extends core.Object {
    _Serializer(opts) {
      let serializeSendPorts = opts && 'serializeSendPorts' in opts ? opts.serializeSendPorts : true;
      this.serializedObjectIds = core.Map$(dart.dynamic, core.int).identity();
      this[_serializeSendPorts] = dart.as(serializeSendPorts, core.bool);
    }
    serialize(x) {
      if (dart.notNull(this.isPrimitive(x))) return this.serializePrimitive(x);
      let serializationId = this.serializedObjectIds[dartx.get](x);
      if (serializationId != null) return this.makeRef(serializationId);
      serializationId = this.serializedObjectIds[dartx.length];
      this.serializedObjectIds[dartx.set](x, serializationId);
      if (dart.is(x, _native_typed_data.NativeByteBuffer)) return this.serializeByteBuffer(x);
      if (dart.is(x, _native_typed_data.NativeTypedData)) return this.serializeTypedData(x);
      if (dart.is(x, _interceptors.JSIndexable)) return this.serializeJSIndexable(x);
      if (dart.is(x, _js_helper.InternalMap)) return this.serializeMap(x);
      if (dart.is(x, _interceptors.JSObject)) return this.serializeJSObject(x);
      if (dart.is(x, _interceptors.Interceptor)) this.unsupported(x);
      if (dart.is(x, isolate.RawReceivePort)) {
        this.unsupported(x, "RawReceivePorts can't be transmitted:");
      }
      if (dart.is(x, _isolate_helper._NativeJsSendPort)) return this.serializeJsSendPort(x);
      if (dart.is(x, _isolate_helper._WorkerSendPort)) return this.serializeWorkerSendPort(x);
      if (dart.is(x, core.Function)) return this.serializeClosure(x);
      return this.serializeDartObject(x);
    }
    unsupported(x, message) {
      if (message === void 0) message = null;
      if (message == null) message = "Can't transmit:";
      dart.throw(new core.UnsupportedError(`${message} ${x}`));
    }
    makeRef(serializationId) {
      return dart.list(["ref", serializationId], core.Object);
    }
    isPrimitive(x) {
      return x == null || typeof x == 'string' || typeof x == 'number' || typeof x == 'boolean';
    }
    serializePrimitive(primitive) {
      return primitive;
    }
    serializeByteBuffer(buffer) {
      return dart.list(["buffer", buffer], core.Object);
    }
    serializeTypedData(data) {
      return dart.list(["typed", data], core.Object);
    }
    serializeJSIndexable(indexable) {
      dart.assert(!(typeof indexable == 'string'));
      let serialized = dart.as(this.serializeArray(dart.as(indexable, _interceptors.JSArray)), core.List);
      if (dart.is(indexable, _interceptors.JSFixedArray)) return dart.list(["fixed", serialized], core.Object);
      if (dart.is(indexable, _interceptors.JSExtendableArray)) return dart.list(["extendable", serialized], core.Object);
      if (dart.is(indexable, _interceptors.JSMutableArray)) return dart.list(["mutable", serialized], core.Object);
      if (dart.is(indexable, _interceptors.JSArray)) return dart.list(["const", serialized], core.Object);
      this.unsupported(indexable, "Can't serialize indexable: ");
      return null;
    }
    serializeArray(x) {
      let serialized = [];
      serialized[dartx.length] = x[dartx.length];
      for (let i = 0; i < dart.notNull(x[dartx.length]); i++) {
        serialized[dartx.set](i, this.serialize(x[dartx.get](i)));
      }
      return serialized;
    }
    serializeArrayInPlace(x) {
      for (let i = 0; i < dart.notNull(x[dartx.length]); i++) {
        x[dartx.set](i, this.serialize(x[dartx.get](i)));
      }
      return x;
    }
    serializeMap(x) {
      let serializeTearOff = dart.bind(this, 'serialize');
      return dart.list(['map', x[dartx.keys][dartx.map](dart.dynamic)(dart.as(serializeTearOff, dart.functionType(dart.dynamic, [dart.dynamic])))[dartx.toList](), x[dartx.values][dartx.map](dart.dynamic)(dart.as(serializeTearOff, dart.functionType(dart.dynamic, [dart.dynamic])))[dartx.toList]()], core.Object);
    }
    serializeJSObject(x) {
      if (!!x.constructor && x.constructor !== Object) {
        this.unsupported(x, "Only plain JS Objects are supported:");
      }
      let keys = Object.keys(x);
      let values = [];
      values[dartx.length] = keys[dartx.length];
      for (let i = 0; i < dart.notNull(keys[dartx.length]); i++) {
        values[dartx.set](i, this.serialize(x[keys[dartx.get](i)]));
      }
      return dart.list(['js-object', keys, values], core.Object);
    }
    serializeWorkerSendPort(x) {
      if (dart.notNull(this[_serializeSendPorts])) {
        return dart.list(['sendport', x[_workerId], x[_isolateId], x[_receivePortId]], core.Object);
      }
      return dart.list(['raw sendport', x], core.Object);
    }
    serializeJsSendPort(x) {
      if (dart.notNull(this[_serializeSendPorts])) {
        let workerId = _isolate_helper._globalState.currentManagerId;
        return dart.list(['sendport', workerId, x[_isolateId], x[_receivePort][_id]], core.Object);
      }
      return dart.list(['raw sendport', x], core.Object);
    }
    serializeCapability(x) {
      return dart.list(['capability', x[_id]], core.Object);
    }
    serializeClosure(x) {
      let name = _isolate_helper.IsolateNatives._getJSFunctionName(x);
      if (name == null) {
        this.unsupported(x, "Closures can't be transmitted:");
      }
      return dart.list(['function', name], core.String);
    }
    serializeDartObject(x) {
      let classExtractor = _foreign_helper.JS_EMBEDDED_GLOBAL('', _js_embedded_names.CLASS_ID_EXTRACTOR);
      let fieldsExtractor = _foreign_helper.JS_EMBEDDED_GLOBAL('', _js_embedded_names.CLASS_FIELDS_EXTRACTOR);
      let classId = classExtractor(x);
      let fields = fieldsExtractor(x);
      return ['dart', classId, this.serializeArrayInPlace(dart.as(fields, _interceptors.JSArray))];
    }
  };
  dart.setSignature(_isolate_helper._Serializer, {
    constructors: () => ({_Serializer: [_isolate_helper._Serializer, [], {serializeSendPorts: dart.dynamic}]}),
    methods: () => ({
      serialize: [dart.dynamic, [dart.dynamic]],
      unsupported: [dart.void, [dart.dynamic], [core.String]],
      makeRef: [dart.dynamic, [core.int]],
      isPrimitive: [core.bool, [dart.dynamic]],
      serializePrimitive: [dart.dynamic, [dart.dynamic]],
      serializeByteBuffer: [dart.dynamic, [_native_typed_data.NativeByteBuffer]],
      serializeTypedData: [dart.dynamic, [_native_typed_data.NativeTypedData]],
      serializeJSIndexable: [dart.dynamic, [_interceptors.JSIndexable]],
      serializeArray: [dart.dynamic, [_interceptors.JSArray]],
      serializeArrayInPlace: [dart.dynamic, [_interceptors.JSArray]],
      serializeMap: [dart.dynamic, [core.Map]],
      serializeJSObject: [dart.dynamic, [_interceptors.JSObject]],
      serializeWorkerSendPort: [dart.dynamic, [_isolate_helper._WorkerSendPort]],
      serializeJsSendPort: [dart.dynamic, [_isolate_helper._NativeJsSendPort]],
      serializeCapability: [dart.dynamic, [_isolate_helper.CapabilityImpl]],
      serializeClosure: [dart.dynamic, [core.Function]],
      serializeDartObject: [dart.dynamic, [dart.dynamic]]
    })
  });
  const _adjustSendPorts = Symbol('_adjustSendPorts');
  _isolate_helper._Deserializer = class _Deserializer extends core.Object {
    _Deserializer(opts) {
      let adjustSendPorts = opts && 'adjustSendPorts' in opts ? opts.adjustSendPorts : true;
      this.deserializedObjects = core.List.new();
      this[_adjustSendPorts] = dart.as(adjustSendPorts, core.bool);
    }
    deserialize(x) {
      if (dart.notNull(this.isPrimitive(x))) return this.deserializePrimitive(x);
      if (!dart.is(x, _interceptors.JSArray)) dart.throw(new core.ArgumentError(`Bad serialized message: ${x}`));
      switch (dart.dload(x, 'first')) {
        case "ref":
        {
          return this.deserializeRef(x);
        }
        case "buffer":
        {
          return this.deserializeByteBuffer(x);
        }
        case "typed":
        {
          return this.deserializeTypedData(x);
        }
        case "fixed":
        {
          return this.deserializeFixed(x);
        }
        case "extendable":
        {
          return this.deserializeExtendable(x);
        }
        case "mutable":
        {
          return this.deserializeMutable(x);
        }
        case "const":
        {
          return this.deserializeConst(x);
        }
        case "map":
        {
          return this.deserializeMap(x);
        }
        case "sendport":
        {
          return this.deserializeSendPort(x);
        }
        case "raw sendport":
        {
          return this.deserializeRawSendPort(x);
        }
        case "js-object":
        {
          return this.deserializeJSObject(x);
        }
        case "function":
        {
          return this.deserializeClosure(x);
        }
        case "dart":
        {
          return this.deserializeDartObject(x);
        }
        default:
        {
          dart.throw(`couldn't deserialize: ${x}`);
        }
      }
    }
    isPrimitive(x) {
      return x == null || typeof x == 'string' || typeof x == 'number' || typeof x == 'boolean';
    }
    deserializePrimitive(x) {
      return x;
    }
    deserializeRef(x) {
      dart.assert(dart.equals(dart.dindex(x, 0), 'ref'));
      let serializationId = dart.as(dart.dindex(x, 1), core.int);
      return this.deserializedObjects[dartx.get](serializationId);
    }
    deserializeByteBuffer(x) {
      dart.assert(dart.equals(dart.dindex(x, 0), 'buffer'));
      let result = dart.as(dart.dindex(x, 1), _native_typed_data.NativeByteBuffer);
      this.deserializedObjects[dartx.add](result);
      return result;
    }
    deserializeTypedData(x) {
      dart.assert(dart.equals(dart.dindex(x, 0), 'typed'));
      let result = dart.as(dart.dindex(x, 1), _native_typed_data.NativeTypedData);
      this.deserializedObjects[dartx.add](result);
      return result;
    }
    deserializeArrayInPlace(x) {
      for (let i = 0; i < dart.notNull(x[dartx.length]); i++) {
        x[dartx.set](i, this.deserialize(x[dartx.get](i)));
      }
      return x;
    }
    deserializeFixed(x) {
      dart.assert(dart.equals(dart.dindex(x, 0), 'fixed'));
      let result = dart.as(dart.dindex(x, 1), core.List);
      this.deserializedObjects[dartx.add](result);
      return _interceptors.JSArray.markFixed(this.deserializeArrayInPlace(dart.as(result, _interceptors.JSArray)));
    }
    deserializeExtendable(x) {
      dart.assert(dart.equals(dart.dindex(x, 0), 'extendable'));
      let result = dart.as(dart.dindex(x, 1), core.List);
      this.deserializedObjects[dartx.add](result);
      return _interceptors.JSArray.markGrowable(this.deserializeArrayInPlace(dart.as(result, _interceptors.JSArray)));
    }
    deserializeMutable(x) {
      dart.assert(dart.equals(dart.dindex(x, 0), 'mutable'));
      let result = dart.as(dart.dindex(x, 1), core.List);
      this.deserializedObjects[dartx.add](result);
      return this.deserializeArrayInPlace(dart.as(result, _interceptors.JSArray));
    }
    deserializeConst(x) {
      dart.assert(dart.equals(dart.dindex(x, 0), 'const'));
      let result = dart.as(dart.dindex(x, 1), core.List);
      this.deserializedObjects[dartx.add](result);
      return _interceptors.JSArray.markFixed(this.deserializeArrayInPlace(dart.as(result, _interceptors.JSArray)));
    }
    deserializeMap(x) {
      dart.assert(dart.equals(dart.dindex(x, 0), 'map'));
      let keys = dart.as(dart.dindex(x, 1), core.List);
      let values = dart.as(dart.dindex(x, 2), core.List);
      let result = dart.map();
      this.deserializedObjects[dartx.add](result);
      keys = keys[dartx.map](dart.dynamic)(dart.bind(this, 'deserialize'))[dartx.toList]();
      for (let i = 0; i < dart.notNull(keys[dartx.length]); i++) {
        result[dartx.set](keys[dartx.get](i), this.deserialize(values[dartx.get](i)));
      }
      return result;
    }
    deserializeSendPort(x) {
      dart.assert(dart.equals(dart.dindex(x, 0), 'sendport'));
      let managerId = dart.as(dart.dindex(x, 1), core.int);
      let isolateId = dart.as(dart.dindex(x, 2), core.int);
      let receivePortId = dart.as(dart.dindex(x, 3), core.int);
      let result = null;
      if (managerId == _isolate_helper._globalState.currentManagerId) {
        let isolate = _isolate_helper._globalState.isolates[dartx.get](isolateId);
        if (isolate == null) return null;
        let receivePort = isolate.lookup(receivePortId);
        if (receivePort == null) return null;
        result = new _isolate_helper._NativeJsSendPort(receivePort, isolateId);
      } else {
        result = new _isolate_helper._WorkerSendPort(managerId, isolateId, receivePortId);
      }
      this.deserializedObjects[dartx.add](result);
      return result;
    }
    deserializeRawSendPort(x) {
      dart.assert(dart.equals(dart.dindex(x, 0), 'raw sendport'));
      let result = dart.as(dart.dindex(x, 1), isolate.SendPort);
      this.deserializedObjects[dartx.add](result);
      return result;
    }
    deserializeJSObject(x) {
      dart.assert(dart.equals(dart.dindex(x, 0), 'js-object'));
      let keys = dart.as(dart.dindex(x, 1), core.List);
      let values = dart.as(dart.dindex(x, 2), core.List);
      let o = {};
      this.deserializedObjects[dartx.add](o);
      for (let i = 0; i < dart.notNull(keys[dartx.length]); i++) {
        o[keys[dartx.get](i)] = this.deserialize(values[dartx.get](i));
      }
      return o;
    }
    deserializeClosure(x) {
      dart.assert(dart.equals(dart.dindex(x, 0), 'function'));
      let name = dart.as(dart.dindex(x, 1), core.String);
      let result = dart.as(_isolate_helper.IsolateNatives._getJSFunctionFromName(name), core.Function);
      this.deserializedObjects[dartx.add](result);
      return result;
    }
    deserializeDartObject(x) {
      dart.assert(dart.equals(dart.dindex(x, 0), 'dart'));
      let classId = dart.as(dart.dindex(x, 1), core.String);
      let fields = dart.as(dart.dindex(x, 2), core.List);
      let instanceFromClassId = _foreign_helper.JS_EMBEDDED_GLOBAL('', _js_embedded_names.INSTANCE_FROM_CLASS_ID);
      let initializeObject = _foreign_helper.JS_EMBEDDED_GLOBAL('', _js_embedded_names.INITIALIZE_EMPTY_INSTANCE);
      let emptyInstance = instanceFromClassId(classId);
      this.deserializedObjects[dartx.add](emptyInstance);
      this.deserializeArrayInPlace(dart.as(fields, _interceptors.JSArray));
      return initializeObject(classId, emptyInstance, fields);
    }
  };
  dart.setSignature(_isolate_helper._Deserializer, {
    constructors: () => ({_Deserializer: [_isolate_helper._Deserializer, [], {adjustSendPorts: dart.dynamic}]}),
    methods: () => ({
      deserialize: [dart.dynamic, [dart.dynamic]],
      isPrimitive: [core.bool, [dart.dynamic]],
      deserializePrimitive: [dart.dynamic, [dart.dynamic]],
      deserializeRef: [dart.dynamic, [dart.dynamic]],
      deserializeByteBuffer: [_native_typed_data.NativeByteBuffer, [dart.dynamic]],
      deserializeTypedData: [_native_typed_data.NativeTypedData, [dart.dynamic]],
      deserializeArrayInPlace: [core.List, [_interceptors.JSArray]],
      deserializeFixed: [core.List, [dart.dynamic]],
      deserializeExtendable: [core.List, [dart.dynamic]],
      deserializeMutable: [core.List, [dart.dynamic]],
      deserializeConst: [core.List, [dart.dynamic]],
      deserializeMap: [core.Map, [dart.dynamic]],
      deserializeSendPort: [isolate.SendPort, [dart.dynamic]],
      deserializeRawSendPort: [isolate.SendPort, [dart.dynamic]],
      deserializeJSObject: [dart.dynamic, [dart.dynamic]],
      deserializeClosure: [core.Function, [dart.dynamic]],
      deserializeDartObject: [dart.dynamic, [dart.dynamic]]
    })
  });
  _js_embedded_names.DISPATCH_PROPERTY_NAME = "dispatchPropertyName";
  _js_embedded_names.TYPE_INFORMATION = 'typeInformation';
  _js_embedded_names.GLOBAL_FUNCTIONS = 'globalFunctions';
  _js_embedded_names.STATICS = 'statics';
  _js_embedded_names.INTERCEPTED_NAMES = 'interceptedNames';
  _js_embedded_names.MANGLED_GLOBAL_NAMES = 'mangledGlobalNames';
  _js_embedded_names.MANGLED_NAMES = 'mangledNames';
  _js_embedded_names.LIBRARIES = 'libraries';
  _js_embedded_names.FINISHED_CLASSES = 'finishedClasses';
  _js_embedded_names.ALL_CLASSES = 'allClasses';
  _js_embedded_names.METADATA = 'metadata';
  _js_embedded_names.INTERCEPTORS_BY_TAG = 'interceptorsByTag';
  _js_embedded_names.LEAF_TAGS = 'leafTags';
  _js_embedded_names.LAZIES = 'lazies';
  _js_embedded_names.GET_ISOLATE_TAG = 'getIsolateTag';
  _js_embedded_names.ISOLATE_TAG = 'isolateTag';
  _js_embedded_names.CURRENT_SCRIPT = 'currentScript';
  _js_embedded_names.DEFERRED_LIBRARY_URIS = 'deferredLibraryUris';
  _js_embedded_names.DEFERRED_LIBRARY_HASHES = 'deferredLibraryHashes';
  _js_embedded_names.INITIALIZE_LOADED_HUNK = 'initializeLoadedHunk';
  _js_embedded_names.IS_HUNK_LOADED = 'isHunkLoaded';
  _js_embedded_names.IS_HUNK_INITIALIZED = 'isHunkInitialized';
  _js_embedded_names.DEFERRED_INITIALIZED = 'deferredInitialized';
  _js_embedded_names.CLASS_ID_EXTRACTOR = 'classIdExtractor';
  _js_embedded_names.CLASS_FIELDS_EXTRACTOR = 'classFieldsExtractor';
  _js_embedded_names.INSTANCE_FROM_CLASS_ID = "instanceFromClassId";
  _js_embedded_names.INITIALIZE_EMPTY_INSTANCE = "initializeEmptyInstance";
  _js_embedded_names.TYPEDEF_TYPE_PROPERTY_NAME = "$typedefType";
  _js_embedded_names.TYPEDEF_PREDICATE_PROPERTY_NAME = "$$isTypedef";
  _js_embedded_names.NATIVE_SUPERCLASS_TAG_NAME = "$nativeSuperclassTag";
  _js_embedded_names.MAP_TYPE_TO_INTERCEPTOR = "mapTypeToInterceptor";
  _js_helper._Patch = class _Patch extends core.Object {
    _Patch() {
    }
  };
  dart.setSignature(_js_helper._Patch, {
    constructors: () => ({_Patch: [_js_helper._Patch, []]})
  });
  _js_helper.patch = dart.const(new _js_helper._Patch());
  _js_helper.InternalMap = class InternalMap extends core.Object {};
  _js_helper.Primitives = class Primitives extends core.Object {
    static initializeStatics(id) {
      _js_helper.Primitives.mirrorFunctionCacheName = dart.notNull(_js_helper.Primitives.mirrorFunctionCacheName) + `_${id}`;
      _js_helper.Primitives.mirrorInvokeCacheName = dart.notNull(_js_helper.Primitives.mirrorInvokeCacheName) + `_${id}`;
    }
    static objectHashCode(object) {
      let hash = object.$identityHash;
      if (hash == null) {
        hash = Math.random() * 0x3fffffff | 0;
        object.$identityHash = hash;
      }
      return hash;
    }
    static _parseIntError(source, handleError) {
      if (handleError == null) dart.throw(new core.FormatException(source));
      return handleError(source);
    }
    static parseInt(source, radix, handleError) {
      _js_helper.checkString(source);
      let re = /^\s*[+-]?((0x[a-f0-9]+)|(\d+)|([a-z0-9]+))\s*$/i;
      let match = re.exec(source);
      let digitsIndex = 1;
      let hexIndex = 2;
      let decimalIndex = 3;
      let nonDecimalHexIndex = 4;
      if (match == null) {
        return _js_helper.Primitives._parseIntError(source, handleError);
      }
      let decimalMatch = match[dartx.get](decimalIndex);
      if (radix == null) {
        if (decimalMatch != null) {
          return parseInt(source, 10);
        }
        if (match[dartx.get](hexIndex) != null) {
          return parseInt(source, 16);
        }
        return _js_helper.Primitives._parseIntError(source, handleError);
      }
      if (!(typeof radix == 'number')) {
        dart.throw(new core.ArgumentError.value(radix, 'radix', 'is not an integer'));
      }
      if (dart.notNull(radix) < 2 || dart.notNull(radix) > 36) {
        dart.throw(new core.RangeError.range(radix, 2, 36, 'radix'));
      }
      if (radix == 10 && decimalMatch != null) {
        return parseInt(source, 10);
      }
      if (dart.notNull(radix) < 10 || decimalMatch == null) {
        let maxCharCode = null;
        if (dart.notNull(radix) <= 10) {
          maxCharCode = 48 - 1 + dart.notNull(radix);
        } else {
          maxCharCode = 97 - 10 - 1 + dart.notNull(radix);
        }
        dart.assert(typeof match[dartx.get](digitsIndex) == 'string');
        let digitsPart = match[digitsIndex];
        for (let i = 0; i < dart.notNull(digitsPart[dartx.length]); i++) {
          let characterCode = (dart.notNull(digitsPart[dartx.codeUnitAt](i)) | 32) >>> 0;
          if (characterCode > dart.notNull(maxCharCode)) {
            return _js_helper.Primitives._parseIntError(source, handleError);
          }
        }
      }
      return parseInt(source, radix);
    }
    static _parseDoubleError(source, handleError) {
      if (handleError == null) {
        dart.throw(new core.FormatException('Invalid double', source));
      }
      return handleError(source);
    }
    static parseDouble(source, handleError) {
      _js_helper.checkString(source);
      if (!/^\s*[+-]?(?:Infinity|NaN|(?:\.\d+|\d+(?:\.\d*)?)(?:[eE][+-]?\d+)?)\s*$/.test(source)) {
        return _js_helper.Primitives._parseDoubleError(source, handleError);
      }
      let result = parseFloat(source);
      if (dart.notNull(result[dartx.isNaN])) {
        let trimmed = source[dartx.trim]();
        if (trimmed == 'NaN' || trimmed == '+NaN' || trimmed == '-NaN') {
          return result;
        }
        return _js_helper.Primitives._parseDoubleError(source, handleError);
      }
      return result;
    }
    static objectTypeName(object) {
      return dart.toString(_js_helper.getRuntimeType(object));
    }
    static objectToString(object) {
      let name = dart.typeName(dart.getReifiedType(object));
      return `Instance of '${name}'`;
    }
    static dateNow() {
      return Date.now();
    }
    static initTicker() {
      if (_js_helper.Primitives.timerFrequency != null) return;
      _js_helper.Primitives.timerFrequency = 1000;
      _js_helper.Primitives.timerTicks = _js_helper.Primitives.dateNow;
      if (typeof window == "undefined") return;
      let jsWindow = window;
      if (jsWindow == null) return;
      let performance = jsWindow.performance;
      if (performance == null) return;
      if (typeof performance.now != "function") return;
      _js_helper.Primitives.timerFrequency = 1000000;
      _js_helper.Primitives.timerTicks = dart.fn(() => (1000 * performance.now())[dartx.floor](), core.int, []);
    }
    static get isD8() {
      return typeof version == "function" && typeof os == "object" && "system" in os;
    }
    static get isJsshell() {
      return typeof version == "function" && typeof system == "function";
    }
    static currentUri() {
      if (!!self.location) {
        return self.location.href;
      }
      return null;
    }
    static _fromCharCodeApply(array) {
      let kMaxApply = 500;
      let end = array[dartx.length];
      if (dart.notNull(end) <= kMaxApply) {
        return String.fromCharCode.apply(null, array);
      }
      let result = '';
      for (let i = 0; i < dart.notNull(end); i = i + kMaxApply) {
        let chunkEnd = i + kMaxApply < dart.notNull(end) ? i + kMaxApply : end;
        result = result + String.fromCharCode.apply(null, array.slice(i, chunkEnd));
      }
      return result;
    }
    static stringFromCodePoints(codePoints) {
      let a = dart.list([], core.int);
      for (let i of codePoints) {
        if (!(typeof i == 'number')) dart.throw(_js_helper.argumentErrorValue(i));
        if (dart.notNull(i) <= 65535) {
          a[dartx.add](i);
        } else if (dart.notNull(i) <= 1114111) {
          a[dartx.add](55296 + ((dart.notNull(i) - 65536)[dartx['>>']](10) & 1023));
          a[dartx.add](56320 + (dart.notNull(i) & 1023));
        } else {
          dart.throw(_js_helper.argumentErrorValue(i));
        }
      }
      return _js_helper.Primitives._fromCharCodeApply(a);
    }
    static stringFromCharCodes(charCodes) {
      for (let i of charCodes) {
        if (!(typeof i == 'number')) dart.throw(_js_helper.argumentErrorValue(i));
        if (dart.notNull(i) < 0) dart.throw(_js_helper.argumentErrorValue(i));
        if (dart.notNull(i) > 65535) return _js_helper.Primitives.stringFromCodePoints(charCodes);
      }
      return _js_helper.Primitives._fromCharCodeApply(charCodes);
    }
    static stringFromNativeUint8List(charCodes, start, end) {
      let kMaxApply = 500;
      if (dart.notNull(end) <= kMaxApply && start == 0 && end == charCodes[dartx.length]) {
        return String.fromCharCode.apply(null, charCodes);
      }
      let result = '';
      for (let i = start; dart.notNull(i) < dart.notNull(end); i = dart.notNull(i) + kMaxApply) {
        let chunkEnd = dart.notNull(i) + kMaxApply < dart.notNull(end) ? dart.notNull(i) + kMaxApply : end;
        result = result + String.fromCharCode.apply(null, charCodes.subarray(i, chunkEnd));
      }
      return result;
    }
    static stringFromCharCode(charCode) {
      if (0 <= dart.notNull(charCode)) {
        if (dart.notNull(charCode) <= 65535) {
          return String.fromCharCode(charCode);
        }
        if (dart.notNull(charCode) <= 1114111) {
          let bits = dart.notNull(charCode) - 65536;
          let low = 56320 | bits & 1023;
          let high = (55296 | bits[dartx['>>']](10)) >>> 0;
          return String.fromCharCode(high, low);
        }
      }
      dart.throw(new core.RangeError.range(charCode, 0, 1114111));
    }
    static stringConcatUnchecked(string1, string2) {
      return _foreign_helper.JS_STRING_CONCAT(string1, string2);
    }
    static flattenString(str) {
      return str.charCodeAt(0) == 0 ? str : str;
    }
    static getTimeZoneName(receiver) {
      let d = _js_helper.Primitives.lazyAsJsDate(receiver);
      let match = /\((.*)\)/.exec(d.toString());
      if (match != null) return dart.as(match[dartx.get](1), core.String);
      match = /^[A-Z,a-z]{3}\s[A-Z,a-z]{3}\s\d+\s\d{2}:\d{2}:\d{2}\s([A-Z]{3,5})\s\d{4}$/.exec(d.toString());
      if (match != null) return dart.as(match[dartx.get](1), core.String);
      match = /(?:GMT|UTC)[+-]\d{4}/.exec(d.toString());
      if (match != null) return dart.as(match[dartx.get](0), core.String);
      return "";
    }
    static getTimeZoneOffsetInMinutes(receiver) {
      return -_js_helper.Primitives.lazyAsJsDate(receiver).getTimezoneOffset();
    }
    static valueFromDecomposedDate(years, month, day, hours, minutes, seconds, milliseconds, isUtc) {
      let MAX_MILLISECONDS_SINCE_EPOCH = 8640000000000000;
      _js_helper.checkInt(years);
      _js_helper.checkInt(month);
      _js_helper.checkInt(day);
      _js_helper.checkInt(hours);
      _js_helper.checkInt(minutes);
      _js_helper.checkInt(seconds);
      _js_helper.checkInt(milliseconds);
      _js_helper.checkBool(isUtc);
      let jsMonth = dart.dsend(month, '-', 1);
      let value = null;
      if (dart.test(isUtc)) {
        value = Date.UTC(years, jsMonth, day, hours, minutes, seconds, milliseconds);
      } else {
        value = new Date(years, jsMonth, day, hours, minutes, seconds, milliseconds).valueOf();
      }
      if (dart.test(dart.dload(value, 'isNaN')) || dart.test(dart.dsend(value, '<', -MAX_MILLISECONDS_SINCE_EPOCH)) || dart.test(dart.dsend(value, '>', MAX_MILLISECONDS_SINCE_EPOCH))) {
        return null;
      }
      if (dart.test(dart.dsend(years, '<=', 0)) || dart.test(dart.dsend(years, '<', 100))) return _js_helper.Primitives.patchUpY2K(value, years, isUtc);
      return value;
    }
    static patchUpY2K(value, years, isUtc) {
      let date = new Date(value);
      if (dart.test(isUtc)) {
        date.setUTCFullYear(years);
      } else {
        date.setFullYear(years);
      }
      return date.valueOf();
    }
    static lazyAsJsDate(receiver) {
      if (receiver.date === void 0) {
        receiver.date = new Date(dart.dload(receiver, 'millisecondsSinceEpoch'));
      }
      return receiver.date;
    }
    static getYear(receiver) {
      return dart.notNull(dart.as(dart.dload(receiver, 'isUtc'), core.bool)) ? _js_helper.Primitives.lazyAsJsDate(receiver).getUTCFullYear() + 0 : _js_helper.Primitives.lazyAsJsDate(receiver).getFullYear() + 0;
    }
    static getMonth(receiver) {
      return dart.notNull(dart.as(dart.dload(receiver, 'isUtc'), core.bool)) ? _js_helper.Primitives.lazyAsJsDate(receiver).getUTCMonth() + 1 : _js_helper.Primitives.lazyAsJsDate(receiver).getMonth() + 1;
    }
    static getDay(receiver) {
      return dart.notNull(dart.as(dart.dload(receiver, 'isUtc'), core.bool)) ? _js_helper.Primitives.lazyAsJsDate(receiver).getUTCDate() + 0 : _js_helper.Primitives.lazyAsJsDate(receiver).getDate() + 0;
    }
    static getHours(receiver) {
      return dart.notNull(dart.as(dart.dload(receiver, 'isUtc'), core.bool)) ? _js_helper.Primitives.lazyAsJsDate(receiver).getUTCHours() + 0 : _js_helper.Primitives.lazyAsJsDate(receiver).getHours() + 0;
    }
    static getMinutes(receiver) {
      return dart.notNull(dart.as(dart.dload(receiver, 'isUtc'), core.bool)) ? _js_helper.Primitives.lazyAsJsDate(receiver).getUTCMinutes() + 0 : _js_helper.Primitives.lazyAsJsDate(receiver).getMinutes() + 0;
    }
    static getSeconds(receiver) {
      return dart.notNull(dart.as(dart.dload(receiver, 'isUtc'), core.bool)) ? _js_helper.Primitives.lazyAsJsDate(receiver).getUTCSeconds() + 0 : _js_helper.Primitives.lazyAsJsDate(receiver).getSeconds() + 0;
    }
    static getMilliseconds(receiver) {
      return dart.notNull(dart.as(dart.dload(receiver, 'isUtc'), core.bool)) ? _js_helper.Primitives.lazyAsJsDate(receiver).getUTCMilliseconds() + 0 : _js_helper.Primitives.lazyAsJsDate(receiver).getMilliseconds() + 0;
    }
    static getWeekday(receiver) {
      let weekday = dart.notNull(dart.as(dart.dload(receiver, 'isUtc'), core.bool)) ? _js_helper.Primitives.lazyAsJsDate(receiver).getUTCDay() + 0 : _js_helper.Primitives.lazyAsJsDate(receiver).getDay() + 0;
      return (weekday + 6)[dartx['%']](7) + 1;
    }
    static valueFromDateString(str) {
      if (!(typeof str == 'string')) dart.throw(_js_helper.argumentErrorValue(str));
      let value = Date.parse(str);
      if (dart.notNull(value[dartx.isNaN])) dart.throw(_js_helper.argumentErrorValue(str));
      return value;
    }
    static getProperty(object, key) {
      if (object == null || typeof object == 'boolean' || typeof object == 'number' || typeof object == 'string') {
        dart.throw(_js_helper.argumentErrorValue(object));
      }
      return object[key];
    }
    static setProperty(object, key, value) {
      if (object == null || typeof object == 'boolean' || typeof object == 'number' || typeof object == 'string') {
        dart.throw(_js_helper.argumentErrorValue(object));
      }
      object[key] = value;
    }
    static extractStackTrace(error) {
      return _js_helper.getTraceFromException(error.$thrownJsError);
    }
  };
  dart.setSignature(_js_helper.Primitives, {
    statics: () => ({
      initializeStatics: [dart.void, [core.int]],
      objectHashCode: [core.int, [dart.dynamic]],
      _parseIntError: [core.int, [core.String, dart.functionType(core.int, [core.String])]],
      parseInt: [core.int, [core.String, core.int, dart.functionType(core.int, [core.String])]],
      _parseDoubleError: [core.double, [core.String, dart.functionType(core.double, [core.String])]],
      parseDouble: [core.double, [core.String, dart.functionType(core.double, [core.String])]],
      objectTypeName: [core.String, [core.Object]],
      objectToString: [core.String, [core.Object]],
      dateNow: [core.int, []],
      initTicker: [dart.void, []],
      currentUri: [core.String, []],
      _fromCharCodeApply: [core.String, [core.List$(core.int)]],
      stringFromCodePoints: [core.String, [_interceptors.JSArray$(core.int)]],
      stringFromCharCodes: [core.String, [_interceptors.JSArray$(core.int)]],
      stringFromNativeUint8List: [core.String, [_native_typed_data.NativeUint8List, core.int, core.int]],
      stringFromCharCode: [core.String, [core.int]],
      stringConcatUnchecked: [core.String, [core.String, core.String]],
      flattenString: [core.String, [core.String]],
      getTimeZoneName: [core.String, [dart.dynamic]],
      getTimeZoneOffsetInMinutes: [core.int, [dart.dynamic]],
      valueFromDecomposedDate: [dart.dynamic, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]],
      patchUpY2K: [dart.dynamic, [dart.dynamic, dart.dynamic, dart.dynamic]],
      lazyAsJsDate: [dart.dynamic, [dart.dynamic]],
      getYear: [dart.dynamic, [dart.dynamic]],
      getMonth: [dart.dynamic, [dart.dynamic]],
      getDay: [dart.dynamic, [dart.dynamic]],
      getHours: [dart.dynamic, [dart.dynamic]],
      getMinutes: [dart.dynamic, [dart.dynamic]],
      getSeconds: [dart.dynamic, [dart.dynamic]],
      getMilliseconds: [dart.dynamic, [dart.dynamic]],
      getWeekday: [dart.dynamic, [dart.dynamic]],
      valueFromDateString: [dart.dynamic, [dart.dynamic]],
      getProperty: [dart.dynamic, [dart.dynamic, dart.dynamic]],
      setProperty: [dart.void, [dart.dynamic, dart.dynamic, dart.dynamic]],
      extractStackTrace: [core.StackTrace, [core.Error]]
    }),
    names: ['initializeStatics', 'objectHashCode', '_parseIntError', 'parseInt', '_parseDoubleError', 'parseDouble', 'objectTypeName', 'objectToString', 'dateNow', 'initTicker', 'currentUri', '_fromCharCodeApply', 'stringFromCodePoints', 'stringFromCharCodes', 'stringFromNativeUint8List', 'stringFromCharCode', 'stringConcatUnchecked', 'flattenString', 'getTimeZoneName', 'getTimeZoneOffsetInMinutes', 'valueFromDecomposedDate', 'patchUpY2K', 'lazyAsJsDate', 'getYear', 'getMonth', 'getDay', 'getHours', 'getMinutes', 'getSeconds', 'getMilliseconds', 'getWeekday', 'valueFromDateString', 'getProperty', 'setProperty', 'extractStackTrace']
  });
  _js_helper.Primitives.mirrorFunctionCacheName = '$cachedFunction';
  _js_helper.Primitives.mirrorInvokeCacheName = '$cachedInvocation';
  _js_helper.Primitives.DOLLAR_CHAR_VALUE = 36;
  _js_helper.Primitives.timerFrequency = null;
  _js_helper.Primitives.timerTicks = null;
  _js_helper.diagnoseIndexError = function(indexable, index) {
    if (!(typeof index == 'number')) return new core.ArgumentError.value(index, 'index');
    let length = dart.as(dart.dload(indexable, 'length'), core.int);
    if (dart.test(dart.dsend(index, '<', 0)) || dart.test(dart.dsend(index, '>=', length))) {
      return core.RangeError.index(dart.as(index, core.int), indexable, 'index', null, length);
    }
    return new core.RangeError.value(dart.as(index, core.num), 'index');
  };
  dart.lazyFn(_js_helper.diagnoseIndexError, () => [core.Error, [dart.dynamic, dart.dynamic]]);
  _js_helper.diagnoseRangeError = function(start, end, length) {
    if (!(typeof start == 'number')) {
      return new core.ArgumentError.value(start, 'start');
    }
    if (dart.test(dart.dsend(start, '<', 0)) || dart.test(dart.dsend(start, '>', length))) {
      return new core.RangeError.range(dart.as(start, core.num), 0, dart.as(length, core.int), 'start');
    }
    if (end != null) {
      if (!(typeof end == 'number')) {
        return new core.ArgumentError.value(end, 'end');
      }
      if (dart.test(dart.dsend(end, '<', start)) || dart.test(dart.dsend(end, '>', length))) {
        return new core.RangeError.range(dart.as(end, core.num), dart.as(start, core.int), dart.as(length, core.int), 'end');
      }
    }
    return new core.ArgumentError.value(end, "end");
  };
  dart.lazyFn(_js_helper.diagnoseRangeError, () => [core.Error, [dart.dynamic, dart.dynamic, dart.dynamic]]);
  _js_helper.stringLastIndexOfUnchecked = function(receiver, element, start) {
    return receiver.lastIndexOf(element, start);
  };
  dart.fn(_js_helper.stringLastIndexOfUnchecked);
  _js_helper.argumentErrorValue = function(object) {
    return new core.ArgumentError.value(object);
  };
  dart.lazyFn(_js_helper.argumentErrorValue, () => [core.ArgumentError, [dart.dynamic]]);
  _js_helper.checkNull = function(object) {
    if (object == null) dart.throw(_js_helper.argumentErrorValue(object));
    return object;
  };
  dart.fn(_js_helper.checkNull);
  _js_helper.checkNum = function(value) {
    if (!(typeof value == 'number')) dart.throw(_js_helper.argumentErrorValue(value));
    return value;
  };
  dart.fn(_js_helper.checkNum);
  _js_helper.checkInt = function(value) {
    if (!(typeof value == 'number')) dart.throw(_js_helper.argumentErrorValue(value));
    return value;
  };
  dart.fn(_js_helper.checkInt);
  _js_helper.checkBool = function(value) {
    if (!(typeof value == 'boolean')) dart.throw(_js_helper.argumentErrorValue(value));
    return value;
  };
  dart.fn(_js_helper.checkBool);
  _js_helper.checkString = function(value) {
    if (!(typeof value == 'string')) dart.throw(_js_helper.argumentErrorValue(value));
    return value;
  };
  dart.fn(_js_helper.checkString);
  _js_helper.throwRuntimeError = function(message) {
    dart.throw(new _js_helper.RuntimeError(message));
  };
  dart.fn(_js_helper.throwRuntimeError);
  _js_helper.throwAbstractClassInstantiationError = function(className) {
    dart.throw(new core.AbstractClassInstantiationError(dart.as(className, core.String)));
  };
  dart.fn(_js_helper.throwAbstractClassInstantiationError);
  _js_helper.throwConcurrentModificationError = function(collection) {
    dart.throw(new core.ConcurrentModificationError(collection));
  };
  dart.fn(_js_helper.throwConcurrentModificationError);
  const _message = Symbol('_message');
  const _method = Symbol('_method');
  core.Error = class Error extends core.Object {
    Error() {
    }
    static safeToString(object) {
      if (typeof object == 'number' || typeof object == 'boolean' || null == object) {
        return dart.toString(object);
      }
      if (typeof object == 'string') {
        return core.Error._stringToSafeString(object);
      }
      return core.Error._objectToString(object);
    }
    static _stringToSafeString(string) {
      return _js_helper.jsonEncodeNative(string);
    }
    static _objectToString(object) {
      return _js_helper.Primitives.objectToString(object);
    }
    get stackTrace() {
      return _js_helper.Primitives.extractStackTrace(this);
    }
  };
  dart.setSignature(core.Error, {
    constructors: () => ({Error: [core.Error, []]}),
    statics: () => ({
      safeToString: [core.String, [core.Object]],
      _stringToSafeString: [core.String, [core.String]],
      _objectToString: [core.String, [core.Object]]
    }),
    names: ['safeToString', '_stringToSafeString', '_objectToString']
  });
  _js_helper.NullError = class NullError extends core.Error {
    NullError(message, match) {
      this[_message] = message;
      this[_method] = dart.as(match == null ? null : match.method, core.String);
      super.Error();
    }
    toString() {
      if (this[_method] == null) return `NullError: ${this[_message]}`;
      return `NullError: method not found: '${this[_method]}' on null`;
    }
  };
  _js_helper.NullError[dart.implements] = () => [core.NoSuchMethodError];
  dart.setSignature(_js_helper.NullError, {
    constructors: () => ({NullError: [_js_helper.NullError, [core.String, dart.dynamic]]})
  });
  const _receiver = Symbol('_receiver');
  _js_helper.JsNoSuchMethodError = class JsNoSuchMethodError extends core.Error {
    JsNoSuchMethodError(message, match) {
      this[_message] = message;
      this[_method] = dart.as(match == null ? null : match.method, core.String);
      this[_receiver] = dart.as(match == null ? null : match.receiver, core.String);
      super.Error();
    }
    toString() {
      if (this[_method] == null) return `NoSuchMethodError: ${this[_message]}`;
      if (this[_receiver] == null) {
        return `NoSuchMethodError: method not found: '${this[_method]}' (${this[_message]})`;
      }
      return "NoSuchMethodError: " + `method not found: '${this[_method]}' on '${this[_receiver]}' (${this[_message]})`;
    }
  };
  _js_helper.JsNoSuchMethodError[dart.implements] = () => [core.NoSuchMethodError];
  dart.setSignature(_js_helper.JsNoSuchMethodError, {
    constructors: () => ({JsNoSuchMethodError: [_js_helper.JsNoSuchMethodError, [core.String, dart.dynamic]]})
  });
  _js_helper.UnknownJsTypeError = class UnknownJsTypeError extends core.Error {
    UnknownJsTypeError(message) {
      this[_message] = message;
      super.Error();
    }
    toString() {
      return dart.notNull(this[_message][dartx.isEmpty]) ? 'Error' : `Error: ${this[_message]}`;
    }
  };
  dart.setSignature(_js_helper.UnknownJsTypeError, {
    constructors: () => ({UnknownJsTypeError: [_js_helper.UnknownJsTypeError, [core.String]]})
  });
  _js_helper.getTraceFromException = function(exception) {
    return new _js_helper._StackTrace(exception);
  };
  dart.lazyFn(_js_helper.getTraceFromException, () => [core.StackTrace, [dart.dynamic]]);
  const _exception = Symbol('_exception');
  const _trace = Symbol('_trace');
  _js_helper._StackTrace = class _StackTrace extends core.Object {
    _StackTrace(exception) {
      this[_exception] = exception;
      this[_trace] = null;
    }
    toString() {
      if (this[_trace] != null) return this[_trace];
      let trace = null;
      if (this[_exception] !== null && typeof this[_exception] === "object") {
        trace = this[_exception].stack;
      }
      return this[_trace] = trace == null ? '' : trace;
    }
  };
  _js_helper._StackTrace[dart.implements] = () => [core.StackTrace];
  dart.setSignature(_js_helper._StackTrace, {
    constructors: () => ({_StackTrace: [_js_helper._StackTrace, [dart.dynamic]]})
  });
  _js_helper.objectHashCode = function(object) {
    if (object == null || typeof object != 'object') {
      return dart.hashCode(object);
    } else {
      return _js_helper.Primitives.objectHashCode(object);
    }
  };
  dart.fn(_js_helper.objectHashCode, core.int, [dart.dynamic]);
  _js_helper.fillLiteralMap = function(keyValuePairs, result) {
    let index = 0;
    let length = _js_helper.getLength(keyValuePairs);
    while (index < dart.notNull(length)) {
      let key = _js_helper.getIndex(keyValuePairs, index++);
      let value = _js_helper.getIndex(keyValuePairs, index++);
      result[dartx.set](key, value);
    }
    return result;
  };
  dart.lazyFn(_js_helper.fillLiteralMap, () => [dart.dynamic, [dart.dynamic, core.Map]]);
  _js_helper.jsHasOwnProperty = function(jsObject, property) {
    return jsObject.hasOwnProperty(property);
  };
  dart.lazyFn(_js_helper.jsHasOwnProperty, () => [core.bool, [dart.dynamic, core.String]]);
  _js_helper.jsPropertyAccess = function(jsObject, property) {
    return jsObject[property];
  };
  dart.lazyFn(_js_helper.jsPropertyAccess, () => [dart.dynamic, [dart.dynamic, core.String]]);
  _js_helper.getFallThroughError = function() {
    return new _js_helper.FallThroughErrorImplementation();
  };
  dart.fn(_js_helper.getFallThroughError);
  _js_helper.Creates = class Creates extends core.Object {
    Creates(types) {
      this.types = types;
    }
  };
  dart.setSignature(_js_helper.Creates, {
    constructors: () => ({Creates: [_js_helper.Creates, [core.String]]})
  });
  _js_helper.Returns = class Returns extends core.Object {
    Returns(types) {
      this.types = types;
    }
  };
  dart.setSignature(_js_helper.Returns, {
    constructors: () => ({Returns: [_js_helper.Returns, [core.String]]})
  });
  _js_helper.JSName = class JSName extends core.Object {
    JSName(name) {
      this.name = name;
    }
  };
  dart.setSignature(_js_helper.JSName, {
    constructors: () => ({JSName: [_js_helper.JSName, [core.String]]})
  });
  _js_helper.JavaScriptIndexingBehavior = class JavaScriptIndexingBehavior extends _interceptors.JSMutableIndexable {};
  _js_helper.TypeErrorImplementation = class TypeErrorImplementation extends core.Error {
    TypeErrorImplementation(value, type) {
      this.message = `type '${_js_helper.Primitives.objectTypeName(value)}' is not a subtype ` + `of type '${type}'`;
      super.Error();
    }
    fromMessage(message) {
      this.message = message;
      super.Error();
    }
    toString() {
      return this.message;
    }
  };
  dart.defineNamedConstructor(_js_helper.TypeErrorImplementation, 'fromMessage');
  _js_helper.TypeErrorImplementation[dart.implements] = () => [core.TypeError];
  dart.setSignature(_js_helper.TypeErrorImplementation, {
    constructors: () => ({
      TypeErrorImplementation: [_js_helper.TypeErrorImplementation, [core.Object, core.String]],
      fromMessage: [_js_helper.TypeErrorImplementation, [core.String]]
    })
  });
  _js_helper.CastErrorImplementation = class CastErrorImplementation extends core.Error {
    CastErrorImplementation(actualType, expectedType) {
      this.message = `CastError: Casting value of type ${actualType} to` + ` incompatible type ${expectedType}`;
      super.Error();
    }
    toString() {
      return this.message;
    }
  };
  _js_helper.CastErrorImplementation[dart.implements] = () => [core.CastError];
  dart.setSignature(_js_helper.CastErrorImplementation, {
    constructors: () => ({CastErrorImplementation: [_js_helper.CastErrorImplementation, [core.Object, core.Object]]})
  });
  core.FallThroughError = class FallThroughError extends core.Error {
    FallThroughError() {
      super.Error();
    }
  };
  dart.setSignature(core.FallThroughError, {
    constructors: () => ({FallThroughError: [core.FallThroughError, []]})
  });
  _js_helper.FallThroughErrorImplementation = class FallThroughErrorImplementation extends core.FallThroughError {
    FallThroughErrorImplementation() {
      super.FallThroughError();
    }
    toString() {
      return "Switch case fall-through.";
    }
  };
  dart.setSignature(_js_helper.FallThroughErrorImplementation, {
    constructors: () => ({FallThroughErrorImplementation: [_js_helper.FallThroughErrorImplementation, []]})
  });
  _js_helper.RuntimeError = class RuntimeError extends core.Error {
    RuntimeError(message) {
      this.message = message;
      super.Error();
    }
    toString() {
      return `RuntimeError: ${this.message}`;
    }
  };
  dart.setSignature(_js_helper.RuntimeError, {
    constructors: () => ({RuntimeError: [_js_helper.RuntimeError, [dart.dynamic]]})
  });
  _js_helper.random64 = function() {
    let int32a = Math.random() * 0x100000000 >>> 0;
    let int32b = Math.random() * 0x100000000 >>> 0;
    return int32a + int32b * 4294967296;
  };
  dart.fn(_js_helper.random64, core.int, []);
  _js_helper.jsonEncodeNative = function(string) {
    return JSON.stringify(string);
  };
  dart.lazyFn(_js_helper.jsonEncodeNative, () => [core.String, [core.String]]);
  const _jsIterator = Symbol('_jsIterator');
  const _current$0 = Symbol('_current');
  _js_helper.SyncIterator$ = dart.generic(E => {
    class SyncIterator extends core.Object {
      SyncIterator(jsIterator) {
        this[_jsIterator] = jsIterator;
        this[_current$0] = null;
      }
      get current() {
        return this[_current$0];
      }
      moveNext() {
        let ret = this[_jsIterator].next();
        this[_current$0] = ret.value;
        return !ret.done;
      }
    }
    SyncIterator[dart.implements] = () => [core.Iterator$(E)];
    dart.setSignature(SyncIterator, {
      constructors: () => ({SyncIterator: [_js_helper.SyncIterator$(E), [dart.dynamic]]}),
      methods: () => ({moveNext: [core.bool, []]})
    });
    return SyncIterator;
  });
  _js_helper.SyncIterator = _js_helper.SyncIterator$();
  const _generator = Symbol('_generator');
  const _args = Symbol('_args');
  collection.IterableBase$ = dart.generic(E => {
    class IterableBase extends core.Iterable$(E) {
      IterableBase() {
        super.Iterable();
      }
      static iterableToShortString(iterable, leftDelimiter, rightDelimiter) {
        if (leftDelimiter === void 0) leftDelimiter = '(';
        if (rightDelimiter === void 0) rightDelimiter = ')';
        if (dart.notNull(collection._isToStringVisiting(iterable))) {
          if (leftDelimiter == "(" && rightDelimiter == ")") {
            return "(...)";
          }
          return `${leftDelimiter}...${rightDelimiter}`;
        }
        let parts = [];
        collection._toStringVisiting[dartx.add](iterable);
        try {
          collection._iterablePartsToStrings(iterable, parts);
        } finally {
          dart.assert(core.identical(collection._toStringVisiting[dartx.last], iterable));
          collection._toStringVisiting[dartx.removeLast]();
        }
        return (() => {
          let _ = new core.StringBuffer(leftDelimiter);
          _.writeAll(parts, ", ");
          _.write(rightDelimiter);
          return _;
        })().toString();
      }
      static iterableToFullString(iterable, leftDelimiter, rightDelimiter) {
        if (leftDelimiter === void 0) leftDelimiter = '(';
        if (rightDelimiter === void 0) rightDelimiter = ')';
        if (dart.notNull(collection._isToStringVisiting(iterable))) {
          return `${leftDelimiter}...${rightDelimiter}`;
        }
        let buffer = new core.StringBuffer(leftDelimiter);
        collection._toStringVisiting[dartx.add](iterable);
        try {
          buffer.writeAll(iterable, ", ");
        } finally {
          dart.assert(core.identical(collection._toStringVisiting[dartx.last], iterable));
          collection._toStringVisiting[dartx.removeLast]();
        }
        buffer.write(rightDelimiter);
        return buffer.toString();
      }
    }
    dart.setSignature(IterableBase, {
      constructors: () => ({IterableBase: [collection.IterableBase$(E), []]}),
      statics: () => ({
        iterableToShortString: [core.String, [core.Iterable], [core.String, core.String]],
        iterableToFullString: [core.String, [core.Iterable], [core.String, core.String]]
      }),
      names: ['iterableToShortString', 'iterableToFullString']
    });
    return IterableBase;
  });
  collection.IterableBase = collection.IterableBase$();
  _js_helper.SyncIterable$ = dart.generic(E => {
    class SyncIterable extends collection.IterableBase$(E) {
      SyncIterable(generator, args) {
        this[_generator] = generator;
        this[_args] = args;
        super.IterableBase();
      }
      [_jsIterator]() {
        return this[_generator](...this[_args]);
      }
      get iterator() {
        return new (_js_helper.SyncIterator$(E))(this[_jsIterator]());
      }
    }
    dart.setSignature(SyncIterable, {
      constructors: () => ({SyncIterable: [_js_helper.SyncIterable$(E), [dart.dynamic, dart.dynamic]]}),
      methods: () => ({[_jsIterator]: [dart.dynamic, []]})
    });
    dart.defineExtensionMembers(SyncIterable, ['iterator']);
    return SyncIterable;
  });
  _js_helper.SyncIterable = _js_helper.SyncIterable$();
  _js_helper.NoThrows = class NoThrows extends core.Object {
    NoThrows() {
    }
  };
  dart.setSignature(_js_helper.NoThrows, {
    constructors: () => ({NoThrows: [_js_helper.NoThrows, []]})
  });
  _js_helper.NoInline = class NoInline extends core.Object {
    NoInline() {
    }
  };
  dart.setSignature(_js_helper.NoInline, {
    constructors: () => ({NoInline: [_js_helper.NoInline, []]})
  });
  _js_helper.Native = class Native extends core.Object {
    Native(name) {
      this.name = name;
    }
  };
  dart.setSignature(_js_helper.Native, {
    constructors: () => ({Native: [_js_helper.Native, [core.String]]})
  });
  _js_helper.JsPeerInterface = class JsPeerInterface extends core.Object {
    JsPeerInterface(opts) {
      let name = opts && 'name' in opts ? opts.name : null;
      this.name = name;
    }
  };
  dart.setSignature(_js_helper.JsPeerInterface, {
    constructors: () => ({JsPeerInterface: [_js_helper.JsPeerInterface, [], {name: core.String}]})
  });
  _js_helper.SupportJsExtensionMethods = class SupportJsExtensionMethods extends core.Object {
    SupportJsExtensionMethods() {
    }
  };
  dart.setSignature(_js_helper.SupportJsExtensionMethods, {
    constructors: () => ({SupportJsExtensionMethods: [_js_helper.SupportJsExtensionMethods, []]})
  });
  const _length$0 = Symbol('_length');
  const _strings = Symbol('_strings');
  const _nums = Symbol('_nums');
  const _rest = Symbol('_rest');
  const _first = Symbol('_first');
  const _last = Symbol('_last');
  const _modifications = Symbol('_modifications');
  const _containsTableEntry = Symbol('_containsTableEntry');
  const _getBucket = Symbol('_getBucket');
  const _getTableCell = Symbol('_getTableCell');
  const _newHashTable = Symbol('_newHashTable');
  const _addHashTableEntry = Symbol('_addHashTableEntry');
  const _getTableBucket = Symbol('_getTableBucket');
  const _newLinkedCell = Symbol('_newLinkedCell');
  const _setTableEntry = Symbol('_setTableEntry');
  const _removeHashTableEntry = Symbol('_removeHashTableEntry');
  const _unlinkCell = Symbol('_unlinkCell');
  const _modified = Symbol('_modified');
  const _next = Symbol('_next');
  const _deleteTableEntry = Symbol('_deleteTableEntry');
  const _previous = Symbol('_previous');
  _js_helper.JsLinkedHashMap$ = dart.generic((K, V) => {
    class JsLinkedHashMap extends core.Object {
      JsLinkedHashMap() {
        this[_length$0] = 0;
        this[_strings] = null;
        this[_nums] = null;
        this[_rest] = null;
        this[_first] = null;
        this[_last] = null;
        this[_modifications] = 0;
      }
      static es6() {
        return new (_js_helper.JsLinkedHashMap$(K, V))();
      }
      get length() {
        return this[_length$0];
      }
      get isEmpty() {
        return this[_length$0] == 0;
      }
      get isNotEmpty() {
        return !dart.notNull(this.isEmpty);
      }
      get keys() {
        return new (_js_helper.LinkedHashMapKeyIterable$(K))(this);
      }
      get values() {
        return _internal.MappedIterable$(K, V).new(this.keys, dart.fn(each => {
          dart.as(each, K);
          return this.get(each);
        }, V, [K]));
      }
      containsKey(key) {
        if (dart.notNull(_js_helper.JsLinkedHashMap._isStringKey(key))) {
          let strings = this[_strings];
          if (strings == null) return false;
          return this[_containsTableEntry](strings, key);
        } else if (dart.notNull(_js_helper.JsLinkedHashMap._isNumericKey(key))) {
          let nums = this[_nums];
          if (nums == null) return false;
          return this[_containsTableEntry](nums, key);
        } else {
          return this.internalContainsKey(key);
        }
      }
      internalContainsKey(key) {
        let rest = this[_rest];
        if (rest == null) return false;
        let bucket = this[_getBucket](rest, key);
        return dart.notNull(this.internalFindBucketIndex(bucket, key)) >= 0;
      }
      containsValue(value) {
        return this.keys[dartx.any](dart.fn(each => {
          dart.as(each, K);
          return dart.equals(this.get(each), value);
        }, core.bool, [K]));
      }
      addAll(other) {
        dart.as(other, core.Map$(K, V));
        other[dartx.forEach](dart.fn((key, value) => {
          dart.as(key, K);
          dart.as(value, V);
          this.set(key, value);
        }, dart.void, [K, V]));
      }
      get(key) {
        if (dart.notNull(_js_helper.JsLinkedHashMap._isStringKey(key))) {
          let strings = this[_strings];
          if (strings == null) return null;
          let cell = this[_getTableCell](strings, key);
          return cell == null ? null : cell.hashMapCellValue;
        } else if (dart.notNull(_js_helper.JsLinkedHashMap._isNumericKey(key))) {
          let nums = this[_nums];
          if (nums == null) return null;
          let cell = this[_getTableCell](nums, key);
          return cell == null ? null : cell.hashMapCellValue;
        } else {
          return this.internalGet(key);
        }
      }
      internalGet(key) {
        let rest = this[_rest];
        if (rest == null) return null;
        let bucket = this[_getBucket](rest, key);
        let index = this.internalFindBucketIndex(bucket, key);
        if (dart.notNull(index) < 0) return null;
        let cell = bucket[index];
        return cell.hashMapCellValue;
      }
      set(key, value) {
        dart.as(key, K);
        dart.as(value, V);
        if (dart.notNull(_js_helper.JsLinkedHashMap._isStringKey(key))) {
          let strings = this[_strings];
          if (strings == null) this[_strings] = strings = this[_newHashTable]();
          this[_addHashTableEntry](strings, key, value);
        } else if (dart.notNull(_js_helper.JsLinkedHashMap._isNumericKey(key))) {
          let nums = this[_nums];
          if (nums == null) this[_nums] = nums = this[_newHashTable]();
          this[_addHashTableEntry](nums, key, value);
        } else {
          this.internalSet(key, value);
        }
        return value;
      }
      internalSet(key, value) {
        dart.as(key, K);
        dart.as(value, V);
        let rest = this[_rest];
        if (rest == null) this[_rest] = rest = this[_newHashTable]();
        let hash = this.internalComputeHashCode(key);
        let bucket = this[_getTableBucket](rest, hash);
        if (bucket == null) {
          let cell = this[_newLinkedCell](key, value);
          this[_setTableEntry](rest, hash, [cell]);
        } else {
          let index = this.internalFindBucketIndex(bucket, key);
          if (dart.notNull(index) >= 0) {
            let cell = bucket[index];
            cell.hashMapCellValue = value;
          } else {
            let cell = this[_newLinkedCell](key, value);
            bucket.push(cell);
          }
        }
      }
      putIfAbsent(key, ifAbsent) {
        dart.as(key, K);
        dart.as(ifAbsent, dart.functionType(V, []));
        if (dart.notNull(this.containsKey(key))) return this.get(key);
        let value = ifAbsent();
        this.set(key, value);
        return value;
      }
      remove(key) {
        if (dart.notNull(_js_helper.JsLinkedHashMap._isStringKey(key))) {
          return this[_removeHashTableEntry](this[_strings], key);
        } else if (dart.notNull(_js_helper.JsLinkedHashMap._isNumericKey(key))) {
          return this[_removeHashTableEntry](this[_nums], key);
        } else {
          return this.internalRemove(key);
        }
      }
      internalRemove(key) {
        let rest = this[_rest];
        if (rest == null) return null;
        let bucket = this[_getBucket](rest, key);
        let index = this.internalFindBucketIndex(bucket, key);
        if (dart.notNull(index) < 0) return null;
        let cell = bucket.splice(index, 1)[0];
        this[_unlinkCell](cell);
        return cell.hashMapCellValue;
      }
      clear() {
        if (dart.notNull(this[_length$0]) > 0) {
          this[_strings] = this[_nums] = this[_rest] = this[_first] = this[_last] = null;
          this[_length$0] = 0;
          this[_modified]();
        }
      }
      forEach(action) {
        dart.as(action, dart.functionType(dart.void, [K, V]));
        let cell = this[_first];
        let modifications = this[_modifications];
        while (cell != null) {
          action(cell.hashMapCellKey, cell.hashMapCellValue);
          if (modifications != this[_modifications]) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
          cell = cell[_next];
        }
      }
      [_addHashTableEntry](table, key, value) {
        dart.as(key, K);
        dart.as(value, V);
        let cell = this[_getTableCell](table, key);
        if (cell == null) {
          this[_setTableEntry](table, key, this[_newLinkedCell](key, value));
        } else {
          cell.hashMapCellValue = value;
        }
      }
      [_removeHashTableEntry](table, key) {
        if (table == null) return null;
        let cell = this[_getTableCell](table, key);
        if (cell == null) return null;
        this[_unlinkCell](cell);
        this[_deleteTableEntry](table, key);
        return cell.hashMapCellValue;
      }
      [_modified]() {
        this[_modifications] = dart.notNull(this[_modifications]) + 1 & 67108863;
      }
      [_newLinkedCell](key, value) {
        dart.as(key, K);
        dart.as(value, V);
        let cell = new (_js_helper.LinkedHashMapCell$(K, V))(key, value);
        if (this[_first] == null) {
          this[_first] = this[_last] = cell;
        } else {
          let last = this[_last];
          cell[_previous] = last;
          this[_last] = last[_next] = cell;
        }
        this[_length$0] = dart.notNull(this[_length$0]) + 1;
        this[_modified]();
        return cell;
      }
      [_unlinkCell](cell) {
        dart.as(cell, _js_helper.LinkedHashMapCell$(K, V));
        let previous = cell[_previous];
        let next = cell[_next];
        if (previous == null) {
          dart.assert(dart.equals(cell, this[_first]));
          this[_first] = next;
        } else {
          previous[_next] = next;
        }
        if (next == null) {
          dart.assert(dart.equals(cell, this[_last]));
          this[_last] = previous;
        } else {
          next[_previous] = previous;
        }
        this[_length$0] = dart.notNull(this[_length$0]) - 1;
        this[_modified]();
      }
      static _isStringKey(key) {
        return typeof key == 'string';
      }
      static _isNumericKey(key) {
        return typeof key == 'number' && (key & 0x3ffffff) === key;
      }
      internalComputeHashCode(key) {
        return dart.hashCode(key) & 0x3ffffff;
      }
      [_getBucket](table, key) {
        let hash = this.internalComputeHashCode(key);
        return this[_getTableBucket](table, hash);
      }
      internalFindBucketIndex(bucket, key) {
        if (bucket == null) return -1;
        let length = bucket.length;
        for (let i = 0; i < length; i++) {
          let cell = bucket[i];
          if (dart.equals(cell.hashMapCellKey, key)) return i;
        }
        return -1;
      }
      toString() {
        return collection.Maps.mapToString(this);
      }
      [_getTableCell](table, key) {
        return table[key];
      }
      [_getTableBucket](table, key) {
        return table[key];
      }
      [_setTableEntry](table, key, value) {
        dart.assert(value != null);
        table[key] = value;
      }
      [_deleteTableEntry](table, key) {
        delete table[key];
      }
      [_containsTableEntry](table, key) {
        let cell = this[_getTableCell](table, key);
        return cell != null;
      }
      [_newHashTable]() {
        let table = Object.create(null);
        let temporaryKey = '<non-identifier-key>';
        this[_setTableEntry](table, temporaryKey, table);
        this[_deleteTableEntry](table, temporaryKey);
        return table;
      }
    }
    JsLinkedHashMap[dart.implements] = () => [collection.LinkedHashMap$(K, V), _js_helper.InternalMap];
    dart.setSignature(JsLinkedHashMap, {
      constructors: () => ({
        JsLinkedHashMap: [_js_helper.JsLinkedHashMap$(K, V), []],
        es6: [_js_helper.JsLinkedHashMap$(K, V), []]
      }),
      methods: () => ({
        containsKey: [core.bool, [core.Object]],
        internalContainsKey: [core.bool, [core.Object]],
        containsValue: [core.bool, [core.Object]],
        addAll: [dart.void, [core.Map$(K, V)]],
        get: [V, [core.Object]],
        internalGet: [V, [core.Object]],
        set: [dart.void, [K, V]],
        internalSet: [dart.void, [K, V]],
        putIfAbsent: [V, [K, dart.functionType(V, [])]],
        remove: [V, [core.Object]],
        internalRemove: [V, [core.Object]],
        clear: [dart.void, []],
        forEach: [dart.void, [dart.functionType(dart.void, [K, V])]],
        [_addHashTableEntry]: [dart.void, [dart.dynamic, K, V]],
        [_removeHashTableEntry]: [V, [dart.dynamic, core.Object]],
        [_modified]: [dart.void, []],
        [_newLinkedCell]: [_js_helper.LinkedHashMapCell$(K, V), [K, V]],
        [_unlinkCell]: [dart.void, [_js_helper.LinkedHashMapCell$(K, V)]],
        internalComputeHashCode: [core.int, [dart.dynamic]],
        [_getBucket]: [core.List$(_js_helper.LinkedHashMapCell$(K, V)), [dart.dynamic, dart.dynamic]],
        internalFindBucketIndex: [core.int, [dart.dynamic, dart.dynamic]],
        [_getTableCell]: [_js_helper.LinkedHashMapCell$(K, V), [dart.dynamic, dart.dynamic]],
        [_getTableBucket]: [core.List$(_js_helper.LinkedHashMapCell$(K, V)), [dart.dynamic, dart.dynamic]],
        [_setTableEntry]: [dart.void, [dart.dynamic, dart.dynamic, dart.dynamic]],
        [_deleteTableEntry]: [dart.void, [dart.dynamic, dart.dynamic]],
        [_containsTableEntry]: [core.bool, [dart.dynamic, dart.dynamic]],
        [_newHashTable]: [dart.dynamic, []]
      }),
      statics: () => ({
        _isStringKey: [core.bool, [dart.dynamic]],
        _isNumericKey: [core.bool, [dart.dynamic]]
      }),
      names: ['_isStringKey', '_isNumericKey']
    });
    dart.defineExtensionMembers(JsLinkedHashMap, [
      'containsKey',
      'containsValue',
      'addAll',
      'get',
      'set',
      'putIfAbsent',
      'remove',
      'clear',
      'forEach',
      'length',
      'isEmpty',
      'isNotEmpty',
      'keys',
      'values'
    ]);
    return JsLinkedHashMap;
  });
  _js_helper.JsLinkedHashMap = _js_helper.JsLinkedHashMap$();
  _js_helper.Es6LinkedHashMap$ = dart.generic((K, V) => {
    class Es6LinkedHashMap extends _js_helper.JsLinkedHashMap$(K, V) {
      Es6LinkedHashMap() {
        super.JsLinkedHashMap();
      }
      [_getTableCell](table, key) {
        return table.get(key);
      }
      [_getTableBucket](table, key) {
        return table.get(key);
      }
      [_setTableEntry](table, key, value) {
        table.set(key, value);
      }
      [_deleteTableEntry](table, key) {
        table.delete(key);
      }
      [_containsTableEntry](table, key) {
        return table.has(key);
      }
      [_newHashTable]() {
        return new Map();
      }
    }
    dart.setSignature(Es6LinkedHashMap, {
      methods: () => ({
        [_getTableCell]: [_js_helper.LinkedHashMapCell$(K, V), [dart.dynamic, dart.dynamic]],
        [_getTableBucket]: [core.List$(_js_helper.LinkedHashMapCell$(K, V)), [dart.dynamic, dart.dynamic]]
      })
    });
    return Es6LinkedHashMap;
  });
  _js_helper.Es6LinkedHashMap = _js_helper.Es6LinkedHashMap$();
  _js_helper.LinkedHashMapCell$ = dart.generic((K, V) => {
    class LinkedHashMapCell extends core.Object {
      LinkedHashMapCell(hashMapCellKey, hashMapCellValue) {
        this.hashMapCellKey = hashMapCellKey;
        this.hashMapCellValue = hashMapCellValue;
        this[_next] = null;
        this[_previous] = null;
      }
    }
    dart.setSignature(LinkedHashMapCell, {
      constructors: () => ({LinkedHashMapCell: [_js_helper.LinkedHashMapCell$(K, V), [K, V]]})
    });
    return LinkedHashMapCell;
  });
  _js_helper.LinkedHashMapCell = _js_helper.LinkedHashMapCell$();
  const _map = Symbol('_map');
  _js_helper.LinkedHashMapKeyIterable$ = dart.generic(E => {
    class LinkedHashMapKeyIterable extends core.Iterable$(E) {
      LinkedHashMapKeyIterable(map) {
        this[_map] = map;
        super.Iterable();
      }
      get length() {
        return this[_map][_length$0];
      }
      get isEmpty() {
        return this[_map][_length$0] == 0;
      }
      get iterator() {
        return new (_js_helper.LinkedHashMapKeyIterator$(E))(this[_map], this[_map][_modifications]);
      }
      contains(element) {
        return this[_map].containsKey(element);
      }
      forEach(f) {
        dart.as(f, dart.functionType(dart.void, [E]));
        let cell = this[_map][_first];
        let modifications = this[_map][_modifications];
        while (cell != null) {
          f(cell.hashMapCellKey);
          if (modifications != this[_map][_modifications]) {
            dart.throw(new core.ConcurrentModificationError(this[_map]));
          }
          cell = cell[_next];
        }
      }
    }
    LinkedHashMapKeyIterable[dart.implements] = () => [_internal.EfficientLength];
    dart.setSignature(LinkedHashMapKeyIterable, {
      constructors: () => ({LinkedHashMapKeyIterable: [_js_helper.LinkedHashMapKeyIterable$(E), [_js_helper.JsLinkedHashMap$(E, dart.dynamic)]]}),
      methods: () => ({forEach: [dart.void, [dart.functionType(dart.void, [E])]]})
    });
    dart.defineExtensionMembers(LinkedHashMapKeyIterable, [
      'contains',
      'forEach',
      'length',
      'isEmpty',
      'iterator'
    ]);
    return LinkedHashMapKeyIterable;
  });
  _js_helper.LinkedHashMapKeyIterable = _js_helper.LinkedHashMapKeyIterable$();
  const _cell = Symbol('_cell');
  _js_helper.LinkedHashMapKeyIterator$ = dart.generic(E => {
    class LinkedHashMapKeyIterator extends core.Object {
      LinkedHashMapKeyIterator(map, modifications) {
        this[_map] = map;
        this[_modifications] = modifications;
        this[_cell] = null;
        this[_current$0] = null;
        this[_cell] = this[_map][_first];
      }
      get current() {
        return this[_current$0];
      }
      moveNext() {
        if (this[_modifications] != this[_map][_modifications]) {
          dart.throw(new core.ConcurrentModificationError(this[_map]));
        } else if (this[_cell] == null) {
          this[_current$0] = null;
          return false;
        } else {
          this[_current$0] = this[_cell].hashMapCellKey;
          this[_cell] = this[_cell][_next];
          return true;
        }
      }
    }
    LinkedHashMapKeyIterator[dart.implements] = () => [core.Iterator$(E)];
    dart.setSignature(LinkedHashMapKeyIterator, {
      constructors: () => ({LinkedHashMapKeyIterator: [_js_helper.LinkedHashMapKeyIterator$(E), [_js_helper.JsLinkedHashMap$(E, dart.dynamic), core.int]]}),
      methods: () => ({moveNext: [core.bool, []]})
    });
    return LinkedHashMapKeyIterator;
  });
  _js_helper.LinkedHashMapKeyIterator = _js_helper.LinkedHashMapKeyIterator$();
  _js_helper.defineProperty = function(obj, property, value) {
    Object.defineProperty(obj, property, {value: value, enumerable: false, writable: true, configurable: true});
  };
  dart.lazyFn(_js_helper.defineProperty, () => [dart.void, [dart.dynamic, core.String, dart.dynamic]]);
  _js_helper.convertDartClosureToJS = function(F) {
    return (closure, arity) => {
      return closure;
    };
  };
  dart.fn(_js_helper.convertDartClosureToJS, F => [F, [F, core.int]]);
  _js_helper.setNativeSubclassDispatchRecord = function(proto, interceptor) {
  };
  dart.fn(_js_helper.setNativeSubclassDispatchRecord);
  _js_helper.findDispatchTagForInterceptorClass = function(interceptorClassConstructor) {
  };
  dart.fn(_js_helper.findDispatchTagForInterceptorClass);
  _js_helper.makeLeafDispatchRecord = function(interceptor) {
  };
  dart.fn(_js_helper.makeLeafDispatchRecord);
  const _nativeRegExp = Symbol('_nativeRegExp');
  _js_helper.regExpGetNative = function(regexp) {
    return regexp[_nativeRegExp];
  };
  dart.lazyFn(_js_helper.regExpGetNative, () => [dart.dynamic, [_js_helper.JSSyntaxRegExp]]);
  const _nativeGlobalVersion = Symbol('_nativeGlobalVersion');
  _js_helper.regExpGetGlobalNative = function(regexp) {
    let nativeRegexp = regexp[_nativeGlobalVersion];
    nativeRegexp.lastIndex = 0;
    return nativeRegexp;
  };
  dart.lazyFn(_js_helper.regExpGetGlobalNative, () => [dart.dynamic, [_js_helper.JSSyntaxRegExp]]);
  const _nativeAnchoredVersion = Symbol('_nativeAnchoredVersion');
  _js_helper.regExpCaptureCount = function(regexp) {
    let nativeAnchoredRegExp = regexp[_nativeAnchoredVersion];
    let match = nativeAnchoredRegExp.exec('');
    return dart.as(dart.dsend(dart.dload(match, 'length'), '-', 2), core.int);
  };
  dart.lazyFn(_js_helper.regExpCaptureCount, () => [core.int, [_js_helper.JSSyntaxRegExp]]);
  const _nativeGlobalRegExp = Symbol('_nativeGlobalRegExp');
  const _nativeAnchoredRegExp = Symbol('_nativeAnchoredRegExp');
  const _isMultiLine = Symbol('_isMultiLine');
  const _isCaseSensitive = Symbol('_isCaseSensitive');
  const _execGlobal = Symbol('_execGlobal');
  const _execAnchored = Symbol('_execAnchored');
  _js_helper.JSSyntaxRegExp = class JSSyntaxRegExp extends core.Object {
    toString() {
      return `RegExp/${this.pattern}/`;
    }
    JSSyntaxRegExp(source, opts) {
      let multiLine = opts && 'multiLine' in opts ? opts.multiLine : false;
      let caseSensitive = opts && 'caseSensitive' in opts ? opts.caseSensitive : true;
      this.pattern = source;
      this[_nativeRegExp] = _js_helper.JSSyntaxRegExp.makeNative(source, multiLine, caseSensitive, false);
      this[_nativeGlobalRegExp] = null;
      this[_nativeAnchoredRegExp] = null;
    }
    get [_nativeGlobalVersion]() {
      if (this[_nativeGlobalRegExp] != null) return this[_nativeGlobalRegExp];
      return this[_nativeGlobalRegExp] = _js_helper.JSSyntaxRegExp.makeNative(this.pattern, this[_isMultiLine], this[_isCaseSensitive], true);
    }
    get [_nativeAnchoredVersion]() {
      if (this[_nativeAnchoredRegExp] != null) return this[_nativeAnchoredRegExp];
      return this[_nativeAnchoredRegExp] = _js_helper.JSSyntaxRegExp.makeNative(`${this.pattern}|()`, this[_isMultiLine], this[_isCaseSensitive], true);
    }
    get [_isMultiLine]() {
      return this[_nativeRegExp].multiline;
    }
    get [_isCaseSensitive]() {
      return !this[_nativeRegExp].ignoreCase;
    }
    static makeNative(source, multiLine, caseSensitive, global) {
      _js_helper.checkString(source);
      let m = dart.notNull(multiLine) ? 'm' : '';
      let i = dart.notNull(caseSensitive) ? '' : 'i';
      let g = dart.notNull(global) ? 'g' : '';
      let regexp = (function() {
        try {
          return new RegExp(source, m + i + g);
        } catch (e) {
          return e;
        }

      })();
      if (regexp instanceof RegExp) return regexp;
      let errorMessage = String(regexp);
      dart.throw(new core.FormatException(`Illegal RegExp pattern: ${source}, ${errorMessage}`));
    }
    firstMatch(string) {
      let m = this[_nativeRegExp].exec(_js_helper.checkString(string));
      if (m == null) return null;
      return new _js_helper._MatchImplementation(this, m);
    }
    hasMatch(string) {
      return this[_nativeRegExp].test(_js_helper.checkString(string));
    }
    stringMatch(string) {
      let match = this.firstMatch(string);
      if (match != null) return match.group(0);
      return null;
    }
    allMatches(string, start) {
      if (start === void 0) start = 0;
      _js_helper.checkString(string);
      _js_helper.checkInt(start);
      if (dart.notNull(start) < 0 || dart.notNull(start) > dart.notNull(string[dartx.length])) {
        dart.throw(new core.RangeError.range(start, 0, string[dartx.length]));
      }
      return new _js_helper._AllMatchesIterable(this, string, start);
    }
    [_execGlobal](string, start) {
      let regexp = this[_nativeGlobalVersion];
      regexp.lastIndex = start;
      let match = regexp.exec(string);
      if (match == null) return null;
      return new _js_helper._MatchImplementation(this, dart.as(match, core.List$(core.String)));
    }
    [_execAnchored](string, start) {
      let regexp = this[_nativeAnchoredVersion];
      regexp.lastIndex = start;
      let match = regexp.exec(string);
      if (match == null) return null;
      if (match[dartx.get](dart.notNull(match[dartx.length]) - 1) != null) return null;
      match[dartx.length] = dart.notNull(match[dartx.length]) - 1;
      return new _js_helper._MatchImplementation(this, dart.as(match, core.List$(core.String)));
    }
    matchAsPrefix(string, start) {
      if (start === void 0) start = 0;
      if (dart.notNull(start) < 0 || dart.notNull(start) > dart.notNull(string[dartx.length])) {
        dart.throw(new core.RangeError.range(start, 0, string[dartx.length]));
      }
      return this[_execAnchored](string, start);
    }
    get isMultiLine() {
      return this[_isMultiLine];
    }
    get isCaseSensitive() {
      return this[_isCaseSensitive];
    }
  };
  _js_helper.JSSyntaxRegExp[dart.implements] = () => [core.RegExp];
  dart.setSignature(_js_helper.JSSyntaxRegExp, {
    constructors: () => ({JSSyntaxRegExp: [_js_helper.JSSyntaxRegExp, [core.String], {multiLine: core.bool, caseSensitive: core.bool}]}),
    methods: () => ({
      firstMatch: [core.Match, [core.String]],
      hasMatch: [core.bool, [core.String]],
      stringMatch: [core.String, [core.String]],
      allMatches: [core.Iterable$(core.Match), [core.String], [core.int]],
      [_execGlobal]: [core.Match, [core.String, core.int]],
      [_execAnchored]: [core.Match, [core.String, core.int]],
      matchAsPrefix: [core.Match, [core.String], [core.int]]
    }),
    statics: () => ({makeNative: [dart.dynamic, [core.String, core.bool, core.bool, core.bool]]}),
    names: ['makeNative']
  });
  dart.defineExtensionMembers(_js_helper.JSSyntaxRegExp, ['allMatches', 'matchAsPrefix']);
  const _match = Symbol('_match');
  _js_helper._MatchImplementation = class _MatchImplementation extends core.Object {
    _MatchImplementation(pattern, match) {
      this.pattern = pattern;
      this[_match] = match;
      dart.assert(typeof this[_match].input == 'string');
      dart.assert(typeof this[_match].index == 'number');
    }
    get input() {
      return this[_match].input;
    }
    get start() {
      return this[_match].index;
    }
    get end() {
      return dart.notNull(this.start) + dart.notNull(this[_match][dartx.get](0)[dartx.length]);
    }
    group(index) {
      return this[_match][dartx.get](index);
    }
    get(index) {
      return this.group(index);
    }
    get groupCount() {
      return dart.notNull(this[_match][dartx.length]) - 1;
    }
    groups(groups) {
      let out = dart.list([], core.String);
      for (let i of groups) {
        out[dartx.add](this.group(i));
      }
      return out;
    }
  };
  _js_helper._MatchImplementation[dart.implements] = () => [core.Match];
  dart.setSignature(_js_helper._MatchImplementation, {
    constructors: () => ({_MatchImplementation: [_js_helper._MatchImplementation, [core.Pattern, core.List$(core.String)]]}),
    methods: () => ({
      group: [core.String, [core.int]],
      get: [core.String, [core.int]],
      groups: [core.List$(core.String), [core.List$(core.int)]]
    })
  });
  const _re = Symbol('_re');
  const _string$ = Symbol('_string');
  const _start$ = Symbol('_start');
  core.Match = class Match extends core.Object {};
  _js_helper._AllMatchesIterable = class _AllMatchesIterable extends collection.IterableBase$(core.Match) {
    _AllMatchesIterable(re, string, start) {
      this[_re] = re;
      this[_string$] = string;
      this[_start$] = start;
      super.IterableBase();
    }
    get iterator() {
      return new _js_helper._AllMatchesIterator(this[_re], this[_string$], this[_start$]);
    }
  };
  dart.setSignature(_js_helper._AllMatchesIterable, {
    constructors: () => ({_AllMatchesIterable: [_js_helper._AllMatchesIterable, [_js_helper.JSSyntaxRegExp, core.String, core.int]]})
  });
  dart.defineExtensionMembers(_js_helper._AllMatchesIterable, ['iterator']);
  const _regExp = Symbol('_regExp');
  const _nextIndex = Symbol('_nextIndex');
  _js_helper._AllMatchesIterator = class _AllMatchesIterator extends core.Object {
    _AllMatchesIterator(regExp, string, nextIndex) {
      this[_regExp] = regExp;
      this[_string$] = string;
      this[_nextIndex] = nextIndex;
      this[_current$0] = null;
    }
    get current() {
      return this[_current$0];
    }
    moveNext() {
      if (this[_string$] == null) return false;
      if (dart.notNull(this[_nextIndex]) <= dart.notNull(this[_string$][dartx.length])) {
        let match = this[_regExp][_execGlobal](this[_string$], this[_nextIndex]);
        if (match != null) {
          this[_current$0] = match;
          let nextIndex = match.end;
          if (match.start == nextIndex) {
            nextIndex = dart.notNull(nextIndex) + 1;
          }
          this[_nextIndex] = nextIndex;
          return true;
        }
      }
      this[_current$0] = null;
      this[_string$] = null;
      return false;
    }
  };
  _js_helper._AllMatchesIterator[dart.implements] = () => [core.Iterator$(core.Match)];
  dart.setSignature(_js_helper._AllMatchesIterator, {
    constructors: () => ({_AllMatchesIterator: [_js_helper._AllMatchesIterator, [_js_helper.JSSyntaxRegExp, core.String, core.int]]}),
    methods: () => ({moveNext: [core.bool, []]})
  });
  _js_helper.firstMatchAfter = function(regExp, string, start) {
    return regExp[_execGlobal](string, start);
  };
  dart.lazyFn(_js_helper.firstMatchAfter, () => [core.Match, [_js_helper.JSSyntaxRegExp, core.String, core.int]]);
  _js_helper.stringIndexOfStringUnchecked = function(receiver, other, startIndex) {
    return receiver.indexOf(other, startIndex);
  };
  dart.fn(_js_helper.stringIndexOfStringUnchecked, core.int, [dart.dynamic, dart.dynamic, dart.dynamic]);
  _js_helper.substring1Unchecked = function(receiver, startIndex) {
    return receiver.substring(startIndex);
  };
  dart.lazyFn(_js_helper.substring1Unchecked, () => [core.String, [dart.dynamic, dart.dynamic]]);
  _js_helper.substring2Unchecked = function(receiver, startIndex, endIndex) {
    return receiver.substring(startIndex, endIndex);
  };
  dart.lazyFn(_js_helper.substring2Unchecked, () => [core.String, [dart.dynamic, dart.dynamic, dart.dynamic]]);
  _js_helper.stringContainsStringUnchecked = function(receiver, other, startIndex) {
    return dart.notNull(_js_helper.stringIndexOfStringUnchecked(receiver, other, startIndex)) >= 0;
  };
  dart.lazyFn(_js_helper.stringContainsStringUnchecked, () => [core.bool, [dart.dynamic, dart.dynamic, dart.dynamic]]);
  _js_helper.StringMatch = class StringMatch extends core.Object {
    StringMatch(start, input, pattern) {
      this.start = start;
      this.input = input;
      this.pattern = pattern;
    }
    get end() {
      return dart.notNull(this.start) + dart.notNull(this.pattern[dartx.length]);
    }
    get(g) {
      return this.group(g);
    }
    get groupCount() {
      return 0;
    }
    group(group_) {
      if (group_ != 0) {
        dart.throw(new core.RangeError.value(group_));
      }
      return this.pattern;
    }
    groups(groups_) {
      let result = core.List$(core.String).new();
      for (let g of groups_) {
        result[dartx.add](this.group(g));
      }
      return result;
    }
  };
  _js_helper.StringMatch[dart.implements] = () => [core.Match];
  dart.setSignature(_js_helper.StringMatch, {
    constructors: () => ({StringMatch: [_js_helper.StringMatch, [core.int, core.String, core.String]]}),
    methods: () => ({
      get: [core.String, [core.int]],
      group: [core.String, [core.int]],
      groups: [core.List$(core.String), [core.List$(core.int)]]
    })
  });
  _js_helper.allMatchesInStringUnchecked = function(pattern, string, startIndex) {
    return new _js_helper._StringAllMatchesIterable(string, pattern, startIndex);
  };
  dart.lazyFn(_js_helper.allMatchesInStringUnchecked, () => [core.Iterable$(core.Match), [core.String, core.String, core.int]]);
  const _input = Symbol('_input');
  const _pattern = Symbol('_pattern');
  const _index$0 = Symbol('_index');
  _js_helper._StringAllMatchesIterable = class _StringAllMatchesIterable extends core.Iterable$(core.Match) {
    _StringAllMatchesIterable(input, pattern, index) {
      this[_input] = input;
      this[_pattern] = pattern;
      this[_index$0] = index;
      super.Iterable();
    }
    get iterator() {
      return new _js_helper._StringAllMatchesIterator(this[_input], this[_pattern], this[_index$0]);
    }
    get first() {
      let index = _js_helper.stringIndexOfStringUnchecked(this[_input], this[_pattern], this[_index$0]);
      if (dart.notNull(index) >= 0) {
        return new _js_helper.StringMatch(index, this[_input], this[_pattern]);
      }
      dart.throw(_internal.IterableElementError.noElement());
    }
  };
  dart.setSignature(_js_helper._StringAllMatchesIterable, {
    constructors: () => ({_StringAllMatchesIterable: [_js_helper._StringAllMatchesIterable, [core.String, core.String, core.int]]})
  });
  dart.defineExtensionMembers(_js_helper._StringAllMatchesIterable, ['iterator', 'first']);
  _js_helper._StringAllMatchesIterator = class _StringAllMatchesIterator extends core.Object {
    _StringAllMatchesIterator(input, pattern, index) {
      this[_input] = input;
      this[_pattern] = pattern;
      this[_index$0] = index;
      this[_current$0] = null;
    }
    moveNext() {
      if (dart.notNull(this[_index$0]) + dart.notNull(this[_pattern][dartx.length]) > dart.notNull(this[_input][dartx.length])) {
        this[_current$0] = null;
        return false;
      }
      let index = _js_helper.stringIndexOfStringUnchecked(this[_input], this[_pattern], this[_index$0]);
      if (dart.notNull(index) < 0) {
        this[_index$0] = dart.notNull(this[_input][dartx.length]) + 1;
        this[_current$0] = null;
        return false;
      }
      let end = dart.notNull(index) + dart.notNull(this[_pattern][dartx.length]);
      this[_current$0] = new _js_helper.StringMatch(index, this[_input], this[_pattern]);
      if (end == this[_index$0]) end++;
      this[_index$0] = end;
      return true;
    }
    get current() {
      return this[_current$0];
    }
  };
  _js_helper._StringAllMatchesIterator[dart.implements] = () => [core.Iterator$(core.Match)];
  dart.setSignature(_js_helper._StringAllMatchesIterator, {
    constructors: () => ({_StringAllMatchesIterator: [_js_helper._StringAllMatchesIterator, [core.String, core.String, core.int]]}),
    methods: () => ({moveNext: [core.bool, []]})
  });
  _js_helper.stringContainsUnchecked = function(receiver, other, startIndex) {
    if (typeof other == 'string') {
      return _js_helper.stringContainsStringUnchecked(receiver, other, startIndex);
    } else if (dart.is(other, _js_helper.JSSyntaxRegExp)) {
      return other.hasMatch(receiver[dartx.substring](startIndex));
    } else {
      let substr = receiver[dartx.substring](startIndex);
      return dart.as(dart.dload(dart.dsend(other, 'allMatches', substr), 'isNotEmpty'), core.bool);
    }
  };
  dart.lazyFn(_js_helper.stringContainsUnchecked, () => [core.bool, [core.String, dart.dynamic, core.int]]);
  _js_helper.stringReplaceJS = function(receiver, replacer, replacement) {
    replacement = replacement.replace(/\$/g, "$$$$");
    return receiver.replace(replacer, replacement);
  };
  dart.lazyFn(_js_helper.stringReplaceJS, () => [core.String, [dart.dynamic, dart.dynamic, dart.dynamic]]);
  _js_helper.stringReplaceFirstRE = function(receiver, regexp, replacement, startIndex) {
    let match = regexp[_execGlobal](receiver, startIndex);
    if (match == null) return receiver;
    let start = match.start;
    let end = match.end;
    return _js_helper.stringReplaceRangeUnchecked(receiver, start, end, replacement);
  };
  dart.lazyFn(_js_helper.stringReplaceFirstRE, () => [core.String, [core.String, _js_helper.JSSyntaxRegExp, core.String, core.int]]);
  _js_helper.quoteStringForRegExp = function(string) {
    return string.replace(/[[\]{}()*+?.\\^$|]/g, "\\$&");
  };
  dart.lazyFn(_js_helper.quoteStringForRegExp, () => [core.String, [dart.dynamic]]);
  _js_helper.stringReplaceAllUnchecked = function(receiver, pattern, replacement) {
    _js_helper.checkString(replacement);
    if (typeof pattern == 'string') {
      if (pattern == "") {
        if (receiver == "") {
          return replacement;
        } else {
          let result = new core.StringBuffer();
          let length = receiver[dartx.length];
          result.write(replacement);
          for (let i = 0; i < dart.notNull(length); i++) {
            result.write(receiver[dartx.get](i));
            result.write(replacement);
          }
          return result.toString();
        }
      } else {
        let quoted = _js_helper.quoteStringForRegExp(pattern);
        let replacer = new RegExp(quoted, 'g');
        return _js_helper.stringReplaceJS(receiver, replacer, replacement);
      }
    } else if (dart.is(pattern, _js_helper.JSSyntaxRegExp)) {
      let re = _js_helper.regExpGetGlobalNative(pattern);
      return _js_helper.stringReplaceJS(receiver, re, replacement);
    } else {
      _js_helper.checkNull(pattern);
      dart.throw("String.replaceAll(Pattern) UNIMPLEMENTED");
    }
  };
  dart.lazyFn(_js_helper.stringReplaceAllUnchecked, () => [core.String, [core.String, core.Pattern, core.String]]);
  _js_helper._matchString = function(match) {
    return match.get(0);
  };
  dart.lazyFn(_js_helper._matchString, () => [core.String, [core.Match]]);
  _js_helper._stringIdentity = function(string) {
    return string;
  };
  dart.lazyFn(_js_helper._stringIdentity, () => [core.String, [core.String]]);
  _js_helper.stringReplaceAllFuncUnchecked = function(receiver, pattern, onMatch, onNonMatch) {
    if (onMatch == null) onMatch = _js_helper._matchString;
    if (onNonMatch == null) onNonMatch = _js_helper._stringIdentity;
    if (typeof pattern == 'string') {
      return _js_helper.stringReplaceAllStringFuncUnchecked(receiver, pattern, onMatch, onNonMatch);
    }
    if (!dart.is(pattern, core.Pattern)) {
      dart.throw(new core.ArgumentError.value(pattern, 'pattern', 'is not a Pattern'));
    }
    let buffer = new core.StringBuffer();
    let startIndex = 0;
    for (let match of pattern[dartx.allMatches](receiver)) {
      buffer.write(onNonMatch(receiver[dartx.substring](startIndex, match.start)));
      buffer.write(onMatch(match));
      startIndex = match.end;
    }
    buffer.write(onNonMatch(receiver[dartx.substring](startIndex)));
    return buffer.toString();
  };
  dart.lazyFn(_js_helper.stringReplaceAllFuncUnchecked, () => [core.String, [core.String, core.Pattern, dart.functionType(core.String, [core.Match]), dart.functionType(core.String, [core.String])]]);
  _js_helper.stringReplaceAllEmptyFuncUnchecked = function(receiver, onMatch, onNonMatch) {
    let buffer = new core.StringBuffer();
    let length = receiver[dartx.length];
    let i = 0;
    buffer.write(onNonMatch(""));
    while (i < dart.notNull(length)) {
      buffer.write(onMatch(new _js_helper.StringMatch(i, receiver, "")));
      let code = receiver[dartx.codeUnitAt](i);
      if ((dart.notNull(code) & ~1023) >>> 0 == 55296 && dart.notNull(length) > i + 1) {
        code = receiver[dartx.codeUnitAt](i + 1);
        if ((dart.notNull(code) & ~1023) >>> 0 == 56320) {
          buffer.write(onNonMatch(receiver[dartx.substring](i, i + 2)));
          i = i + 2;
          continue;
        }
      }
      buffer.write(onNonMatch(receiver[dartx.get](i)));
      i++;
    }
    buffer.write(onMatch(new _js_helper.StringMatch(i, receiver, "")));
    buffer.write(onNonMatch(""));
    return buffer.toString();
  };
  dart.lazyFn(_js_helper.stringReplaceAllEmptyFuncUnchecked, () => [core.String, [core.String, dart.functionType(core.String, [core.Match]), dart.functionType(core.String, [core.String])]]);
  _js_helper.stringReplaceAllStringFuncUnchecked = function(receiver, pattern, onMatch, onNonMatch) {
    let patternLength = pattern[dartx.length];
    if (patternLength == 0) {
      return _js_helper.stringReplaceAllEmptyFuncUnchecked(receiver, onMatch, onNonMatch);
    }
    let length = receiver[dartx.length];
    let buffer = new core.StringBuffer();
    let startIndex = 0;
    while (startIndex < dart.notNull(length)) {
      let position = _js_helper.stringIndexOfStringUnchecked(receiver, pattern, startIndex);
      if (position == -1) {
        break;
      }
      buffer.write(onNonMatch(receiver[dartx.substring](startIndex, position)));
      buffer.write(onMatch(new _js_helper.StringMatch(position, receiver, pattern)));
      startIndex = dart.notNull(position) + dart.notNull(patternLength);
    }
    buffer.write(onNonMatch(receiver[dartx.substring](startIndex)));
    return buffer.toString();
  };
  dart.lazyFn(_js_helper.stringReplaceAllStringFuncUnchecked, () => [core.String, [core.String, core.String, dart.functionType(core.String, [core.Match]), dart.functionType(core.String, [core.String])]]);
  _js_helper.stringReplaceFirstUnchecked = function(receiver, pattern, replacement, startIndex) {
    if (typeof pattern == 'string') {
      let index = _js_helper.stringIndexOfStringUnchecked(receiver, pattern, startIndex);
      if (dart.notNull(index) < 0) return receiver;
      let end = dart.notNull(index) + dart.notNull(pattern[dartx.length]);
      return _js_helper.stringReplaceRangeUnchecked(receiver, index, end, replacement);
    }
    if (dart.is(pattern, _js_helper.JSSyntaxRegExp)) {
      return startIndex == 0 ? _js_helper.stringReplaceJS(receiver, _js_helper.regExpGetNative(pattern), replacement) : _js_helper.stringReplaceFirstRE(receiver, pattern, replacement, startIndex);
    }
    _js_helper.checkNull(pattern);
    let matches = pattern[dartx.allMatches](receiver, startIndex)[dartx.iterator];
    if (!dart.notNull(matches.moveNext())) return receiver;
    let match = matches.current;
    return receiver[dartx.replaceRange](match.start, match.end, replacement);
  };
  dart.lazyFn(_js_helper.stringReplaceFirstUnchecked, () => [core.String, [core.String, core.Pattern, core.String, core.int]]);
  _js_helper.stringReplaceFirstMappedUnchecked = function(receiver, pattern, replace, startIndex) {
    let matches = pattern[dartx.allMatches](receiver, startIndex)[dartx.iterator];
    if (!dart.notNull(matches.moveNext())) return receiver;
    let match = matches.current;
    let replacement = `${replace(match)}`;
    return receiver[dartx.replaceRange](match.start, match.end, replacement);
  };
  dart.lazyFn(_js_helper.stringReplaceFirstMappedUnchecked, () => [core.String, [core.String, core.Pattern, dart.functionType(core.String, [core.Match]), core.int]]);
  _js_helper.stringJoinUnchecked = function(array, separator) {
    return array.join(separator);
  };
  dart.lazyFn(_js_helper.stringJoinUnchecked, () => [core.String, [dart.dynamic, dart.dynamic]]);
  _js_helper.stringReplaceRangeUnchecked = function(receiver, start, end, replacement) {
    let prefix = receiver.substring(0, start);
    let suffix = receiver.substring(end);
    return `${prefix}${replacement}${suffix}`;
  };
  dart.lazyFn(_js_helper.stringReplaceRangeUnchecked, () => [core.String, [core.String, core.int, core.int, core.String]]);
  _js_helper.getRuntimeType = function(object) {
    return dart.getReifiedType(object);
  };
  dart.lazyFn(_js_helper.getRuntimeType, () => [core.Type, [dart.dynamic]]);
  _js_helper.getIndex = function(array, index) {
    dart.assert(_js_helper.isJsArray(array));
    return array[index];
  };
  dart.fn(_js_helper.getIndex, dart.dynamic, [dart.dynamic, core.int]);
  _js_helper.getLength = function(array) {
    dart.assert(_js_helper.isJsArray(array));
    return array.length;
  };
  dart.fn(_js_helper.getLength, core.int, [dart.dynamic]);
  _js_helper.isJsArray = function(value) {
    return dart.is(value, _interceptors.JSArray);
  };
  dart.lazyFn(_js_helper.isJsArray, () => [core.bool, [dart.dynamic]]);
  _js_mirrors.getName = function(symbol) {
    return _internal.Symbol.getName(dart.as(symbol, _internal.Symbol));
  };
  dart.lazyFn(_js_mirrors.getName, () => [core.String, [core.Symbol]]);
  _js_mirrors.getSymbol = function(name, library) {
    return dart.throw(new core.UnimplementedError("MirrorSystem.getSymbol unimplemented"));
  };
  dart.lazyFn(_js_mirrors.getSymbol, () => [core.Symbol, [dart.dynamic, dart.dynamic]]);
  dart.defineLazy(_js_mirrors, {
    get currentJsMirrorSystem() {
      return dart.throw(new core.UnimplementedError("MirrorSystem.currentJsMirrorSystem unimplemented"));
    }
  });
  _js_mirrors.reflect = function(reflectee) {
    return new _js_mirrors.JsInstanceMirror._(reflectee);
  };
  dart.lazyFn(_js_mirrors.reflect, () => [mirrors.InstanceMirror, [dart.dynamic]]);
  _js_mirrors.reflectType = function(key) {
    return new _js_mirrors.JsClassMirror._(key);
  };
  dart.lazyFn(_js_mirrors.reflectType, () => [mirrors.TypeMirror, [core.Type]]);
  dart.defineLazy(_js_mirrors, {
    get _dart() {
      return dart;
    }
  });
  _js_mirrors._dload = function(obj, name) {
    return _js_mirrors._dart.dload(obj, name);
  };
  dart.lazyFn(_js_mirrors._dload, () => [dart.dynamic, [dart.dynamic, core.String]]);
  _js_mirrors._dput = function(obj, name, val) {
    _js_mirrors._dart.dput(obj, name, val);
  };
  dart.lazyFn(_js_mirrors._dput, () => [dart.void, [dart.dynamic, core.String, dart.dynamic]]);
  _js_mirrors._dsend = function(obj, name, args) {
    return _js_mirrors._dart.dsend(obj, name, ...args);
  };
  dart.lazyFn(_js_mirrors._dsend, () => [dart.dynamic, [dart.dynamic, core.String, core.List]]);
  const _toJsMap = Symbol('_toJsMap');
  _js_mirrors.JsInstanceMirror = class JsInstanceMirror extends core.Object {
    _(reflectee) {
      this.reflectee = reflectee;
    }
    get type() {
      return dart.throw(new core.UnimplementedError("ClassMirror.type unimplemented"));
    }
    get hasReflectee() {
      return dart.throw(new core.UnimplementedError("ClassMirror.hasReflectee unimplemented"));
    }
    delegate(invocation) {
      return dart.throw(new core.UnimplementedError("ClassMirror.delegate unimplemented"));
    }
    getField(symbol) {
      let name = _js_mirrors.getName(symbol);
      let field = _js_mirrors._dload(this.reflectee, name);
      return new _js_mirrors.JsInstanceMirror._(field);
    }
    setField(symbol, value) {
      let name = _js_mirrors.getName(symbol);
      _js_mirrors._dput(this.reflectee, name, value);
      return new _js_mirrors.JsInstanceMirror._(value);
    }
    invoke(symbol, args, namedArgs) {
      if (namedArgs === void 0) namedArgs = null;
      let name = _js_mirrors.getName(symbol);
      if (namedArgs != null) {
        args = core.List.from(args);
        args[dartx.add](this[_toJsMap](namedArgs));
      }
      let result = _js_mirrors._dsend(this.reflectee, name, args);
      return new _js_mirrors.JsInstanceMirror._(result);
    }
    [_toJsMap](map) {
      let obj = {};
      map[dartx.forEach](dart.fn((key, value) => {
        obj[_js_mirrors.getName(key)] = value;
      }, dart.void, [core.Symbol, dart.dynamic]));
      return obj;
    }
  };
  dart.defineNamedConstructor(_js_mirrors.JsInstanceMirror, '_');
  _js_mirrors.JsInstanceMirror[dart.implements] = () => [mirrors.InstanceMirror];
  dart.setSignature(_js_mirrors.JsInstanceMirror, {
    constructors: () => ({_: [_js_mirrors.JsInstanceMirror, [core.Object]]}),
    methods: () => ({
      delegate: [dart.dynamic, [core.Invocation]],
      getField: [mirrors.InstanceMirror, [core.Symbol]],
      setField: [mirrors.InstanceMirror, [core.Symbol, core.Object]],
      invoke: [mirrors.InstanceMirror, [core.Symbol, core.List], [core.Map$(core.Symbol, dart.dynamic)]],
      [_toJsMap]: [dart.dynamic, [core.Map$(core.Symbol, dart.dynamic)]]
    })
  });
  const _metadata$ = Symbol('_metadata');
  const _declarations = Symbol('_declarations');
  const _cls = Symbol('_cls');
  _js_mirrors.JsClassMirror = class JsClassMirror extends core.Object {
    get metadata() {
      return this[_metadata$];
    }
    get declarations() {
      return this[_declarations];
    }
    _(cls) {
      this[_cls] = cls;
      this.simpleName = core.Symbol.new(cls.name);
      this[_metadata$] = null;
      this[_declarations] = null;
      let fn = this[_cls][dart.metadata];
      this[_metadata$] = fn == null ? dart.list([], mirrors.InstanceMirror) : core.List$(mirrors.InstanceMirror).from(dart.as(dart.dsend(dart.dcall(fn), 'map', dart.fn(i => new _js_mirrors.JsInstanceMirror._(i), _js_mirrors.JsInstanceMirror, [dart.dynamic])), core.Iterable));
      this[_declarations] = core.Map$(core.Symbol, mirrors.MethodMirror).new();
      this[_declarations][dartx.set](this.simpleName, new _js_mirrors.JsMethodMirror._(this, this[_cls]));
    }
    newInstance(constructorName, args, namedArgs) {
      if (namedArgs === void 0) namedArgs = null;
      dart.assert(_js_mirrors.getName(constructorName) == "");
      dart.assert(namedArgs == null || dart.notNull(namedArgs[dartx.isEmpty]));
      let instance = new this[_cls](...args);
      return new _js_mirrors.JsInstanceMirror._(instance);
    }
    get superinterfaces() {
      let interfaceThunk = this[_cls][dart.implements];
      if (interfaceThunk == null) {
        return dart.list([], mirrors.ClassMirror);
      } else {
        let interfaces = dart.as(dart.dcall(interfaceThunk), core.List$(core.Type));
        return interfaces[dartx.map](_js_mirrors.JsClassMirror)(dart.fn(t => new _js_mirrors.JsClassMirror._(t), _js_mirrors.JsClassMirror, [core.Type]))[dartx.toList]();
      }
    }
    getField(fieldName) {
      return dart.throw(new core.UnimplementedError("ClassMirror.getField unimplemented"));
    }
    invoke(memberName, positionalArguments, namedArguments) {
      if (namedArguments === void 0) namedArguments = null;
      return dart.throw(new core.UnimplementedError("ClassMirror.invoke unimplemented"));
    }
    isAssignableTo(other) {
      return dart.throw(new core.UnimplementedError("ClassMirror.isAssignable unimplemented"));
    }
    isSubclassOf(other) {
      return dart.throw(new core.UnimplementedError("ClassMirror.isSubclassOf unimplemented"));
    }
    isSubtypeOf(other) {
      return dart.throw(new core.UnimplementedError("ClassMirror.isSubtypeOf unimplemented"));
    }
    setField(fieldName, value) {
      return dart.throw(new core.UnimplementedError("ClassMirror.setField unimplemented"));
    }
    get hasReflectedType() {
      return dart.throw(new core.UnimplementedError("ClassMirror.hasReflectedType unimplemented"));
    }
    get instanceMembers() {
      return dart.throw(new core.UnimplementedError("ClassMirror.instanceMembers unimplemented"));
    }
    get isAbstract() {
      return dart.throw(new core.UnimplementedError("ClassMirror.isAbstract unimplemented"));
    }
    get isEnum() {
      return dart.throw(new core.UnimplementedError("ClassMirror.isEnum unimplemented"));
    }
    get isOriginalDeclaration() {
      return dart.throw(new core.UnimplementedError("ClassMirror.isOriginalDeclaration unimplemented"));
    }
    get isPrivate() {
      return dart.throw(new core.UnimplementedError("ClassMirror.isPrivate unimplemented"));
    }
    get isTopLevel() {
      return dart.throw(new core.UnimplementedError("ClassMirror.isTopLevel unimplemented"));
    }
    get location() {
      return dart.throw(new core.UnimplementedError("ClassMirror.location unimplemented"));
    }
    get mixin() {
      return dart.throw(new core.UnimplementedError("ClassMirror.mixin unimplemented"));
    }
    get originalDeclaration() {
      return this;
    }
    get owner() {
      return dart.throw(new core.UnimplementedError("ClassMirror.owner unimplemented"));
    }
    get qualifiedName() {
      return dart.throw(new core.UnimplementedError("ClassMirror.qualifiedName unimplemented"));
    }
    get reflectedType() {
      return this[_cls];
    }
    get staticMembers() {
      return dart.throw(new core.UnimplementedError("ClassMirror.staticMembers unimplemented"));
    }
    get superclass() {
      if (dart.equals(this[_cls], dart.wrapType(core.Object))) {
        return null;
      } else {
        return new _js_mirrors.JsClassMirror._(this[_cls].__proto__);
      }
    }
    get typeArguments() {
      return dart.throw(new core.UnimplementedError("ClassMirror.typeArguments unimplemented"));
    }
    get typeVariables() {
      return dart.throw(new core.UnimplementedError("ClassMirror.typeVariables unimplemented"));
    }
  };
  dart.defineNamedConstructor(_js_mirrors.JsClassMirror, '_');
  _js_mirrors.JsClassMirror[dart.implements] = () => [mirrors.ClassMirror];
  dart.setSignature(_js_mirrors.JsClassMirror, {
    constructors: () => ({_: [_js_mirrors.JsClassMirror, [core.Type]]}),
    methods: () => ({
      newInstance: [mirrors.InstanceMirror, [core.Symbol, core.List], [core.Map$(core.Symbol, dart.dynamic)]],
      getField: [mirrors.InstanceMirror, [core.Symbol]],
      invoke: [mirrors.InstanceMirror, [core.Symbol, core.List], [core.Map$(core.Symbol, dart.dynamic)]],
      isAssignableTo: [core.bool, [mirrors.TypeMirror]],
      isSubclassOf: [core.bool, [mirrors.ClassMirror]],
      isSubtypeOf: [core.bool, [mirrors.TypeMirror]],
      setField: [mirrors.InstanceMirror, [core.Symbol, core.Object]]
    })
  });
  _js_mirrors.JsTypeMirror = class JsTypeMirror extends core.Object {
    _(reflectedType) {
      this.reflectedType = reflectedType;
      this.hasReflectedType = true;
    }
    isAssignableTo(other) {
      return dart.throw(new core.UnimplementedError("TypeMirror.isAssignable unimplemented"));
    }
    isSubtypeOf(other) {
      return dart.throw(new core.UnimplementedError("TypeMirror.isSubtypeOf unimplemented"));
    }
    get isOriginalDeclaration() {
      return dart.throw(new core.UnimplementedError("TypeMirror.isOriginalDeclaration unimplemented"));
    }
    get isPrivate() {
      return dart.throw(new core.UnimplementedError("TypeMirror.isPrivate unimplemented"));
    }
    get isTopLevel() {
      return dart.throw(new core.UnimplementedError("TypeMirror.isTopLevel unimplemented"));
    }
    get location() {
      return dart.throw(new core.UnimplementedError("TypeMirror.location unimplemented"));
    }
    get metadata() {
      return dart.throw(new core.UnimplementedError("TypeMirror.metadata unimplemented"));
    }
    get originalDeclaration() {
      return dart.throw(new core.UnimplementedError("TypeMirror.originalDeclaration unimplemented"));
    }
    get owner() {
      return dart.throw(new core.UnimplementedError("TypeMirror.owner unimplemented"));
    }
    get qualifiedName() {
      return dart.throw(new core.UnimplementedError("TypeMirror.qualifiedName unimplemented"));
    }
    get simpleName() {
      return dart.throw(new core.UnimplementedError("TypeMirror.simpleName unimplemented"));
    }
    get typeArguments() {
      return dart.throw(new core.UnimplementedError("TypeMirror.typeArguments unimplemented"));
    }
    get typeVariables() {
      return dart.throw(new core.UnimplementedError("TypeMirror.typeVariables unimplemented"));
    }
  };
  dart.defineNamedConstructor(_js_mirrors.JsTypeMirror, '_');
  _js_mirrors.JsTypeMirror[dart.implements] = () => [mirrors.TypeMirror];
  dart.setSignature(_js_mirrors.JsTypeMirror, {
    constructors: () => ({_: [_js_mirrors.JsTypeMirror, [core.Type]]}),
    methods: () => ({
      isAssignableTo: [core.bool, [mirrors.TypeMirror]],
      isSubtypeOf: [core.bool, [mirrors.TypeMirror]]
    })
  });
  const _name$ = Symbol('_name');
  _js_mirrors.JsParameterMirror = class JsParameterMirror extends core.Object {
    _(name, t, annotations) {
      this[_name$] = name;
      this.type = new _js_mirrors.JsTypeMirror._(t);
      this.metadata = core.List$(mirrors.InstanceMirror).from(annotations[dartx.map](_js_mirrors.JsInstanceMirror)(dart.fn(a => new _js_mirrors.JsInstanceMirror._(a), _js_mirrors.JsInstanceMirror, [dart.dynamic])));
    }
    get defaultValue() {
      return dart.throw(new core.UnimplementedError("ParameterMirror.defaultValues unimplemented"));
    }
    get hasDefaultValue() {
      return dart.throw(new core.UnimplementedError("ParameterMirror.hasDefaultValue unimplemented"));
    }
    get isConst() {
      return dart.throw(new core.UnimplementedError("ParameterMirror.isConst unimplemented"));
    }
    get isFinal() {
      return dart.throw(new core.UnimplementedError("ParameterMirror.isFinal unimplemented"));
    }
    get isNamed() {
      return dart.throw(new core.UnimplementedError("ParameterMirror.isNamed unimplemented"));
    }
    get isOptional() {
      return dart.throw(new core.UnimplementedError("ParameterMirror.isOptional unimplemented"));
    }
    get isPrivate() {
      return dart.throw(new core.UnimplementedError("ParameterMirror.isPrivate unimplemented"));
    }
    get isStatic() {
      return dart.throw(new core.UnimplementedError("ParameterMirror.isStatic unimplemented"));
    }
    get isTopLevel() {
      return dart.throw(new core.UnimplementedError("ParameterMirror.isTopLevel unimplemented"));
    }
    get location() {
      return dart.throw(new core.UnimplementedError("ParameterMirror.location unimplemented"));
    }
    get owner() {
      return dart.throw(new core.UnimplementedError("ParameterMirror.owner unimplemented"));
    }
    get qualifiedName() {
      return dart.throw(new core.UnimplementedError("ParameterMirror.qualifiedName unimplemented"));
    }
    get simpleName() {
      return dart.throw(new core.UnimplementedError("ParameterMirror.simpleName unimplemented"));
    }
  };
  dart.defineNamedConstructor(_js_mirrors.JsParameterMirror, '_');
  _js_mirrors.JsParameterMirror[dart.implements] = () => [mirrors.ParameterMirror];
  dart.setSignature(_js_mirrors.JsParameterMirror, {
    constructors: () => ({_: [_js_mirrors.JsParameterMirror, [core.String, core.Type, core.List]]})
  });
  const _method$ = Symbol('_method');
  const _params = Symbol('_params');
  const _createParameterMirrorList = Symbol('_createParameterMirrorList');
  _js_mirrors.JsMethodMirror = class JsMethodMirror extends core.Object {
    _(cls, method) {
      this[_method$] = method;
      this[_name$] = _js_mirrors.getName(cls.simpleName);
      this[_params] = null;
      let ftype = _js_mirrors._dart.classGetConstructorType(cls[_cls]);
      this[_params] = this[_createParameterMirrorList](ftype);
    }
    get constructorName() {
      return core.Symbol.new('');
    }
    get parameters() {
      return this[_params];
    }
    [_createParameterMirrorList](ftype) {
      if (ftype == null) {
        return dart.list([], mirrors.ParameterMirror);
      }
      let args = dart.as(dart.dload(ftype, 'args'), core.List);
      let opts = dart.as(dart.dload(ftype, 'optionals'), core.List);
      let params = core.List$(mirrors.ParameterMirror).new(dart.notNull(args[dartx.length]) + dart.notNull(opts[dartx.length]));
      for (let i = 0; i < dart.notNull(args[dartx.length]); ++i) {
        let type = args[dartx.get](i);
        let metadata = dart.dindex(dart.dload(ftype, 'metadata'), i);
        let param = new _js_mirrors.JsParameterMirror._('', dart.as(type, core.Type), dart.as(metadata, core.List));
        params[dartx.set](i, param);
      }
      for (let i = 0; i < dart.notNull(opts[dartx.length]); ++i) {
        let type = opts[dartx.get](i);
        let metadata = dart.dindex(dart.dload(ftype, 'metadata'), dart.notNull(args[dartx.length]) + i);
        let param = new _js_mirrors.JsParameterMirror._('', dart.as(type, core.Type), dart.as(metadata, core.List));
        params[dartx.set](i + dart.notNull(args[dartx.length]), param);
      }
      return params;
    }
    get isAbstract() {
      return dart.throw(new core.UnimplementedError("MethodMirror.isAbstract unimplemented"));
    }
    get isConstConstructor() {
      return dart.throw(new core.UnimplementedError("MethodMirror.isConstConstructor unimplemented"));
    }
    get isConstructor() {
      return dart.throw(new core.UnimplementedError("MethodMirror.isConstructor unimplemented"));
    }
    get isFactoryConstructor() {
      return dart.throw(new core.UnimplementedError("MethodMirror.isFactoryConstructor unimplemented"));
    }
    get isGenerativeConstructor() {
      return dart.throw(new core.UnimplementedError("MethodMirror.isGenerativeConstructor unimplemented"));
    }
    get isGetter() {
      return dart.throw(new core.UnimplementedError("MethodMirror.isGetter unimplemented"));
    }
    get isOperator() {
      return dart.throw(new core.UnimplementedError("MethodMirror.isOperator unimplemented"));
    }
    get isPrivate() {
      return dart.throw(new core.UnimplementedError("MethodMirror.isPrivate unimplemented"));
    }
    get isRedirectingConstructor() {
      return dart.throw(new core.UnimplementedError("MethodMirror.isRedirectingConstructor unimplemented"));
    }
    get isRegularMethod() {
      return dart.throw(new core.UnimplementedError("MethodMirror.isRegularMethod unimplemented"));
    }
    get isSetter() {
      return dart.throw(new core.UnimplementedError("MethodMirror.isSetter unimplemented"));
    }
    get isStatic() {
      return dart.throw(new core.UnimplementedError("MethodMirror.isStatic unimplemented"));
    }
    get isSynthetic() {
      return dart.throw(new core.UnimplementedError("MethodMirror.isSynthetic unimplemented"));
    }
    get isTopLevel() {
      return dart.throw(new core.UnimplementedError("MethodMirror.isTopLevel unimplemented"));
    }
    get location() {
      return dart.throw(new core.UnimplementedError("MethodMirror.location unimplemented"));
    }
    get metadata() {
      return dart.list([], mirrors.InstanceMirror);
    }
    get owner() {
      return dart.throw(new core.UnimplementedError("MethodMirror.owner unimplemented"));
    }
    get qualifiedName() {
      return dart.throw(new core.UnimplementedError("MethodMirror.qualifiedName unimplemented"));
    }
    get returnType() {
      return dart.throw(new core.UnimplementedError("MethodMirror.returnType unimplemented"));
    }
    get simpleName() {
      return dart.throw(new core.UnimplementedError("MethodMirror.simpleName unimplemented"));
    }
    get source() {
      return dart.throw(new core.UnimplementedError("MethodMirror.source unimplemented"));
    }
  };
  dart.defineNamedConstructor(_js_mirrors.JsMethodMirror, '_');
  _js_mirrors.JsMethodMirror[dart.implements] = () => [mirrors.MethodMirror];
  dart.setSignature(_js_mirrors.JsMethodMirror, {
    constructors: () => ({_: [_js_mirrors.JsMethodMirror, [_js_mirrors.JsClassMirror, dart.dynamic]]}),
    methods: () => ({[_createParameterMirrorList]: [core.List$(mirrors.ParameterMirror), [dart.dynamic]]})
  });
  _js_primitives.printString = function(string) {
    if (typeof dartPrint == "function") {
      dartPrint(string);
      return;
    }
    if (typeof console == "object" && typeof console.log != "undefined") {
      console.log(string);
      return;
    }
    if (typeof window == "object") {
      return;
    }
    if (typeof print == "function") {
      print(string);
      return;
    }
    throw "Unable to print message: " + String(string);
  };
  dart.lazyFn(_js_primitives.printString, () => [dart.void, [core.String]]);
  _metadata.SupportedBrowser = class SupportedBrowser extends core.Object {
    SupportedBrowser(browserName, minimumVersion) {
      if (minimumVersion === void 0) minimumVersion = null;
      this.browserName = browserName;
      this.minimumVersion = minimumVersion;
    }
  };
  dart.setSignature(_metadata.SupportedBrowser, {
    constructors: () => ({SupportedBrowser: [_metadata.SupportedBrowser, [core.String], [core.String]]})
  });
  _metadata.SupportedBrowser.CHROME = "Chrome";
  _metadata.SupportedBrowser.FIREFOX = "Firefox";
  _metadata.SupportedBrowser.IE = "Internet Explorer";
  _metadata.SupportedBrowser.OPERA = "Opera";
  _metadata.SupportedBrowser.SAFARI = "Safari";
  _metadata.Experimental = class Experimental extends core.Object {
    Experimental() {
    }
  };
  dart.setSignature(_metadata.Experimental, {
    constructors: () => ({Experimental: [_metadata.Experimental, []]})
  });
  _metadata.DomName = class DomName extends core.Object {
    DomName(name) {
      this.name = name;
    }
  };
  dart.setSignature(_metadata.DomName, {
    constructors: () => ({DomName: [_metadata.DomName, [core.String]]})
  });
  _metadata.DocsEditable = class DocsEditable extends core.Object {
    DocsEditable() {
    }
  };
  dart.setSignature(_metadata.DocsEditable, {
    constructors: () => ({DocsEditable: [_metadata.DocsEditable, []]})
  });
  _metadata.Unstable = class Unstable extends core.Object {
    Unstable() {
    }
  };
  dart.setSignature(_metadata.Unstable, {
    constructors: () => ({Unstable: [_metadata.Unstable, []]})
  });
  dart.defineExtensionNames([
    'lengthInBytes',
    'runtimeType',
    'asUint8List',
    'asInt8List',
    'asUint8ClampedList',
    'asUint16List',
    'asInt16List',
    'asUint32List',
    'asInt32List',
    'asUint64List',
    'asInt64List',
    'asInt32x4List',
    'asFloat32List',
    'asFloat64List',
    'asFloat32x4List',
    'asFloat64x2List',
    'asByteData'
  ]);
  _native_typed_data.NativeByteBuffer = class NativeByteBuffer extends core.Object {
    get [dartx.lengthInBytes]() {
      return this.byteLength;
    }
    get [dartx.runtimeType]() {
      return dart.wrapType(typed_data.ByteBuffer);
    }
    [dartx.asUint8List](offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      return _native_typed_data.NativeUint8List.view(this, offsetInBytes, length);
    }
    [dartx.asInt8List](offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      return _native_typed_data.NativeInt8List.view(this, offsetInBytes, length);
    }
    [dartx.asUint8ClampedList](offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      return _native_typed_data.NativeUint8ClampedList.view(this, offsetInBytes, length);
    }
    [dartx.asUint16List](offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      return _native_typed_data.NativeUint16List.view(this, offsetInBytes, length);
    }
    [dartx.asInt16List](offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      return _native_typed_data.NativeInt16List.view(this, offsetInBytes, length);
    }
    [dartx.asUint32List](offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      return _native_typed_data.NativeUint32List.view(this, offsetInBytes, length);
    }
    [dartx.asInt32List](offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      return _native_typed_data.NativeInt32List.view(this, offsetInBytes, length);
    }
    [dartx.asUint64List](offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      dart.throw(new core.UnsupportedError("Uint64List not supported by dart2js."));
    }
    [dartx.asInt64List](offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      dart.throw(new core.UnsupportedError("Int64List not supported by dart2js."));
    }
    [dartx.asInt32x4List](offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      let storage = dart.as(this[dartx.asInt32List](offsetInBytes, length != null ? dart.notNull(length) * 4 : null), _native_typed_data.NativeInt32List);
      return new _native_typed_data.NativeInt32x4List._externalStorage(storage);
    }
    [dartx.asFloat32List](offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      return _native_typed_data.NativeFloat32List.view(this, offsetInBytes, length);
    }
    [dartx.asFloat64List](offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      return _native_typed_data.NativeFloat64List.view(this, offsetInBytes, length);
    }
    [dartx.asFloat32x4List](offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      let storage = dart.as(this[dartx.asFloat32List](offsetInBytes, length != null ? dart.notNull(length) * 4 : null), _native_typed_data.NativeFloat32List);
      return new _native_typed_data.NativeFloat32x4List._externalStorage(storage);
    }
    [dartx.asFloat64x2List](offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      let storage = dart.as(this[dartx.asFloat64List](offsetInBytes, length != null ? dart.notNull(length) * 2 : null), _native_typed_data.NativeFloat64List);
      return new _native_typed_data.NativeFloat64x2List._externalStorage(storage);
    }
    [dartx.asByteData](offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      return _native_typed_data.NativeByteData.view(this, offsetInBytes, length);
    }
  };
  _native_typed_data.NativeByteBuffer[dart.implements] = () => [typed_data.ByteBuffer];
  dart.setSignature(_native_typed_data.NativeByteBuffer, {
    methods: () => ({
      [dartx.asUint8List]: [typed_data.Uint8List, [], [core.int, core.int]],
      [dartx.asInt8List]: [typed_data.Int8List, [], [core.int, core.int]],
      [dartx.asUint8ClampedList]: [typed_data.Uint8ClampedList, [], [core.int, core.int]],
      [dartx.asUint16List]: [typed_data.Uint16List, [], [core.int, core.int]],
      [dartx.asInt16List]: [typed_data.Int16List, [], [core.int, core.int]],
      [dartx.asUint32List]: [typed_data.Uint32List, [], [core.int, core.int]],
      [dartx.asInt32List]: [typed_data.Int32List, [], [core.int, core.int]],
      [dartx.asUint64List]: [typed_data.Uint64List, [], [core.int, core.int]],
      [dartx.asInt64List]: [typed_data.Int64List, [], [core.int, core.int]],
      [dartx.asInt32x4List]: [typed_data.Int32x4List, [], [core.int, core.int]],
      [dartx.asFloat32List]: [typed_data.Float32List, [], [core.int, core.int]],
      [dartx.asFloat64List]: [typed_data.Float64List, [], [core.int, core.int]],
      [dartx.asFloat32x4List]: [typed_data.Float32x4List, [], [core.int, core.int]],
      [dartx.asFloat64x2List]: [typed_data.Float64x2List, [], [core.int, core.int]],
      [dartx.asByteData]: [typed_data.ByteData, [], [core.int, core.int]]
    })
  });
  _native_typed_data.NativeByteBuffer[dart.metadata] = () => [dart.const(new _js_helper.Native("ArrayBuffer"))];
  dart.registerExtension(dart.global.ArrayBuffer, _native_typed_data.NativeByteBuffer);
  const _storage = Symbol('_storage');
  typed_data.Float32x4 = class Float32x4 extends core.Object {
    static new(x, y, z, w) {
      return new _native_typed_data.NativeFloat32x4(x, y, z, w);
    }
    static splat(v) {
      return new _native_typed_data.NativeFloat32x4.splat(v);
    }
    static zero() {
      return new _native_typed_data.NativeFloat32x4.zero();
    }
    static fromInt32x4Bits(x) {
      return _native_typed_data.NativeFloat32x4.fromInt32x4Bits(x);
    }
    static fromFloat64x2(v) {
      return new _native_typed_data.NativeFloat32x4.fromFloat64x2(v);
    }
  };
  dart.setSignature(typed_data.Float32x4, {
    constructors: () => ({
      new: [typed_data.Float32x4, [core.double, core.double, core.double, core.double]],
      splat: [typed_data.Float32x4, [core.double]],
      zero: [typed_data.Float32x4, []],
      fromInt32x4Bits: [typed_data.Float32x4, [typed_data.Int32x4]],
      fromFloat64x2: [typed_data.Float32x4, [typed_data.Float64x2]]
    })
  });
  typed_data.Float32x4.XXXX = 0;
  typed_data.Float32x4.XXXY = 64;
  typed_data.Float32x4.XXXZ = 128;
  typed_data.Float32x4.XXXW = 192;
  typed_data.Float32x4.XXYX = 16;
  typed_data.Float32x4.XXYY = 80;
  typed_data.Float32x4.XXYZ = 144;
  typed_data.Float32x4.XXYW = 208;
  typed_data.Float32x4.XXZX = 32;
  typed_data.Float32x4.XXZY = 96;
  typed_data.Float32x4.XXZZ = 160;
  typed_data.Float32x4.XXZW = 224;
  typed_data.Float32x4.XXWX = 48;
  typed_data.Float32x4.XXWY = 112;
  typed_data.Float32x4.XXWZ = 176;
  typed_data.Float32x4.XXWW = 240;
  typed_data.Float32x4.XYXX = 4;
  typed_data.Float32x4.XYXY = 68;
  typed_data.Float32x4.XYXZ = 132;
  typed_data.Float32x4.XYXW = 196;
  typed_data.Float32x4.XYYX = 20;
  typed_data.Float32x4.XYYY = 84;
  typed_data.Float32x4.XYYZ = 148;
  typed_data.Float32x4.XYYW = 212;
  typed_data.Float32x4.XYZX = 36;
  typed_data.Float32x4.XYZY = 100;
  typed_data.Float32x4.XYZZ = 164;
  typed_data.Float32x4.XYZW = 228;
  typed_data.Float32x4.XYWX = 52;
  typed_data.Float32x4.XYWY = 116;
  typed_data.Float32x4.XYWZ = 180;
  typed_data.Float32x4.XYWW = 244;
  typed_data.Float32x4.XZXX = 8;
  typed_data.Float32x4.XZXY = 72;
  typed_data.Float32x4.XZXZ = 136;
  typed_data.Float32x4.XZXW = 200;
  typed_data.Float32x4.XZYX = 24;
  typed_data.Float32x4.XZYY = 88;
  typed_data.Float32x4.XZYZ = 152;
  typed_data.Float32x4.XZYW = 216;
  typed_data.Float32x4.XZZX = 40;
  typed_data.Float32x4.XZZY = 104;
  typed_data.Float32x4.XZZZ = 168;
  typed_data.Float32x4.XZZW = 232;
  typed_data.Float32x4.XZWX = 56;
  typed_data.Float32x4.XZWY = 120;
  typed_data.Float32x4.XZWZ = 184;
  typed_data.Float32x4.XZWW = 248;
  typed_data.Float32x4.XWXX = 12;
  typed_data.Float32x4.XWXY = 76;
  typed_data.Float32x4.XWXZ = 140;
  typed_data.Float32x4.XWXW = 204;
  typed_data.Float32x4.XWYX = 28;
  typed_data.Float32x4.XWYY = 92;
  typed_data.Float32x4.XWYZ = 156;
  typed_data.Float32x4.XWYW = 220;
  typed_data.Float32x4.XWZX = 44;
  typed_data.Float32x4.XWZY = 108;
  typed_data.Float32x4.XWZZ = 172;
  typed_data.Float32x4.XWZW = 236;
  typed_data.Float32x4.XWWX = 60;
  typed_data.Float32x4.XWWY = 124;
  typed_data.Float32x4.XWWZ = 188;
  typed_data.Float32x4.XWWW = 252;
  typed_data.Float32x4.YXXX = 1;
  typed_data.Float32x4.YXXY = 65;
  typed_data.Float32x4.YXXZ = 129;
  typed_data.Float32x4.YXXW = 193;
  typed_data.Float32x4.YXYX = 17;
  typed_data.Float32x4.YXYY = 81;
  typed_data.Float32x4.YXYZ = 145;
  typed_data.Float32x4.YXYW = 209;
  typed_data.Float32x4.YXZX = 33;
  typed_data.Float32x4.YXZY = 97;
  typed_data.Float32x4.YXZZ = 161;
  typed_data.Float32x4.YXZW = 225;
  typed_data.Float32x4.YXWX = 49;
  typed_data.Float32x4.YXWY = 113;
  typed_data.Float32x4.YXWZ = 177;
  typed_data.Float32x4.YXWW = 241;
  typed_data.Float32x4.YYXX = 5;
  typed_data.Float32x4.YYXY = 69;
  typed_data.Float32x4.YYXZ = 133;
  typed_data.Float32x4.YYXW = 197;
  typed_data.Float32x4.YYYX = 21;
  typed_data.Float32x4.YYYY = 85;
  typed_data.Float32x4.YYYZ = 149;
  typed_data.Float32x4.YYYW = 213;
  typed_data.Float32x4.YYZX = 37;
  typed_data.Float32x4.YYZY = 101;
  typed_data.Float32x4.YYZZ = 165;
  typed_data.Float32x4.YYZW = 229;
  typed_data.Float32x4.YYWX = 53;
  typed_data.Float32x4.YYWY = 117;
  typed_data.Float32x4.YYWZ = 181;
  typed_data.Float32x4.YYWW = 245;
  typed_data.Float32x4.YZXX = 9;
  typed_data.Float32x4.YZXY = 73;
  typed_data.Float32x4.YZXZ = 137;
  typed_data.Float32x4.YZXW = 201;
  typed_data.Float32x4.YZYX = 25;
  typed_data.Float32x4.YZYY = 89;
  typed_data.Float32x4.YZYZ = 153;
  typed_data.Float32x4.YZYW = 217;
  typed_data.Float32x4.YZZX = 41;
  typed_data.Float32x4.YZZY = 105;
  typed_data.Float32x4.YZZZ = 169;
  typed_data.Float32x4.YZZW = 233;
  typed_data.Float32x4.YZWX = 57;
  typed_data.Float32x4.YZWY = 121;
  typed_data.Float32x4.YZWZ = 185;
  typed_data.Float32x4.YZWW = 249;
  typed_data.Float32x4.YWXX = 13;
  typed_data.Float32x4.YWXY = 77;
  typed_data.Float32x4.YWXZ = 141;
  typed_data.Float32x4.YWXW = 205;
  typed_data.Float32x4.YWYX = 29;
  typed_data.Float32x4.YWYY = 93;
  typed_data.Float32x4.YWYZ = 157;
  typed_data.Float32x4.YWYW = 221;
  typed_data.Float32x4.YWZX = 45;
  typed_data.Float32x4.YWZY = 109;
  typed_data.Float32x4.YWZZ = 173;
  typed_data.Float32x4.YWZW = 237;
  typed_data.Float32x4.YWWX = 61;
  typed_data.Float32x4.YWWY = 125;
  typed_data.Float32x4.YWWZ = 189;
  typed_data.Float32x4.YWWW = 253;
  typed_data.Float32x4.ZXXX = 2;
  typed_data.Float32x4.ZXXY = 66;
  typed_data.Float32x4.ZXXZ = 130;
  typed_data.Float32x4.ZXXW = 194;
  typed_data.Float32x4.ZXYX = 18;
  typed_data.Float32x4.ZXYY = 82;
  typed_data.Float32x4.ZXYZ = 146;
  typed_data.Float32x4.ZXYW = 210;
  typed_data.Float32x4.ZXZX = 34;
  typed_data.Float32x4.ZXZY = 98;
  typed_data.Float32x4.ZXZZ = 162;
  typed_data.Float32x4.ZXZW = 226;
  typed_data.Float32x4.ZXWX = 50;
  typed_data.Float32x4.ZXWY = 114;
  typed_data.Float32x4.ZXWZ = 178;
  typed_data.Float32x4.ZXWW = 242;
  typed_data.Float32x4.ZYXX = 6;
  typed_data.Float32x4.ZYXY = 70;
  typed_data.Float32x4.ZYXZ = 134;
  typed_data.Float32x4.ZYXW = 198;
  typed_data.Float32x4.ZYYX = 22;
  typed_data.Float32x4.ZYYY = 86;
  typed_data.Float32x4.ZYYZ = 150;
  typed_data.Float32x4.ZYYW = 214;
  typed_data.Float32x4.ZYZX = 38;
  typed_data.Float32x4.ZYZY = 102;
  typed_data.Float32x4.ZYZZ = 166;
  typed_data.Float32x4.ZYZW = 230;
  typed_data.Float32x4.ZYWX = 54;
  typed_data.Float32x4.ZYWY = 118;
  typed_data.Float32x4.ZYWZ = 182;
  typed_data.Float32x4.ZYWW = 246;
  typed_data.Float32x4.ZZXX = 10;
  typed_data.Float32x4.ZZXY = 74;
  typed_data.Float32x4.ZZXZ = 138;
  typed_data.Float32x4.ZZXW = 202;
  typed_data.Float32x4.ZZYX = 26;
  typed_data.Float32x4.ZZYY = 90;
  typed_data.Float32x4.ZZYZ = 154;
  typed_data.Float32x4.ZZYW = 218;
  typed_data.Float32x4.ZZZX = 42;
  typed_data.Float32x4.ZZZY = 106;
  typed_data.Float32x4.ZZZZ = 170;
  typed_data.Float32x4.ZZZW = 234;
  typed_data.Float32x4.ZZWX = 58;
  typed_data.Float32x4.ZZWY = 122;
  typed_data.Float32x4.ZZWZ = 186;
  typed_data.Float32x4.ZZWW = 250;
  typed_data.Float32x4.ZWXX = 14;
  typed_data.Float32x4.ZWXY = 78;
  typed_data.Float32x4.ZWXZ = 142;
  typed_data.Float32x4.ZWXW = 206;
  typed_data.Float32x4.ZWYX = 30;
  typed_data.Float32x4.ZWYY = 94;
  typed_data.Float32x4.ZWYZ = 158;
  typed_data.Float32x4.ZWYW = 222;
  typed_data.Float32x4.ZWZX = 46;
  typed_data.Float32x4.ZWZY = 110;
  typed_data.Float32x4.ZWZZ = 174;
  typed_data.Float32x4.ZWZW = 238;
  typed_data.Float32x4.ZWWX = 62;
  typed_data.Float32x4.ZWWY = 126;
  typed_data.Float32x4.ZWWZ = 190;
  typed_data.Float32x4.ZWWW = 254;
  typed_data.Float32x4.WXXX = 3;
  typed_data.Float32x4.WXXY = 67;
  typed_data.Float32x4.WXXZ = 131;
  typed_data.Float32x4.WXXW = 195;
  typed_data.Float32x4.WXYX = 19;
  typed_data.Float32x4.WXYY = 83;
  typed_data.Float32x4.WXYZ = 147;
  typed_data.Float32x4.WXYW = 211;
  typed_data.Float32x4.WXZX = 35;
  typed_data.Float32x4.WXZY = 99;
  typed_data.Float32x4.WXZZ = 163;
  typed_data.Float32x4.WXZW = 227;
  typed_data.Float32x4.WXWX = 51;
  typed_data.Float32x4.WXWY = 115;
  typed_data.Float32x4.WXWZ = 179;
  typed_data.Float32x4.WXWW = 243;
  typed_data.Float32x4.WYXX = 7;
  typed_data.Float32x4.WYXY = 71;
  typed_data.Float32x4.WYXZ = 135;
  typed_data.Float32x4.WYXW = 199;
  typed_data.Float32x4.WYYX = 23;
  typed_data.Float32x4.WYYY = 87;
  typed_data.Float32x4.WYYZ = 151;
  typed_data.Float32x4.WYYW = 215;
  typed_data.Float32x4.WYZX = 39;
  typed_data.Float32x4.WYZY = 103;
  typed_data.Float32x4.WYZZ = 167;
  typed_data.Float32x4.WYZW = 231;
  typed_data.Float32x4.WYWX = 55;
  typed_data.Float32x4.WYWY = 119;
  typed_data.Float32x4.WYWZ = 183;
  typed_data.Float32x4.WYWW = 247;
  typed_data.Float32x4.WZXX = 11;
  typed_data.Float32x4.WZXY = 75;
  typed_data.Float32x4.WZXZ = 139;
  typed_data.Float32x4.WZXW = 203;
  typed_data.Float32x4.WZYX = 27;
  typed_data.Float32x4.WZYY = 91;
  typed_data.Float32x4.WZYZ = 155;
  typed_data.Float32x4.WZYW = 219;
  typed_data.Float32x4.WZZX = 43;
  typed_data.Float32x4.WZZY = 107;
  typed_data.Float32x4.WZZZ = 171;
  typed_data.Float32x4.WZZW = 235;
  typed_data.Float32x4.WZWX = 59;
  typed_data.Float32x4.WZWY = 123;
  typed_data.Float32x4.WZWZ = 187;
  typed_data.Float32x4.WZWW = 251;
  typed_data.Float32x4.WWXX = 15;
  typed_data.Float32x4.WWXY = 79;
  typed_data.Float32x4.WWXZ = 143;
  typed_data.Float32x4.WWXW = 207;
  typed_data.Float32x4.WWYX = 31;
  typed_data.Float32x4.WWYY = 95;
  typed_data.Float32x4.WWYZ = 159;
  typed_data.Float32x4.WWYW = 223;
  typed_data.Float32x4.WWZX = 47;
  typed_data.Float32x4.WWZY = 111;
  typed_data.Float32x4.WWZZ = 175;
  typed_data.Float32x4.WWZW = 239;
  typed_data.Float32x4.WWWX = 63;
  typed_data.Float32x4.WWWY = 127;
  typed_data.Float32x4.WWWZ = 191;
  typed_data.Float32x4.WWWW = 255;
  _native_typed_data.NativeFloat32x4List = class NativeFloat32x4List extends dart.mixin(core.Object, collection.ListMixin$(typed_data.Float32x4), _internal.FixedLengthListMixin$(typed_data.Float32x4)) {
    NativeFloat32x4List(length) {
      this[_storage] = _native_typed_data.NativeFloat32List.new(dart.notNull(length) * 4);
    }
    _externalStorage(storage) {
      this[_storage] = storage;
    }
    _slowFromList(list) {
      this[_storage] = _native_typed_data.NativeFloat32List.new(dart.notNull(list[dartx.length]) * 4);
      for (let i = 0; i < dart.notNull(list[dartx.length]); i++) {
        let e = list[dartx.get](i);
        this[_storage][dartx.set](i * 4 + 0, e.x);
        this[_storage][dartx.set](i * 4 + 1, e.y);
        this[_storage][dartx.set](i * 4 + 2, e.z);
        this[_storage][dartx.set](i * 4 + 3, e.w);
      }
    }
    get runtimeType() {
      return dart.wrapType(typed_data.Float32x4List);
    }
    static fromList(list) {
      if (dart.is(list, _native_typed_data.NativeFloat32x4List)) {
        return new _native_typed_data.NativeFloat32x4List._externalStorage(_native_typed_data.NativeFloat32List.fromList(list[_storage]));
      } else {
        return new _native_typed_data.NativeFloat32x4List._slowFromList(list);
      }
    }
    get buffer() {
      return this[_storage][dartx.buffer];
    }
    get lengthInBytes() {
      return this[_storage][dartx.lengthInBytes];
    }
    get offsetInBytes() {
      return this[_storage][dartx.offsetInBytes];
    }
    get elementSizeInBytes() {
      return typed_data.Float32x4List.BYTES_PER_ELEMENT;
    }
    get length() {
      return (dart.notNull(this[_storage][dartx.length]) / 4)[dartx.truncate]();
    }
    set length(value) {
      super.length = value;
    }
    get(index) {
      _native_typed_data._checkValidIndex(index, this, this.length);
      let _x = this[_storage][dartx.get](dart.notNull(index) * 4 + 0);
      let _y = this[_storage][dartx.get](dart.notNull(index) * 4 + 1);
      let _z = this[_storage][dartx.get](dart.notNull(index) * 4 + 2);
      let _w = this[_storage][dartx.get](dart.notNull(index) * 4 + 3);
      return new _native_typed_data.NativeFloat32x4._truncated(_x, _y, _z, _w);
    }
    set(index, value) {
      _native_typed_data._checkValidIndex(index, this, this.length);
      this[_storage][dartx.set](dart.notNull(index) * 4 + 0, value.x);
      this[_storage][dartx.set](dart.notNull(index) * 4 + 1, value.y);
      this[_storage][dartx.set](dart.notNull(index) * 4 + 2, value.z);
      this[_storage][dartx.set](dart.notNull(index) * 4 + 3, value.w);
      return value;
    }
    sublist(start, end) {
      if (end === void 0) end = null;
      end = _native_typed_data._checkValidRange(start, end, this.length);
      return new _native_typed_data.NativeFloat32x4List._externalStorage(dart.as(this[_storage][dartx.sublist](dart.notNull(start) * 4, dart.notNull(end) * 4), _native_typed_data.NativeFloat32List));
    }
  };
  dart.defineNamedConstructor(_native_typed_data.NativeFloat32x4List, '_externalStorage');
  dart.defineNamedConstructor(_native_typed_data.NativeFloat32x4List, '_slowFromList');
  _native_typed_data.NativeFloat32x4List[dart.implements] = () => [typed_data.Float32x4List];
  dart.setSignature(_native_typed_data.NativeFloat32x4List, {
    constructors: () => ({
      NativeFloat32x4List: [_native_typed_data.NativeFloat32x4List, [core.int]],
      _externalStorage: [_native_typed_data.NativeFloat32x4List, [_native_typed_data.NativeFloat32List]],
      _slowFromList: [_native_typed_data.NativeFloat32x4List, [core.List$(typed_data.Float32x4)]],
      fromList: [_native_typed_data.NativeFloat32x4List, [core.List$(typed_data.Float32x4)]]
    }),
    methods: () => ({
      get: [typed_data.Float32x4, [core.int]],
      set: [dart.void, [core.int, typed_data.Float32x4]],
      sublist: [core.List$(typed_data.Float32x4), [core.int], [core.int]]
    })
  });
  dart.defineExtensionMembers(_native_typed_data.NativeFloat32x4List, [
    'get',
    'set',
    'sublist',
    'buffer',
    'lengthInBytes',
    'offsetInBytes',
    'elementSizeInBytes',
    'length'
  ]);
  typed_data.Int32x4 = class Int32x4 extends core.Object {
    static new(x, y, z, w) {
      return new _native_typed_data.NativeInt32x4(x, y, z, w);
    }
    static bool(x, y, z, w) {
      return new _native_typed_data.NativeInt32x4.bool(x, y, z, w);
    }
    static fromFloat32x4Bits(x) {
      return _native_typed_data.NativeInt32x4.fromFloat32x4Bits(x);
    }
  };
  dart.setSignature(typed_data.Int32x4, {
    constructors: () => ({
      new: [typed_data.Int32x4, [core.int, core.int, core.int, core.int]],
      bool: [typed_data.Int32x4, [core.bool, core.bool, core.bool, core.bool]],
      fromFloat32x4Bits: [typed_data.Int32x4, [typed_data.Float32x4]]
    })
  });
  typed_data.Int32x4.XXXX = 0;
  typed_data.Int32x4.XXXY = 64;
  typed_data.Int32x4.XXXZ = 128;
  typed_data.Int32x4.XXXW = 192;
  typed_data.Int32x4.XXYX = 16;
  typed_data.Int32x4.XXYY = 80;
  typed_data.Int32x4.XXYZ = 144;
  typed_data.Int32x4.XXYW = 208;
  typed_data.Int32x4.XXZX = 32;
  typed_data.Int32x4.XXZY = 96;
  typed_data.Int32x4.XXZZ = 160;
  typed_data.Int32x4.XXZW = 224;
  typed_data.Int32x4.XXWX = 48;
  typed_data.Int32x4.XXWY = 112;
  typed_data.Int32x4.XXWZ = 176;
  typed_data.Int32x4.XXWW = 240;
  typed_data.Int32x4.XYXX = 4;
  typed_data.Int32x4.XYXY = 68;
  typed_data.Int32x4.XYXZ = 132;
  typed_data.Int32x4.XYXW = 196;
  typed_data.Int32x4.XYYX = 20;
  typed_data.Int32x4.XYYY = 84;
  typed_data.Int32x4.XYYZ = 148;
  typed_data.Int32x4.XYYW = 212;
  typed_data.Int32x4.XYZX = 36;
  typed_data.Int32x4.XYZY = 100;
  typed_data.Int32x4.XYZZ = 164;
  typed_data.Int32x4.XYZW = 228;
  typed_data.Int32x4.XYWX = 52;
  typed_data.Int32x4.XYWY = 116;
  typed_data.Int32x4.XYWZ = 180;
  typed_data.Int32x4.XYWW = 244;
  typed_data.Int32x4.XZXX = 8;
  typed_data.Int32x4.XZXY = 72;
  typed_data.Int32x4.XZXZ = 136;
  typed_data.Int32x4.XZXW = 200;
  typed_data.Int32x4.XZYX = 24;
  typed_data.Int32x4.XZYY = 88;
  typed_data.Int32x4.XZYZ = 152;
  typed_data.Int32x4.XZYW = 216;
  typed_data.Int32x4.XZZX = 40;
  typed_data.Int32x4.XZZY = 104;
  typed_data.Int32x4.XZZZ = 168;
  typed_data.Int32x4.XZZW = 232;
  typed_data.Int32x4.XZWX = 56;
  typed_data.Int32x4.XZWY = 120;
  typed_data.Int32x4.XZWZ = 184;
  typed_data.Int32x4.XZWW = 248;
  typed_data.Int32x4.XWXX = 12;
  typed_data.Int32x4.XWXY = 76;
  typed_data.Int32x4.XWXZ = 140;
  typed_data.Int32x4.XWXW = 204;
  typed_data.Int32x4.XWYX = 28;
  typed_data.Int32x4.XWYY = 92;
  typed_data.Int32x4.XWYZ = 156;
  typed_data.Int32x4.XWYW = 220;
  typed_data.Int32x4.XWZX = 44;
  typed_data.Int32x4.XWZY = 108;
  typed_data.Int32x4.XWZZ = 172;
  typed_data.Int32x4.XWZW = 236;
  typed_data.Int32x4.XWWX = 60;
  typed_data.Int32x4.XWWY = 124;
  typed_data.Int32x4.XWWZ = 188;
  typed_data.Int32x4.XWWW = 252;
  typed_data.Int32x4.YXXX = 1;
  typed_data.Int32x4.YXXY = 65;
  typed_data.Int32x4.YXXZ = 129;
  typed_data.Int32x4.YXXW = 193;
  typed_data.Int32x4.YXYX = 17;
  typed_data.Int32x4.YXYY = 81;
  typed_data.Int32x4.YXYZ = 145;
  typed_data.Int32x4.YXYW = 209;
  typed_data.Int32x4.YXZX = 33;
  typed_data.Int32x4.YXZY = 97;
  typed_data.Int32x4.YXZZ = 161;
  typed_data.Int32x4.YXZW = 225;
  typed_data.Int32x4.YXWX = 49;
  typed_data.Int32x4.YXWY = 113;
  typed_data.Int32x4.YXWZ = 177;
  typed_data.Int32x4.YXWW = 241;
  typed_data.Int32x4.YYXX = 5;
  typed_data.Int32x4.YYXY = 69;
  typed_data.Int32x4.YYXZ = 133;
  typed_data.Int32x4.YYXW = 197;
  typed_data.Int32x4.YYYX = 21;
  typed_data.Int32x4.YYYY = 85;
  typed_data.Int32x4.YYYZ = 149;
  typed_data.Int32x4.YYYW = 213;
  typed_data.Int32x4.YYZX = 37;
  typed_data.Int32x4.YYZY = 101;
  typed_data.Int32x4.YYZZ = 165;
  typed_data.Int32x4.YYZW = 229;
  typed_data.Int32x4.YYWX = 53;
  typed_data.Int32x4.YYWY = 117;
  typed_data.Int32x4.YYWZ = 181;
  typed_data.Int32x4.YYWW = 245;
  typed_data.Int32x4.YZXX = 9;
  typed_data.Int32x4.YZXY = 73;
  typed_data.Int32x4.YZXZ = 137;
  typed_data.Int32x4.YZXW = 201;
  typed_data.Int32x4.YZYX = 25;
  typed_data.Int32x4.YZYY = 89;
  typed_data.Int32x4.YZYZ = 153;
  typed_data.Int32x4.YZYW = 217;
  typed_data.Int32x4.YZZX = 41;
  typed_data.Int32x4.YZZY = 105;
  typed_data.Int32x4.YZZZ = 169;
  typed_data.Int32x4.YZZW = 233;
  typed_data.Int32x4.YZWX = 57;
  typed_data.Int32x4.YZWY = 121;
  typed_data.Int32x4.YZWZ = 185;
  typed_data.Int32x4.YZWW = 249;
  typed_data.Int32x4.YWXX = 13;
  typed_data.Int32x4.YWXY = 77;
  typed_data.Int32x4.YWXZ = 141;
  typed_data.Int32x4.YWXW = 205;
  typed_data.Int32x4.YWYX = 29;
  typed_data.Int32x4.YWYY = 93;
  typed_data.Int32x4.YWYZ = 157;
  typed_data.Int32x4.YWYW = 221;
  typed_data.Int32x4.YWZX = 45;
  typed_data.Int32x4.YWZY = 109;
  typed_data.Int32x4.YWZZ = 173;
  typed_data.Int32x4.YWZW = 237;
  typed_data.Int32x4.YWWX = 61;
  typed_data.Int32x4.YWWY = 125;
  typed_data.Int32x4.YWWZ = 189;
  typed_data.Int32x4.YWWW = 253;
  typed_data.Int32x4.ZXXX = 2;
  typed_data.Int32x4.ZXXY = 66;
  typed_data.Int32x4.ZXXZ = 130;
  typed_data.Int32x4.ZXXW = 194;
  typed_data.Int32x4.ZXYX = 18;
  typed_data.Int32x4.ZXYY = 82;
  typed_data.Int32x4.ZXYZ = 146;
  typed_data.Int32x4.ZXYW = 210;
  typed_data.Int32x4.ZXZX = 34;
  typed_data.Int32x4.ZXZY = 98;
  typed_data.Int32x4.ZXZZ = 162;
  typed_data.Int32x4.ZXZW = 226;
  typed_data.Int32x4.ZXWX = 50;
  typed_data.Int32x4.ZXWY = 114;
  typed_data.Int32x4.ZXWZ = 178;
  typed_data.Int32x4.ZXWW = 242;
  typed_data.Int32x4.ZYXX = 6;
  typed_data.Int32x4.ZYXY = 70;
  typed_data.Int32x4.ZYXZ = 134;
  typed_data.Int32x4.ZYXW = 198;
  typed_data.Int32x4.ZYYX = 22;
  typed_data.Int32x4.ZYYY = 86;
  typed_data.Int32x4.ZYYZ = 150;
  typed_data.Int32x4.ZYYW = 214;
  typed_data.Int32x4.ZYZX = 38;
  typed_data.Int32x4.ZYZY = 102;
  typed_data.Int32x4.ZYZZ = 166;
  typed_data.Int32x4.ZYZW = 230;
  typed_data.Int32x4.ZYWX = 54;
  typed_data.Int32x4.ZYWY = 118;
  typed_data.Int32x4.ZYWZ = 182;
  typed_data.Int32x4.ZYWW = 246;
  typed_data.Int32x4.ZZXX = 10;
  typed_data.Int32x4.ZZXY = 74;
  typed_data.Int32x4.ZZXZ = 138;
  typed_data.Int32x4.ZZXW = 202;
  typed_data.Int32x4.ZZYX = 26;
  typed_data.Int32x4.ZZYY = 90;
  typed_data.Int32x4.ZZYZ = 154;
  typed_data.Int32x4.ZZYW = 218;
  typed_data.Int32x4.ZZZX = 42;
  typed_data.Int32x4.ZZZY = 106;
  typed_data.Int32x4.ZZZZ = 170;
  typed_data.Int32x4.ZZZW = 234;
  typed_data.Int32x4.ZZWX = 58;
  typed_data.Int32x4.ZZWY = 122;
  typed_data.Int32x4.ZZWZ = 186;
  typed_data.Int32x4.ZZWW = 250;
  typed_data.Int32x4.ZWXX = 14;
  typed_data.Int32x4.ZWXY = 78;
  typed_data.Int32x4.ZWXZ = 142;
  typed_data.Int32x4.ZWXW = 206;
  typed_data.Int32x4.ZWYX = 30;
  typed_data.Int32x4.ZWYY = 94;
  typed_data.Int32x4.ZWYZ = 158;
  typed_data.Int32x4.ZWYW = 222;
  typed_data.Int32x4.ZWZX = 46;
  typed_data.Int32x4.ZWZY = 110;
  typed_data.Int32x4.ZWZZ = 174;
  typed_data.Int32x4.ZWZW = 238;
  typed_data.Int32x4.ZWWX = 62;
  typed_data.Int32x4.ZWWY = 126;
  typed_data.Int32x4.ZWWZ = 190;
  typed_data.Int32x4.ZWWW = 254;
  typed_data.Int32x4.WXXX = 3;
  typed_data.Int32x4.WXXY = 67;
  typed_data.Int32x4.WXXZ = 131;
  typed_data.Int32x4.WXXW = 195;
  typed_data.Int32x4.WXYX = 19;
  typed_data.Int32x4.WXYY = 83;
  typed_data.Int32x4.WXYZ = 147;
  typed_data.Int32x4.WXYW = 211;
  typed_data.Int32x4.WXZX = 35;
  typed_data.Int32x4.WXZY = 99;
  typed_data.Int32x4.WXZZ = 163;
  typed_data.Int32x4.WXZW = 227;
  typed_data.Int32x4.WXWX = 51;
  typed_data.Int32x4.WXWY = 115;
  typed_data.Int32x4.WXWZ = 179;
  typed_data.Int32x4.WXWW = 243;
  typed_data.Int32x4.WYXX = 7;
  typed_data.Int32x4.WYXY = 71;
  typed_data.Int32x4.WYXZ = 135;
  typed_data.Int32x4.WYXW = 199;
  typed_data.Int32x4.WYYX = 23;
  typed_data.Int32x4.WYYY = 87;
  typed_data.Int32x4.WYYZ = 151;
  typed_data.Int32x4.WYYW = 215;
  typed_data.Int32x4.WYZX = 39;
  typed_data.Int32x4.WYZY = 103;
  typed_data.Int32x4.WYZZ = 167;
  typed_data.Int32x4.WYZW = 231;
  typed_data.Int32x4.WYWX = 55;
  typed_data.Int32x4.WYWY = 119;
  typed_data.Int32x4.WYWZ = 183;
  typed_data.Int32x4.WYWW = 247;
  typed_data.Int32x4.WZXX = 11;
  typed_data.Int32x4.WZXY = 75;
  typed_data.Int32x4.WZXZ = 139;
  typed_data.Int32x4.WZXW = 203;
  typed_data.Int32x4.WZYX = 27;
  typed_data.Int32x4.WZYY = 91;
  typed_data.Int32x4.WZYZ = 155;
  typed_data.Int32x4.WZYW = 219;
  typed_data.Int32x4.WZZX = 43;
  typed_data.Int32x4.WZZY = 107;
  typed_data.Int32x4.WZZZ = 171;
  typed_data.Int32x4.WZZW = 235;
  typed_data.Int32x4.WZWX = 59;
  typed_data.Int32x4.WZWY = 123;
  typed_data.Int32x4.WZWZ = 187;
  typed_data.Int32x4.WZWW = 251;
  typed_data.Int32x4.WWXX = 15;
  typed_data.Int32x4.WWXY = 79;
  typed_data.Int32x4.WWXZ = 143;
  typed_data.Int32x4.WWXW = 207;
  typed_data.Int32x4.WWYX = 31;
  typed_data.Int32x4.WWYY = 95;
  typed_data.Int32x4.WWYZ = 159;
  typed_data.Int32x4.WWYW = 223;
  typed_data.Int32x4.WWZX = 47;
  typed_data.Int32x4.WWZY = 111;
  typed_data.Int32x4.WWZZ = 175;
  typed_data.Int32x4.WWZW = 239;
  typed_data.Int32x4.WWWX = 63;
  typed_data.Int32x4.WWWY = 127;
  typed_data.Int32x4.WWWZ = 191;
  typed_data.Int32x4.WWWW = 255;
  _native_typed_data.NativeInt32x4List = class NativeInt32x4List extends dart.mixin(core.Object, collection.ListMixin$(typed_data.Int32x4), _internal.FixedLengthListMixin$(typed_data.Int32x4)) {
    NativeInt32x4List(length) {
      this[_storage] = _native_typed_data.NativeInt32List.new(dart.notNull(length) * 4);
    }
    _externalStorage(storage) {
      this[_storage] = storage;
    }
    _slowFromList(list) {
      this[_storage] = _native_typed_data.NativeInt32List.new(dart.notNull(list[dartx.length]) * 4);
      for (let i = 0; i < dart.notNull(list[dartx.length]); i++) {
        let e = list[dartx.get](i);
        this[_storage][dartx.set](i * 4 + 0, e.x);
        this[_storage][dartx.set](i * 4 + 1, e.y);
        this[_storage][dartx.set](i * 4 + 2, e.z);
        this[_storage][dartx.set](i * 4 + 3, e.w);
      }
    }
    get runtimeType() {
      return dart.wrapType(typed_data.Int32x4List);
    }
    static fromList(list) {
      if (dart.is(list, _native_typed_data.NativeInt32x4List)) {
        return new _native_typed_data.NativeInt32x4List._externalStorage(_native_typed_data.NativeInt32List.fromList(list[_storage]));
      } else {
        return new _native_typed_data.NativeInt32x4List._slowFromList(list);
      }
    }
    get buffer() {
      return this[_storage][dartx.buffer];
    }
    get lengthInBytes() {
      return this[_storage][dartx.lengthInBytes];
    }
    get offsetInBytes() {
      return this[_storage][dartx.offsetInBytes];
    }
    get elementSizeInBytes() {
      return typed_data.Int32x4List.BYTES_PER_ELEMENT;
    }
    get length() {
      return (dart.notNull(this[_storage][dartx.length]) / 4)[dartx.truncate]();
    }
    set length(value) {
      super.length = value;
    }
    get(index) {
      _native_typed_data._checkValidIndex(index, this, this.length);
      let _x = this[_storage][dartx.get](dart.notNull(index) * 4 + 0);
      let _y = this[_storage][dartx.get](dart.notNull(index) * 4 + 1);
      let _z = this[_storage][dartx.get](dart.notNull(index) * 4 + 2);
      let _w = this[_storage][dartx.get](dart.notNull(index) * 4 + 3);
      return new _native_typed_data.NativeInt32x4._truncated(_x, _y, _z, _w);
    }
    set(index, value) {
      _native_typed_data._checkValidIndex(index, this, this.length);
      this[_storage][dartx.set](dart.notNull(index) * 4 + 0, value.x);
      this[_storage][dartx.set](dart.notNull(index) * 4 + 1, value.y);
      this[_storage][dartx.set](dart.notNull(index) * 4 + 2, value.z);
      this[_storage][dartx.set](dart.notNull(index) * 4 + 3, value.w);
      return value;
    }
    sublist(start, end) {
      if (end === void 0) end = null;
      end = _native_typed_data._checkValidRange(start, end, this.length);
      return new _native_typed_data.NativeInt32x4List._externalStorage(dart.as(this[_storage][dartx.sublist](dart.notNull(start) * 4, dart.notNull(end) * 4), typed_data.Int32List));
    }
  };
  dart.defineNamedConstructor(_native_typed_data.NativeInt32x4List, '_externalStorage');
  dart.defineNamedConstructor(_native_typed_data.NativeInt32x4List, '_slowFromList');
  _native_typed_data.NativeInt32x4List[dart.implements] = () => [typed_data.Int32x4List];
  dart.setSignature(_native_typed_data.NativeInt32x4List, {
    constructors: () => ({
      NativeInt32x4List: [_native_typed_data.NativeInt32x4List, [core.int]],
      _externalStorage: [_native_typed_data.NativeInt32x4List, [typed_data.Int32List]],
      _slowFromList: [_native_typed_data.NativeInt32x4List, [core.List$(typed_data.Int32x4)]],
      fromList: [_native_typed_data.NativeInt32x4List, [core.List$(typed_data.Int32x4)]]
    }),
    methods: () => ({
      get: [typed_data.Int32x4, [core.int]],
      set: [dart.void, [core.int, typed_data.Int32x4]],
      sublist: [core.List$(typed_data.Int32x4), [core.int], [core.int]]
    })
  });
  dart.defineExtensionMembers(_native_typed_data.NativeInt32x4List, [
    'get',
    'set',
    'sublist',
    'buffer',
    'lengthInBytes',
    'offsetInBytes',
    'elementSizeInBytes',
    'length'
  ]);
  typed_data.Float64x2 = class Float64x2 extends core.Object {
    static new(x, y) {
      return new _native_typed_data.NativeFloat64x2(x, y);
    }
    static splat(v) {
      return new _native_typed_data.NativeFloat64x2.splat(v);
    }
    static zero() {
      return new _native_typed_data.NativeFloat64x2.zero();
    }
    static fromFloat32x4(v) {
      return new _native_typed_data.NativeFloat64x2.fromFloat32x4(v);
    }
  };
  dart.setSignature(typed_data.Float64x2, {
    constructors: () => ({
      new: [typed_data.Float64x2, [core.double, core.double]],
      splat: [typed_data.Float64x2, [core.double]],
      zero: [typed_data.Float64x2, []],
      fromFloat32x4: [typed_data.Float64x2, [typed_data.Float32x4]]
    })
  });
  _native_typed_data.NativeFloat64x2List = class NativeFloat64x2List extends dart.mixin(core.Object, collection.ListMixin$(typed_data.Float64x2), _internal.FixedLengthListMixin$(typed_data.Float64x2)) {
    NativeFloat64x2List(length) {
      this[_storage] = _native_typed_data.NativeFloat64List.new(dart.notNull(length) * 2);
    }
    _externalStorage(storage) {
      this[_storage] = storage;
    }
    _slowFromList(list) {
      this[_storage] = _native_typed_data.NativeFloat64List.new(dart.notNull(list[dartx.length]) * 2);
      for (let i = 0; i < dart.notNull(list[dartx.length]); i++) {
        let e = list[dartx.get](i);
        this[_storage][dartx.set](i * 2 + 0, e.x);
        this[_storage][dartx.set](i * 2 + 1, e.y);
      }
    }
    static fromList(list) {
      if (dart.is(list, _native_typed_data.NativeFloat64x2List)) {
        return new _native_typed_data.NativeFloat64x2List._externalStorage(_native_typed_data.NativeFloat64List.fromList(list[_storage]));
      } else {
        return new _native_typed_data.NativeFloat64x2List._slowFromList(list);
      }
    }
    get runtimeType() {
      return dart.wrapType(typed_data.Float64x2List);
    }
    get buffer() {
      return this[_storage][dartx.buffer];
    }
    get lengthInBytes() {
      return this[_storage][dartx.lengthInBytes];
    }
    get offsetInBytes() {
      return this[_storage][dartx.offsetInBytes];
    }
    get elementSizeInBytes() {
      return typed_data.Float64x2List.BYTES_PER_ELEMENT;
    }
    get length() {
      return (dart.notNull(this[_storage][dartx.length]) / 2)[dartx.truncate]();
    }
    set length(value) {
      super.length = value;
    }
    get(index) {
      _native_typed_data._checkValidIndex(index, this, this.length);
      let _x = this[_storage][dartx.get](dart.notNull(index) * 2 + 0);
      let _y = this[_storage][dartx.get](dart.notNull(index) * 2 + 1);
      return typed_data.Float64x2.new(_x, _y);
    }
    set(index, value) {
      _native_typed_data._checkValidIndex(index, this, this.length);
      this[_storage][dartx.set](dart.notNull(index) * 2 + 0, value.x);
      this[_storage][dartx.set](dart.notNull(index) * 2 + 1, value.y);
      return value;
    }
    sublist(start, end) {
      if (end === void 0) end = null;
      end = _native_typed_data._checkValidRange(start, end, this.length);
      return new _native_typed_data.NativeFloat64x2List._externalStorage(dart.as(this[_storage][dartx.sublist](dart.notNull(start) * 2, dart.notNull(end) * 2), _native_typed_data.NativeFloat64List));
    }
  };
  dart.defineNamedConstructor(_native_typed_data.NativeFloat64x2List, '_externalStorage');
  dart.defineNamedConstructor(_native_typed_data.NativeFloat64x2List, '_slowFromList');
  _native_typed_data.NativeFloat64x2List[dart.implements] = () => [typed_data.Float64x2List];
  dart.setSignature(_native_typed_data.NativeFloat64x2List, {
    constructors: () => ({
      NativeFloat64x2List: [_native_typed_data.NativeFloat64x2List, [core.int]],
      _externalStorage: [_native_typed_data.NativeFloat64x2List, [_native_typed_data.NativeFloat64List]],
      _slowFromList: [_native_typed_data.NativeFloat64x2List, [core.List$(typed_data.Float64x2)]],
      fromList: [_native_typed_data.NativeFloat64x2List, [core.List$(typed_data.Float64x2)]]
    }),
    methods: () => ({
      get: [typed_data.Float64x2, [core.int]],
      set: [dart.void, [core.int, typed_data.Float64x2]],
      sublist: [core.List$(typed_data.Float64x2), [core.int], [core.int]]
    })
  });
  dart.defineExtensionMembers(_native_typed_data.NativeFloat64x2List, [
    'get',
    'set',
    'sublist',
    'buffer',
    'lengthInBytes',
    'offsetInBytes',
    'elementSizeInBytes',
    'length'
  ]);
  const _invalidPosition = Symbol('_invalidPosition');
  const _checkPosition = Symbol('_checkPosition');
  dart.defineExtensionNames([
    'buffer',
    'lengthInBytes',
    'offsetInBytes',
    'elementSizeInBytes'
  ]);
  _native_typed_data.NativeTypedData = class NativeTypedData extends core.Object {
    get [dartx.buffer]() {
      return this.buffer;
    }
    get [dartx.lengthInBytes]() {
      return this.byteLength;
    }
    get [dartx.offsetInBytes]() {
      return this.byteOffset;
    }
    get [dartx.elementSizeInBytes]() {
      return this.BYTES_PER_ELEMENT;
    }
    [_invalidPosition](position, length, name) {
      if (!(typeof position == 'number')) {
        dart.throw(new core.ArgumentError.value(position, name, 'Invalid list position'));
      } else {
        dart.throw(new core.RangeError.range(position, 0, length, name));
      }
    }
    [_checkPosition](position, length, name) {
      if (position >>> 0 !== position || position > dart.notNull(length)) {
        this[_invalidPosition](position, length, name);
      }
    }
  };
  _native_typed_data.NativeTypedData[dart.implements] = () => [typed_data.TypedData];
  dart.setSignature(_native_typed_data.NativeTypedData, {
    methods: () => ({
      [_invalidPosition]: [dart.void, [core.int, core.int, core.String]],
      [_checkPosition]: [dart.void, [core.int, core.int, core.String]]
    })
  });
  _native_typed_data.NativeTypedData[dart.metadata] = () => [dart.const(new _js_helper.Native("ArrayBufferView"))];
  dart.registerExtension(dart.global.ArrayBufferView, _native_typed_data.NativeTypedData);
  _native_typed_data._checkLength = function(length) {
    if (!(typeof length == 'number')) dart.throw(new core.ArgumentError(`Invalid length ${length}`));
    return dart.as(length, core.int);
  };
  dart.fn(_native_typed_data._checkLength, core.int, [dart.dynamic]);
  _native_typed_data._checkViewArguments = function(buffer, offsetInBytes, length) {
    if (!dart.is(buffer, _native_typed_data.NativeByteBuffer)) {
      dart.throw(new core.ArgumentError('Invalid view buffer'));
    }
    if (!(typeof offsetInBytes == 'number')) {
      dart.throw(new core.ArgumentError(`Invalid view offsetInBytes ${offsetInBytes}`));
    }
    if (length != null && !(typeof length == 'number')) {
      dart.throw(new core.ArgumentError(`Invalid view length ${length}`));
    }
  };
  dart.fn(_native_typed_data._checkViewArguments, dart.void, [dart.dynamic, dart.dynamic, dart.dynamic]);
  _native_typed_data._ensureNativeList = function(list) {
    if (dart.is(list, _interceptors.JSIndexable)) return list;
    let result = core.List.new(list[dartx.length]);
    for (let i = 0; i < dart.notNull(list[dartx.length]); i++) {
      result[dartx.set](i, list[dartx.get](i));
    }
    return result;
  };
  dart.lazyFn(_native_typed_data._ensureNativeList, () => [core.List, [core.List]]);
  const _getFloat32 = Symbol('_getFloat32');
  const _getFloat64 = Symbol('_getFloat64');
  const _getInt16 = Symbol('_getInt16');
  const _getInt32 = Symbol('_getInt32');
  const _getUint16 = Symbol('_getUint16');
  const _getUint32 = Symbol('_getUint32');
  const _setFloat32 = Symbol('_setFloat32');
  const _setFloat64 = Symbol('_setFloat64');
  const _setInt16 = Symbol('_setInt16');
  const _setInt32 = Symbol('_setInt32');
  const _setUint16 = Symbol('_setUint16');
  const _setUint32 = Symbol('_setUint32');
  dart.defineExtensionNames([
    'runtimeType',
    'elementSizeInBytes',
    'getFloat32',
    'getFloat64',
    'getInt16',
    'getInt32',
    'getInt64',
    'getInt8',
    'getUint16',
    'getUint32',
    'getUint64',
    'getUint8',
    'setFloat32',
    'setFloat64',
    'setInt16',
    'setInt32',
    'setInt64',
    'setInt8',
    'setUint16',
    'setUint32',
    'setUint64',
    'setUint8'
  ]);
  _native_typed_data.NativeByteData = class NativeByteData extends _native_typed_data.NativeTypedData {
    static new(length) {
      return _native_typed_data.NativeByteData._create1(_native_typed_data._checkLength(length));
    }
    static view(buffer, offsetInBytes, length) {
      _native_typed_data._checkViewArguments(buffer, offsetInBytes, length);
      return length == null ? _native_typed_data.NativeByteData._create2(buffer, offsetInBytes) : _native_typed_data.NativeByteData._create3(buffer, offsetInBytes, length);
    }
    get [dartx.runtimeType]() {
      return dart.wrapType(typed_data.ByteData);
    }
    get [dartx.elementSizeInBytes]() {
      return 1;
    }
    [dartx.getFloat32](byteOffset, endian) {
      if (endian === void 0) endian = typed_data.Endianness.BIG_ENDIAN;
      return this[_getFloat32](byteOffset, dart.equals(typed_data.Endianness.LITTLE_ENDIAN, endian));
    }
    [_getFloat32](byteOffset, littleEndian) {
      return this.getFloat32(byteOffset, littleEndian);
    }
    [dartx.getFloat64](byteOffset, endian) {
      if (endian === void 0) endian = typed_data.Endianness.BIG_ENDIAN;
      return this[_getFloat64](byteOffset, dart.equals(typed_data.Endianness.LITTLE_ENDIAN, endian));
    }
    [_getFloat64](byteOffset, littleEndian) {
      return this.getFloat64(byteOffset, littleEndian);
    }
    [dartx.getInt16](byteOffset, endian) {
      if (endian === void 0) endian = typed_data.Endianness.BIG_ENDIAN;
      return this[_getInt16](byteOffset, dart.equals(typed_data.Endianness.LITTLE_ENDIAN, endian));
    }
    [_getInt16](byteOffset, littleEndian) {
      return this.getInt16(byteOffset, littleEndian);
    }
    [dartx.getInt32](byteOffset, endian) {
      if (endian === void 0) endian = typed_data.Endianness.BIG_ENDIAN;
      return this[_getInt32](byteOffset, dart.equals(typed_data.Endianness.LITTLE_ENDIAN, endian));
    }
    [_getInt32](byteOffset, littleEndian) {
      return this.getInt32(byteOffset, littleEndian);
    }
    [dartx.getInt64](byteOffset, endian) {
      if (endian === void 0) endian = typed_data.Endianness.BIG_ENDIAN;
      dart.throw(new core.UnsupportedError('Int64 accessor not supported by dart2js.'));
    }
    [dartx.getInt8](byteOffset) {
      return this.getInt8(byteOffset);
    }
    [dartx.getUint16](byteOffset, endian) {
      if (endian === void 0) endian = typed_data.Endianness.BIG_ENDIAN;
      return this[_getUint16](byteOffset, dart.equals(typed_data.Endianness.LITTLE_ENDIAN, endian));
    }
    [_getUint16](byteOffset, littleEndian) {
      return this.getUint16(byteOffset, littleEndian);
    }
    [dartx.getUint32](byteOffset, endian) {
      if (endian === void 0) endian = typed_data.Endianness.BIG_ENDIAN;
      return this[_getUint32](byteOffset, dart.equals(typed_data.Endianness.LITTLE_ENDIAN, endian));
    }
    [_getUint32](byteOffset, littleEndian) {
      return this.getUint32(byteOffset, littleEndian);
    }
    [dartx.getUint64](byteOffset, endian) {
      if (endian === void 0) endian = typed_data.Endianness.BIG_ENDIAN;
      dart.throw(new core.UnsupportedError('Uint64 accessor not supported by dart2js.'));
    }
    [dartx.getUint8](byteOffset) {
      return this.getUint8(byteOffset);
    }
    [dartx.setFloat32](byteOffset, value, endian) {
      if (endian === void 0) endian = typed_data.Endianness.BIG_ENDIAN;
      return this[_setFloat32](byteOffset, value, dart.equals(typed_data.Endianness.LITTLE_ENDIAN, endian));
    }
    [_setFloat32](byteOffset, value, littleEndian) {
      return this.setFloat32(byteOffset, value, littleEndian);
    }
    [dartx.setFloat64](byteOffset, value, endian) {
      if (endian === void 0) endian = typed_data.Endianness.BIG_ENDIAN;
      return this[_setFloat64](byteOffset, value, dart.equals(typed_data.Endianness.LITTLE_ENDIAN, endian));
    }
    [_setFloat64](byteOffset, value, littleEndian) {
      return this.setFloat64(byteOffset, value, littleEndian);
    }
    [dartx.setInt16](byteOffset, value, endian) {
      if (endian === void 0) endian = typed_data.Endianness.BIG_ENDIAN;
      return this[_setInt16](byteOffset, value, dart.equals(typed_data.Endianness.LITTLE_ENDIAN, endian));
    }
    [_setInt16](byteOffset, value, littleEndian) {
      return this.setInt16(byteOffset, value, littleEndian);
    }
    [dartx.setInt32](byteOffset, value, endian) {
      if (endian === void 0) endian = typed_data.Endianness.BIG_ENDIAN;
      return this[_setInt32](byteOffset, value, dart.equals(typed_data.Endianness.LITTLE_ENDIAN, endian));
    }
    [_setInt32](byteOffset, value, littleEndian) {
      return this.setInt32(byteOffset, value, littleEndian);
    }
    [dartx.setInt64](byteOffset, value, endian) {
      if (endian === void 0) endian = typed_data.Endianness.BIG_ENDIAN;
      dart.throw(new core.UnsupportedError('Int64 accessor not supported by dart2js.'));
    }
    [dartx.setInt8](byteOffset, value) {
      return this.setInt8(byteOffset, value);
    }
    [dartx.setUint16](byteOffset, value, endian) {
      if (endian === void 0) endian = typed_data.Endianness.BIG_ENDIAN;
      return this[_setUint16](byteOffset, value, dart.equals(typed_data.Endianness.LITTLE_ENDIAN, endian));
    }
    [_setUint16](byteOffset, value, littleEndian) {
      return this.setUint16(byteOffset, value, littleEndian);
    }
    [dartx.setUint32](byteOffset, value, endian) {
      if (endian === void 0) endian = typed_data.Endianness.BIG_ENDIAN;
      return this[_setUint32](byteOffset, value, dart.equals(typed_data.Endianness.LITTLE_ENDIAN, endian));
    }
    [_setUint32](byteOffset, value, littleEndian) {
      return this.setUint32(byteOffset, value, littleEndian);
    }
    [dartx.setUint64](byteOffset, value, endian) {
      if (endian === void 0) endian = typed_data.Endianness.BIG_ENDIAN;
      dart.throw(new core.UnsupportedError('Uint64 accessor not supported by dart2js.'));
    }
    [dartx.setUint8](byteOffset, value) {
      return this.setUint8(byteOffset, value);
    }
    static _create1(arg) {
      return new DataView(new ArrayBuffer(arg));
    }
    static _create2(arg1, arg2) {
      return new DataView(arg1, arg2);
    }
    static _create3(arg1, arg2, arg3) {
      return new DataView(arg1, arg2, arg3);
    }
  };
  _native_typed_data.NativeByteData[dart.implements] = () => [typed_data.ByteData];
  dart.setSignature(_native_typed_data.NativeByteData, {
    constructors: () => ({
      new: [_native_typed_data.NativeByteData, [core.int]],
      view: [_native_typed_data.NativeByteData, [typed_data.ByteBuffer, core.int, core.int]]
    }),
    methods: () => ({
      [dartx.getFloat32]: [core.double, [core.int], [typed_data.Endianness]],
      [_getFloat32]: [core.double, [core.int], [core.bool]],
      [dartx.getFloat64]: [core.double, [core.int], [typed_data.Endianness]],
      [_getFloat64]: [core.double, [core.int], [core.bool]],
      [dartx.getInt16]: [core.int, [core.int], [typed_data.Endianness]],
      [_getInt16]: [core.int, [core.int], [core.bool]],
      [dartx.getInt32]: [core.int, [core.int], [typed_data.Endianness]],
      [_getInt32]: [core.int, [core.int], [core.bool]],
      [dartx.getInt64]: [core.int, [core.int], [typed_data.Endianness]],
      [dartx.getInt8]: [core.int, [core.int]],
      [dartx.getUint16]: [core.int, [core.int], [typed_data.Endianness]],
      [_getUint16]: [core.int, [core.int], [core.bool]],
      [dartx.getUint32]: [core.int, [core.int], [typed_data.Endianness]],
      [_getUint32]: [core.int, [core.int], [core.bool]],
      [dartx.getUint64]: [core.int, [core.int], [typed_data.Endianness]],
      [dartx.getUint8]: [core.int, [core.int]],
      [dartx.setFloat32]: [dart.void, [core.int, core.num], [typed_data.Endianness]],
      [_setFloat32]: [dart.void, [core.int, core.num], [core.bool]],
      [dartx.setFloat64]: [dart.void, [core.int, core.num], [typed_data.Endianness]],
      [_setFloat64]: [dart.void, [core.int, core.num], [core.bool]],
      [dartx.setInt16]: [dart.void, [core.int, core.int], [typed_data.Endianness]],
      [_setInt16]: [dart.void, [core.int, core.int], [core.bool]],
      [dartx.setInt32]: [dart.void, [core.int, core.int], [typed_data.Endianness]],
      [_setInt32]: [dart.void, [core.int, core.int], [core.bool]],
      [dartx.setInt64]: [dart.void, [core.int, core.int], [typed_data.Endianness]],
      [dartx.setInt8]: [dart.void, [core.int, core.int]],
      [dartx.setUint16]: [dart.void, [core.int, core.int], [typed_data.Endianness]],
      [_setUint16]: [dart.void, [core.int, core.int], [core.bool]],
      [dartx.setUint32]: [dart.void, [core.int, core.int], [typed_data.Endianness]],
      [_setUint32]: [dart.void, [core.int, core.int], [core.bool]],
      [dartx.setUint64]: [dart.void, [core.int, core.int], [typed_data.Endianness]],
      [dartx.setUint8]: [dart.void, [core.int, core.int]]
    }),
    statics: () => ({
      _create1: [_native_typed_data.NativeByteData, [dart.dynamic]],
      _create2: [_native_typed_data.NativeByteData, [dart.dynamic, dart.dynamic]],
      _create3: [_native_typed_data.NativeByteData, [dart.dynamic, dart.dynamic, dart.dynamic]]
    }),
    names: ['_create1', '_create2', '_create3']
  });
  _native_typed_data.NativeByteData[dart.metadata] = () => [dart.const(new _js_helper.Native("DataView"))];
  dart.registerExtension(dart.global.DataView, _native_typed_data.NativeByteData);
  const _setRangeFast = Symbol('_setRangeFast');
  _native_typed_data.NativeTypedArray = class NativeTypedArray extends _native_typed_data.NativeTypedData {
    [_setRangeFast](start, end, source, skipCount) {
      let targetLength = this[dartx.length];
      this[_checkPosition](start, targetLength, "start");
      this[_checkPosition](end, targetLength, "end");
      if (dart.notNull(start) > dart.notNull(end)) dart.throw(new core.RangeError.range(start, 0, end));
      let count = dart.notNull(end) - dart.notNull(start);
      if (dart.notNull(skipCount) < 0) dart.throw(new core.ArgumentError(skipCount));
      let sourceLength = source[dartx.length];
      if (dart.notNull(sourceLength) - dart.notNull(skipCount) < count) {
        dart.throw(new core.StateError('Not enough elements'));
      }
      if (skipCount != 0 || sourceLength != count) {
        source = source.subarray(skipCount, dart.notNull(skipCount) + count);
      }
      this.set(source, start);
    }
  };
  _native_typed_data.NativeTypedArray[dart.implements] = () => [_js_helper.JavaScriptIndexingBehavior];
  dart.setSignature(_native_typed_data.NativeTypedArray, {
    methods: () => ({[_setRangeFast]: [dart.void, [core.int, core.int, _native_typed_data.NativeTypedArray, core.int]]})
  });
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'setRange'
  ]);
  _native_typed_data.NativeTypedArrayOfDouble = class NativeTypedArrayOfDouble extends dart.mixin(_native_typed_data.NativeTypedArray, collection.ListMixin$(core.double), _internal.FixedLengthListMixin$(core.double)) {
    get length() {
      return this.length;
    }
    set length(value) {
      super.length = value;
    }
    get(index) {
      _native_typed_data._checkValidIndex(index, this, this[dartx.length]);
      return this[index];
    }
    set(index, value) {
      _native_typed_data._checkValidIndex(index, this, this[dartx.length]);
      this[index] = value;
      return value;
    }
    setRange(start, end, iterable, skipCount) {
      if (skipCount === void 0) skipCount = 0;
      if (dart.is(iterable, _native_typed_data.NativeTypedArrayOfDouble)) {
        this[_setRangeFast](start, end, iterable, skipCount);
        return;
      }
      super[dartx.setRange](start, end, iterable, skipCount);
    }
  };
  dart.setSignature(_native_typed_data.NativeTypedArrayOfDouble, {
    methods: () => ({
      get: [core.double, [core.int]],
      set: [dart.void, [core.int, core.num]],
      setRange: [dart.void, [core.int, core.int, core.Iterable$(core.double)], [core.int]]
    })
  });
  dart.defineExtensionMembers(_native_typed_data.NativeTypedArrayOfDouble, ['get', 'set', 'setRange', 'length']);
  dart.defineExtensionNames([
    'length',
    'set',
    'setRange'
  ]);
  _native_typed_data.NativeTypedArrayOfInt = class NativeTypedArrayOfInt extends dart.mixin(_native_typed_data.NativeTypedArray, collection.ListMixin$(core.int), _internal.FixedLengthListMixin$(core.int)) {
    get length() {
      return this.length;
    }
    set length(value) {
      super.length = value;
    }
    set(index, value) {
      _native_typed_data._checkValidIndex(index, this, this[dartx.length]);
      this[index] = value;
      return value;
    }
    setRange(start, end, iterable, skipCount) {
      if (skipCount === void 0) skipCount = 0;
      if (dart.is(iterable, _native_typed_data.NativeTypedArrayOfInt)) {
        this[_setRangeFast](start, end, iterable, skipCount);
        return;
      }
      super[dartx.setRange](start, end, iterable, skipCount);
    }
  };
  _native_typed_data.NativeTypedArrayOfInt[dart.implements] = () => [core.List$(core.int)];
  dart.setSignature(_native_typed_data.NativeTypedArrayOfInt, {
    methods: () => ({
      set: [dart.void, [core.int, core.int]],
      setRange: [dart.void, [core.int, core.int, core.Iterable$(core.int)], [core.int]]
    })
  });
  dart.defineExtensionMembers(_native_typed_data.NativeTypedArrayOfInt, ['set', 'setRange', 'length']);
  dart.defineExtensionNames([
    'runtimeType',
    'sublist'
  ]);
  _native_typed_data.NativeFloat32List = class NativeFloat32List extends _native_typed_data.NativeTypedArrayOfDouble {
    static new(length) {
      return _native_typed_data.NativeFloat32List._create1(_native_typed_data._checkLength(length));
    }
    static fromList(elements) {
      return _native_typed_data.NativeFloat32List._create1(_native_typed_data._ensureNativeList(elements));
    }
    static view(buffer, offsetInBytes, length) {
      _native_typed_data._checkViewArguments(buffer, offsetInBytes, length);
      return length == null ? _native_typed_data.NativeFloat32List._create2(buffer, offsetInBytes) : _native_typed_data.NativeFloat32List._create3(buffer, offsetInBytes, length);
    }
    get [dartx.runtimeType]() {
      return dart.wrapType(typed_data.Float32List);
    }
    [dartx.sublist](start, end) {
      if (end === void 0) end = null;
      end = _native_typed_data._checkValidRange(start, end, this[dartx.length]);
      let source = this.subarray(start, end);
      return _native_typed_data.NativeFloat32List._create1(source);
    }
    static _create1(arg) {
      return new Float32Array(arg);
    }
    static _create2(arg1, arg2) {
      return new Float32Array(arg1, arg2);
    }
    static _create3(arg1, arg2, arg3) {
      return new Float32Array(arg1, arg2, arg3);
    }
  };
  _native_typed_data.NativeFloat32List[dart.implements] = () => [typed_data.Float32List];
  dart.setSignature(_native_typed_data.NativeFloat32List, {
    constructors: () => ({
      new: [_native_typed_data.NativeFloat32List, [core.int]],
      fromList: [_native_typed_data.NativeFloat32List, [core.List$(core.double)]],
      view: [_native_typed_data.NativeFloat32List, [typed_data.ByteBuffer, core.int, core.int]]
    }),
    methods: () => ({[dartx.sublist]: [core.List$(core.double), [core.int], [core.int]]}),
    statics: () => ({
      _create1: [_native_typed_data.NativeFloat32List, [dart.dynamic]],
      _create2: [_native_typed_data.NativeFloat32List, [dart.dynamic, dart.dynamic]],
      _create3: [_native_typed_data.NativeFloat32List, [dart.dynamic, dart.dynamic, dart.dynamic]]
    }),
    names: ['_create1', '_create2', '_create3']
  });
  _native_typed_data.NativeFloat32List[dart.metadata] = () => [dart.const(new _js_helper.Native("Float32Array"))];
  dart.registerExtension(dart.global.Float32Array, _native_typed_data.NativeFloat32List);
  dart.defineExtensionNames([
    'runtimeType',
    'sublist'
  ]);
  _native_typed_data.NativeFloat64List = class NativeFloat64List extends _native_typed_data.NativeTypedArrayOfDouble {
    static new(length) {
      return _native_typed_data.NativeFloat64List._create1(_native_typed_data._checkLength(length));
    }
    static fromList(elements) {
      return _native_typed_data.NativeFloat64List._create1(_native_typed_data._ensureNativeList(elements));
    }
    static view(buffer, offsetInBytes, length) {
      _native_typed_data._checkViewArguments(buffer, offsetInBytes, length);
      return length == null ? _native_typed_data.NativeFloat64List._create2(buffer, offsetInBytes) : _native_typed_data.NativeFloat64List._create3(buffer, offsetInBytes, length);
    }
    get [dartx.runtimeType]() {
      return dart.wrapType(typed_data.Float64List);
    }
    [dartx.sublist](start, end) {
      if (end === void 0) end = null;
      end = _native_typed_data._checkValidRange(start, end, this[dartx.length]);
      let source = this.subarray(start, end);
      return _native_typed_data.NativeFloat64List._create1(source);
    }
    static _create1(arg) {
      return new Float64Array(arg);
    }
    static _create2(arg1, arg2) {
      return new Float64Array(arg1, arg2);
    }
    static _create3(arg1, arg2, arg3) {
      return new Float64Array(arg1, arg2, arg3);
    }
  };
  _native_typed_data.NativeFloat64List[dart.implements] = () => [typed_data.Float64List];
  dart.setSignature(_native_typed_data.NativeFloat64List, {
    constructors: () => ({
      new: [_native_typed_data.NativeFloat64List, [core.int]],
      fromList: [_native_typed_data.NativeFloat64List, [core.List$(core.double)]],
      view: [_native_typed_data.NativeFloat64List, [typed_data.ByteBuffer, core.int, core.int]]
    }),
    methods: () => ({[dartx.sublist]: [core.List$(core.double), [core.int], [core.int]]}),
    statics: () => ({
      _create1: [_native_typed_data.NativeFloat64List, [dart.dynamic]],
      _create2: [_native_typed_data.NativeFloat64List, [dart.dynamic, dart.dynamic]],
      _create3: [_native_typed_data.NativeFloat64List, [dart.dynamic, dart.dynamic, dart.dynamic]]
    }),
    names: ['_create1', '_create2', '_create3']
  });
  _native_typed_data.NativeFloat64List[dart.metadata] = () => [dart.const(new _js_helper.Native("Float64Array"))];
  dart.registerExtension(dart.global.Float64Array, _native_typed_data.NativeFloat64List);
  dart.defineExtensionNames([
    'runtimeType',
    'get',
    'sublist'
  ]);
  _native_typed_data.NativeInt16List = class NativeInt16List extends _native_typed_data.NativeTypedArrayOfInt {
    static new(length) {
      return _native_typed_data.NativeInt16List._create1(_native_typed_data._checkLength(length));
    }
    static fromList(elements) {
      return _native_typed_data.NativeInt16List._create1(_native_typed_data._ensureNativeList(elements));
    }
    static view(buffer, offsetInBytes, length) {
      _native_typed_data._checkViewArguments(buffer, offsetInBytes, length);
      return length == null ? _native_typed_data.NativeInt16List._create2(buffer, offsetInBytes) : _native_typed_data.NativeInt16List._create3(buffer, offsetInBytes, length);
    }
    get [dartx.runtimeType]() {
      return dart.wrapType(typed_data.Int16List);
    }
    [dartx.get](index) {
      _native_typed_data._checkValidIndex(index, this, this[dartx.length]);
      return this[index];
    }
    [dartx.sublist](start, end) {
      if (end === void 0) end = null;
      end = _native_typed_data._checkValidRange(start, end, this[dartx.length]);
      let source = this.subarray(start, end);
      return _native_typed_data.NativeInt16List._create1(source);
    }
    static _create1(arg) {
      return new Int16Array(arg);
    }
    static _create2(arg1, arg2) {
      return new Int16Array(arg1, arg2);
    }
    static _create3(arg1, arg2, arg3) {
      return new Int16Array(arg1, arg2, arg3);
    }
  };
  _native_typed_data.NativeInt16List[dart.implements] = () => [typed_data.Int16List];
  dart.setSignature(_native_typed_data.NativeInt16List, {
    constructors: () => ({
      new: [_native_typed_data.NativeInt16List, [core.int]],
      fromList: [_native_typed_data.NativeInt16List, [core.List$(core.int)]],
      view: [_native_typed_data.NativeInt16List, [_native_typed_data.NativeByteBuffer, core.int, core.int]]
    }),
    methods: () => ({
      [dartx.get]: [core.int, [core.int]],
      [dartx.sublist]: [core.List$(core.int), [core.int], [core.int]]
    }),
    statics: () => ({
      _create1: [_native_typed_data.NativeInt16List, [dart.dynamic]],
      _create2: [_native_typed_data.NativeInt16List, [dart.dynamic, dart.dynamic]],
      _create3: [_native_typed_data.NativeInt16List, [dart.dynamic, dart.dynamic, dart.dynamic]]
    }),
    names: ['_create1', '_create2', '_create3']
  });
  _native_typed_data.NativeInt16List[dart.metadata] = () => [dart.const(new _js_helper.Native("Int16Array"))];
  dart.registerExtension(dart.global.Int16Array, _native_typed_data.NativeInt16List);
  dart.defineExtensionNames([
    'runtimeType',
    'get',
    'sublist'
  ]);
  _native_typed_data.NativeInt32List = class NativeInt32List extends _native_typed_data.NativeTypedArrayOfInt {
    static new(length) {
      return _native_typed_data.NativeInt32List._create1(_native_typed_data._checkLength(length));
    }
    static fromList(elements) {
      return _native_typed_data.NativeInt32List._create1(_native_typed_data._ensureNativeList(elements));
    }
    static view(buffer, offsetInBytes, length) {
      _native_typed_data._checkViewArguments(buffer, offsetInBytes, length);
      return length == null ? _native_typed_data.NativeInt32List._create2(buffer, offsetInBytes) : _native_typed_data.NativeInt32List._create3(buffer, offsetInBytes, length);
    }
    get [dartx.runtimeType]() {
      return dart.wrapType(typed_data.Int32List);
    }
    [dartx.get](index) {
      _native_typed_data._checkValidIndex(index, this, this[dartx.length]);
      return this[index];
    }
    [dartx.sublist](start, end) {
      if (end === void 0) end = null;
      end = _native_typed_data._checkValidRange(start, end, this[dartx.length]);
      let source = this.subarray(start, end);
      return _native_typed_data.NativeInt32List._create1(source);
    }
    static _create1(arg) {
      return new Int32Array(arg);
    }
    static _create2(arg1, arg2) {
      return new Int32Array(arg1, arg2);
    }
    static _create3(arg1, arg2, arg3) {
      return new Int32Array(arg1, arg2, arg3);
    }
  };
  _native_typed_data.NativeInt32List[dart.implements] = () => [typed_data.Int32List];
  dart.setSignature(_native_typed_data.NativeInt32List, {
    constructors: () => ({
      new: [_native_typed_data.NativeInt32List, [core.int]],
      fromList: [_native_typed_data.NativeInt32List, [core.List$(core.int)]],
      view: [_native_typed_data.NativeInt32List, [typed_data.ByteBuffer, core.int, core.int]]
    }),
    methods: () => ({
      [dartx.get]: [core.int, [core.int]],
      [dartx.sublist]: [core.List$(core.int), [core.int], [core.int]]
    }),
    statics: () => ({
      _create1: [_native_typed_data.NativeInt32List, [dart.dynamic]],
      _create2: [_native_typed_data.NativeInt32List, [dart.dynamic, dart.dynamic]],
      _create3: [_native_typed_data.NativeInt32List, [dart.dynamic, dart.dynamic, dart.dynamic]]
    }),
    names: ['_create1', '_create2', '_create3']
  });
  _native_typed_data.NativeInt32List[dart.metadata] = () => [dart.const(new _js_helper.Native("Int32Array"))];
  dart.registerExtension(dart.global.Int32Array, _native_typed_data.NativeInt32List);
  dart.defineExtensionNames([
    'runtimeType',
    'get',
    'sublist'
  ]);
  _native_typed_data.NativeInt8List = class NativeInt8List extends _native_typed_data.NativeTypedArrayOfInt {
    static new(length) {
      return _native_typed_data.NativeInt8List._create1(_native_typed_data._checkLength(length));
    }
    static fromList(elements) {
      return _native_typed_data.NativeInt8List._create1(_native_typed_data._ensureNativeList(elements));
    }
    static view(buffer, offsetInBytes, length) {
      _native_typed_data._checkViewArguments(buffer, offsetInBytes, length);
      return dart.as(length == null ? _native_typed_data.NativeInt8List._create2(buffer, offsetInBytes) : _native_typed_data.NativeInt8List._create3(buffer, offsetInBytes, length), _native_typed_data.NativeInt8List);
    }
    get [dartx.runtimeType]() {
      return dart.wrapType(typed_data.Int8List);
    }
    [dartx.get](index) {
      _native_typed_data._checkValidIndex(index, this, this[dartx.length]);
      return this[index];
    }
    [dartx.sublist](start, end) {
      if (end === void 0) end = null;
      end = _native_typed_data._checkValidRange(start, end, this[dartx.length]);
      let source = this.subarray(start, end);
      return _native_typed_data.NativeInt8List._create1(source);
    }
    static _create1(arg) {
      return new Int8Array(arg);
    }
    static _create2(arg1, arg2) {
      return new Int8Array(arg1, arg2);
    }
    static _create3(arg1, arg2, arg3) {
      return new Int8Array(arg1, arg2, arg3);
    }
  };
  _native_typed_data.NativeInt8List[dart.implements] = () => [typed_data.Int8List];
  dart.setSignature(_native_typed_data.NativeInt8List, {
    constructors: () => ({
      new: [_native_typed_data.NativeInt8List, [core.int]],
      fromList: [_native_typed_data.NativeInt8List, [core.List$(core.int)]],
      view: [_native_typed_data.NativeInt8List, [typed_data.ByteBuffer, core.int, core.int]]
    }),
    methods: () => ({
      [dartx.get]: [core.int, [core.int]],
      [dartx.sublist]: [core.List$(core.int), [core.int], [core.int]]
    }),
    statics: () => ({
      _create1: [_native_typed_data.NativeInt8List, [dart.dynamic]],
      _create2: [_native_typed_data.NativeInt8List, [dart.dynamic, dart.dynamic]],
      _create3: [typed_data.Int8List, [dart.dynamic, dart.dynamic, dart.dynamic]]
    }),
    names: ['_create1', '_create2', '_create3']
  });
  _native_typed_data.NativeInt8List[dart.metadata] = () => [dart.const(new _js_helper.Native("Int8Array"))];
  dart.registerExtension(dart.global.Int8Array, _native_typed_data.NativeInt8List);
  dart.defineExtensionNames([
    'runtimeType',
    'get',
    'sublist'
  ]);
  _native_typed_data.NativeUint16List = class NativeUint16List extends _native_typed_data.NativeTypedArrayOfInt {
    static new(length) {
      return _native_typed_data.NativeUint16List._create1(_native_typed_data._checkLength(length));
    }
    static fromList(list) {
      return _native_typed_data.NativeUint16List._create1(_native_typed_data._ensureNativeList(list));
    }
    static view(buffer, offsetInBytes, length) {
      _native_typed_data._checkViewArguments(buffer, offsetInBytes, length);
      return length == null ? _native_typed_data.NativeUint16List._create2(buffer, offsetInBytes) : _native_typed_data.NativeUint16List._create3(buffer, offsetInBytes, length);
    }
    get [dartx.runtimeType]() {
      return dart.wrapType(typed_data.Uint16List);
    }
    [dartx.get](index) {
      _native_typed_data._checkValidIndex(index, this, this[dartx.length]);
      return this[index];
    }
    [dartx.sublist](start, end) {
      if (end === void 0) end = null;
      end = _native_typed_data._checkValidRange(start, end, this[dartx.length]);
      let source = this.subarray(start, end);
      return _native_typed_data.NativeUint16List._create1(source);
    }
    static _create1(arg) {
      return new Uint16Array(arg);
    }
    static _create2(arg1, arg2) {
      return new Uint16Array(arg1, arg2);
    }
    static _create3(arg1, arg2, arg3) {
      return new Uint16Array(arg1, arg2, arg3);
    }
  };
  _native_typed_data.NativeUint16List[dart.implements] = () => [typed_data.Uint16List];
  dart.setSignature(_native_typed_data.NativeUint16List, {
    constructors: () => ({
      new: [_native_typed_data.NativeUint16List, [core.int]],
      fromList: [_native_typed_data.NativeUint16List, [core.List$(core.int)]],
      view: [_native_typed_data.NativeUint16List, [typed_data.ByteBuffer, core.int, core.int]]
    }),
    methods: () => ({
      [dartx.get]: [core.int, [core.int]],
      [dartx.sublist]: [core.List$(core.int), [core.int], [core.int]]
    }),
    statics: () => ({
      _create1: [_native_typed_data.NativeUint16List, [dart.dynamic]],
      _create2: [_native_typed_data.NativeUint16List, [dart.dynamic, dart.dynamic]],
      _create3: [_native_typed_data.NativeUint16List, [dart.dynamic, dart.dynamic, dart.dynamic]]
    }),
    names: ['_create1', '_create2', '_create3']
  });
  _native_typed_data.NativeUint16List[dart.metadata] = () => [dart.const(new _js_helper.Native("Uint16Array"))];
  dart.registerExtension(dart.global.Uint16Array, _native_typed_data.NativeUint16List);
  dart.defineExtensionNames([
    'runtimeType',
    'get',
    'sublist'
  ]);
  _native_typed_data.NativeUint32List = class NativeUint32List extends _native_typed_data.NativeTypedArrayOfInt {
    static new(length) {
      return _native_typed_data.NativeUint32List._create1(_native_typed_data._checkLength(length));
    }
    static fromList(elements) {
      return _native_typed_data.NativeUint32List._create1(_native_typed_data._ensureNativeList(elements));
    }
    static view(buffer, offsetInBytes, length) {
      _native_typed_data._checkViewArguments(buffer, offsetInBytes, length);
      return length == null ? _native_typed_data.NativeUint32List._create2(buffer, offsetInBytes) : _native_typed_data.NativeUint32List._create3(buffer, offsetInBytes, length);
    }
    get [dartx.runtimeType]() {
      return dart.wrapType(typed_data.Uint32List);
    }
    [dartx.get](index) {
      _native_typed_data._checkValidIndex(index, this, this[dartx.length]);
      return this[index];
    }
    [dartx.sublist](start, end) {
      if (end === void 0) end = null;
      end = _native_typed_data._checkValidRange(start, end, this[dartx.length]);
      let source = this.subarray(start, end);
      return _native_typed_data.NativeUint32List._create1(source);
    }
    static _create1(arg) {
      return new Uint32Array(arg);
    }
    static _create2(arg1, arg2) {
      return new Uint32Array(arg1, arg2);
    }
    static _create3(arg1, arg2, arg3) {
      return new Uint32Array(arg1, arg2, arg3);
    }
  };
  _native_typed_data.NativeUint32List[dart.implements] = () => [typed_data.Uint32List];
  dart.setSignature(_native_typed_data.NativeUint32List, {
    constructors: () => ({
      new: [_native_typed_data.NativeUint32List, [core.int]],
      fromList: [_native_typed_data.NativeUint32List, [core.List$(core.int)]],
      view: [_native_typed_data.NativeUint32List, [typed_data.ByteBuffer, core.int, core.int]]
    }),
    methods: () => ({
      [dartx.get]: [core.int, [core.int]],
      [dartx.sublist]: [core.List$(core.int), [core.int], [core.int]]
    }),
    statics: () => ({
      _create1: [_native_typed_data.NativeUint32List, [dart.dynamic]],
      _create2: [_native_typed_data.NativeUint32List, [dart.dynamic, dart.dynamic]],
      _create3: [_native_typed_data.NativeUint32List, [dart.dynamic, dart.dynamic, dart.dynamic]]
    }),
    names: ['_create1', '_create2', '_create3']
  });
  _native_typed_data.NativeUint32List[dart.metadata] = () => [dart.const(new _js_helper.Native("Uint32Array"))];
  dart.registerExtension(dart.global.Uint32Array, _native_typed_data.NativeUint32List);
  dart.defineExtensionNames([
    'runtimeType',
    'length',
    'get',
    'sublist'
  ]);
  _native_typed_data.NativeUint8ClampedList = class NativeUint8ClampedList extends _native_typed_data.NativeTypedArrayOfInt {
    static new(length) {
      return _native_typed_data.NativeUint8ClampedList._create1(_native_typed_data._checkLength(length));
    }
    static fromList(elements) {
      return _native_typed_data.NativeUint8ClampedList._create1(_native_typed_data._ensureNativeList(elements));
    }
    static view(buffer, offsetInBytes, length) {
      _native_typed_data._checkViewArguments(buffer, offsetInBytes, length);
      return length == null ? _native_typed_data.NativeUint8ClampedList._create2(buffer, offsetInBytes) : _native_typed_data.NativeUint8ClampedList._create3(buffer, offsetInBytes, length);
    }
    get [dartx.runtimeType]() {
      return dart.wrapType(typed_data.Uint8ClampedList);
    }
    get [dartx.length]() {
      return this.length;
    }
    set [dartx.length](value) {
      super[dartx.length] = value;
    }
    [dartx.get](index) {
      _native_typed_data._checkValidIndex(index, this, this[dartx.length]);
      return this[index];
    }
    [dartx.sublist](start, end) {
      if (end === void 0) end = null;
      end = _native_typed_data._checkValidRange(start, end, this[dartx.length]);
      let source = this.subarray(start, end);
      return _native_typed_data.NativeUint8ClampedList._create1(source);
    }
    static _create1(arg) {
      return new Uint8ClampedArray(arg);
    }
    static _create2(arg1, arg2) {
      return new Uint8ClampedArray(arg1, arg2);
    }
    static _create3(arg1, arg2, arg3) {
      return new Uint8ClampedArray(arg1, arg2, arg3);
    }
  };
  _native_typed_data.NativeUint8ClampedList[dart.implements] = () => [typed_data.Uint8ClampedList];
  dart.setSignature(_native_typed_data.NativeUint8ClampedList, {
    constructors: () => ({
      new: [_native_typed_data.NativeUint8ClampedList, [core.int]],
      fromList: [_native_typed_data.NativeUint8ClampedList, [core.List$(core.int)]],
      view: [_native_typed_data.NativeUint8ClampedList, [typed_data.ByteBuffer, core.int, core.int]]
    }),
    methods: () => ({
      [dartx.get]: [core.int, [core.int]],
      [dartx.sublist]: [core.List$(core.int), [core.int], [core.int]]
    }),
    statics: () => ({
      _create1: [_native_typed_data.NativeUint8ClampedList, [dart.dynamic]],
      _create2: [_native_typed_data.NativeUint8ClampedList, [dart.dynamic, dart.dynamic]],
      _create3: [_native_typed_data.NativeUint8ClampedList, [dart.dynamic, dart.dynamic, dart.dynamic]]
    }),
    names: ['_create1', '_create2', '_create3']
  });
  _native_typed_data.NativeUint8ClampedList[dart.metadata] = () => [dart.const(new _js_helper.Native("Uint8ClampedArray,CanvasPixelArray"))];
  dart.registerExtension(dart.global.Uint8ClampedArray, _native_typed_data.NativeUint8ClampedList);
  dart.defineExtensionNames([
    'runtimeType',
    'length',
    'get',
    'sublist'
  ]);
  _native_typed_data.NativeUint8List = class NativeUint8List extends _native_typed_data.NativeTypedArrayOfInt {
    static new(length) {
      return _native_typed_data.NativeUint8List._create1(_native_typed_data._checkLength(length));
    }
    static fromList(elements) {
      return _native_typed_data.NativeUint8List._create1(_native_typed_data._ensureNativeList(elements));
    }
    static view(buffer, offsetInBytes, length) {
      _native_typed_data._checkViewArguments(buffer, offsetInBytes, length);
      return length == null ? _native_typed_data.NativeUint8List._create2(buffer, offsetInBytes) : _native_typed_data.NativeUint8List._create3(buffer, offsetInBytes, length);
    }
    get [dartx.runtimeType]() {
      return dart.wrapType(typed_data.Uint8List);
    }
    get [dartx.length]() {
      return this.length;
    }
    set [dartx.length](value) {
      super[dartx.length] = value;
    }
    [dartx.get](index) {
      _native_typed_data._checkValidIndex(index, this, this[dartx.length]);
      return this[index];
    }
    [dartx.sublist](start, end) {
      if (end === void 0) end = null;
      end = _native_typed_data._checkValidRange(start, end, this[dartx.length]);
      let source = this.subarray(start, end);
      return _native_typed_data.NativeUint8List._create1(source);
    }
    static _create1(arg) {
      return new Uint8Array(arg);
    }
    static _create2(arg1, arg2) {
      return new Uint8Array(arg1, arg2);
    }
    static _create3(arg1, arg2, arg3) {
      return new Uint8Array(arg1, arg2, arg3);
    }
  };
  _native_typed_data.NativeUint8List[dart.implements] = () => [typed_data.Uint8List];
  dart.setSignature(_native_typed_data.NativeUint8List, {
    constructors: () => ({
      new: [_native_typed_data.NativeUint8List, [core.int]],
      fromList: [_native_typed_data.NativeUint8List, [core.List$(core.int)]],
      view: [_native_typed_data.NativeUint8List, [typed_data.ByteBuffer, core.int, core.int]]
    }),
    methods: () => ({
      [dartx.get]: [core.int, [core.int]],
      [dartx.sublist]: [core.List$(core.int), [core.int], [core.int]]
    }),
    statics: () => ({
      _create1: [_native_typed_data.NativeUint8List, [dart.dynamic]],
      _create2: [_native_typed_data.NativeUint8List, [dart.dynamic, dart.dynamic]],
      _create3: [_native_typed_data.NativeUint8List, [dart.dynamic, dart.dynamic, dart.dynamic]]
    }),
    names: ['_create1', '_create2', '_create3']
  });
  _native_typed_data.NativeUint8List[dart.metadata] = () => [dart.const(new _js_helper.Native("Uint8Array,!nonleaf"))];
  dart.registerExtension(dart.global.Uint8Array, _native_typed_data.NativeUint8List);
  _native_typed_data.NativeFloat32x4 = class NativeFloat32x4 extends core.Object {
    static _truncate(x) {
      _native_typed_data.NativeFloat32x4._list[dartx.set](0, dart.as(x, core.num));
      return _native_typed_data.NativeFloat32x4._list[dartx.get](0);
    }
    NativeFloat32x4(x, y, z, w) {
      this.x = dart.as(_native_typed_data.NativeFloat32x4._truncate(x), core.double);
      this.y = dart.as(_native_typed_data.NativeFloat32x4._truncate(y), core.double);
      this.z = dart.as(_native_typed_data.NativeFloat32x4._truncate(z), core.double);
      this.w = dart.as(_native_typed_data.NativeFloat32x4._truncate(w), core.double);
      if (!(typeof x == 'number')) dart.throw(new core.ArgumentError(x));
      if (!(typeof y == 'number')) dart.throw(new core.ArgumentError(y));
      if (!(typeof z == 'number')) dart.throw(new core.ArgumentError(z));
      if (!(typeof w == 'number')) dart.throw(new core.ArgumentError(w));
    }
    splat(v) {
      this.NativeFloat32x4(v, v, v, v);
    }
    zero() {
      this._truncated(0.0, 0.0, 0.0, 0.0);
    }
    static fromInt32x4Bits(i) {
      _native_typed_data.NativeFloat32x4._uint32view[dartx.set](0, i.x);
      _native_typed_data.NativeFloat32x4._uint32view[dartx.set](1, i.y);
      _native_typed_data.NativeFloat32x4._uint32view[dartx.set](2, i.z);
      _native_typed_data.NativeFloat32x4._uint32view[dartx.set](3, i.w);
      return new _native_typed_data.NativeFloat32x4._truncated(_native_typed_data.NativeFloat32x4._list[dartx.get](0), _native_typed_data.NativeFloat32x4._list[dartx.get](1), _native_typed_data.NativeFloat32x4._list[dartx.get](2), _native_typed_data.NativeFloat32x4._list[dartx.get](3));
    }
    fromFloat64x2(v) {
      this._truncated(dart.as(_native_typed_data.NativeFloat32x4._truncate(v.x), core.double), dart.as(_native_typed_data.NativeFloat32x4._truncate(v.y), core.double), 0.0, 0.0);
    }
    _doubles(x, y, z, w) {
      this.x = dart.as(_native_typed_data.NativeFloat32x4._truncate(x), core.double);
      this.y = dart.as(_native_typed_data.NativeFloat32x4._truncate(y), core.double);
      this.z = dart.as(_native_typed_data.NativeFloat32x4._truncate(z), core.double);
      this.w = dart.as(_native_typed_data.NativeFloat32x4._truncate(w), core.double);
    }
    _truncated(x, y, z, w) {
      this.x = x;
      this.y = y;
      this.z = z;
      this.w = w;
    }
    toString() {
      return `[${this.x}, ${this.y}, ${this.z}, ${this.w}]`;
    }
    ['+'](other) {
      let _x = dart.notNull(this.x) + dart.notNull(other.x);
      let _y = dart.notNull(this.y) + dart.notNull(other.y);
      let _z = dart.notNull(this.z) + dart.notNull(other.z);
      let _w = dart.notNull(this.w) + dart.notNull(other.w);
      return new _native_typed_data.NativeFloat32x4._doubles(_x, _y, _z, _w);
    }
    ['unary-']() {
      return new _native_typed_data.NativeFloat32x4._truncated(-dart.notNull(this.x), -dart.notNull(this.y), -dart.notNull(this.z), -dart.notNull(this.w));
    }
    ['-'](other) {
      let _x = dart.notNull(this.x) - dart.notNull(other.x);
      let _y = dart.notNull(this.y) - dart.notNull(other.y);
      let _z = dart.notNull(this.z) - dart.notNull(other.z);
      let _w = dart.notNull(this.w) - dart.notNull(other.w);
      return new _native_typed_data.NativeFloat32x4._doubles(_x, _y, _z, _w);
    }
    ['*'](other) {
      let _x = dart.notNull(this.x) * dart.notNull(other.x);
      let _y = dart.notNull(this.y) * dart.notNull(other.y);
      let _z = dart.notNull(this.z) * dart.notNull(other.z);
      let _w = dart.notNull(this.w) * dart.notNull(other.w);
      return new _native_typed_data.NativeFloat32x4._doubles(_x, _y, _z, _w);
    }
    ['/'](other) {
      let _x = dart.notNull(this.x) / dart.notNull(other.x);
      let _y = dart.notNull(this.y) / dart.notNull(other.y);
      let _z = dart.notNull(this.z) / dart.notNull(other.z);
      let _w = dart.notNull(this.w) / dart.notNull(other.w);
      return new _native_typed_data.NativeFloat32x4._doubles(_x, _y, _z, _w);
    }
    lessThan(other) {
      let _cx = dart.notNull(this.x) < dart.notNull(other.x);
      let _cy = dart.notNull(this.y) < dart.notNull(other.y);
      let _cz = dart.notNull(this.z) < dart.notNull(other.z);
      let _cw = dart.notNull(this.w) < dart.notNull(other.w);
      return new _native_typed_data.NativeInt32x4._truncated(_cx ? -1 : 0, _cy ? -1 : 0, _cz ? -1 : 0, _cw ? -1 : 0);
    }
    lessThanOrEqual(other) {
      let _cx = dart.notNull(this.x) <= dart.notNull(other.x);
      let _cy = dart.notNull(this.y) <= dart.notNull(other.y);
      let _cz = dart.notNull(this.z) <= dart.notNull(other.z);
      let _cw = dart.notNull(this.w) <= dart.notNull(other.w);
      return new _native_typed_data.NativeInt32x4._truncated(_cx ? -1 : 0, _cy ? -1 : 0, _cz ? -1 : 0, _cw ? -1 : 0);
    }
    greaterThan(other) {
      let _cx = dart.notNull(this.x) > dart.notNull(other.x);
      let _cy = dart.notNull(this.y) > dart.notNull(other.y);
      let _cz = dart.notNull(this.z) > dart.notNull(other.z);
      let _cw = dart.notNull(this.w) > dart.notNull(other.w);
      return new _native_typed_data.NativeInt32x4._truncated(_cx ? -1 : 0, _cy ? -1 : 0, _cz ? -1 : 0, _cw ? -1 : 0);
    }
    greaterThanOrEqual(other) {
      let _cx = dart.notNull(this.x) >= dart.notNull(other.x);
      let _cy = dart.notNull(this.y) >= dart.notNull(other.y);
      let _cz = dart.notNull(this.z) >= dart.notNull(other.z);
      let _cw = dart.notNull(this.w) >= dart.notNull(other.w);
      return new _native_typed_data.NativeInt32x4._truncated(_cx ? -1 : 0, _cy ? -1 : 0, _cz ? -1 : 0, _cw ? -1 : 0);
    }
    equal(other) {
      let _cx = this.x == other.x;
      let _cy = this.y == other.y;
      let _cz = this.z == other.z;
      let _cw = this.w == other.w;
      return new _native_typed_data.NativeInt32x4._truncated(_cx ? -1 : 0, _cy ? -1 : 0, _cz ? -1 : 0, _cw ? -1 : 0);
    }
    notEqual(other) {
      let _cx = this.x != other.x;
      let _cy = this.y != other.y;
      let _cz = this.z != other.z;
      let _cw = this.w != other.w;
      return new _native_typed_data.NativeInt32x4._truncated(_cx ? -1 : 0, _cy ? -1 : 0, _cz ? -1 : 0, _cw ? -1 : 0);
    }
    scale(s) {
      let _x = dart.notNull(s) * dart.notNull(this.x);
      let _y = dart.notNull(s) * dart.notNull(this.y);
      let _z = dart.notNull(s) * dart.notNull(this.z);
      let _w = dart.notNull(s) * dart.notNull(this.w);
      return new _native_typed_data.NativeFloat32x4._doubles(_x, _y, _z, _w);
    }
    abs() {
      let _x = this.x[dartx.abs]();
      let _y = this.y[dartx.abs]();
      let _z = this.z[dartx.abs]();
      let _w = this.w[dartx.abs]();
      return new _native_typed_data.NativeFloat32x4._truncated(_x, _y, _z, _w);
    }
    clamp(lowerLimit, upperLimit) {
      let _lx = lowerLimit.x;
      let _ly = lowerLimit.y;
      let _lz = lowerLimit.z;
      let _lw = lowerLimit.w;
      let _ux = upperLimit.x;
      let _uy = upperLimit.y;
      let _uz = upperLimit.z;
      let _uw = upperLimit.w;
      let _x = this.x;
      let _y = this.y;
      let _z = this.z;
      let _w = this.w;
      _x = dart.notNull(_x) > dart.notNull(_ux) ? _ux : _x;
      _y = dart.notNull(_y) > dart.notNull(_uy) ? _uy : _y;
      _z = dart.notNull(_z) > dart.notNull(_uz) ? _uz : _z;
      _w = dart.notNull(_w) > dart.notNull(_uw) ? _uw : _w;
      _x = dart.notNull(_x) < dart.notNull(_lx) ? _lx : _x;
      _y = dart.notNull(_y) < dart.notNull(_ly) ? _ly : _y;
      _z = dart.notNull(_z) < dart.notNull(_lz) ? _lz : _z;
      _w = dart.notNull(_w) < dart.notNull(_lw) ? _lw : _w;
      return new _native_typed_data.NativeFloat32x4._truncated(_x, _y, _z, _w);
    }
    get signMask() {
      let view = _native_typed_data.NativeFloat32x4._uint32view;
      let mx = null, my = null, mz = null, mw = null;
      _native_typed_data.NativeFloat32x4._list[dartx.set](0, this.x);
      _native_typed_data.NativeFloat32x4._list[dartx.set](1, this.y);
      _native_typed_data.NativeFloat32x4._list[dartx.set](2, this.z);
      _native_typed_data.NativeFloat32x4._list[dartx.set](3, this.w);
      mx = (dart.notNull(view[dartx.get](0)) & 2147483648) >>> 0 >>> 31;
      my = (dart.notNull(view[dartx.get](1)) & 2147483648) >>> 0 >>> 30;
      mz = (dart.notNull(view[dartx.get](2)) & 2147483648) >>> 0 >>> 29;
      mw = (dart.notNull(view[dartx.get](3)) & 2147483648) >>> 0 >>> 28;
      return dart.as(dart.dsend(dart.dsend(dart.dsend(mx, '|', my), '|', mz), '|', mw), core.int);
    }
    shuffle(mask) {
      if (dart.notNull(mask) < 0 || dart.notNull(mask) > 255) {
        dart.throw(new core.RangeError.range(mask, 0, 255, "mask"));
      }
      _native_typed_data.NativeFloat32x4._list[dartx.set](0, this.x);
      _native_typed_data.NativeFloat32x4._list[dartx.set](1, this.y);
      _native_typed_data.NativeFloat32x4._list[dartx.set](2, this.z);
      _native_typed_data.NativeFloat32x4._list[dartx.set](3, this.w);
      let _x = _native_typed_data.NativeFloat32x4._list[dartx.get](dart.notNull(mask) & 3);
      let _y = _native_typed_data.NativeFloat32x4._list[dartx.get](mask[dartx['>>']](2) & 3);
      let _z = _native_typed_data.NativeFloat32x4._list[dartx.get](mask[dartx['>>']](4) & 3);
      let _w = _native_typed_data.NativeFloat32x4._list[dartx.get](mask[dartx['>>']](6) & 3);
      return new _native_typed_data.NativeFloat32x4._truncated(_x, _y, _z, _w);
    }
    shuffleMix(other, mask) {
      if (dart.notNull(mask) < 0 || dart.notNull(mask) > 255) {
        dart.throw(new core.RangeError.range(mask, 0, 255, "mask"));
      }
      _native_typed_data.NativeFloat32x4._list[dartx.set](0, this.x);
      _native_typed_data.NativeFloat32x4._list[dartx.set](1, this.y);
      _native_typed_data.NativeFloat32x4._list[dartx.set](2, this.z);
      _native_typed_data.NativeFloat32x4._list[dartx.set](3, this.w);
      let _x = _native_typed_data.NativeFloat32x4._list[dartx.get](dart.notNull(mask) & 3);
      let _y = _native_typed_data.NativeFloat32x4._list[dartx.get](mask[dartx['>>']](2) & 3);
      _native_typed_data.NativeFloat32x4._list[dartx.set](0, other.x);
      _native_typed_data.NativeFloat32x4._list[dartx.set](1, other.y);
      _native_typed_data.NativeFloat32x4._list[dartx.set](2, other.z);
      _native_typed_data.NativeFloat32x4._list[dartx.set](3, other.w);
      let _z = _native_typed_data.NativeFloat32x4._list[dartx.get](mask[dartx['>>']](4) & 3);
      let _w = _native_typed_data.NativeFloat32x4._list[dartx.get](mask[dartx['>>']](6) & 3);
      return new _native_typed_data.NativeFloat32x4._truncated(_x, _y, _z, _w);
    }
    withX(newX) {
      return new _native_typed_data.NativeFloat32x4._truncated(dart.as(_native_typed_data.NativeFloat32x4._truncate(newX), core.double), this.y, this.z, this.w);
    }
    withY(newY) {
      return new _native_typed_data.NativeFloat32x4._truncated(this.x, dart.as(_native_typed_data.NativeFloat32x4._truncate(newY), core.double), this.z, this.w);
    }
    withZ(newZ) {
      return new _native_typed_data.NativeFloat32x4._truncated(this.x, this.y, dart.as(_native_typed_data.NativeFloat32x4._truncate(newZ), core.double), this.w);
    }
    withW(newW) {
      return new _native_typed_data.NativeFloat32x4._truncated(this.x, this.y, this.z, dart.as(_native_typed_data.NativeFloat32x4._truncate(newW), core.double));
    }
    min(other) {
      let _x = dart.notNull(this.x) < dart.notNull(other.x) ? this.x : other.x;
      let _y = dart.notNull(this.y) < dart.notNull(other.y) ? this.y : other.y;
      let _z = dart.notNull(this.z) < dart.notNull(other.z) ? this.z : other.z;
      let _w = dart.notNull(this.w) < dart.notNull(other.w) ? this.w : other.w;
      return new _native_typed_data.NativeFloat32x4._truncated(_x, _y, _z, _w);
    }
    max(other) {
      let _x = dart.notNull(this.x) > dart.notNull(other.x) ? this.x : other.x;
      let _y = dart.notNull(this.y) > dart.notNull(other.y) ? this.y : other.y;
      let _z = dart.notNull(this.z) > dart.notNull(other.z) ? this.z : other.z;
      let _w = dart.notNull(this.w) > dart.notNull(other.w) ? this.w : other.w;
      return new _native_typed_data.NativeFloat32x4._truncated(_x, _y, _z, _w);
    }
    sqrt() {
      let _x = math.sqrt(this.x);
      let _y = math.sqrt(this.y);
      let _z = math.sqrt(this.z);
      let _w = math.sqrt(this.w);
      return new _native_typed_data.NativeFloat32x4._doubles(_x, _y, _z, _w);
    }
    reciprocal() {
      let _x = 1.0 / dart.notNull(this.x);
      let _y = 1.0 / dart.notNull(this.y);
      let _z = 1.0 / dart.notNull(this.z);
      let _w = 1.0 / dart.notNull(this.w);
      return new _native_typed_data.NativeFloat32x4._doubles(_x, _y, _z, _w);
    }
    reciprocalSqrt() {
      let _x = math.sqrt(1.0 / dart.notNull(this.x));
      let _y = math.sqrt(1.0 / dart.notNull(this.y));
      let _z = math.sqrt(1.0 / dart.notNull(this.z));
      let _w = math.sqrt(1.0 / dart.notNull(this.w));
      return new _native_typed_data.NativeFloat32x4._doubles(_x, _y, _z, _w);
    }
  };
  dart.defineNamedConstructor(_native_typed_data.NativeFloat32x4, 'splat');
  dart.defineNamedConstructor(_native_typed_data.NativeFloat32x4, 'zero');
  dart.defineNamedConstructor(_native_typed_data.NativeFloat32x4, 'fromFloat64x2');
  dart.defineNamedConstructor(_native_typed_data.NativeFloat32x4, '_doubles');
  dart.defineNamedConstructor(_native_typed_data.NativeFloat32x4, '_truncated');
  _native_typed_data.NativeFloat32x4[dart.implements] = () => [typed_data.Float32x4];
  dart.setSignature(_native_typed_data.NativeFloat32x4, {
    constructors: () => ({
      NativeFloat32x4: [_native_typed_data.NativeFloat32x4, [core.double, core.double, core.double, core.double]],
      splat: [_native_typed_data.NativeFloat32x4, [core.double]],
      zero: [_native_typed_data.NativeFloat32x4, []],
      fromInt32x4Bits: [_native_typed_data.NativeFloat32x4, [typed_data.Int32x4]],
      fromFloat64x2: [_native_typed_data.NativeFloat32x4, [typed_data.Float64x2]],
      _doubles: [_native_typed_data.NativeFloat32x4, [core.double, core.double, core.double, core.double]],
      _truncated: [_native_typed_data.NativeFloat32x4, [core.double, core.double, core.double, core.double]]
    }),
    methods: () => ({
      '+': [typed_data.Float32x4, [typed_data.Float32x4]],
      'unary-': [typed_data.Float32x4, []],
      '-': [typed_data.Float32x4, [typed_data.Float32x4]],
      '*': [typed_data.Float32x4, [typed_data.Float32x4]],
      '/': [typed_data.Float32x4, [typed_data.Float32x4]],
      lessThan: [typed_data.Int32x4, [typed_data.Float32x4]],
      lessThanOrEqual: [typed_data.Int32x4, [typed_data.Float32x4]],
      greaterThan: [typed_data.Int32x4, [typed_data.Float32x4]],
      greaterThanOrEqual: [typed_data.Int32x4, [typed_data.Float32x4]],
      equal: [typed_data.Int32x4, [typed_data.Float32x4]],
      notEqual: [typed_data.Int32x4, [typed_data.Float32x4]],
      scale: [typed_data.Float32x4, [core.double]],
      abs: [typed_data.Float32x4, []],
      clamp: [typed_data.Float32x4, [typed_data.Float32x4, typed_data.Float32x4]],
      shuffle: [typed_data.Float32x4, [core.int]],
      shuffleMix: [typed_data.Float32x4, [typed_data.Float32x4, core.int]],
      withX: [typed_data.Float32x4, [core.double]],
      withY: [typed_data.Float32x4, [core.double]],
      withZ: [typed_data.Float32x4, [core.double]],
      withW: [typed_data.Float32x4, [core.double]],
      min: [typed_data.Float32x4, [typed_data.Float32x4]],
      max: [typed_data.Float32x4, [typed_data.Float32x4]],
      sqrt: [typed_data.Float32x4, []],
      reciprocal: [typed_data.Float32x4, []],
      reciprocalSqrt: [typed_data.Float32x4, []]
    }),
    statics: () => ({_truncate: [dart.dynamic, [dart.dynamic]]}),
    names: ['_truncate']
  });
  dart.defineLazy(_native_typed_data.NativeFloat32x4, {
    get _list() {
      return _native_typed_data.NativeFloat32List.new(4);
    },
    get _uint32view() {
      return _native_typed_data.NativeFloat32x4._list[dartx.buffer][dartx.asUint32List]();
    }
  });
  _native_typed_data.NativeInt32x4 = class NativeInt32x4 extends core.Object {
    static _truncate(x) {
      _native_typed_data.NativeInt32x4._list[dartx.set](0, dart.as(x, core.int));
      return _native_typed_data.NativeInt32x4._list[dartx.get](0);
    }
    NativeInt32x4(x, y, z, w) {
      this.x = dart.as(_native_typed_data.NativeInt32x4._truncate(x), core.int);
      this.y = dart.as(_native_typed_data.NativeInt32x4._truncate(y), core.int);
      this.z = dart.as(_native_typed_data.NativeInt32x4._truncate(z), core.int);
      this.w = dart.as(_native_typed_data.NativeInt32x4._truncate(w), core.int);
      if (x != this.x && !(typeof x == 'number')) dart.throw(new core.ArgumentError(x));
      if (y != this.y && !(typeof y == 'number')) dart.throw(new core.ArgumentError(y));
      if (z != this.z && !(typeof z == 'number')) dart.throw(new core.ArgumentError(z));
      if (w != this.w && !(typeof w == 'number')) dart.throw(new core.ArgumentError(w));
    }
    bool(x, y, z, w) {
      this.x = dart.notNull(x) ? -1 : 0;
      this.y = dart.notNull(y) ? -1 : 0;
      this.z = dart.notNull(z) ? -1 : 0;
      this.w = dart.notNull(w) ? -1 : 0;
    }
    static fromFloat32x4Bits(f) {
      let floatList = _native_typed_data.NativeFloat32x4._list;
      floatList[dartx.set](0, f.x);
      floatList[dartx.set](1, f.y);
      floatList[dartx.set](2, f.z);
      floatList[dartx.set](3, f.w);
      let view = dart.as(floatList[dartx.buffer][dartx.asInt32List](), _native_typed_data.NativeInt32List);
      return new _native_typed_data.NativeInt32x4._truncated(view[dartx.get](0), view[dartx.get](1), view[dartx.get](2), view[dartx.get](3));
    }
    _truncated(x, y, z, w) {
      this.x = x;
      this.y = y;
      this.z = z;
      this.w = w;
    }
    toString() {
      return `[${this.x}, ${this.y}, ${this.z}, ${this.w}]`;
    }
    ['|'](other) {
      return new _native_typed_data.NativeInt32x4._truncated(this.x | other.x, this.y | other.y, this.z | other.z, this.w | other.w);
    }
    ['&'](other) {
      return new _native_typed_data.NativeInt32x4._truncated(this.x & other.x, this.y & other.y, this.z & other.z, this.w & other.w);
    }
    ['^'](other) {
      return new _native_typed_data.NativeInt32x4._truncated(this.x ^ other.x, this.y ^ other.y, this.z ^ other.z, this.w ^ other.w);
    }
    ['+'](other) {
      return new _native_typed_data.NativeInt32x4._truncated(this.x + other.x | 0, this.y + other.y | 0, this.z + other.z | 0, this.w + other.w | 0);
    }
    ['-'](other) {
      return new _native_typed_data.NativeInt32x4._truncated(this.x - other.x | 0, this.y - other.y | 0, this.z - other.z | 0, this.w - other.w | 0);
    }
    ['unary-']() {
      return new _native_typed_data.NativeInt32x4._truncated(-this.x | 0, -this.y | 0, -this.z | 0, -this.w | 0);
    }
    get signMask() {
      let mx = (dart.notNull(this.x) & 2147483648) >>> 0 >>> 31;
      let my = (dart.notNull(this.y) & 2147483648) >>> 0 >>> 31;
      let mz = (dart.notNull(this.z) & 2147483648) >>> 0 >>> 31;
      let mw = (dart.notNull(this.w) & 2147483648) >>> 0 >>> 31;
      return (mx | my << 1 | mz << 2 | mw << 3) >>> 0;
    }
    shuffle(mask) {
      if (dart.notNull(mask) < 0 || dart.notNull(mask) > 255) {
        dart.throw(new core.RangeError.range(mask, 0, 255, "mask"));
      }
      _native_typed_data.NativeInt32x4._list[dartx.set](0, this.x);
      _native_typed_data.NativeInt32x4._list[dartx.set](1, this.y);
      _native_typed_data.NativeInt32x4._list[dartx.set](2, this.z);
      _native_typed_data.NativeInt32x4._list[dartx.set](3, this.w);
      let _x = _native_typed_data.NativeInt32x4._list[dartx.get](dart.notNull(mask) & 3);
      let _y = _native_typed_data.NativeInt32x4._list[dartx.get](mask[dartx['>>']](2) & 3);
      let _z = _native_typed_data.NativeInt32x4._list[dartx.get](mask[dartx['>>']](4) & 3);
      let _w = _native_typed_data.NativeInt32x4._list[dartx.get](mask[dartx['>>']](6) & 3);
      return new _native_typed_data.NativeInt32x4._truncated(_x, _y, _z, _w);
    }
    shuffleMix(other, mask) {
      if (dart.notNull(mask) < 0 || dart.notNull(mask) > 255) {
        dart.throw(new core.RangeError.range(mask, 0, 255, "mask"));
      }
      _native_typed_data.NativeInt32x4._list[dartx.set](0, this.x);
      _native_typed_data.NativeInt32x4._list[dartx.set](1, this.y);
      _native_typed_data.NativeInt32x4._list[dartx.set](2, this.z);
      _native_typed_data.NativeInt32x4._list[dartx.set](3, this.w);
      let _x = _native_typed_data.NativeInt32x4._list[dartx.get](dart.notNull(mask) & 3);
      let _y = _native_typed_data.NativeInt32x4._list[dartx.get](mask[dartx['>>']](2) & 3);
      _native_typed_data.NativeInt32x4._list[dartx.set](0, other.x);
      _native_typed_data.NativeInt32x4._list[dartx.set](1, other.y);
      _native_typed_data.NativeInt32x4._list[dartx.set](2, other.z);
      _native_typed_data.NativeInt32x4._list[dartx.set](3, other.w);
      let _z = _native_typed_data.NativeInt32x4._list[dartx.get](mask[dartx['>>']](4) & 3);
      let _w = _native_typed_data.NativeInt32x4._list[dartx.get](mask[dartx['>>']](6) & 3);
      return new _native_typed_data.NativeInt32x4._truncated(_x, _y, _z, _w);
    }
    withX(x) {
      let _x = dart.as(_native_typed_data.NativeInt32x4._truncate(x), core.int);
      return new _native_typed_data.NativeInt32x4._truncated(_x, this.y, this.z, this.w);
    }
    withY(y) {
      let _y = dart.as(_native_typed_data.NativeInt32x4._truncate(y), core.int);
      return new _native_typed_data.NativeInt32x4._truncated(this.x, _y, this.z, this.w);
    }
    withZ(z) {
      let _z = dart.as(_native_typed_data.NativeInt32x4._truncate(z), core.int);
      return new _native_typed_data.NativeInt32x4._truncated(this.x, this.y, _z, this.w);
    }
    withW(w) {
      let _w = dart.as(_native_typed_data.NativeInt32x4._truncate(w), core.int);
      return new _native_typed_data.NativeInt32x4._truncated(this.x, this.y, this.z, _w);
    }
    get flagX() {
      return this.x != 0;
    }
    get flagY() {
      return this.y != 0;
    }
    get flagZ() {
      return this.z != 0;
    }
    get flagW() {
      return this.w != 0;
    }
    withFlagX(flagX) {
      let _x = dart.notNull(flagX) ? -1 : 0;
      return new _native_typed_data.NativeInt32x4._truncated(_x, this.y, this.z, this.w);
    }
    withFlagY(flagY) {
      let _y = dart.notNull(flagY) ? -1 : 0;
      return new _native_typed_data.NativeInt32x4._truncated(this.x, _y, this.z, this.w);
    }
    withFlagZ(flagZ) {
      let _z = dart.notNull(flagZ) ? -1 : 0;
      return new _native_typed_data.NativeInt32x4._truncated(this.x, this.y, _z, this.w);
    }
    withFlagW(flagW) {
      let _w = dart.notNull(flagW) ? -1 : 0;
      return new _native_typed_data.NativeInt32x4._truncated(this.x, this.y, this.z, _w);
    }
    select(trueValue, falseValue) {
      let floatList = _native_typed_data.NativeFloat32x4._list;
      let intView = _native_typed_data.NativeFloat32x4._uint32view;
      floatList[dartx.set](0, trueValue.x);
      floatList[dartx.set](1, trueValue.y);
      floatList[dartx.set](2, trueValue.z);
      floatList[dartx.set](3, trueValue.w);
      let stx = intView[dartx.get](0);
      let sty = intView[dartx.get](1);
      let stz = intView[dartx.get](2);
      let stw = intView[dartx.get](3);
      floatList[dartx.set](0, falseValue.x);
      floatList[dartx.set](1, falseValue.y);
      floatList[dartx.set](2, falseValue.z);
      floatList[dartx.set](3, falseValue.w);
      let sfx = intView[dartx.get](0);
      let sfy = intView[dartx.get](1);
      let sfz = intView[dartx.get](2);
      let sfw = intView[dartx.get](3);
      let _x = (dart.notNull(this.x) & dart.notNull(stx) | ~dart.notNull(this.x) & dart.notNull(sfx)) >>> 0;
      let _y = (dart.notNull(this.y) & dart.notNull(sty) | ~dart.notNull(this.y) & dart.notNull(sfy)) >>> 0;
      let _z = (dart.notNull(this.z) & dart.notNull(stz) | ~dart.notNull(this.z) & dart.notNull(sfz)) >>> 0;
      let _w = (dart.notNull(this.w) & dart.notNull(stw) | ~dart.notNull(this.w) & dart.notNull(sfw)) >>> 0;
      intView[dartx.set](0, _x);
      intView[dartx.set](1, _y);
      intView[dartx.set](2, _z);
      intView[dartx.set](3, _w);
      return new _native_typed_data.NativeFloat32x4._truncated(floatList[dartx.get](0), floatList[dartx.get](1), floatList[dartx.get](2), floatList[dartx.get](3));
    }
  };
  dart.defineNamedConstructor(_native_typed_data.NativeInt32x4, 'bool');
  dart.defineNamedConstructor(_native_typed_data.NativeInt32x4, '_truncated');
  _native_typed_data.NativeInt32x4[dart.implements] = () => [typed_data.Int32x4];
  dart.setSignature(_native_typed_data.NativeInt32x4, {
    constructors: () => ({
      NativeInt32x4: [_native_typed_data.NativeInt32x4, [core.int, core.int, core.int, core.int]],
      bool: [_native_typed_data.NativeInt32x4, [core.bool, core.bool, core.bool, core.bool]],
      fromFloat32x4Bits: [_native_typed_data.NativeInt32x4, [typed_data.Float32x4]],
      _truncated: [_native_typed_data.NativeInt32x4, [core.int, core.int, core.int, core.int]]
    }),
    methods: () => ({
      '|': [typed_data.Int32x4, [typed_data.Int32x4]],
      '&': [typed_data.Int32x4, [typed_data.Int32x4]],
      '^': [typed_data.Int32x4, [typed_data.Int32x4]],
      '+': [typed_data.Int32x4, [typed_data.Int32x4]],
      '-': [typed_data.Int32x4, [typed_data.Int32x4]],
      'unary-': [typed_data.Int32x4, []],
      shuffle: [typed_data.Int32x4, [core.int]],
      shuffleMix: [typed_data.Int32x4, [typed_data.Int32x4, core.int]],
      withX: [typed_data.Int32x4, [core.int]],
      withY: [typed_data.Int32x4, [core.int]],
      withZ: [typed_data.Int32x4, [core.int]],
      withW: [typed_data.Int32x4, [core.int]],
      withFlagX: [typed_data.Int32x4, [core.bool]],
      withFlagY: [typed_data.Int32x4, [core.bool]],
      withFlagZ: [typed_data.Int32x4, [core.bool]],
      withFlagW: [typed_data.Int32x4, [core.bool]],
      select: [typed_data.Float32x4, [typed_data.Float32x4, typed_data.Float32x4]]
    }),
    statics: () => ({_truncate: [dart.dynamic, [dart.dynamic]]}),
    names: ['_truncate']
  });
  dart.defineLazy(_native_typed_data.NativeInt32x4, {
    get _list() {
      return _native_typed_data.NativeInt32List.new(4);
    }
  });
  _native_typed_data.NativeFloat64x2 = class NativeFloat64x2 extends core.Object {
    NativeFloat64x2(x, y) {
      this.x = x;
      this.y = y;
      if (!(typeof this.x == 'number')) dart.throw(new core.ArgumentError(this.x));
      if (!(typeof this.y == 'number')) dart.throw(new core.ArgumentError(this.y));
    }
    splat(v) {
      this.NativeFloat64x2(v, v);
    }
    zero() {
      this.splat(0.0);
    }
    fromFloat32x4(v) {
      this.NativeFloat64x2(v.x, v.y);
    }
    _doubles(x, y) {
      this.x = x;
      this.y = y;
    }
    toString() {
      return `[${this.x}, ${this.y}]`;
    }
    ['+'](other) {
      return new _native_typed_data.NativeFloat64x2._doubles(dart.notNull(this.x) + dart.notNull(other.x), dart.notNull(this.y) + dart.notNull(other.y));
    }
    ['unary-']() {
      return new _native_typed_data.NativeFloat64x2._doubles(-dart.notNull(this.x), -dart.notNull(this.y));
    }
    ['-'](other) {
      return new _native_typed_data.NativeFloat64x2._doubles(dart.notNull(this.x) - dart.notNull(other.x), dart.notNull(this.y) - dart.notNull(other.y));
    }
    ['*'](other) {
      return new _native_typed_data.NativeFloat64x2._doubles(dart.notNull(this.x) * dart.notNull(other.x), dart.notNull(this.y) * dart.notNull(other.y));
    }
    ['/'](other) {
      return new _native_typed_data.NativeFloat64x2._doubles(dart.notNull(this.x) / dart.notNull(other.x), dart.notNull(this.y) / dart.notNull(other.y));
    }
    scale(s) {
      return new _native_typed_data.NativeFloat64x2._doubles(dart.notNull(this.x) * dart.notNull(s), dart.notNull(this.y) * dart.notNull(s));
    }
    abs() {
      return new _native_typed_data.NativeFloat64x2._doubles(this.x[dartx.abs](), this.y[dartx.abs]());
    }
    clamp(lowerLimit, upperLimit) {
      let _lx = lowerLimit.x;
      let _ly = lowerLimit.y;
      let _ux = upperLimit.x;
      let _uy = upperLimit.y;
      let _x = this.x;
      let _y = this.y;
      _x = dart.notNull(_x) > dart.notNull(_ux) ? _ux : _x;
      _y = dart.notNull(_y) > dart.notNull(_uy) ? _uy : _y;
      _x = dart.notNull(_x) < dart.notNull(_lx) ? _lx : _x;
      _y = dart.notNull(_y) < dart.notNull(_ly) ? _ly : _y;
      return new _native_typed_data.NativeFloat64x2._doubles(_x, _y);
    }
    get signMask() {
      let view = _native_typed_data.NativeFloat64x2._uint32View;
      _native_typed_data.NativeFloat64x2._list[dartx.set](0, this.x);
      _native_typed_data.NativeFloat64x2._list[dartx.set](1, this.y);
      let mx = (dart.notNull(view[dartx.get](1)) & 2147483648) >>> 0 >>> 31;
      let my = (dart.notNull(view[dartx.get](3)) & 2147483648) >>> 0 >>> 31;
      return (mx | my << 1) >>> 0;
    }
    withX(x) {
      if (!(typeof x == 'number')) dart.throw(new core.ArgumentError(x));
      return new _native_typed_data.NativeFloat64x2._doubles(x, this.y);
    }
    withY(y) {
      if (!(typeof y == 'number')) dart.throw(new core.ArgumentError(y));
      return new _native_typed_data.NativeFloat64x2._doubles(this.x, y);
    }
    min(other) {
      return new _native_typed_data.NativeFloat64x2._doubles(dart.notNull(this.x) < dart.notNull(other.x) ? this.x : other.x, dart.notNull(this.y) < dart.notNull(other.y) ? this.y : other.y);
    }
    max(other) {
      return new _native_typed_data.NativeFloat64x2._doubles(dart.notNull(this.x) > dart.notNull(other.x) ? this.x : other.x, dart.notNull(this.y) > dart.notNull(other.y) ? this.y : other.y);
    }
    sqrt() {
      return new _native_typed_data.NativeFloat64x2._doubles(math.sqrt(this.x), math.sqrt(this.y));
    }
  };
  dart.defineNamedConstructor(_native_typed_data.NativeFloat64x2, 'splat');
  dart.defineNamedConstructor(_native_typed_data.NativeFloat64x2, 'zero');
  dart.defineNamedConstructor(_native_typed_data.NativeFloat64x2, 'fromFloat32x4');
  dart.defineNamedConstructor(_native_typed_data.NativeFloat64x2, '_doubles');
  _native_typed_data.NativeFloat64x2[dart.implements] = () => [typed_data.Float64x2];
  dart.setSignature(_native_typed_data.NativeFloat64x2, {
    constructors: () => ({
      NativeFloat64x2: [_native_typed_data.NativeFloat64x2, [core.double, core.double]],
      splat: [_native_typed_data.NativeFloat64x2, [core.double]],
      zero: [_native_typed_data.NativeFloat64x2, []],
      fromFloat32x4: [_native_typed_data.NativeFloat64x2, [typed_data.Float32x4]],
      _doubles: [_native_typed_data.NativeFloat64x2, [core.double, core.double]]
    }),
    methods: () => ({
      '+': [typed_data.Float64x2, [typed_data.Float64x2]],
      'unary-': [typed_data.Float64x2, []],
      '-': [typed_data.Float64x2, [typed_data.Float64x2]],
      '*': [typed_data.Float64x2, [typed_data.Float64x2]],
      '/': [typed_data.Float64x2, [typed_data.Float64x2]],
      scale: [typed_data.Float64x2, [core.double]],
      abs: [typed_data.Float64x2, []],
      clamp: [typed_data.Float64x2, [typed_data.Float64x2, typed_data.Float64x2]],
      withX: [typed_data.Float64x2, [core.double]],
      withY: [typed_data.Float64x2, [core.double]],
      min: [typed_data.Float64x2, [typed_data.Float64x2]],
      max: [typed_data.Float64x2, [typed_data.Float64x2]],
      sqrt: [typed_data.Float64x2, []]
    })
  });
  dart.defineLazy(_native_typed_data.NativeFloat64x2, {
    get _list() {
      return _native_typed_data.NativeFloat64List.new(2);
    },
    set _list(_) {},
    get _uint32View() {
      return dart.as(_native_typed_data.NativeFloat64x2._list[dartx.buffer][dartx.asUint32List](), _native_typed_data.NativeUint32List);
    },
    set _uint32View(_) {}
  });
  _native_typed_data._isInvalidArrayIndex = function(index) {
    return index >>> 0 !== index;
  };
  dart.lazyFn(_native_typed_data._isInvalidArrayIndex, () => [core.bool, [core.int]]);
  _native_typed_data._checkValidIndex = function(index, list, length) {
    if (dart.notNull(_native_typed_data._isInvalidArrayIndex(index)) || index >= dart.notNull(length)) {
      dart.throw(_js_helper.diagnoseIndexError(list, index));
    }
  };
  dart.lazyFn(_native_typed_data._checkValidIndex, () => [dart.void, [core.int, core.List, core.int]]);
  _native_typed_data._checkValidRange = function(start, end, length) {
    if (dart.notNull(_native_typed_data._isInvalidArrayIndex(start)) || (end == null ? dart.notNull(start) > dart.notNull(length) : dart.notNull(_native_typed_data._isInvalidArrayIndex(end)) || dart.notNull(start) > dart.notNull(end) || dart.notNull(end) > dart.notNull(length))) {
      dart.throw(_js_helper.diagnoseRangeError(start, end, length));
    }
    if (end == null) return length;
    return end;
  };
  dart.fn(_native_typed_data._checkValidRange, core.int, [core.int, core.int, core.int]);
  async._invokeErrorHandler = function(errorHandler, error, stackTrace) {
    if (dart.is(errorHandler, async.ZoneBinaryCallback)) {
      return dart.dcall(errorHandler, error, stackTrace);
    } else {
      let unaryErrorHandler = dart.as(errorHandler, async.ZoneUnaryCallback);
      return dart.dcall(unaryErrorHandler, error);
    }
  };
  dart.lazyFn(async._invokeErrorHandler, () => [dart.dynamic, [core.Function, core.Object, core.StackTrace]]);
  async._registerErrorHandler = function(R) {
    return (errorHandler, zone) => {
      if (dart.is(errorHandler, async.ZoneBinaryCallback)) {
        return zone.registerBinaryCallback(dart.dynamic, dart.dynamic, core.StackTrace)(dart.as(errorHandler, async.ZoneBinaryCallback$(dart.dynamic, dart.dynamic, core.StackTrace)));
      } else {
        return zone.registerUnaryCallback(dart.dynamic, dart.dynamic)(dart.as(errorHandler, async.ZoneUnaryCallback));
      }
    };
  };
  dart.lazyFn(async._registerErrorHandler, () => [R => [core.Function, [core.Function, async.Zone]]]);
  async.AsyncError = class AsyncError extends core.Object {
    AsyncError(error, stackTrace) {
      this.error = error;
      this.stackTrace = stackTrace;
    }
    toString() {
      return `${this.error}`;
    }
  };
  async.AsyncError[dart.implements] = () => [core.Error];
  dart.setSignature(async.AsyncError, {
    constructors: () => ({AsyncError: [async.AsyncError, [core.Object, core.StackTrace]]})
  });
  async._UncaughtAsyncError = class _UncaughtAsyncError extends async.AsyncError {
    _UncaughtAsyncError(error, stackTrace) {
      super.AsyncError(error, async._UncaughtAsyncError._getBestStackTrace(error, stackTrace));
    }
    static _getBestStackTrace(error, stackTrace) {
      if (stackTrace != null) return stackTrace;
      if (dart.is(error, core.Error)) {
        return error.stackTrace;
      }
      return null;
    }
    toString() {
      let result = `Uncaught Error: ${this.error}`;
      if (this.stackTrace != null) {
        result = result + `\nStack Trace:\n${this.stackTrace}`;
      }
      return result;
    }
  };
  dart.setSignature(async._UncaughtAsyncError, {
    constructors: () => ({_UncaughtAsyncError: [async._UncaughtAsyncError, [dart.dynamic, core.StackTrace]]}),
    statics: () => ({_getBestStackTrace: [core.StackTrace, [dart.dynamic, core.StackTrace]]}),
    names: ['_getBestStackTrace']
  });
  const _controller$ = Symbol('_controller');
  const _subscribe = Symbol('_subscribe');
  const _createSubscription = Symbol('_createSubscription');
  const _onListen = Symbol('_onListen');
  async._StreamImpl$ = dart.generic(T => {
    class _StreamImpl extends async.Stream$(T) {
      _StreamImpl() {
        super.Stream();
      }
      listen(onData, opts) {
        dart.as(onData, dart.functionType(dart.void, [T]));
        let onError = opts && 'onError' in opts ? opts.onError : null;
        let onDone = opts && 'onDone' in opts ? opts.onDone : null;
        dart.as(onDone, dart.functionType(dart.void, []));
        let cancelOnError = opts && 'cancelOnError' in opts ? opts.cancelOnError : null;
        cancelOnError = core.identical(true, cancelOnError);
        let subscription = this[_createSubscription](onData, onError, onDone, cancelOnError);
        this[_onListen](subscription);
        return subscription;
      }
      [_createSubscription](onData, onError, onDone, cancelOnError) {
        dart.as(onData, dart.functionType(dart.void, [T]));
        dart.as(onDone, dart.functionType(dart.void, []));
        return new (async._BufferingStreamSubscription$(T))(onData, onError, onDone, cancelOnError);
      }
      [_onListen](subscription) {}
    }
    dart.setSignature(_StreamImpl, {
      methods: () => ({
        listen: [async.StreamSubscription$(T), [dart.functionType(dart.void, [T])], {onError: core.Function, onDone: dart.functionType(dart.void, []), cancelOnError: core.bool}],
        [_createSubscription]: [async.StreamSubscription$(T), [dart.functionType(dart.void, [T]), core.Function, dart.functionType(dart.void, []), core.bool]],
        [_onListen]: [dart.void, [async.StreamSubscription]]
      })
    });
    return _StreamImpl;
  });
  async._StreamImpl = async._StreamImpl$();
  async._ControllerStream$ = dart.generic(T => {
    class _ControllerStream extends async._StreamImpl$(T) {
      _ControllerStream(controller) {
        this[_controller$] = controller;
      }
      [_createSubscription](onData, onError, onDone, cancelOnError) {
        dart.as(onData, dart.functionType(dart.void, [T]));
        dart.as(onDone, dart.functionType(dart.void, []));
        return this[_controller$][_subscribe](onData, onError, onDone, cancelOnError);
      }
      get hashCode() {
        return (dart.notNull(dart.hashCode(this[_controller$])) ^ 892482866) >>> 0;
      }
      ['=='](other) {
        if (core.identical(this, other)) return true;
        if (!dart.is(other, async._ControllerStream)) return false;
        let otherStream = dart.as(other, async._ControllerStream);
        return core.identical(otherStream[_controller$], this[_controller$]);
      }
    }
    dart.setSignature(_ControllerStream, {
      constructors: () => ({_ControllerStream: [async._ControllerStream$(T), [async._StreamControllerLifecycle$(T)]]}),
      methods: () => ({
        [_createSubscription]: [async.StreamSubscription$(T), [dart.functionType(dart.void, [T]), core.Function, dart.functionType(dart.void, []), core.bool]],
        '==': [core.bool, [core.Object]]
      })
    });
    return _ControllerStream;
  });
  async._ControllerStream = async._ControllerStream$();
  async._BroadcastStream$ = dart.generic(T => {
    class _BroadcastStream extends async._ControllerStream$(T) {
      _BroadcastStream(controller) {
        super._ControllerStream(controller);
      }
      get isBroadcast() {
        return true;
      }
    }
    dart.setSignature(_BroadcastStream, {
      constructors: () => ({_BroadcastStream: [async._BroadcastStream$(T), [async._StreamControllerLifecycle$(T)]]})
    });
    return _BroadcastStream;
  });
  async._BroadcastStream = async._BroadcastStream$();
  const _eventState = Symbol('_eventState');
  const _next$ = Symbol('_next');
  const _previous$ = Symbol('_previous');
  const _expectsEvent = Symbol('_expectsEvent');
  const _toggleEventId = Symbol('_toggleEventId');
  const _isFiring = Symbol('_isFiring');
  const _setRemoveAfterFiring = Symbol('_setRemoveAfterFiring');
  const _removeAfterFiring = Symbol('_removeAfterFiring');
  const _onPause = Symbol('_onPause');
  const _onResume = Symbol('_onResume');
  const _recordCancel = Symbol('_recordCancel');
  const _onCancel = Symbol('_onCancel');
  const _recordPause = Symbol('_recordPause');
  const _recordResume = Symbol('_recordResume');
  const _zone = Symbol('_zone');
  const _state = Symbol('_state');
  const _onData = Symbol('_onData');
  const _onError = Symbol('_onError');
  const _onDone = Symbol('_onDone');
  const _cancelFuture = Symbol('_cancelFuture');
  const _pending = Symbol('_pending');
  const _setPendingEvents = Symbol('_setPendingEvents');
  const _isCanceled = Symbol('_isCanceled');
  const _isPaused = Symbol('_isPaused');
  const _isInputPaused = Symbol('_isInputPaused');
  const _inCallback = Symbol('_inCallback');
  const _guardCallback = Symbol('_guardCallback');
  const _decrementPauseCount = Symbol('_decrementPauseCount');
  const _hasPending = Symbol('_hasPending');
  const _mayResumeInput = Symbol('_mayResumeInput');
  const _cancel = Symbol('_cancel');
  const _isClosed$ = Symbol('_isClosed');
  const _waitsForCancel = Symbol('_waitsForCancel');
  const _canFire = Symbol('_canFire');
  const _cancelOnError = Symbol('_cancelOnError');
  const _incrementPauseCount = Symbol('_incrementPauseCount');
  const _sendData = Symbol('_sendData');
  const _addPending = Symbol('_addPending');
  const _sendError = Symbol('_sendError');
  const _sendDone = Symbol('_sendDone');
  const _close$ = Symbol('_close');
  const _checkState = Symbol('_checkState');
  async._BufferingStreamSubscription$ = dart.generic(T => {
    class _BufferingStreamSubscription extends core.Object {
      _BufferingStreamSubscription(onData, onError, onDone, cancelOnError) {
        this[_zone] = async.Zone.current;
        this[_state] = dart.notNull(cancelOnError) ? async._BufferingStreamSubscription._STATE_CANCEL_ON_ERROR : 0;
        this[_onData] = null;
        this[_onError] = null;
        this[_onDone] = null;
        this[_cancelFuture] = null;
        this[_pending] = null;
        this.onData(onData);
        this.onError(onError);
        this.onDone(onDone);
      }
      [_setPendingEvents](pendingEvents) {
        dart.as(pendingEvents, async._PendingEvents$(T));
        dart.assert(this[_pending] == null);
        if (pendingEvents == null) return;
        this[_pending] = pendingEvents;
        if (!dart.notNull(pendingEvents.isEmpty)) {
          this[_state] = (dart.notNull(this[_state]) | dart.notNull(async._BufferingStreamSubscription._STATE_HAS_PENDING)) >>> 0;
          this[_pending].schedule(this);
        }
      }
      onData(handleData) {
        dart.as(handleData, dart.functionType(dart.void, [T]));
        if (handleData == null) handleData = async._nullDataHandler;
        this[_onData] = this[_zone].registerUnaryCallback(dart.dynamic, T)(handleData);
      }
      onError(handleError) {
        if (handleError == null) handleError = async._nullErrorHandler;
        this[_onError] = async._registerErrorHandler(T)(handleError, this[_zone]);
      }
      onDone(handleDone) {
        dart.as(handleDone, dart.functionType(dart.void, []));
        if (handleDone == null) handleDone = async._nullDoneHandler;
        this[_onDone] = this[_zone].registerCallback(dart.dynamic)(handleDone);
      }
      pause(resumeSignal) {
        if (resumeSignal === void 0) resumeSignal = null;
        if (dart.notNull(this[_isCanceled])) return;
        let wasPaused = this[_isPaused];
        let wasInputPaused = this[_isInputPaused];
        this[_state] = (dart.notNull(this[_state]) + dart.notNull(async._BufferingStreamSubscription._STATE_PAUSE_COUNT) | dart.notNull(async._BufferingStreamSubscription._STATE_INPUT_PAUSED)) >>> 0;
        if (resumeSignal != null) resumeSignal.whenComplete(dart.bind(this, 'resume'));
        if (!dart.notNull(wasPaused) && this[_pending] != null) this[_pending].cancelSchedule();
        if (!dart.notNull(wasInputPaused) && !dart.notNull(this[_inCallback])) this[_guardCallback](dart.bind(this, _onPause));
      }
      resume() {
        if (dart.notNull(this[_isCanceled])) return;
        if (dart.notNull(this[_isPaused])) {
          this[_decrementPauseCount]();
          if (!dart.notNull(this[_isPaused])) {
            if (dart.notNull(this[_hasPending]) && !dart.notNull(this[_pending].isEmpty)) {
              this[_pending].schedule(this);
            } else {
              dart.assert(this[_mayResumeInput]);
              this[_state] = (dart.notNull(this[_state]) & ~dart.notNull(async._BufferingStreamSubscription._STATE_INPUT_PAUSED)) >>> 0;
              if (!dart.notNull(this[_inCallback])) this[_guardCallback](dart.bind(this, _onResume));
            }
          }
        }
      }
      cancel() {
        this[_state] = (dart.notNull(this[_state]) & ~dart.notNull(async._BufferingStreamSubscription._STATE_WAIT_FOR_CANCEL)) >>> 0;
        if (dart.notNull(this[_isCanceled])) return this[_cancelFuture];
        this[_cancel]();
        return this[_cancelFuture];
      }
      asFuture(E) {
        return futureValue => {
          if (futureValue === void 0) futureValue = null;
          let result = new (async._Future$(E))();
          this[_onDone] = dart.fn(() => {
            result[_complete](futureValue);
          }, dart.void, []);
          this[_onError] = dart.fn((error, stackTrace) => {
            this.cancel();
            result[_completeError](error, dart.as(stackTrace, core.StackTrace));
          });
          return result;
        };
      }
      get [_isInputPaused]() {
        return (dart.notNull(this[_state]) & dart.notNull(async._BufferingStreamSubscription._STATE_INPUT_PAUSED)) >>> 0 != 0;
      }
      get [_isClosed$]() {
        return (dart.notNull(this[_state]) & dart.notNull(async._BufferingStreamSubscription._STATE_CLOSED)) >>> 0 != 0;
      }
      get [_isCanceled]() {
        return (dart.notNull(this[_state]) & dart.notNull(async._BufferingStreamSubscription._STATE_CANCELED)) >>> 0 != 0;
      }
      get [_waitsForCancel]() {
        return (dart.notNull(this[_state]) & dart.notNull(async._BufferingStreamSubscription._STATE_WAIT_FOR_CANCEL)) >>> 0 != 0;
      }
      get [_inCallback]() {
        return (dart.notNull(this[_state]) & dart.notNull(async._BufferingStreamSubscription._STATE_IN_CALLBACK)) >>> 0 != 0;
      }
      get [_hasPending]() {
        return (dart.notNull(this[_state]) & dart.notNull(async._BufferingStreamSubscription._STATE_HAS_PENDING)) >>> 0 != 0;
      }
      get [_isPaused]() {
        return dart.notNull(this[_state]) >= dart.notNull(async._BufferingStreamSubscription._STATE_PAUSE_COUNT);
      }
      get [_canFire]() {
        return dart.notNull(this[_state]) < dart.notNull(async._BufferingStreamSubscription._STATE_IN_CALLBACK);
      }
      get [_mayResumeInput]() {
        return !dart.notNull(this[_isPaused]) && (this[_pending] == null || dart.notNull(this[_pending].isEmpty));
      }
      get [_cancelOnError]() {
        return (dart.notNull(this[_state]) & dart.notNull(async._BufferingStreamSubscription._STATE_CANCEL_ON_ERROR)) >>> 0 != 0;
      }
      get isPaused() {
        return this[_isPaused];
      }
      [_cancel]() {
        this[_state] = (dart.notNull(this[_state]) | dart.notNull(async._BufferingStreamSubscription._STATE_CANCELED)) >>> 0;
        if (dart.notNull(this[_hasPending])) {
          this[_pending].cancelSchedule();
        }
        if (!dart.notNull(this[_inCallback])) this[_pending] = null;
        this[_cancelFuture] = this[_onCancel]();
      }
      [_incrementPauseCount]() {
        this[_state] = (dart.notNull(this[_state]) + dart.notNull(async._BufferingStreamSubscription._STATE_PAUSE_COUNT) | dart.notNull(async._BufferingStreamSubscription._STATE_INPUT_PAUSED)) >>> 0;
      }
      [_decrementPauseCount]() {
        dart.assert(this[_isPaused]);
        this[_state] = dart.notNull(this[_state]) - dart.notNull(async._BufferingStreamSubscription._STATE_PAUSE_COUNT);
      }
      [_add$](data) {
        dart.as(data, T);
        dart.assert(!dart.notNull(this[_isClosed$]));
        if (dart.notNull(this[_isCanceled])) return;
        if (dart.notNull(this[_canFire])) {
          this[_sendData](data);
        } else {
          this[_addPending](new (async._DelayedData$(T))(data));
        }
      }
      [_addError](error, stackTrace) {
        if (dart.notNull(this[_isCanceled])) return;
        if (dart.notNull(this[_canFire])) {
          this[_sendError](error, stackTrace);
        } else {
          this[_addPending](new async._DelayedError(error, stackTrace));
        }
      }
      [_close$]() {
        dart.assert(!dart.notNull(this[_isClosed$]));
        if (dart.notNull(this[_isCanceled])) return;
        this[_state] = (dart.notNull(this[_state]) | dart.notNull(async._BufferingStreamSubscription._STATE_CLOSED)) >>> 0;
        if (dart.notNull(this[_canFire])) {
          this[_sendDone]();
        } else {
          this[_addPending](dart.const(new async._DelayedDone()));
        }
      }
      [_onPause]() {
        dart.assert(this[_isInputPaused]);
      }
      [_onResume]() {
        dart.assert(!dart.notNull(this[_isInputPaused]));
      }
      [_onCancel]() {
        dart.assert(this[_isCanceled]);
        return null;
      }
      [_addPending](event) {
        let pending = dart.as(this[_pending], async._StreamImplEvents$(T));
        if (this[_pending] == null) {
          pending = this[_pending] = new (async._StreamImplEvents$(T))();
        }
        pending.add(event);
        if (!dart.notNull(this[_hasPending])) {
          this[_state] = (dart.notNull(this[_state]) | dart.notNull(async._BufferingStreamSubscription._STATE_HAS_PENDING)) >>> 0;
          if (!dart.notNull(this[_isPaused])) {
            this[_pending].schedule(this);
          }
        }
      }
      [_sendData](data) {
        dart.as(data, T);
        dart.assert(!dart.notNull(this[_isCanceled]));
        dart.assert(!dart.notNull(this[_isPaused]));
        dart.assert(!dart.notNull(this[_inCallback]));
        let wasInputPaused = this[_isInputPaused];
        this[_state] = (dart.notNull(this[_state]) | dart.notNull(async._BufferingStreamSubscription._STATE_IN_CALLBACK)) >>> 0;
        this[_zone].runUnaryGuarded(dart.dynamic, T)(this[_onData], data);
        this[_state] = (dart.notNull(this[_state]) & ~dart.notNull(async._BufferingStreamSubscription._STATE_IN_CALLBACK)) >>> 0;
        this[_checkState](wasInputPaused);
      }
      [_sendError](error, stackTrace) {
        dart.assert(!dart.notNull(this[_isCanceled]));
        dart.assert(!dart.notNull(this[_isPaused]));
        dart.assert(!dart.notNull(this[_inCallback]));
        let wasInputPaused = this[_isInputPaused];
        const sendError = (function() {
          if (dart.notNull(this[_isCanceled]) && !dart.notNull(this[_waitsForCancel])) return;
          this[_state] = (dart.notNull(this[_state]) | dart.notNull(async._BufferingStreamSubscription._STATE_IN_CALLBACK)) >>> 0;
          if (dart.is(this[_onError], async.ZoneBinaryCallback$(dart.dynamic, core.Object, core.StackTrace))) {
            let errorCallback = dart.as(this[_onError], async.ZoneBinaryCallback$(dart.dynamic, core.Object, core.StackTrace));
            this[_zone].runBinaryGuarded(dart.dynamic, core.Object, core.StackTrace)(errorCallback, error, stackTrace);
          } else {
            this[_zone].runUnaryGuarded(dart.dynamic, dart.dynamic)(dart.as(this[_onError], async.ZoneUnaryCallback), error);
          }
          this[_state] = (dart.notNull(this[_state]) & ~dart.notNull(async._BufferingStreamSubscription._STATE_IN_CALLBACK)) >>> 0;
        }).bind(this);
        dart.fn(sendError, dart.void, []);
        if (dart.notNull(this[_cancelOnError])) {
          this[_state] = (dart.notNull(this[_state]) | dart.notNull(async._BufferingStreamSubscription._STATE_WAIT_FOR_CANCEL)) >>> 0;
          this[_cancel]();
          if (dart.is(this[_cancelFuture], async.Future)) {
            this[_cancelFuture].whenComplete(sendError);
          } else {
            sendError();
          }
        } else {
          sendError();
          this[_checkState](wasInputPaused);
        }
      }
      [_sendDone]() {
        dart.assert(!dart.notNull(this[_isCanceled]));
        dart.assert(!dart.notNull(this[_isPaused]));
        dart.assert(!dart.notNull(this[_inCallback]));
        const sendDone = (function() {
          if (!dart.notNull(this[_waitsForCancel])) return;
          this[_state] = (dart.notNull(this[_state]) | dart.notNull(async._BufferingStreamSubscription._STATE_CANCELED) | dart.notNull(async._BufferingStreamSubscription._STATE_CLOSED) | dart.notNull(async._BufferingStreamSubscription._STATE_IN_CALLBACK)) >>> 0;
          this[_zone].runGuarded(dart.dynamic)(this[_onDone]);
          this[_state] = (dart.notNull(this[_state]) & ~dart.notNull(async._BufferingStreamSubscription._STATE_IN_CALLBACK)) >>> 0;
        }).bind(this);
        dart.fn(sendDone, dart.void, []);
        this[_cancel]();
        this[_state] = (dart.notNull(this[_state]) | dart.notNull(async._BufferingStreamSubscription._STATE_WAIT_FOR_CANCEL)) >>> 0;
        if (dart.is(this[_cancelFuture], async.Future)) {
          this[_cancelFuture].whenComplete(sendDone);
        } else {
          sendDone();
        }
      }
      [_guardCallback](callback) {
        dart.assert(!dart.notNull(this[_inCallback]));
        let wasInputPaused = this[_isInputPaused];
        this[_state] = (dart.notNull(this[_state]) | dart.notNull(async._BufferingStreamSubscription._STATE_IN_CALLBACK)) >>> 0;
        dart.dcall(callback);
        this[_state] = (dart.notNull(this[_state]) & ~dart.notNull(async._BufferingStreamSubscription._STATE_IN_CALLBACK)) >>> 0;
        this[_checkState](wasInputPaused);
      }
      [_checkState](wasInputPaused) {
        dart.assert(!dart.notNull(this[_inCallback]));
        if (dart.notNull(this[_hasPending]) && dart.notNull(this[_pending].isEmpty)) {
          this[_state] = (dart.notNull(this[_state]) & ~dart.notNull(async._BufferingStreamSubscription._STATE_HAS_PENDING)) >>> 0;
          if (dart.notNull(this[_isInputPaused]) && dart.notNull(this[_mayResumeInput])) {
            this[_state] = (dart.notNull(this[_state]) & ~dart.notNull(async._BufferingStreamSubscription._STATE_INPUT_PAUSED)) >>> 0;
          }
        }
        while (true) {
          if (dart.notNull(this[_isCanceled])) {
            this[_pending] = null;
            return;
          }
          let isInputPaused = this[_isInputPaused];
          if (wasInputPaused == isInputPaused) break;
          this[_state] = (dart.notNull(this[_state]) ^ dart.notNull(async._BufferingStreamSubscription._STATE_IN_CALLBACK)) >>> 0;
          if (dart.notNull(isInputPaused)) {
            this[_onPause]();
          } else {
            this[_onResume]();
          }
          this[_state] = (dart.notNull(this[_state]) & ~dart.notNull(async._BufferingStreamSubscription._STATE_IN_CALLBACK)) >>> 0;
          wasInputPaused = isInputPaused;
        }
        if (dart.notNull(this[_hasPending]) && !dart.notNull(this[_isPaused])) {
          this[_pending].schedule(this);
        }
      }
    }
    _BufferingStreamSubscription[dart.implements] = () => [async.StreamSubscription$(T), async._EventSink$(T), async._EventDispatch$(T)];
    dart.setSignature(_BufferingStreamSubscription, {
      constructors: () => ({_BufferingStreamSubscription: [async._BufferingStreamSubscription$(T), [dart.functionType(dart.void, [T]), core.Function, dart.functionType(dart.void, []), core.bool]]}),
      methods: () => ({
        [_setPendingEvents]: [dart.void, [async._PendingEvents$(T)]],
        onData: [dart.void, [dart.functionType(dart.void, [T])]],
        onError: [dart.void, [core.Function]],
        onDone: [dart.void, [dart.functionType(dart.void, [])]],
        pause: [dart.void, [], [async.Future]],
        resume: [dart.void, []],
        cancel: [async.Future, []],
        asFuture: [E => [async.Future$(E), [], [E]]],
        [_cancel]: [dart.void, []],
        [_incrementPauseCount]: [dart.void, []],
        [_decrementPauseCount]: [dart.void, []],
        [_add$]: [dart.void, [T]],
        [_addError]: [dart.void, [core.Object, core.StackTrace]],
        [_close$]: [dart.void, []],
        [_onPause]: [dart.void, []],
        [_onResume]: [dart.void, []],
        [_onCancel]: [async.Future, []],
        [_addPending]: [dart.void, [async._DelayedEvent]],
        [_sendData]: [dart.void, [T]],
        [_sendError]: [dart.void, [core.Object, core.StackTrace]],
        [_sendDone]: [dart.void, []],
        [_guardCallback]: [dart.void, [dart.dynamic]],
        [_checkState]: [dart.void, [core.bool]]
      })
    });
    return _BufferingStreamSubscription;
  });
  async._BufferingStreamSubscription = async._BufferingStreamSubscription$();
  async._BufferingStreamSubscription._STATE_CANCEL_ON_ERROR = 1;
  async._BufferingStreamSubscription._STATE_CLOSED = 2;
  async._BufferingStreamSubscription._STATE_INPUT_PAUSED = 4;
  async._BufferingStreamSubscription._STATE_CANCELED = 8;
  async._BufferingStreamSubscription._STATE_WAIT_FOR_CANCEL = 16;
  async._BufferingStreamSubscription._STATE_IN_CALLBACK = 32;
  async._BufferingStreamSubscription._STATE_HAS_PENDING = 64;
  async._BufferingStreamSubscription._STATE_PAUSE_COUNT = 128;
  async._BufferingStreamSubscription._STATE_PAUSE_COUNT_SHIFT = 7;
  async._ControllerSubscription$ = dart.generic(T => {
    class _ControllerSubscription extends async._BufferingStreamSubscription$(T) {
      _ControllerSubscription(controller, onData, onError, onDone, cancelOnError) {
        this[_controller$] = controller;
        super._BufferingStreamSubscription(onData, onError, onDone, cancelOnError);
      }
      [_onCancel]() {
        return this[_controller$][_recordCancel](this);
      }
      [_onPause]() {
        this[_controller$][_recordPause](this);
      }
      [_onResume]() {
        this[_controller$][_recordResume](this);
      }
    }
    dart.setSignature(_ControllerSubscription, {
      constructors: () => ({_ControllerSubscription: [async._ControllerSubscription$(T), [async._StreamControllerLifecycle$(T), dart.functionType(dart.void, [T]), core.Function, dart.functionType(dart.void, []), core.bool]]})
    });
    return _ControllerSubscription;
  });
  async._ControllerSubscription = async._ControllerSubscription$();
  async._BroadcastSubscription$ = dart.generic(T => {
    class _BroadcastSubscription extends async._ControllerSubscription$(T) {
      _BroadcastSubscription(controller, onData, onError, onDone, cancelOnError) {
        this[_eventState] = 0;
        this[_next$] = null;
        this[_previous$] = null;
        super._ControllerSubscription(controller, onData, onError, onDone, cancelOnError);
        this[_next$] = this[_previous$] = this;
      }
      [_expectsEvent](eventId) {
        return (dart.notNull(this[_eventState]) & dart.notNull(async._BroadcastSubscription._STATE_EVENT_ID)) >>> 0 == eventId;
      }
      [_toggleEventId]() {
        this[_eventState] = (dart.notNull(this[_eventState]) ^ dart.notNull(async._BroadcastSubscription._STATE_EVENT_ID)) >>> 0;
      }
      get [_isFiring]() {
        return (dart.notNull(this[_eventState]) & dart.notNull(async._BroadcastSubscription._STATE_FIRING)) >>> 0 != 0;
      }
      [_setRemoveAfterFiring]() {
        dart.assert(this[_isFiring]);
        this[_eventState] = (dart.notNull(this[_eventState]) | dart.notNull(async._BroadcastSubscription._STATE_REMOVE_AFTER_FIRING)) >>> 0;
      }
      get [_removeAfterFiring]() {
        return (dart.notNull(this[_eventState]) & dart.notNull(async._BroadcastSubscription._STATE_REMOVE_AFTER_FIRING)) >>> 0 != 0;
      }
      [_onPause]() {}
      [_onResume]() {}
    }
    dart.setSignature(_BroadcastSubscription, {
      constructors: () => ({_BroadcastSubscription: [async._BroadcastSubscription$(T), [async._StreamControllerLifecycle$(T), dart.functionType(dart.void, [T]), core.Function, dart.functionType(dart.void, []), core.bool]]}),
      methods: () => ({
        [_expectsEvent]: [core.bool, [core.int]],
        [_toggleEventId]: [dart.void, []],
        [_setRemoveAfterFiring]: [dart.void, []]
      })
    });
    return _BroadcastSubscription;
  });
  async._BroadcastSubscription = async._BroadcastSubscription$();
  async._BroadcastSubscription._STATE_EVENT_ID = 1;
  async._BroadcastSubscription._STATE_FIRING = 2;
  async._BroadcastSubscription._STATE_REMOVE_AFTER_FIRING = 4;
  const _firstSubscription = Symbol('_firstSubscription');
  const _lastSubscription = Symbol('_lastSubscription');
  const _addStreamState = Symbol('_addStreamState');
  const _doneFuture = Symbol('_doneFuture');
  const _isEmpty = Symbol('_isEmpty');
  const _hasOneListener = Symbol('_hasOneListener');
  const _isAddingStream = Symbol('_isAddingStream');
  const _mayAddEvent = Symbol('_mayAddEvent');
  const _ensureDoneFuture = Symbol('_ensureDoneFuture');
  const _addListener = Symbol('_addListener');
  const _removeListener = Symbol('_removeListener');
  const _callOnCancel = Symbol('_callOnCancel');
  const _addEventError = Symbol('_addEventError');
  const _forEachListener = Symbol('_forEachListener');
  const _mayComplete = Symbol('_mayComplete');
  const _asyncComplete = Symbol('_asyncComplete');
  async._BroadcastStreamController$ = dart.generic(T => {
    class _BroadcastStreamController extends core.Object {
      _BroadcastStreamController(onListen, onCancel) {
        this.onListen = onListen;
        this.onCancel = onCancel;
        this[_state] = async._BroadcastStreamController._STATE_INITIAL;
        this[_firstSubscription] = null;
        this[_lastSubscription] = null;
        this[_addStreamState] = null;
        this[_doneFuture] = null;
      }
      get onPause() {
        dart.throw(new core.UnsupportedError("Broadcast stream controllers do not support pause callbacks"));
      }
      set onPause(onPauseHandler) {
        dart.as(onPauseHandler, dart.functionType(dart.void, []));
        dart.throw(new core.UnsupportedError("Broadcast stream controllers do not support pause callbacks"));
      }
      get onResume() {
        dart.throw(new core.UnsupportedError("Broadcast stream controllers do not support pause callbacks"));
      }
      set onResume(onResumeHandler) {
        dart.as(onResumeHandler, dart.functionType(dart.void, []));
        dart.throw(new core.UnsupportedError("Broadcast stream controllers do not support pause callbacks"));
      }
      get stream() {
        return new (async._BroadcastStream$(T))(this);
      }
      get sink() {
        return new (async._StreamSinkWrapper$(T))(this);
      }
      get isClosed() {
        return (dart.notNull(this[_state]) & dart.notNull(async._BroadcastStreamController._STATE_CLOSED)) >>> 0 != 0;
      }
      get isPaused() {
        return false;
      }
      get hasListener() {
        return !dart.notNull(this[_isEmpty]);
      }
      get [_hasOneListener]() {
        dart.assert(!dart.notNull(this[_isEmpty]));
        return core.identical(this[_firstSubscription], this[_lastSubscription]);
      }
      get [_isFiring]() {
        return (dart.notNull(this[_state]) & dart.notNull(async._BroadcastStreamController._STATE_FIRING)) >>> 0 != 0;
      }
      get [_isAddingStream]() {
        return (dart.notNull(this[_state]) & dart.notNull(async._BroadcastStreamController._STATE_ADDSTREAM)) >>> 0 != 0;
      }
      get [_mayAddEvent]() {
        return dart.notNull(this[_state]) < dart.notNull(async._BroadcastStreamController._STATE_CLOSED);
      }
      [_ensureDoneFuture]() {
        if (this[_doneFuture] != null) return this[_doneFuture];
        return this[_doneFuture] = new async._Future();
      }
      get [_isEmpty]() {
        return this[_firstSubscription] == null;
      }
      [_addListener](subscription) {
        dart.as(subscription, async._BroadcastSubscription$(T));
        dart.assert(core.identical(subscription[_next$], subscription));
        subscription[_eventState] = (dart.notNull(this[_state]) & dart.notNull(async._BroadcastStreamController._STATE_EVENT_ID)) >>> 0;
        let oldLast = this[_lastSubscription];
        this[_lastSubscription] = subscription;
        subscription[_next$] = null;
        subscription[_previous$] = oldLast;
        if (oldLast == null) {
          this[_firstSubscription] = subscription;
        } else {
          oldLast[_next$] = subscription;
        }
      }
      [_removeListener](subscription) {
        dart.as(subscription, async._BroadcastSubscription$(T));
        dart.assert(core.identical(subscription[_controller$], this));
        dart.assert(!core.identical(subscription[_next$], subscription));
        let previous = subscription[_previous$];
        let next = subscription[_next$];
        if (previous == null) {
          this[_firstSubscription] = next;
        } else {
          previous[_next$] = next;
        }
        if (next == null) {
          this[_lastSubscription] = previous;
        } else {
          next[_previous$] = previous;
        }
        subscription[_next$] = subscription[_previous$] = subscription;
      }
      [_subscribe](onData, onError, onDone, cancelOnError) {
        dart.as(onData, dart.functionType(dart.void, [T]));
        dart.as(onDone, dart.functionType(dart.void, []));
        if (dart.notNull(this.isClosed)) {
          if (onDone == null) onDone = async._nullDoneHandler;
          return new (async._DoneStreamSubscription$(T))(onDone);
        }
        let subscription = new (async._BroadcastSubscription$(T))(this, onData, onError, onDone, cancelOnError);
        this[_addListener](dart.as(subscription, async._BroadcastSubscription$(T)));
        if (core.identical(this[_firstSubscription], this[_lastSubscription])) {
          async._runGuarded(this.onListen);
        }
        return subscription;
      }
      [_recordCancel](sub) {
        dart.as(sub, async.StreamSubscription$(T));
        let subscription = dart.as(sub, async._BroadcastSubscription$(T));
        if (core.identical(subscription[_next$], subscription)) return null;
        if (dart.notNull(subscription[_isFiring])) {
          subscription[_setRemoveAfterFiring]();
        } else {
          this[_removeListener](subscription);
          if (!dart.notNull(this[_isFiring]) && dart.notNull(this[_isEmpty])) {
            this[_callOnCancel]();
          }
        }
        return null;
      }
      [_recordPause](subscription) {
        dart.as(subscription, async.StreamSubscription$(T));
      }
      [_recordResume](subscription) {
        dart.as(subscription, async.StreamSubscription$(T));
      }
      [_addEventError]() {
        if (dart.notNull(this.isClosed)) {
          return new core.StateError("Cannot add new events after calling close");
        }
        dart.assert(this[_isAddingStream]);
        return new core.StateError("Cannot add new events while doing an addStream");
      }
      add(data) {
        dart.as(data, T);
        if (!dart.notNull(this[_mayAddEvent])) dart.throw(this[_addEventError]());
        this[_sendData](data);
      }
      addError(error, stackTrace) {
        if (stackTrace === void 0) stackTrace = null;
        error = async._nonNullError(error);
        if (!dart.notNull(this[_mayAddEvent])) dart.throw(this[_addEventError]());
        let replacement = async.Zone.current.errorCallback(error, stackTrace);
        if (replacement != null) {
          error = async._nonNullError(replacement.error);
          stackTrace = replacement.stackTrace;
        }
        this[_sendError](error, stackTrace);
      }
      close() {
        if (dart.notNull(this.isClosed)) {
          dart.assert(this[_doneFuture] != null);
          return this[_doneFuture];
        }
        if (!dart.notNull(this[_mayAddEvent])) dart.throw(this[_addEventError]());
        this[_state] = (dart.notNull(this[_state]) | dart.notNull(async._BroadcastStreamController._STATE_CLOSED)) >>> 0;
        let doneFuture = this[_ensureDoneFuture]();
        this[_sendDone]();
        return doneFuture;
      }
      get done() {
        return this[_ensureDoneFuture]();
      }
      addStream(stream, opts) {
        dart.as(stream, async.Stream$(T));
        let cancelOnError = opts && 'cancelOnError' in opts ? opts.cancelOnError : true;
        if (!dart.notNull(this[_mayAddEvent])) dart.throw(this[_addEventError]());
        this[_state] = (dart.notNull(this[_state]) | dart.notNull(async._BroadcastStreamController._STATE_ADDSTREAM)) >>> 0;
        this[_addStreamState] = new (async._AddStreamState$(T))(this, stream, cancelOnError);
        return this[_addStreamState].addStreamFuture;
      }
      [_add$](data) {
        dart.as(data, T);
        this[_sendData](data);
      }
      [_addError](error, stackTrace) {
        this[_sendError](error, stackTrace);
      }
      [_close$]() {
        dart.assert(this[_isAddingStream]);
        let addState = this[_addStreamState];
        this[_addStreamState] = null;
        this[_state] = (dart.notNull(this[_state]) & ~dart.notNull(async._BroadcastStreamController._STATE_ADDSTREAM)) >>> 0;
        addState.complete();
      }
      [_forEachListener](action) {
        dart.as(action, dart.functionType(dart.void, [async._BufferingStreamSubscription$(T)]));
        if (dart.notNull(this[_isFiring])) {
          dart.throw(new core.StateError("Cannot fire new event. Controller is already firing an event"));
        }
        if (dart.notNull(this[_isEmpty])) return;
        let id = (dart.notNull(this[_state]) & dart.notNull(async._BroadcastStreamController._STATE_EVENT_ID)) >>> 0;
        this[_state] = (dart.notNull(this[_state]) ^ (dart.notNull(async._BroadcastStreamController._STATE_EVENT_ID) | dart.notNull(async._BroadcastStreamController._STATE_FIRING))) >>> 0;
        let subscription = this[_firstSubscription];
        while (subscription != null) {
          if (dart.notNull(subscription[_expectsEvent](id))) {
            subscription[_eventState] = (dart.notNull(subscription[_eventState]) | dart.notNull(async._BroadcastSubscription._STATE_FIRING)) >>> 0;
            action(subscription);
            subscription[_toggleEventId]();
            let next = subscription[_next$];
            if (dart.notNull(subscription[_removeAfterFiring])) {
              this[_removeListener](subscription);
            }
            subscription[_eventState] = (dart.notNull(subscription[_eventState]) & ~dart.notNull(async._BroadcastSubscription._STATE_FIRING)) >>> 0;
            subscription = next;
          } else {
            subscription = subscription[_next$];
          }
        }
        this[_state] = (dart.notNull(this[_state]) & ~dart.notNull(async._BroadcastStreamController._STATE_FIRING)) >>> 0;
        if (dart.notNull(this[_isEmpty])) {
          this[_callOnCancel]();
        }
      }
      [_callOnCancel]() {
        dart.assert(this[_isEmpty]);
        if (dart.notNull(this.isClosed) && dart.notNull(this[_doneFuture][_mayComplete])) {
          this[_doneFuture][_asyncComplete](null);
        }
        async._runGuarded(this.onCancel);
      }
    }
    _BroadcastStreamController[dart.implements] = () => [async.StreamController$(T), async._StreamControllerLifecycle$(T), async._EventSink$(T), async._EventDispatch$(T)];
    dart.setSignature(_BroadcastStreamController, {
      constructors: () => ({_BroadcastStreamController: [async._BroadcastStreamController$(T), [async.ControllerCallback, async.ControllerCancelCallback]]}),
      methods: () => ({
        [_ensureDoneFuture]: [async._Future, []],
        [_addListener]: [dart.void, [async._BroadcastSubscription$(T)]],
        [_removeListener]: [dart.void, [async._BroadcastSubscription$(T)]],
        [_subscribe]: [async.StreamSubscription$(T), [dart.functionType(dart.void, [T]), core.Function, dart.functionType(dart.void, []), core.bool]],
        [_recordCancel]: [async.Future, [async.StreamSubscription$(T)]],
        [_recordPause]: [dart.void, [async.StreamSubscription$(T)]],
        [_recordResume]: [dart.void, [async.StreamSubscription$(T)]],
        [_addEventError]: [core.Error, []],
        add: [dart.void, [T]],
        addError: [dart.void, [core.Object], [core.StackTrace]],
        close: [async.Future, []],
        addStream: [async.Future, [async.Stream$(T)], {cancelOnError: core.bool}],
        [_add$]: [dart.void, [T]],
        [_addError]: [dart.void, [core.Object, core.StackTrace]],
        [_close$]: [dart.void, []],
        [_forEachListener]: [dart.void, [dart.functionType(dart.void, [async._BufferingStreamSubscription$(T)])]],
        [_callOnCancel]: [dart.void, []]
      })
    });
    return _BroadcastStreamController;
  });
  async._BroadcastStreamController = async._BroadcastStreamController$();
  async._BroadcastStreamController._STATE_INITIAL = 0;
  async._BroadcastStreamController._STATE_EVENT_ID = 1;
  async._BroadcastStreamController._STATE_FIRING = 2;
  async._BroadcastStreamController._STATE_CLOSED = 4;
  async._BroadcastStreamController._STATE_ADDSTREAM = 8;
  async._SyncBroadcastStreamController$ = dart.generic(T => {
    class _SyncBroadcastStreamController extends async._BroadcastStreamController$(T) {
      _SyncBroadcastStreamController(onListen, onCancel) {
        super._BroadcastStreamController(onListen, onCancel);
      }
      get [_mayAddEvent]() {
        return dart.notNull(super[_mayAddEvent]) && !dart.notNull(this[_isFiring]);
      }
      [_addEventError]() {
        if (dart.notNull(this[_isFiring])) {
          return new core.StateError("Cannot fire new event. Controller is already firing an event");
        }
        return super[_addEventError]();
      }
      [_sendData](data) {
        dart.as(data, T);
        if (dart.notNull(this[_isEmpty])) return;
        if (dart.notNull(this[_hasOneListener])) {
          this[_state] = (dart.notNull(this[_state]) | dart.notNull(async._BroadcastStreamController._STATE_FIRING)) >>> 0;
          let subscription = this[_firstSubscription];
          subscription[_add$](data);
          this[_state] = (dart.notNull(this[_state]) & ~dart.notNull(async._BroadcastStreamController._STATE_FIRING)) >>> 0;
          if (dart.notNull(this[_isEmpty])) {
            this[_callOnCancel]();
          }
          return;
        }
        this[_forEachListener](dart.fn(subscription => {
          dart.as(subscription, async._BufferingStreamSubscription$(T));
          subscription[_add$](data);
        }, dart.void, [async._BufferingStreamSubscription$(T)]));
      }
      [_sendError](error, stackTrace) {
        if (dart.notNull(this[_isEmpty])) return;
        this[_forEachListener](dart.fn(subscription => {
          dart.as(subscription, async._BufferingStreamSubscription$(T));
          subscription[_addError](error, stackTrace);
        }, dart.void, [async._BufferingStreamSubscription$(T)]));
      }
      [_sendDone]() {
        if (!dart.notNull(this[_isEmpty])) {
          this[_forEachListener](dart.fn(subscription => {
            dart.as(subscription, async._BufferingStreamSubscription$(T));
            subscription[_close$]();
          }, dart.void, [async._BufferingStreamSubscription$(T)]));
        } else {
          dart.assert(this[_doneFuture] != null);
          dart.assert(this[_doneFuture][_mayComplete]);
          this[_doneFuture][_asyncComplete](null);
        }
      }
    }
    _SyncBroadcastStreamController[dart.implements] = () => [async.SynchronousStreamController$(T)];
    dart.setSignature(_SyncBroadcastStreamController, {
      constructors: () => ({_SyncBroadcastStreamController: [async._SyncBroadcastStreamController$(T), [dart.functionType(dart.void, []), dart.functionType(dart.void, [])]]}),
      methods: () => ({
        [_sendData]: [dart.void, [T]],
        [_sendError]: [dart.void, [core.Object, core.StackTrace]],
        [_sendDone]: [dart.void, []]
      })
    });
    return _SyncBroadcastStreamController;
  });
  async._SyncBroadcastStreamController = async._SyncBroadcastStreamController$();
  async._AsyncBroadcastStreamController$ = dart.generic(T => {
    class _AsyncBroadcastStreamController extends async._BroadcastStreamController$(T) {
      _AsyncBroadcastStreamController(onListen, onCancel) {
        super._BroadcastStreamController(onListen, onCancel);
      }
      [_sendData](data) {
        dart.as(data, T);
        for (let subscription = this[_firstSubscription]; subscription != null; subscription = subscription[_next$]) {
          subscription[_addPending](new (async._DelayedData$(T))(data));
        }
      }
      [_sendError](error, stackTrace) {
        for (let subscription = this[_firstSubscription]; subscription != null; subscription = subscription[_next$]) {
          subscription[_addPending](new async._DelayedError(error, stackTrace));
        }
      }
      [_sendDone]() {
        if (!dart.notNull(this[_isEmpty])) {
          for (let subscription = this[_firstSubscription]; subscription != null; subscription = subscription[_next$]) {
            subscription[_addPending](dart.const(new async._DelayedDone()));
          }
        } else {
          dart.assert(this[_doneFuture] != null);
          dart.assert(this[_doneFuture][_mayComplete]);
          this[_doneFuture][_asyncComplete](null);
        }
      }
    }
    dart.setSignature(_AsyncBroadcastStreamController, {
      constructors: () => ({_AsyncBroadcastStreamController: [async._AsyncBroadcastStreamController$(T), [dart.functionType(dart.void, []), dart.functionType(dart.void, [])]]}),
      methods: () => ({
        [_sendData]: [dart.void, [T]],
        [_sendError]: [dart.void, [core.Object, core.StackTrace]],
        [_sendDone]: [dart.void, []]
      })
    });
    return _AsyncBroadcastStreamController;
  });
  async._AsyncBroadcastStreamController = async._AsyncBroadcastStreamController$();
  const _addPendingEvent = Symbol('_addPendingEvent');
  async._AsBroadcastStreamController$ = dart.generic(T => {
    class _AsBroadcastStreamController extends async._SyncBroadcastStreamController$(T) {
      _AsBroadcastStreamController(onListen, onCancel) {
        this[_pending] = null;
        super._SyncBroadcastStreamController(onListen, onCancel);
      }
      get [_hasPending]() {
        return this[_pending] != null && !dart.notNull(this[_pending].isEmpty);
      }
      [_addPendingEvent](event) {
        if (this[_pending] == null) {
          this[_pending] = new (async._StreamImplEvents$(T))();
        }
        this[_pending].add(event);
      }
      add(data) {
        dart.as(data, T);
        if (!dart.notNull(this.isClosed) && dart.notNull(this[_isFiring])) {
          this[_addPendingEvent](new (async._DelayedData$(T))(data));
          return;
        }
        super.add(data);
        while (dart.notNull(this[_hasPending])) {
          this[_pending].handleNext(this);
        }
      }
      addError(error, stackTrace) {
        if (stackTrace === void 0) stackTrace = null;
        if (!dart.notNull(this.isClosed) && dart.notNull(this[_isFiring])) {
          this[_addPendingEvent](new async._DelayedError(error, stackTrace));
          return;
        }
        if (!dart.notNull(this[_mayAddEvent])) dart.throw(this[_addEventError]());
        this[_sendError](error, stackTrace);
        while (dart.notNull(this[_hasPending])) {
          this[_pending].handleNext(this);
        }
      }
      close() {
        if (!dart.notNull(this.isClosed) && dart.notNull(this[_isFiring])) {
          this[_addPendingEvent](dart.const(new async._DelayedDone()));
          this[_state] = (dart.notNull(this[_state]) | dart.notNull(async._BroadcastStreamController._STATE_CLOSED)) >>> 0;
          return super.done;
        }
        let result = super.close();
        dart.assert(!dart.notNull(this[_hasPending]));
        return result;
      }
      [_callOnCancel]() {
        if (dart.notNull(this[_hasPending])) {
          this[_pending].clear();
          this[_pending] = null;
        }
        super[_callOnCancel]();
      }
    }
    _AsBroadcastStreamController[dart.implements] = () => [async._EventDispatch$(T)];
    dart.setSignature(_AsBroadcastStreamController, {
      constructors: () => ({_AsBroadcastStreamController: [async._AsBroadcastStreamController$(T), [dart.functionType(dart.void, []), dart.functionType(dart.void, [])]]}),
      methods: () => ({
        [_addPendingEvent]: [dart.void, [async._DelayedEvent]],
        add: [dart.void, [T]]
      })
    });
    return _AsBroadcastStreamController;
  });
  async._AsBroadcastStreamController = async._AsBroadcastStreamController$();
  const _pauseCount = Symbol('_pauseCount');
  const _resume = Symbol('_resume');
  async._DoneSubscription$ = dart.generic(T => {
    class _DoneSubscription extends core.Object {
      _DoneSubscription() {
        this[_pauseCount] = 0;
      }
      onData(handleData) {
        dart.as(handleData, dart.functionType(dart.void, [T]));
      }
      onError(handleError) {}
      onDone(handleDone) {
        dart.as(handleDone, dart.functionType(dart.void, []));
      }
      pause(resumeSignal) {
        if (resumeSignal === void 0) resumeSignal = null;
        if (resumeSignal != null) resumeSignal.then(dart.dynamic)(dart.bind(this, _resume));
        this[_pauseCount] = dart.notNull(this[_pauseCount]) + 1;
      }
      resume() {
        this[_resume](null);
      }
      [_resume](_) {
        if (dart.notNull(this[_pauseCount]) > 0) {
          this[_pauseCount] = dart.notNull(this[_pauseCount]) - 1;
        }
      }
      cancel() {
        return new async._Future.immediate(null);
      }
      get isPaused() {
        return dart.notNull(this[_pauseCount]) > 0;
      }
      asFuture(E) {
        return value => {
          if (value === void 0) value = null;
          return new (async._Future$(E))();
        };
      }
    }
    _DoneSubscription[dart.implements] = () => [async.StreamSubscription$(T)];
    dart.setSignature(_DoneSubscription, {
      methods: () => ({
        onData: [dart.void, [dart.functionType(dart.void, [T])]],
        onError: [dart.void, [core.Function]],
        onDone: [dart.void, [dart.functionType(dart.void, [])]],
        pause: [dart.void, [], [async.Future]],
        resume: [dart.void, []],
        [_resume]: [dart.void, [dart.dynamic]],
        cancel: [async.Future, []],
        asFuture: [E => [async.Future$(E), [], [E]]]
      })
    });
    return _DoneSubscription;
  });
  async._DoneSubscription = async._DoneSubscription$();
  async.DeferredLibrary = class DeferredLibrary extends core.Object {
    DeferredLibrary(libraryName, opts) {
      let uri = opts && 'uri' in opts ? opts.uri : null;
      this.libraryName = libraryName;
      this.uri = uri;
    }
    load() {
      dart.throw('DeferredLibrary not supported. ' + 'please use the `import "lib.dart" deferred as lib` syntax.');
    }
  };
  dart.setSignature(async.DeferredLibrary, {
    constructors: () => ({DeferredLibrary: [async.DeferredLibrary, [core.String], {uri: core.String}]}),
    methods: () => ({load: [async.Future$(core.Null), []]})
  });
  async.DeferredLibrary[dart.metadata] = () => [dart.const(new core.Deprecated("Dart sdk v. 1.8"))];
  const _s = Symbol('_s');
  async.DeferredLoadException = class DeferredLoadException extends core.Object {
    DeferredLoadException(s) {
      this[_s] = s;
    }
    toString() {
      return `DeferredLoadException: '${this[_s]}'`;
    }
  };
  async.DeferredLoadException[dart.implements] = () => [core.Exception];
  dart.setSignature(async.DeferredLoadException, {
    constructors: () => ({DeferredLoadException: [async.DeferredLoadException, [core.String]]})
  });
  const _completeWithValue = Symbol('_completeWithValue');
  async.Future$ = dart.generic(T => {
    class Future extends core.Object {
      static new(computation) {
        let result = new (async._Future$(T))();
        async.Timer.run(dart.fn(() => {
          try {
            result[_complete](computation());
          } catch (e) {
            let s = dart.stackTrace(e);
            async._completeWithErrorCallback(result, e, s);
          }

        }, dart.void, []));
        return result;
      }
      static microtask(computation) {
        let result = new (async._Future$(T))();
        async.scheduleMicrotask(dart.fn(() => {
          try {
            result[_complete](computation());
          } catch (e) {
            let s = dart.stackTrace(e);
            async._completeWithErrorCallback(result, e, s);
          }

        }, dart.void, []));
        return result;
      }
      static sync(computation) {
        try {
          let result = computation();
          return async.Future$(T).value(result);
        } catch (error) {
          let stackTrace = dart.stackTrace(error);
          return async.Future$(T).error(error, stackTrace);
        }

      }
      static value(value) {
        if (value === void 0) value = null;
        return new (async._Future$(T)).immediate(value);
      }
      static error(error, stackTrace) {
        if (stackTrace === void 0) stackTrace = null;
        error = async._nonNullError(error);
        if (!core.identical(async.Zone.current, async._ROOT_ZONE)) {
          let replacement = async.Zone.current.errorCallback(error, stackTrace);
          if (replacement != null) {
            error = async._nonNullError(replacement.error);
            stackTrace = replacement.stackTrace;
          }
        }
        return new (async._Future$(T)).immediateError(error, stackTrace);
      }
      static delayed(duration, computation) {
        if (computation === void 0) computation = null;
        let result = new (async._Future$(T))();
        async.Timer.new(duration, dart.fn(() => {
          try {
            result[_complete](computation == null ? null : computation());
          } catch (e) {
            let s = dart.stackTrace(e);
            async._completeWithErrorCallback(result, e, s);
          }

        }, dart.void, []));
        return result;
      }
      static wait(T) {
        return (futures, opts) => {
          let eagerError = opts && 'eagerError' in opts ? opts.eagerError : false;
          let cleanUp = opts && 'cleanUp' in opts ? opts.cleanUp : null;
          let result = new (async._Future$(core.List$(T)))();
          let values = null;
          let remaining = 0;
          let error = null;
          let stackTrace = null;
          function handleError(theError, theStackTrace) {
            remaining--;
            if (values != null) {
              if (cleanUp != null) {
                for (let value of values) {
                  if (value != null) {
                    async.Future.sync(dart.fn(() => {
                      cleanUp(value);
                    }));
                  }
                }
              }
              values = null;
              if (remaining == 0 || dart.notNull(eagerError)) {
                result[_completeError](theError, dart.as(theStackTrace, core.StackTrace));
              } else {
                error = theError;
                stackTrace = dart.as(theStackTrace, core.StackTrace);
              }
            } else if (remaining == 0 && !dart.notNull(eagerError)) {
              result[_completeError](error, stackTrace);
            }
          }
          dart.fn(handleError, dart.void, [dart.dynamic, dart.dynamic]);
          for (let future of futures) {
            let pos = remaining++;
            future.then(dart.dynamic)(dart.fn(value => {
              remaining--;
              if (values != null) {
                values[dartx.set](pos, value);
                if (remaining == 0) {
                  result[_completeWithValue](values);
                }
              } else {
                if (cleanUp != null && value != null) {
                  async.Future.sync(dart.fn(() => {
                    cleanUp(value);
                  }));
                }
                if (remaining == 0 && !dart.notNull(eagerError)) {
                  result[_completeError](error, stackTrace);
                }
              }
            }, dart.dynamic, [T]), {onError: handleError});
          }
          if (remaining == 0) {
            return async.Future$(core.List$(T)).value(dart.const([]));
          }
          values = core.List$(T).new(remaining);
          return result;
        };
      }
      static any(T) {
        return futures => {
          let completer = async.Completer$(T).sync();
          let onValue = dart.fn(value => {
            if (!dart.notNull(completer.isCompleted)) completer.complete(value);
          }, dart.dynamic, [T]);
          let onError = dart.fn((error, stack) => {
            if (!dart.notNull(completer.isCompleted)) completer.completeError(error, dart.as(stack, core.StackTrace));
          });
          for (let future of futures) {
            future.then(dart.dynamic)(onValue, {onError: onError});
          }
          return completer.future;
        };
      }
      static forEach(input, f) {
        let iterator = input[dartx.iterator];
        return async.Future.doWhile(dart.fn(() => {
          if (!dart.notNull(iterator.moveNext())) return false;
          return async.Future.sync(dart.fn(() => dart.dcall(f, iterator.current))).then(core.bool)(dart.fn(_ => true, core.bool, [dart.dynamic]));
        }, core.Object, []));
      }
      static doWhile(f) {
        let doneSignal = new async._Future();
        let nextIteration = null;
        nextIteration = async.Zone.current.bindUnaryCallback(dart.dynamic, core.bool)(dart.fn(keepGoing => {
          if (dart.notNull(keepGoing)) {
            async.Future.sync(f).then(dart.dynamic)(dart.as(nextIteration, dart.functionType(dart.dynamic, [dart.dynamic])), {onError: dart.bind(doneSignal, _completeError)});
          } else {
            doneSignal[_complete](null);
          }
        }, dart.dynamic, [core.bool]), {runGuarded: true});
        dart.dcall(nextIteration, true);
        return doneSignal;
      }
    }
    dart.setSignature(Future, {
      constructors: () => ({
        new: [async.Future$(T), [dart.functionType(dart.dynamic, [])]],
        microtask: [async.Future$(T), [dart.functionType(dart.dynamic, [])]],
        sync: [async.Future$(T), [dart.functionType(dart.dynamic, [])]],
        value: [async.Future$(T), [], [dart.dynamic]],
        error: [async.Future$(T), [core.Object], [core.StackTrace]],
        delayed: [async.Future$(T), [core.Duration], [dart.functionType(dart.dynamic, [])]]
      }),
      statics: () => ({
        wait: [T => [async.Future$(core.List$(T)), [core.Iterable$(async.Future$(T))], {eagerError: core.bool, cleanUp: dart.functionType(dart.void, [T])}]],
        any: [T => [async.Future$(T), [core.Iterable$(async.Future$(T))]]],
        forEach: [async.Future, [core.Iterable, dart.functionType(dart.dynamic, [dart.dynamic])]],
        doWhile: [async.Future, [dart.functionType(dart.dynamic, [])]]
      }),
      names: ['wait', 'any', 'forEach', 'doWhile']
    });
    return Future;
  });
  async.Future = async.Future$();
  dart.defineLazy(async.Future, {
    get _nullFuture() {
      return dart.as(async.Future.value(null), async._Future);
    }
  });
  async.TimeoutException = class TimeoutException extends core.Object {
    TimeoutException(message, duration) {
      if (duration === void 0) duration = null;
      this.message = message;
      this.duration = duration;
    }
    toString() {
      let result = "TimeoutException";
      if (this.duration != null) result = `TimeoutException after ${this.duration}`;
      if (this.message != null) result = `${result}: ${this.message}`;
      return result;
    }
  };
  async.TimeoutException[dart.implements] = () => [core.Exception];
  dart.setSignature(async.TimeoutException, {
    constructors: () => ({TimeoutException: [async.TimeoutException, [core.String], [core.Duration]]})
  });
  async.Completer$ = dart.generic(T => {
    class Completer extends core.Object {
      static new() {
        return new (async._AsyncCompleter$(T))();
      }
      static sync() {
        return new (async._SyncCompleter$(T))();
      }
    }
    dart.setSignature(Completer, {
      constructors: () => ({
        new: [async.Completer$(T), []],
        sync: [async.Completer$(T), []]
      })
    });
    return Completer;
  });
  async.Completer = async.Completer$();
  async._completeWithErrorCallback = function(result, error, stackTrace) {
    let replacement = async.Zone.current.errorCallback(error, dart.as(stackTrace, core.StackTrace));
    if (replacement != null) {
      error = async._nonNullError(replacement.error);
      stackTrace = replacement.stackTrace;
    }
    result[_completeError](error, dart.as(stackTrace, core.StackTrace));
  };
  dart.lazyFn(async._completeWithErrorCallback, () => [dart.void, [async._Future, dart.dynamic, dart.dynamic]]);
  async._nonNullError = function(error) {
    return error != null ? error : new core.NullThrownError();
  };
  dart.fn(async._nonNullError, core.Object, [core.Object]);
  async._FutureOnValue$ = dart.generic((S, T) => {
    const _FutureOnValue = dart.typedef('_FutureOnValue', () => dart.functionType(dart.dynamic, [S]));
    return _FutureOnValue;
  });
  async._FutureOnValue = async._FutureOnValue$();
  async._FutureErrorTest = dart.typedef('_FutureErrorTest', () => dart.functionType(core.bool, [dart.dynamic]));
  async._FutureAction = dart.typedef('_FutureAction', () => dart.functionType(dart.dynamic, []));
  async._Completer$ = dart.generic(T => {
    class _Completer extends core.Object {
      _Completer() {
        this.future = new (async._Future$(T))();
      }
      completeError(error, stackTrace) {
        if (stackTrace === void 0) stackTrace = null;
        error = async._nonNullError(error);
        if (!dart.notNull(this.future[_mayComplete])) dart.throw(new core.StateError("Future already completed"));
        let replacement = async.Zone.current.errorCallback(error, stackTrace);
        if (replacement != null) {
          error = async._nonNullError(replacement.error);
          stackTrace = replacement.stackTrace;
        }
        this[_completeError](error, stackTrace);
      }
      get isCompleted() {
        return !dart.notNull(this.future[_mayComplete]);
      }
    }
    _Completer[dart.implements] = () => [async.Completer$(T)];
    dart.setSignature(_Completer, {
      methods: () => ({completeError: [dart.void, [core.Object], [core.StackTrace]]})
    });
    return _Completer;
  });
  async._Completer = async._Completer$();
  const _asyncCompleteError = Symbol('_asyncCompleteError');
  async._AsyncCompleter$ = dart.generic(T => {
    class _AsyncCompleter extends async._Completer$(T) {
      _AsyncCompleter() {
        super._Completer();
      }
      complete(value) {
        if (value === void 0) value = null;
        if (!dart.notNull(this.future[_mayComplete])) dart.throw(new core.StateError("Future already completed"));
        this.future[_asyncComplete](value);
      }
      [_completeError](error, stackTrace) {
        this.future[_asyncCompleteError](error, stackTrace);
      }
    }
    dart.setSignature(_AsyncCompleter, {
      methods: () => ({
        complete: [dart.void, [], [dart.dynamic]],
        [_completeError]: [dart.void, [core.Object, core.StackTrace]]
      })
    });
    return _AsyncCompleter;
  });
  async._AsyncCompleter = async._AsyncCompleter$();
  async._SyncCompleter$ = dart.generic(T => {
    class _SyncCompleter extends async._Completer$(T) {
      _SyncCompleter() {
        super._Completer();
      }
      complete(value) {
        if (value === void 0) value = null;
        if (!dart.notNull(this.future[_mayComplete])) dart.throw(new core.StateError("Future already completed"));
        this.future[_complete](value);
      }
      [_completeError](error, stackTrace) {
        this.future[_completeError](error, stackTrace);
      }
    }
    dart.setSignature(_SyncCompleter, {
      methods: () => ({
        complete: [dart.void, [], [dart.dynamic]],
        [_completeError]: [dart.void, [core.Object, core.StackTrace]]
      })
    });
    return _SyncCompleter;
  });
  async._SyncCompleter = async._SyncCompleter$();
  const _nextListener = Symbol('_nextListener');
  const _onValue = Symbol('_onValue');
  const _errorTest = Symbol('_errorTest');
  const _whenCompleteAction = Symbol('_whenCompleteAction');
  async._FutureListener$ = dart.generic((S, T) => {
    class _FutureListener extends core.Object {
      then(result, onValue, errorCallback) {
        this.result = result;
        this.callback = onValue;
        this.errorCallback = errorCallback;
        this.state = errorCallback == null ? async._FutureListener.STATE_THEN : async._FutureListener.STATE_THEN_ONERROR;
        this[_nextListener] = null;
      }
      catchError(result, errorCallback, test) {
        this.result = result;
        this.errorCallback = errorCallback;
        this.callback = test;
        this.state = test == null ? async._FutureListener.STATE_CATCHERROR : async._FutureListener.STATE_CATCHERROR_TEST;
        this[_nextListener] = null;
      }
      whenComplete(result, onComplete) {
        this.result = result;
        this.callback = onComplete;
        this.errorCallback = null;
        this.state = async._FutureListener.STATE_WHENCOMPLETE;
        this[_nextListener] = null;
      }
      get [_zone]() {
        return this.result[_zone];
      }
      get handlesValue() {
        return (dart.notNull(this.state) & dart.notNull(async._FutureListener.MASK_VALUE)) >>> 0 != 0;
      }
      get handlesError() {
        return (dart.notNull(this.state) & dart.notNull(async._FutureListener.MASK_ERROR)) >>> 0 != 0;
      }
      get hasErrorTest() {
        return this.state == async._FutureListener.STATE_CATCHERROR_TEST;
      }
      get handlesComplete() {
        return this.state == async._FutureListener.STATE_WHENCOMPLETE;
      }
      get [_onValue]() {
        dart.assert(this.handlesValue);
        return dart.as(this.callback, async._FutureOnValue$(S, T));
      }
      get [_onError]() {
        return this.errorCallback;
      }
      get [_errorTest]() {
        dart.assert(this.hasErrorTest);
        return dart.as(this.callback, async._FutureErrorTest);
      }
      get [_whenCompleteAction]() {
        dart.assert(this.handlesComplete);
        return dart.as(this.callback, async._FutureAction);
      }
      get hasErrorCallback() {
        dart.assert(this.handlesError);
        return this[_onError] != null;
      }
      handleValue(sourceResult) {
        dart.as(sourceResult, S);
        return this[_zone].runUnary(dart.dynamic, S)(this[_onValue], sourceResult);
      }
      matchesErrorTest(asyncError) {
        if (!dart.notNull(this.hasErrorTest)) return true;
        let test = this[_errorTest];
        return this[_zone].runUnary(core.bool, dart.dynamic)(this[_errorTest], asyncError.error);
      }
      handleError(asyncError) {
        dart.assert(dart.notNull(this.handlesError) && dart.notNull(this.hasErrorCallback));
        if (dart.is(this.errorCallback, async.ZoneBinaryCallback)) {
          let typedErrorCallback = dart.as(this.errorCallback, async.ZoneBinaryCallback$(core.Object, core.Object, core.StackTrace));
          return this[_zone].runBinary(core.Object, core.Object, core.StackTrace)(typedErrorCallback, asyncError.error, asyncError.stackTrace);
        } else {
          return this[_zone].runUnary(dart.dynamic, dart.dynamic)(dart.as(this.errorCallback, dart.functionType(dart.dynamic, [dart.dynamic])), asyncError.error);
        }
      }
      handleWhenComplete() {
        dart.assert(!dart.notNull(this.handlesError));
        return this[_zone].run(dart.dynamic)(this[_whenCompleteAction]);
      }
    }
    dart.defineNamedConstructor(_FutureListener, 'then');
    dart.defineNamedConstructor(_FutureListener, 'catchError');
    dart.defineNamedConstructor(_FutureListener, 'whenComplete');
    dart.setSignature(_FutureListener, {
      constructors: () => ({
        then: [async._FutureListener$(S, T), [async._Future$(T), async._FutureOnValue$(S, T), core.Function]],
        catchError: [async._FutureListener$(S, T), [async._Future$(T), core.Function, async._FutureErrorTest]],
        whenComplete: [async._FutureListener$(S, T), [async._Future$(T), async._FutureAction]]
      }),
      methods: () => ({
        handleValue: [dart.dynamic, [S]],
        matchesErrorTest: [core.bool, [async.AsyncError]],
        handleError: [dart.dynamic, [async.AsyncError]],
        handleWhenComplete: [dart.dynamic, []]
      })
    });
    return _FutureListener;
  });
  async._FutureListener = async._FutureListener$();
  async._FutureListener.MASK_VALUE = 1;
  async._FutureListener.MASK_ERROR = 2;
  async._FutureListener.MASK_TEST_ERROR = 4;
  async._FutureListener.MASK_WHENCOMPLETE = 8;
  async._FutureListener.STATE_CHAIN = 0;
  async._FutureListener.STATE_THEN_ONERROR = 3;
  async._FutureListener.STATE_CATCHERROR_TEST = 6;
  dart.defineLazy(async._FutureListener, {
    get STATE_THEN() {
      return async._FutureListener.MASK_VALUE;
    },
    get STATE_CATCHERROR() {
      return async._FutureListener.MASK_ERROR;
    },
    get STATE_WHENCOMPLETE() {
      return async._FutureListener.MASK_WHENCOMPLETE;
    }
  });
  const _resultOrListeners = Symbol('_resultOrListeners');
  const _isPendingComplete = Symbol('_isPendingComplete');
  const _mayAddListener = Symbol('_mayAddListener');
  const _isChained = Symbol('_isChained');
  const _isComplete = Symbol('_isComplete');
  const _hasError = Symbol('_hasError');
  const _setChained = Symbol('_setChained');
  const _thenNoZoneRegistration = Symbol('_thenNoZoneRegistration');
  const _setPendingComplete = Symbol('_setPendingComplete');
  const _error = Symbol('_error');
  const _chainSource = Symbol('_chainSource');
  const _setValue = Symbol('_setValue');
  const _setErrorObject = Symbol('_setErrorObject');
  const _setError = Symbol('_setError');
  const _cloneResult = Symbol('_cloneResult');
  const _prependListeners = Symbol('_prependListeners');
  const _reverseListeners = Symbol('_reverseListeners');
  const _removeListeners = Symbol('_removeListeners');
  async._Future$ = dart.generic(T => {
    class _Future extends core.Object {
      _Future() {
        this[_zone] = async.Zone.current;
        this[_state] = async._Future._INCOMPLETE;
        this[_resultOrListeners] = null;
      }
      immediate(value) {
        this[_zone] = async.Zone.current;
        this[_state] = async._Future._INCOMPLETE;
        this[_resultOrListeners] = null;
        this[_asyncComplete](value);
      }
      immediateError(error, stackTrace) {
        if (stackTrace === void 0) stackTrace = null;
        this[_zone] = async.Zone.current;
        this[_state] = async._Future._INCOMPLETE;
        this[_resultOrListeners] = null;
        this[_asyncCompleteError](error, stackTrace);
      }
      get [_mayComplete]() {
        return this[_state] == async._Future._INCOMPLETE;
      }
      get [_isPendingComplete]() {
        return this[_state] == async._Future._PENDING_COMPLETE;
      }
      get [_mayAddListener]() {
        return dart.notNull(this[_state]) <= dart.notNull(async._Future._PENDING_COMPLETE);
      }
      get [_isChained]() {
        return this[_state] == async._Future._CHAINED;
      }
      get [_isComplete]() {
        return dart.notNull(this[_state]) >= dart.notNull(async._Future._VALUE);
      }
      get [_hasError]() {
        return this[_state] == async._Future._ERROR;
      }
      [_setChained](source) {
        dart.assert(this[_mayAddListener]);
        this[_state] = async._Future._CHAINED;
        this[_resultOrListeners] = source;
      }
      then(E) {
        return (f, opts) => {
          dart.as(f, dart.functionType(dart.dynamic, [T]));
          let onError = opts && 'onError' in opts ? opts.onError : null;
          let currentZone = async.Zone.current;
          let registered = null;
          if (!core.identical(currentZone, async._ROOT_ZONE)) {
            f = currentZone.registerUnaryCallback(dart.dynamic, T)(f);
            if (onError != null) {
              onError = async._registerErrorHandler(T)(onError, currentZone);
            }
          }
          return this[_thenNoZoneRegistration](E)(f, onError);
        };
      }
      [_thenNoZoneRegistration](E) {
        return (f, onError) => {
          dart.as(f, dart.functionType(dart.dynamic, [T]));
          let result = new (async._Future$(E))();
          this[_addListener](new (async._FutureListener$(T, E)).then(result, f, onError));
          return result;
        };
      }
      catchError(onError, opts) {
        let test = opts && 'test' in opts ? opts.test : null;
        dart.as(test, dart.functionType(core.bool, [dart.dynamic]));
        let result = new (async._Future$(T))();
        if (!core.identical(result[_zone], async._ROOT_ZONE)) {
          onError = async._registerErrorHandler(T)(onError, result[_zone]);
          if (test != null) test = result[_zone].registerUnaryCallback(core.bool, dart.dynamic)(test);
        }
        this[_addListener](new (async._FutureListener$(T, T)).catchError(result, onError, test));
        return result;
      }
      whenComplete(action) {
        dart.as(action, dart.functionType(dart.dynamic, []));
        let result = new (async._Future$(T))();
        if (!core.identical(result[_zone], async._ROOT_ZONE)) {
          action = result[_zone].registerCallback(dart.dynamic)(action);
        }
        this[_addListener](new (async._FutureListener$(T, T)).whenComplete(result, action));
        return result;
      }
      asStream() {
        return async.Stream$(T).fromFuture(this);
      }
      [_setPendingComplete]() {
        dart.assert(this[_mayComplete]);
        this[_state] = async._Future._PENDING_COMPLETE;
      }
      get [_error]() {
        dart.assert(this[_hasError]);
        return dart.as(this[_resultOrListeners], async.AsyncError);
      }
      get [_chainSource]() {
        dart.assert(this[_isChained]);
        return dart.as(this[_resultOrListeners], async._Future);
      }
      [_setValue](value) {
        dart.as(value, T);
        dart.assert(!dart.notNull(this[_isComplete]));
        this[_state] = async._Future._VALUE;
        this[_resultOrListeners] = value;
      }
      [_setErrorObject](error) {
        dart.assert(!dart.notNull(this[_isComplete]));
        this[_state] = async._Future._ERROR;
        this[_resultOrListeners] = error;
      }
      [_setError](error, stackTrace) {
        this[_setErrorObject](new async.AsyncError(error, stackTrace));
      }
      [_cloneResult](source) {
        dart.assert(!dart.notNull(this[_isComplete]));
        dart.assert(source[_isComplete]);
        this[_state] = source[_state];
        this[_resultOrListeners] = source[_resultOrListeners];
      }
      [_addListener](listener) {
        dart.assert(listener[_nextListener] == null);
        if (dart.notNull(this[_mayAddListener])) {
          listener[_nextListener] = dart.as(this[_resultOrListeners], async._FutureListener);
          this[_resultOrListeners] = listener;
        } else {
          if (dart.notNull(this[_isChained])) {
            let source = this[_chainSource];
            if (!dart.notNull(source[_isComplete])) {
              source[_addListener](listener);
              return;
            }
            this[_cloneResult](source);
          }
          dart.assert(this[_isComplete]);
          this[_zone].scheduleMicrotask(dart.fn(() => {
            async._Future._propagateToListeners(this, listener);
          }, dart.void, []));
        }
      }
      [_prependListeners](listeners) {
        if (listeners == null) return;
        if (dart.notNull(this[_mayAddListener])) {
          let existingListeners = dart.as(this[_resultOrListeners], async._FutureListener);
          this[_resultOrListeners] = listeners;
          if (existingListeners != null) {
            let cursor = listeners;
            while (cursor[_nextListener] != null) {
              cursor = cursor[_nextListener];
            }
            cursor[_nextListener] = existingListeners;
          }
        } else {
          if (dart.notNull(this[_isChained])) {
            let source = this[_chainSource];
            if (!dart.notNull(source[_isComplete])) {
              source[_prependListeners](listeners);
              return;
            }
            this[_cloneResult](source);
          }
          dart.assert(this[_isComplete]);
          listeners = this[_reverseListeners](listeners);
          this[_zone].scheduleMicrotask(dart.fn(() => {
            async._Future._propagateToListeners(this, listeners);
          }, dart.void, []));
        }
      }
      [_removeListeners]() {
        dart.assert(!dart.notNull(this[_isComplete]));
        let current = dart.as(this[_resultOrListeners], async._FutureListener);
        this[_resultOrListeners] = null;
        return this[_reverseListeners](current);
      }
      [_reverseListeners](listeners) {
        let prev = null;
        let current = listeners;
        while (current != null) {
          let next = current[_nextListener];
          current[_nextListener] = prev;
          prev = current;
          current = next;
        }
        return prev;
      }
      static _chainForeignFuture(source, target) {
        dart.assert(!dart.notNull(target[_isComplete]));
        dart.assert(!dart.is(source, async._Future));
        target[_setPendingComplete]();
        try {
          source.then(dart.dynamic)(dart.fn(value => {
            dart.assert(target[_isPendingComplete]);
            target[_completeWithValue](value);
          }), {onError: dart.fn((error, stackTrace) => {
              if (stackTrace === void 0) stackTrace = null;
              dart.assert(target[_isPendingComplete]);
              target[_completeError](error, dart.as(stackTrace, core.StackTrace));
            }, dart.dynamic, [dart.dynamic], [dart.dynamic])});
        } catch (e) {
          let s = dart.stackTrace(e);
          async.scheduleMicrotask(dart.fn(() => {
            target[_completeError](e, s);
          }, dart.void, []));
        }

      }
      static _chainCoreFuture(source, target) {
        dart.assert(target[_mayAddListener]);
        while (dart.notNull(source[_isChained])) {
          source = source[_chainSource];
        }
        if (dart.notNull(source[_isComplete])) {
          let listeners = target[_removeListeners]();
          target[_cloneResult](source);
          async._Future._propagateToListeners(target, listeners);
        } else {
          let listeners = dart.as(target[_resultOrListeners], async._FutureListener);
          target[_setChained](source);
          source[_prependListeners](listeners);
        }
      }
      [_complete](value) {
        dart.assert(!dart.notNull(this[_isComplete]));
        if (dart.is(value, async.Future)) {
          if (dart.is(value, async._Future)) {
            async._Future._chainCoreFuture(value, this);
          } else {
            async._Future._chainForeignFuture(value, this);
          }
        } else {
          let listeners = this[_removeListeners]();
          this[_setValue](dart.as(value, T));
          async._Future._propagateToListeners(this, listeners);
        }
      }
      [_completeWithValue](value) {
        dart.as(value, T);
        dart.assert(!dart.notNull(this[_isComplete]));
        dart.assert(!dart.is(value, async.Future));
        let listeners = this[_removeListeners]();
        this[_setValue](value);
        async._Future._propagateToListeners(this, listeners);
      }
      [_completeError](error, stackTrace) {
        if (stackTrace === void 0) stackTrace = null;
        dart.assert(!dart.notNull(this[_isComplete]));
        let listeners = this[_removeListeners]();
        this[_setError](error, stackTrace);
        async._Future._propagateToListeners(this, listeners);
      }
      [_asyncComplete](value) {
        dart.assert(!dart.notNull(this[_isComplete]));
        if (dart.is(value, async.Future)) {
          let typedFuture = dart.as(value, async.Future$(T));
          if (dart.is(typedFuture, async._Future)) {
            let coreFuture = dart.as(typedFuture, async._Future$(T));
            if (dart.notNull(coreFuture[_hasError])) {
              this[_setPendingComplete]();
              this[_zone].scheduleMicrotask(dart.fn(() => {
                async._Future._chainCoreFuture(coreFuture, this);
              }, dart.void, []));
            } else {
              async._Future._chainCoreFuture(coreFuture, this);
            }
          } else {
            async._Future._chainForeignFuture(typedFuture, this);
          }
          return;
        }
        let typedValue = dart.as(value, T);
        this[_setPendingComplete]();
        this[_zone].scheduleMicrotask(dart.fn(() => {
          this[_completeWithValue](typedValue);
        }, dart.void, []));
      }
      [_asyncCompleteError](error, stackTrace) {
        dart.assert(!dart.notNull(this[_isComplete]));
        this[_setPendingComplete]();
        this[_zone].scheduleMicrotask(dart.fn(() => {
          this[_completeError](error, stackTrace);
        }, dart.void, []));
      }
      static _propagateToListeners(source, listeners) {
        while (true) {
          dart.assert(source[_isComplete]);
          let hasError = source[_hasError];
          if (listeners == null) {
            if (dart.notNull(hasError)) {
              let asyncError = source[_error];
              source[_zone].handleUncaughtError(dart.dynamic)(asyncError.error, asyncError.stackTrace);
            }
            return;
          }
          while (listeners[_nextListener] != null) {
            let listener = listeners;
            listeners = listener[_nextListener];
            listener[_nextListener] = null;
            async._Future._propagateToListeners(source, listener);
          }
          let listener = listeners;
          let sourceResult = source[_resultOrListeners];
          let listenerHasError = hasError;
          let listenerValueOrError = sourceResult;
          if (dart.notNull(hasError) || dart.notNull(listener.handlesValue) || dart.notNull(listener.handlesComplete)) {
            let zone = listener[_zone];
            if (dart.notNull(hasError) && !dart.notNull(source[_zone].inSameErrorZone(zone))) {
              let asyncError = source[_error];
              source[_zone].handleUncaughtError(dart.dynamic)(asyncError.error, asyncError.stackTrace);
              return;
            }
            let oldZone = null;
            if (!core.identical(async.Zone.current, zone)) {
              oldZone = async.Zone._enter(zone);
            }
            function handleWhenCompleteCallback() {
              dart.assert(!dart.notNull(listener.handlesValue));
              dart.assert(!dart.notNull(listener.handlesError));
              let completeResult = null;
              try {
                completeResult = listener.handleWhenComplete();
              } catch (e) {
                let s = dart.stackTrace(e);
                if (dart.notNull(hasError) && core.identical(source[_error].error, e)) {
                  listenerValueOrError = source[_error];
                } else {
                  listenerValueOrError = new async.AsyncError(e, s);
                }
                listenerHasError = true;
                return;
              }

              if (dart.is(completeResult, async.Future)) {
                if (dart.is(completeResult, async._Future) && dart.notNull(completeResult[_isComplete])) {
                  if (dart.notNull(completeResult[_hasError])) {
                    listenerValueOrError = completeResult[_error];
                    listenerHasError = true;
                  }
                  return;
                }
                let originalSource = source;
                listenerValueOrError = completeResult.then(async._Future)(dart.fn(_ => originalSource, async._Future, [dart.dynamic]));
                listenerHasError = false;
              }
            }
            dart.fn(handleWhenCompleteCallback, dart.void, []);
            function handleValueCallback() {
              try {
                listenerValueOrError = listener.handleValue(sourceResult);
              } catch (e) {
                let s = dart.stackTrace(e);
                listenerValueOrError = new async.AsyncError(e, s);
                listenerHasError = true;
              }

            }
            dart.fn(handleValueCallback, dart.void, []);
            function handleError() {
              try {
                let asyncError = source[_error];
                if (dart.notNull(listener.matchesErrorTest(asyncError)) && dart.notNull(listener.hasErrorCallback)) {
                  listenerValueOrError = listener.handleError(asyncError);
                  listenerHasError = false;
                }
              } catch (e) {
                let s = dart.stackTrace(e);
                if (core.identical(source[_error].error, e)) {
                  listenerValueOrError = source[_error];
                } else {
                  listenerValueOrError = new async.AsyncError(e, s);
                }
                listenerHasError = true;
              }

            }
            dart.fn(handleError, dart.void, []);
            if (dart.notNull(listener.handlesComplete)) {
              handleWhenCompleteCallback();
            } else if (!dart.notNull(hasError)) {
              if (dart.notNull(listener.handlesValue)) {
                handleValueCallback();
              }
            } else {
              if (dart.notNull(listener.handlesError)) {
                handleError();
              }
            }
            if (oldZone != null) async.Zone._leave(oldZone);
            if (dart.is(listenerValueOrError, async.Future)) {
              let chainSource = dart.as(listenerValueOrError, async.Future);
              let result = listener.result;
              if (dart.is(chainSource, async._Future)) {
                if (dart.notNull(chainSource[_isComplete])) {
                  listeners = result[_removeListeners]();
                  result[_cloneResult](chainSource);
                  source = chainSource;
                  continue;
                } else {
                  async._Future._chainCoreFuture(chainSource, result);
                }
              } else {
                async._Future._chainForeignFuture(chainSource, result);
              }
              return;
            }
          }
          let result = listener.result;
          listeners = result[_removeListeners]();
          if (!dart.notNull(listenerHasError)) {
            result[_setValue](listenerValueOrError);
          } else {
            let asyncError = dart.as(listenerValueOrError, async.AsyncError);
            result[_setErrorObject](asyncError);
          }
          source = result;
        }
      }
      timeout(timeLimit, opts) {
        let onTimeout = opts && 'onTimeout' in opts ? opts.onTimeout : null;
        dart.as(onTimeout, dart.functionType(dart.dynamic, []));
        if (dart.notNull(this[_isComplete])) return new (async._Future$(T)).immediate(this);
        let result = new (async._Future$(T))();
        let timer = null;
        if (onTimeout == null) {
          timer = async.Timer.new(timeLimit, dart.fn(() => {
            result[_completeError](new async.TimeoutException("Future not completed", timeLimit));
          }, dart.void, []));
        } else {
          let zone = async.Zone.current;
          onTimeout = zone.registerCallback(dart.dynamic)(onTimeout);
          timer = async.Timer.new(timeLimit, dart.fn(() => {
            try {
              result[_complete](zone.run(dart.dynamic)(onTimeout));
            } catch (e) {
              let s = dart.stackTrace(e);
              result[_completeError](e, s);
            }

          }, dart.void, []));
        }
        this.then(dart.dynamic)(dart.fn(v => {
          dart.as(v, T);
          if (dart.notNull(timer.isActive)) {
            timer.cancel();
            result[_completeWithValue](v);
          }
        }, dart.dynamic, [T]), {onError: dart.fn((e, s) => {
            if (dart.notNull(timer.isActive)) {
              timer.cancel();
              result[_completeError](e, dart.as(s, core.StackTrace));
            }
          })});
        return result;
      }
    }
    dart.defineNamedConstructor(_Future, 'immediate');
    dart.defineNamedConstructor(_Future, 'immediateError');
    _Future[dart.implements] = () => [async.Future$(T)];
    dart.setSignature(_Future, {
      constructors: () => ({
        _Future: [async._Future$(T), []],
        immediate: [async._Future$(T), [dart.dynamic]],
        immediateError: [async._Future$(T), [dart.dynamic], [core.StackTrace]]
      }),
      methods: () => ({
        [_setChained]: [dart.void, [async._Future]],
        then: [E => [async.Future$(E), [dart.functionType(dart.dynamic, [T])], {onError: core.Function}]],
        [_thenNoZoneRegistration]: [E => [async.Future$(E), [dart.functionType(dart.dynamic, [T]), core.Function]]],
        catchError: [async.Future$(T), [core.Function], {test: dart.functionType(core.bool, [dart.dynamic])}],
        whenComplete: [async.Future$(T), [dart.functionType(dart.dynamic, [])]],
        asStream: [async.Stream$(T), []],
        [_setPendingComplete]: [dart.void, []],
        [_setValue]: [dart.void, [T]],
        [_setErrorObject]: [dart.void, [async.AsyncError]],
        [_setError]: [dart.void, [core.Object, core.StackTrace]],
        [_cloneResult]: [dart.void, [async._Future]],
        [_addListener]: [dart.void, [async._FutureListener]],
        [_prependListeners]: [dart.void, [async._FutureListener]],
        [_removeListeners]: [async._FutureListener, []],
        [_reverseListeners]: [async._FutureListener, [async._FutureListener]],
        [_complete]: [dart.void, [dart.dynamic]],
        [_completeWithValue]: [dart.void, [T]],
        [_completeError]: [dart.void, [dart.dynamic], [core.StackTrace]],
        [_asyncComplete]: [dart.void, [dart.dynamic]],
        [_asyncCompleteError]: [dart.void, [dart.dynamic, core.StackTrace]],
        timeout: [async.Future$(T), [core.Duration], {onTimeout: dart.functionType(dart.dynamic, [])}]
      }),
      statics: () => ({
        _chainForeignFuture: [dart.void, [async.Future, async._Future]],
        _chainCoreFuture: [dart.void, [async._Future, async._Future]],
        _propagateToListeners: [dart.void, [async._Future, async._FutureListener]]
      }),
      names: ['_chainForeignFuture', '_chainCoreFuture', '_propagateToListeners']
    });
    return _Future;
  });
  async._Future = async._Future$();
  async._Future._INCOMPLETE = 0;
  async._Future._PENDING_COMPLETE = 1;
  async._Future._CHAINED = 2;
  async._Future._VALUE = 4;
  async._Future._ERROR = 8;
  async._AsyncCallback = dart.typedef('_AsyncCallback', () => dart.functionType(dart.void, []));
  async._AsyncCallbackEntry = class _AsyncCallbackEntry extends core.Object {
    _AsyncCallbackEntry(callback) {
      this.callback = callback;
      this.next = null;
    }
  };
  dart.setSignature(async._AsyncCallbackEntry, {
    constructors: () => ({_AsyncCallbackEntry: [async._AsyncCallbackEntry, [async._AsyncCallback]]})
  });
  async._nextCallback = null;
  async._lastCallback = null;
  async._lastPriorityCallback = null;
  async._isInCallbackLoop = false;
  async._microtaskLoop = function() {
    while (async._nextCallback != null) {
      async._lastPriorityCallback = null;
      let entry = async._nextCallback;
      async._nextCallback = entry.next;
      if (async._nextCallback == null) async._lastCallback = null;
      entry.callback();
    }
  };
  dart.fn(async._microtaskLoop, dart.void, []);
  async._startMicrotaskLoop = function() {
    async._isInCallbackLoop = true;
    try {
      async._microtaskLoop();
    } finally {
      async._lastPriorityCallback = null;
      async._isInCallbackLoop = false;
      if (async._nextCallback != null) {
        async._AsyncRun._scheduleImmediate(async._startMicrotaskLoop);
      }
    }
  };
  dart.fn(async._startMicrotaskLoop, dart.void, []);
  async._scheduleAsyncCallback = function(callback) {
    let newEntry = new async._AsyncCallbackEntry(callback);
    if (async._nextCallback == null) {
      async._nextCallback = async._lastCallback = newEntry;
      if (!dart.notNull(async._isInCallbackLoop)) {
        async._AsyncRun._scheduleImmediate(async._startMicrotaskLoop);
      }
    } else {
      async._lastCallback.next = newEntry;
      async._lastCallback = newEntry;
    }
  };
  dart.fn(async._scheduleAsyncCallback, dart.void, [async._AsyncCallback]);
  async._schedulePriorityAsyncCallback = function(callback) {
    if (async._nextCallback == null) {
      async._scheduleAsyncCallback(callback);
      async._lastPriorityCallback = async._lastCallback;
      return;
    }
    let entry = new async._AsyncCallbackEntry(callback);
    if (async._lastPriorityCallback == null) {
      entry.next = async._nextCallback;
      async._nextCallback = async._lastPriorityCallback = entry;
    } else {
      entry.next = async._lastPriorityCallback.next;
      async._lastPriorityCallback.next = entry;
      async._lastPriorityCallback = entry;
      if (entry.next == null) {
        async._lastCallback = entry;
      }
    }
  };
  dart.fn(async._schedulePriorityAsyncCallback, dart.void, [async._AsyncCallback]);
  const _scheduleMicrotask = Symbol('_scheduleMicrotask');
  async.scheduleMicrotask = function(callback) {
    let currentZone = dart.as(async.Zone.current, async._Zone);
    if (core.identical(async._ROOT_ZONE, currentZone)) {
      async._rootScheduleMicrotask(null, null, async._ROOT_ZONE, callback);
      return;
    }
    let implementation = currentZone[_scheduleMicrotask];
    if (core.identical(async._ROOT_ZONE, implementation.zone) && dart.notNull(async._ROOT_ZONE.inSameErrorZone(currentZone))) {
      async._rootScheduleMicrotask(null, null, currentZone, currentZone.registerCallback(dart.dynamic)(callback));
      return;
    }
    async.Zone.current.scheduleMicrotask(async.Zone.current.bindCallback(dart.dynamic)(callback, {runGuarded: true}));
  };
  dart.fn(async.scheduleMicrotask, dart.void, [dart.functionType(dart.void, [])]);
  async._AsyncRun = class _AsyncRun extends core.Object {
    static _scheduleImmediate(callback) {
      dart.dcall(async._AsyncRun._scheduleImmediateClosure, callback);
    }
    static _initializeScheduleImmediate() {
      if (self.scheduleImmediate != null) {
        return async._AsyncRun._scheduleImmediateJsOverride;
      }
      if (self.MutationObserver != null && self.document != null) {
        let div = self.document.createElement("div");
        let span = self.document.createElement("span");
        let storedCallback = null;
        function internalCallback(_) {
          _isolate_helper.leaveJsAsync();
          let f = storedCallback;
          storedCallback = null;
          dart.dcall(f);
        }
        dart.fn(internalCallback);
        ;
        let observer = new self.MutationObserver(internalCallback);
        observer.observe(div, {childList: true});
        return dart.fn(callback => {
          dart.assert(storedCallback == null);
          _isolate_helper.enterJsAsync();
          storedCallback = callback;
          div.firstChild ? div.removeChild(span) : div.appendChild(span);
        }, dart.dynamic, [dart.functionType(dart.void, [])]);
      } else if (self.setImmediate != null) {
        return async._AsyncRun._scheduleImmediateWithSetImmediate;
      }
      return async._AsyncRun._scheduleImmediateWithTimer;
    }
    static _scheduleImmediateJsOverride(callback) {
      function internalCallback() {
        _isolate_helper.leaveJsAsync();
        callback();
      }
      dart.fn(internalCallback);
      ;
      _isolate_helper.enterJsAsync();
      self.scheduleImmediate(internalCallback);
    }
    static _scheduleImmediateWithSetImmediate(callback) {
      function internalCallback() {
        _isolate_helper.leaveJsAsync();
        callback();
      }
      dart.fn(internalCallback);
      ;
      _isolate_helper.enterJsAsync();
      self.setImmediate(internalCallback);
    }
    static _scheduleImmediateWithTimer(callback) {
      async.Timer._createTimer(core.Duration.ZERO, callback);
    }
  };
  dart.setSignature(async._AsyncRun, {
    statics: () => ({
      _scheduleImmediate: [dart.void, [dart.functionType(dart.void, [])]],
      _initializeScheduleImmediate: [core.Function, []],
      _scheduleImmediateJsOverride: [dart.void, [dart.functionType(dart.void, [])]],
      _scheduleImmediateWithSetImmediate: [dart.void, [dart.functionType(dart.void, [])]],
      _scheduleImmediateWithTimer: [dart.void, [dart.functionType(dart.void, [])]]
    }),
    names: ['_scheduleImmediate', '_initializeScheduleImmediate', '_scheduleImmediateJsOverride', '_scheduleImmediateWithSetImmediate', '_scheduleImmediateWithTimer']
  });
  dart.defineLazy(async._AsyncRun, {
    get _scheduleImmediateClosure() {
      return async._AsyncRun._initializeScheduleImmediate();
    }
  });
  async._TimerCallback = dart.typedef('_TimerCallback', () => dart.functionType(dart.void, []));
  async.StreamSubscription$ = dart.generic(T => {
    class StreamSubscription extends core.Object {}
    return StreamSubscription;
  });
  async.StreamSubscription = async.StreamSubscription$();
  async.EventSink$ = dart.generic(T => {
    class EventSink extends core.Object {}
    EventSink[dart.implements] = () => [core.Sink$(T)];
    return EventSink;
  });
  async.EventSink = async.EventSink$();
  const _stream = Symbol('_stream');
  async.StreamView$ = dart.generic(T => {
    class StreamView extends async.Stream$(T) {
      StreamView(stream) {
        this[_stream] = stream;
        super._internal();
      }
      get isBroadcast() {
        return this[_stream].isBroadcast;
      }
      asBroadcastStream(opts) {
        let onListen = opts && 'onListen' in opts ? opts.onListen : null;
        dart.as(onListen, dart.functionType(dart.void, [async.StreamSubscription$(T)]));
        let onCancel = opts && 'onCancel' in opts ? opts.onCancel : null;
        dart.as(onCancel, dart.functionType(dart.void, [async.StreamSubscription$(T)]));
        return this[_stream].asBroadcastStream({onListen: onListen, onCancel: onCancel});
      }
      listen(onData, opts) {
        dart.as(onData, dart.functionType(dart.void, [T]));
        let onError = opts && 'onError' in opts ? opts.onError : null;
        let onDone = opts && 'onDone' in opts ? opts.onDone : null;
        dart.as(onDone, dart.functionType(dart.void, []));
        let cancelOnError = opts && 'cancelOnError' in opts ? opts.cancelOnError : null;
        return this[_stream].listen(onData, {onError: onError, onDone: onDone, cancelOnError: cancelOnError});
      }
    }
    dart.setSignature(StreamView, {
      constructors: () => ({StreamView: [async.StreamView$(T), [async.Stream$(T)]]}),
      methods: () => ({
        asBroadcastStream: [async.Stream$(T), [], {onListen: dart.functionType(dart.void, [async.StreamSubscription$(T)]), onCancel: dart.functionType(dart.void, [async.StreamSubscription$(T)])}],
        listen: [async.StreamSubscription$(T), [dart.functionType(dart.void, [T])], {onError: core.Function, onDone: dart.functionType(dart.void, []), cancelOnError: core.bool}]
      })
    });
    return StreamView;
  });
  async.StreamView = async.StreamView$();
  async.StreamConsumer$ = dart.generic(S => {
    class StreamConsumer extends core.Object {}
    return StreamConsumer;
  });
  async.StreamConsumer = async.StreamConsumer$();
  async.StreamSink$ = dart.generic(S => {
    class StreamSink extends core.Object {}
    StreamSink[dart.implements] = () => [async.EventSink$(S), async.StreamConsumer$(S)];
    return StreamSink;
  });
  async.StreamSink = async.StreamSink$();
  async.StreamTransformer$ = dart.generic((S, T) => {
    class StreamTransformer extends core.Object {
      static new(transformer) {
        return new (async._StreamSubscriptionTransformer$(S, T))(transformer);
      }
      static fromHandlers(opts) {
        return new (async._StreamHandlerTransformer$(S, T))(opts);
      }
    }
    dart.setSignature(StreamTransformer, {
      constructors: () => ({
        new: [async.StreamTransformer$(S, T), [dart.functionType(async.StreamSubscription$(T), [async.Stream$(S), core.bool])]],
        fromHandlers: [async.StreamTransformer$(S, T), [], {handleData: dart.functionType(dart.void, [S, async.EventSink$(T)]), handleError: dart.functionType(dart.void, [core.Object, core.StackTrace, async.EventSink$(T)]), handleDone: dart.functionType(dart.void, [async.EventSink$(T)])}]
      })
    });
    return StreamTransformer;
  });
  async.StreamTransformer = async.StreamTransformer$();
  async.StreamIterator$ = dart.generic(T => {
    class StreamIterator extends core.Object {
      static new(stream) {
        return new (async._StreamIteratorImpl$(T))(stream);
      }
    }
    dart.setSignature(StreamIterator, {
      constructors: () => ({new: [async.StreamIterator$(T), [async.Stream$(T)]]})
    });
    return StreamIterator;
  });
  async.StreamIterator = async.StreamIterator$();
  async._ControllerEventSinkWrapper$ = dart.generic(T => {
    class _ControllerEventSinkWrapper extends core.Object {
      _ControllerEventSinkWrapper(sink) {
        this[_sink] = sink;
      }
      add(data) {
        dart.as(data, T);
        this[_sink].add(data);
      }
      addError(error, stackTrace) {
        if (stackTrace === void 0) stackTrace = null;
        this[_sink].addError(error, stackTrace);
      }
      close() {
        this[_sink].close();
      }
    }
    _ControllerEventSinkWrapper[dart.implements] = () => [async.EventSink$(T)];
    dart.setSignature(_ControllerEventSinkWrapper, {
      constructors: () => ({_ControllerEventSinkWrapper: [async._ControllerEventSinkWrapper$(T), [async.EventSink]]}),
      methods: () => ({
        add: [dart.void, [T]],
        addError: [dart.void, [dart.dynamic], [core.StackTrace]],
        close: [dart.void, []]
      })
    });
    return _ControllerEventSinkWrapper;
  });
  async._ControllerEventSinkWrapper = async._ControllerEventSinkWrapper$();
  async.ControllerCallback = dart.typedef('ControllerCallback', () => dart.functionType(dart.void, []));
  async.ControllerCancelCallback = dart.typedef('ControllerCancelCallback', () => dart.functionType(dart.dynamic, []));
  async.StreamController$ = dart.generic(T => {
    class StreamController extends core.Object {
      static new(opts) {
        let onListen = opts && 'onListen' in opts ? opts.onListen : null;
        let onPause = opts && 'onPause' in opts ? opts.onPause : null;
        let onResume = opts && 'onResume' in opts ? opts.onResume : null;
        let onCancel = opts && 'onCancel' in opts ? opts.onCancel : null;
        let sync = opts && 'sync' in opts ? opts.sync : false;
        return dart.notNull(sync) ? new (async._SyncStreamController$(T))(onListen, onPause, onResume, onCancel) : new (async._AsyncStreamController$(T))(onListen, onPause, onResume, onCancel);
      }
      static broadcast(opts) {
        let onListen = opts && 'onListen' in opts ? opts.onListen : null;
        let onCancel = opts && 'onCancel' in opts ? opts.onCancel : null;
        let sync = opts && 'sync' in opts ? opts.sync : false;
        return dart.notNull(sync) ? new (async._SyncBroadcastStreamController$(T))(onListen, onCancel) : new (async._AsyncBroadcastStreamController$(T))(onListen, onCancel);
      }
    }
    StreamController[dart.implements] = () => [async.StreamSink$(T)];
    dart.setSignature(StreamController, {
      constructors: () => ({
        new: [async.StreamController$(T), [], {onListen: dart.functionType(dart.void, []), onPause: dart.functionType(dart.void, []), onResume: dart.functionType(dart.void, []), onCancel: dart.functionType(dart.dynamic, []), sync: core.bool}],
        broadcast: [async.StreamController$(T), [], {onListen: dart.functionType(dart.void, []), onCancel: dart.functionType(dart.void, []), sync: core.bool}]
      })
    });
    return StreamController;
  });
  async.StreamController = async.StreamController$();
  async.SynchronousStreamController$ = dart.generic(T => {
    class SynchronousStreamController extends core.Object {}
    SynchronousStreamController[dart.implements] = () => [async.StreamController$(T)];
    return SynchronousStreamController;
  });
  async.SynchronousStreamController = async.SynchronousStreamController$();
  async._StreamControllerLifecycle$ = dart.generic(T => {
    class _StreamControllerLifecycle extends core.Object {
      [_recordPause](subscription) {
        dart.as(subscription, async.StreamSubscription$(T));
      }
      [_recordResume](subscription) {
        dart.as(subscription, async.StreamSubscription$(T));
      }
      [_recordCancel](subscription) {
        dart.as(subscription, async.StreamSubscription$(T));
        return null;
      }
    }
    dart.setSignature(_StreamControllerLifecycle, {
      methods: () => ({
        [_recordPause]: [dart.void, [async.StreamSubscription$(T)]],
        [_recordResume]: [dart.void, [async.StreamSubscription$(T)]],
        [_recordCancel]: [async.Future, [async.StreamSubscription$(T)]]
      })
    });
    return _StreamControllerLifecycle;
  });
  async._StreamControllerLifecycle = async._StreamControllerLifecycle$();
  const _varData = Symbol('_varData');
  const _isInitialState = Symbol('_isInitialState');
  const _subscription = Symbol('_subscription');
  const _pendingEvents = Symbol('_pendingEvents');
  const _ensurePendingEvents = Symbol('_ensurePendingEvents');
  const _badEventState = Symbol('_badEventState');
  async._StreamController$ = dart.generic(T => {
    class _StreamController extends core.Object {
      _StreamController(onListen, onPause, onResume, onCancel) {
        this.onListen = onListen;
        this.onPause = onPause;
        this.onResume = onResume;
        this.onCancel = onCancel;
        this[_varData] = null;
        this[_state] = async._StreamController._STATE_INITIAL;
        this[_doneFuture] = null;
      }
      get stream() {
        return new (async._ControllerStream$(T))(this);
      }
      get sink() {
        return new (async._StreamSinkWrapper$(T))(this);
      }
      get [_isCanceled]() {
        return (dart.notNull(this[_state]) & dart.notNull(async._StreamController._STATE_CANCELED)) >>> 0 != 0;
      }
      get hasListener() {
        return (dart.notNull(this[_state]) & dart.notNull(async._StreamController._STATE_SUBSCRIBED)) >>> 0 != 0;
      }
      get [_isInitialState]() {
        return (dart.notNull(this[_state]) & dart.notNull(async._StreamController._STATE_SUBSCRIPTION_MASK)) >>> 0 == async._StreamController._STATE_INITIAL;
      }
      get isClosed() {
        return (dart.notNull(this[_state]) & dart.notNull(async._StreamController._STATE_CLOSED)) >>> 0 != 0;
      }
      get isPaused() {
        return dart.notNull(this.hasListener) ? this[_subscription][_isInputPaused] : !dart.notNull(this[_isCanceled]);
      }
      get [_isAddingStream]() {
        return (dart.notNull(this[_state]) & dart.notNull(async._StreamController._STATE_ADDSTREAM)) >>> 0 != 0;
      }
      get [_mayAddEvent]() {
        return dart.notNull(this[_state]) < dart.notNull(async._StreamController._STATE_CLOSED);
      }
      get [_pendingEvents]() {
        dart.assert(this[_isInitialState]);
        if (!dart.notNull(this[_isAddingStream])) {
          return dart.as(this[_varData], async._PendingEvents$(T));
        }
        let state = dart.as(this[_varData], async._StreamControllerAddStreamState$(T));
        return dart.as(state.varData, async._PendingEvents$(T));
      }
      [_ensurePendingEvents]() {
        dart.assert(this[_isInitialState]);
        if (!dart.notNull(this[_isAddingStream])) {
          if (this[_varData] == null) this[_varData] = new (async._StreamImplEvents$(T))();
          return dart.as(this[_varData], async._StreamImplEvents$(T));
        }
        let state = dart.as(this[_varData], async._StreamControllerAddStreamState$(T));
        if (state.varData == null) state.varData = new (async._StreamImplEvents$(T))();
        return dart.as(state.varData, async._StreamImplEvents$(T));
      }
      get [_subscription]() {
        dart.assert(this.hasListener);
        if (dart.notNull(this[_isAddingStream])) {
          let addState = dart.as(this[_varData], async._StreamControllerAddStreamState$(T));
          return dart.as(addState.varData, async._ControllerSubscription$(T));
        }
        return dart.as(this[_varData], async._ControllerSubscription$(T));
      }
      [_badEventState]() {
        if (dart.notNull(this.isClosed)) {
          return new core.StateError("Cannot add event after closing");
        }
        dart.assert(this[_isAddingStream]);
        return new core.StateError("Cannot add event while adding a stream");
      }
      addStream(source, opts) {
        dart.as(source, async.Stream$(T));
        let cancelOnError = opts && 'cancelOnError' in opts ? opts.cancelOnError : true;
        if (!dart.notNull(this[_mayAddEvent])) dart.throw(this[_badEventState]());
        if (dart.notNull(this[_isCanceled])) return new async._Future.immediate(null);
        let addState = new (async._StreamControllerAddStreamState$(T))(this, this[_varData], source, cancelOnError);
        this[_varData] = addState;
        this[_state] = (dart.notNull(this[_state]) | dart.notNull(async._StreamController._STATE_ADDSTREAM)) >>> 0;
        return addState.addStreamFuture;
      }
      get done() {
        return this[_ensureDoneFuture]();
      }
      [_ensureDoneFuture]() {
        if (this[_doneFuture] == null) {
          this[_doneFuture] = dart.notNull(this[_isCanceled]) ? async.Future._nullFuture : new async._Future();
        }
        return this[_doneFuture];
      }
      add(value) {
        dart.as(value, T);
        if (!dart.notNull(this[_mayAddEvent])) dart.throw(this[_badEventState]());
        this[_add$](value);
      }
      addError(error, stackTrace) {
        if (stackTrace === void 0) stackTrace = null;
        if (!dart.notNull(this[_mayAddEvent])) dart.throw(this[_badEventState]());
        error = async._nonNullError(error);
        let replacement = async.Zone.current.errorCallback(error, stackTrace);
        if (replacement != null) {
          error = async._nonNullError(replacement.error);
          stackTrace = replacement.stackTrace;
        }
        this[_addError](error, stackTrace);
      }
      close() {
        if (dart.notNull(this.isClosed)) {
          return this[_ensureDoneFuture]();
        }
        if (!dart.notNull(this[_mayAddEvent])) dart.throw(this[_badEventState]());
        this[_closeUnchecked]();
        return this[_ensureDoneFuture]();
      }
      [_closeUnchecked]() {
        this[_state] = (dart.notNull(this[_state]) | dart.notNull(async._StreamController._STATE_CLOSED)) >>> 0;
        if (dart.notNull(this.hasListener)) {
          this[_sendDone]();
        } else if (dart.notNull(this[_isInitialState])) {
          this[_ensurePendingEvents]().add(dart.const(new async._DelayedDone()));
        }
      }
      [_add$](value) {
        dart.as(value, T);
        if (dart.notNull(this.hasListener)) {
          this[_sendData](value);
        } else if (dart.notNull(this[_isInitialState])) {
          this[_ensurePendingEvents]().add(new (async._DelayedData$(T))(value));
        }
      }
      [_addError](error, stackTrace) {
        if (dart.notNull(this.hasListener)) {
          this[_sendError](error, stackTrace);
        } else if (dart.notNull(this[_isInitialState])) {
          this[_ensurePendingEvents]().add(new async._DelayedError(error, stackTrace));
        }
      }
      [_close$]() {
        dart.assert(this[_isAddingStream]);
        let addState = dart.as(this[_varData], async._StreamControllerAddStreamState$(T));
        this[_varData] = addState.varData;
        this[_state] = (dart.notNull(this[_state]) & ~dart.notNull(async._StreamController._STATE_ADDSTREAM)) >>> 0;
        addState.complete();
      }
      [_subscribe](onData, onError, onDone, cancelOnError) {
        dart.as(onData, dart.functionType(dart.void, [T]));
        dart.as(onDone, dart.functionType(dart.void, []));
        if (!dart.notNull(this[_isInitialState])) {
          dart.throw(new core.StateError("Stream has already been listened to."));
        }
        let subscription = new (async._ControllerSubscription$(T))(this, onData, onError, onDone, cancelOnError);
        let pendingEvents = this[_pendingEvents];
        this[_state] = (dart.notNull(this[_state]) | dart.notNull(async._StreamController._STATE_SUBSCRIBED)) >>> 0;
        if (dart.notNull(this[_isAddingStream])) {
          let addState = dart.as(this[_varData], async._StreamControllerAddStreamState$(T));
          addState.varData = subscription;
          addState.resume();
        } else {
          this[_varData] = subscription;
        }
        subscription[_setPendingEvents](pendingEvents);
        subscription[_guardCallback](dart.fn(() => {
          async._runGuarded(this.onListen);
        }));
        return subscription;
      }
      [_recordCancel](subscription) {
        dart.as(subscription, async.StreamSubscription$(T));
        let result = null;
        if (dart.notNull(this[_isAddingStream])) {
          let addState = dart.as(this[_varData], async._StreamControllerAddStreamState$(T));
          result = addState.cancel();
        }
        this[_varData] = null;
        this[_state] = (dart.notNull(this[_state]) & ~(dart.notNull(async._StreamController._STATE_SUBSCRIBED) | dart.notNull(async._StreamController._STATE_ADDSTREAM)) | dart.notNull(async._StreamController._STATE_CANCELED)) >>> 0;
        if (this.onCancel != null) {
          if (result == null) {
            try {
              result = dart.as(this.onCancel(), async.Future);
            } catch (e) {
              let s = dart.stackTrace(e);
              result = new async._Future();
              result[_asyncCompleteError](e, s);
            }

          } else {
            result = result.whenComplete(this.onCancel);
          }
        }
        const complete = (function() {
          if (this[_doneFuture] != null && dart.notNull(this[_doneFuture][_mayComplete])) {
            this[_doneFuture][_asyncComplete](null);
          }
        }).bind(this);
        dart.fn(complete, dart.void, []);
        if (result != null) {
          result = result.whenComplete(complete);
        } else {
          complete();
        }
        return result;
      }
      [_recordPause](subscription) {
        dart.as(subscription, async.StreamSubscription$(T));
        if (dart.notNull(this[_isAddingStream])) {
          let addState = dart.as(this[_varData], async._StreamControllerAddStreamState$(T));
          addState.pause();
        }
        async._runGuarded(this.onPause);
      }
      [_recordResume](subscription) {
        dart.as(subscription, async.StreamSubscription$(T));
        if (dart.notNull(this[_isAddingStream])) {
          let addState = dart.as(this[_varData], async._StreamControllerAddStreamState$(T));
          addState.resume();
        }
        async._runGuarded(this.onResume);
      }
    }
    _StreamController[dart.implements] = () => [async.StreamController$(T), async._StreamControllerLifecycle$(T), async._EventSink$(T), async._EventDispatch$(T)];
    dart.setSignature(_StreamController, {
      constructors: () => ({_StreamController: [async._StreamController$(T), [async.ControllerCallback, async.ControllerCallback, async.ControllerCallback, async.ControllerCancelCallback]]}),
      methods: () => ({
        [_ensurePendingEvents]: [async._StreamImplEvents$(T), []],
        [_badEventState]: [core.Error, []],
        addStream: [async.Future, [async.Stream$(T)], {cancelOnError: core.bool}],
        [_ensureDoneFuture]: [async.Future, []],
        add: [dart.void, [T]],
        addError: [dart.void, [core.Object], [core.StackTrace]],
        close: [async.Future, []],
        [_closeUnchecked]: [dart.void, []],
        [_add$]: [dart.void, [T]],
        [_addError]: [dart.void, [core.Object, core.StackTrace]],
        [_close$]: [dart.void, []],
        [_subscribe]: [async.StreamSubscription$(T), [dart.functionType(dart.void, [T]), core.Function, dart.functionType(dart.void, []), core.bool]],
        [_recordCancel]: [async.Future, [async.StreamSubscription$(T)]],
        [_recordPause]: [dart.void, [async.StreamSubscription$(T)]],
        [_recordResume]: [dart.void, [async.StreamSubscription$(T)]]
      })
    });
    return _StreamController;
  });
  async._StreamController = async._StreamController$();
  async._StreamController._STATE_INITIAL = 0;
  async._StreamController._STATE_SUBSCRIBED = 1;
  async._StreamController._STATE_CANCELED = 2;
  async._StreamController._STATE_SUBSCRIPTION_MASK = 3;
  async._StreamController._STATE_CLOSED = 4;
  async._StreamController._STATE_ADDSTREAM = 8;
  async._SyncStreamControllerDispatch$ = dart.generic(T => {
    class _SyncStreamControllerDispatch extends core.Object {
      [_sendData](data) {
        dart.as(data, T);
        this[_subscription][_add$](data);
      }
      [_sendError](error, stackTrace) {
        this[_subscription][_addError](error, stackTrace);
      }
      [_sendDone]() {
        this[_subscription][_close$]();
      }
    }
    _SyncStreamControllerDispatch[dart.implements] = () => [async._StreamController$(T), async.SynchronousStreamController$(T)];
    dart.setSignature(_SyncStreamControllerDispatch, {
      methods: () => ({
        [_sendData]: [dart.void, [T]],
        [_sendError]: [dart.void, [core.Object, core.StackTrace]],
        [_sendDone]: [dart.void, []]
      })
    });
    return _SyncStreamControllerDispatch;
  });
  async._SyncStreamControllerDispatch = async._SyncStreamControllerDispatch$();
  async._AsyncStreamControllerDispatch$ = dart.generic(T => {
    class _AsyncStreamControllerDispatch extends core.Object {
      [_sendData](data) {
        dart.as(data, T);
        this[_subscription][_addPending](new (async._DelayedData$(T))(data));
      }
      [_sendError](error, stackTrace) {
        this[_subscription][_addPending](new async._DelayedError(error, stackTrace));
      }
      [_sendDone]() {
        this[_subscription][_addPending](dart.const(new async._DelayedDone()));
      }
    }
    _AsyncStreamControllerDispatch[dart.implements] = () => [async._StreamController$(T)];
    dart.setSignature(_AsyncStreamControllerDispatch, {
      methods: () => ({
        [_sendData]: [dart.void, [T]],
        [_sendError]: [dart.void, [core.Object, core.StackTrace]],
        [_sendDone]: [dart.void, []]
      })
    });
    return _AsyncStreamControllerDispatch;
  });
  async._AsyncStreamControllerDispatch = async._AsyncStreamControllerDispatch$();
  async._AsyncStreamController$ = dart.generic(T => {
    class _AsyncStreamController extends dart.mixin(async._StreamController$(T), async._AsyncStreamControllerDispatch$(T)) {
      _AsyncStreamController(onListen, onPause, onResume, onCancel) {
        super._StreamController(onListen, onPause, onResume, onCancel);
      }
    }
    return _AsyncStreamController;
  });
  async._AsyncStreamController = async._AsyncStreamController$();
  async._SyncStreamController$ = dart.generic(T => {
    class _SyncStreamController extends dart.mixin(async._StreamController$(T), async._SyncStreamControllerDispatch$(T)) {
      _SyncStreamController(onListen, onPause, onResume, onCancel) {
        super._StreamController(onListen, onPause, onResume, onCancel);
      }
    }
    return _SyncStreamController;
  });
  async._SyncStreamController = async._SyncStreamController$();
  async._NotificationHandler = dart.typedef('_NotificationHandler', () => dart.functionType(dart.dynamic, []));
  async._runGuarded = function(notificationHandler) {
    if (notificationHandler == null) return null;
    try {
      let result = notificationHandler();
      if (dart.is(result, async.Future)) return result;
      return null;
    } catch (e) {
      let s = dart.stackTrace(e);
      async.Zone.current.handleUncaughtError(dart.dynamic)(e, s);
    }

  };
  dart.fn(async._runGuarded, async.Future, [async._NotificationHandler]);
  const _target = Symbol('_target');
  async._StreamSinkWrapper$ = dart.generic(T => {
    class _StreamSinkWrapper extends core.Object {
      _StreamSinkWrapper(target) {
        this[_target] = target;
      }
      add(data) {
        dart.as(data, T);
        this[_target].add(data);
      }
      addError(error, stackTrace) {
        if (stackTrace === void 0) stackTrace = null;
        this[_target].addError(error, stackTrace);
      }
      close() {
        return this[_target].close();
      }
      addStream(source, opts) {
        dart.as(source, async.Stream$(T));
        let cancelOnError = opts && 'cancelOnError' in opts ? opts.cancelOnError : true;
        return this[_target].addStream(source, {cancelOnError: cancelOnError});
      }
      get done() {
        return this[_target].done;
      }
    }
    _StreamSinkWrapper[dart.implements] = () => [async.StreamSink$(T)];
    dart.setSignature(_StreamSinkWrapper, {
      constructors: () => ({_StreamSinkWrapper: [async._StreamSinkWrapper$(T), [async.StreamController]]}),
      methods: () => ({
        add: [dart.void, [T]],
        addError: [dart.void, [core.Object], [core.StackTrace]],
        close: [async.Future, []],
        addStream: [async.Future, [async.Stream$(T)], {cancelOnError: core.bool}]
      })
    });
    return _StreamSinkWrapper;
  });
  async._StreamSinkWrapper = async._StreamSinkWrapper$();
  async._AddStreamState$ = dart.generic(T => {
    class _AddStreamState extends core.Object {
      _AddStreamState(controller, source, cancelOnError) {
        this.addStreamFuture = new async._Future();
        this.addSubscription = source.listen(dart.bind(controller, _add$), {onError: dart.as(dart.notNull(cancelOnError) ? async._AddStreamState.makeErrorHandler(controller) : dart.bind(controller, _addError), core.Function), onDone: dart.bind(controller, _close$), cancelOnError: cancelOnError});
      }
      static makeErrorHandler(controller) {
        return dart.fn((e, s) => {
          controller[_addError](e, s);
          controller[_close$]();
        }, dart.dynamic, [dart.dynamic, core.StackTrace]);
      }
      pause() {
        this.addSubscription.pause();
      }
      resume() {
        this.addSubscription.resume();
      }
      cancel() {
        let cancel = this.addSubscription.cancel();
        if (cancel == null) {
          this.addStreamFuture[_asyncComplete](null);
          return null;
        }
        return cancel.whenComplete(dart.fn(() => {
          this.addStreamFuture[_asyncComplete](null);
        }));
      }
      complete() {
        this.addStreamFuture[_asyncComplete](null);
      }
    }
    dart.setSignature(_AddStreamState, {
      constructors: () => ({_AddStreamState: [async._AddStreamState$(T), [async._EventSink$(T), async.Stream, core.bool]]}),
      methods: () => ({
        pause: [dart.void, []],
        resume: [dart.void, []],
        cancel: [async.Future, []],
        complete: [dart.void, []]
      }),
      statics: () => ({makeErrorHandler: [dart.dynamic, [async._EventSink]]}),
      names: ['makeErrorHandler']
    });
    return _AddStreamState;
  });
  async._AddStreamState = async._AddStreamState$();
  async._StreamControllerAddStreamState$ = dart.generic(T => {
    class _StreamControllerAddStreamState extends async._AddStreamState$(T) {
      _StreamControllerAddStreamState(controller, varData, source, cancelOnError) {
        this.varData = varData;
        super._AddStreamState(controller, source, cancelOnError);
        if (dart.notNull(controller.isPaused)) {
          this.addSubscription.pause();
        }
      }
    }
    dart.setSignature(_StreamControllerAddStreamState, {
      constructors: () => ({_StreamControllerAddStreamState: [async._StreamControllerAddStreamState$(T), [async._StreamController$(T), dart.dynamic, async.Stream, core.bool]]})
    });
    return _StreamControllerAddStreamState;
  });
  async._StreamControllerAddStreamState = async._StreamControllerAddStreamState$();
  async._EventSink$ = dart.generic(T => {
    class _EventSink extends core.Object {}
    return _EventSink;
  });
  async._EventSink = async._EventSink$();
  async._EventDispatch$ = dart.generic(T => {
    class _EventDispatch extends core.Object {}
    return _EventDispatch;
  });
  async._EventDispatch = async._EventDispatch$();
  async._EventGenerator$ = dart.generic(T => {
    const _EventGenerator = dart.typedef('_EventGenerator', () => dart.functionType(async._PendingEvents$(T), []));
    return _EventGenerator;
  });
  async._EventGenerator = async._EventGenerator$();
  const _isUsed = Symbol('_isUsed');
  async._GeneratedStreamImpl$ = dart.generic(T => {
    class _GeneratedStreamImpl extends async._StreamImpl$(T) {
      _GeneratedStreamImpl(pending) {
        this[_pending] = pending;
        this[_isUsed] = false;
      }
      [_createSubscription](onData, onError, onDone, cancelOnError) {
        dart.as(onData, dart.functionType(dart.void, [T]));
        dart.as(onDone, dart.functionType(dart.void, []));
        if (dart.notNull(this[_isUsed])) dart.throw(new core.StateError("Stream has already been listened to."));
        this[_isUsed] = true;
        let _ = new (async._BufferingStreamSubscription$(T))(onData, onError, onDone, cancelOnError);
        _[_setPendingEvents](this[_pending]());
        return _;
      }
    }
    dart.setSignature(_GeneratedStreamImpl, {
      constructors: () => ({_GeneratedStreamImpl: [async._GeneratedStreamImpl$(T), [async._EventGenerator$(T)]]}),
      methods: () => ({[_createSubscription]: [async.StreamSubscription$(T), [dart.functionType(dart.void, [T]), core.Function, dart.functionType(dart.void, []), core.bool]]})
    });
    return _GeneratedStreamImpl;
  });
  async._GeneratedStreamImpl = async._GeneratedStreamImpl$();
  const _iterator$ = Symbol('_iterator');
  const _eventScheduled = Symbol('_eventScheduled');
  async._PendingEvents$ = dart.generic(T => {
    class _PendingEvents extends core.Object {
      _PendingEvents() {
        this[_state] = async._PendingEvents._STATE_UNSCHEDULED;
      }
      get isScheduled() {
        return this[_state] == async._PendingEvents._STATE_SCHEDULED;
      }
      get [_eventScheduled]() {
        return dart.notNull(this[_state]) >= dart.notNull(async._PendingEvents._STATE_SCHEDULED);
      }
      schedule(dispatch) {
        dart.as(dispatch, async._EventDispatch$(T));
        if (dart.notNull(this.isScheduled)) return;
        dart.assert(!dart.notNull(this.isEmpty));
        if (dart.notNull(this[_eventScheduled])) {
          dart.assert(this[_state] == async._PendingEvents._STATE_CANCELED);
          this[_state] = async._PendingEvents._STATE_SCHEDULED;
          return;
        }
        async.scheduleMicrotask(dart.fn(() => {
          let oldState = this[_state];
          this[_state] = async._PendingEvents._STATE_UNSCHEDULED;
          if (oldState == async._PendingEvents._STATE_CANCELED) return;
          this.handleNext(dispatch);
        }, dart.void, []));
        this[_state] = async._PendingEvents._STATE_SCHEDULED;
      }
      cancelSchedule() {
        if (dart.notNull(this.isScheduled)) this[_state] = async._PendingEvents._STATE_CANCELED;
      }
    }
    dart.setSignature(_PendingEvents, {
      methods: () => ({
        schedule: [dart.void, [async._EventDispatch$(T)]],
        cancelSchedule: [dart.void, []]
      })
    });
    return _PendingEvents;
  });
  async._PendingEvents = async._PendingEvents$();
  async._PendingEvents._STATE_UNSCHEDULED = 0;
  async._PendingEvents._STATE_SCHEDULED = 1;
  async._PendingEvents._STATE_CANCELED = 3;
  async._IterablePendingEvents$ = dart.generic(T => {
    class _IterablePendingEvents extends async._PendingEvents$(T) {
      _IterablePendingEvents(data) {
        this[_iterator$] = data[dartx.iterator];
        super._PendingEvents();
      }
      get isEmpty() {
        return this[_iterator$] == null;
      }
      handleNext(dispatch) {
        dart.as(dispatch, async._EventDispatch$(T));
        if (this[_iterator$] == null) {
          dart.throw(new core.StateError("No events pending."));
        }
        let isDone = null;
        try {
          isDone = !dart.notNull(this[_iterator$].moveNext());
        } catch (e) {
          let s = dart.stackTrace(e);
          this[_iterator$] = null;
          dispatch[_sendError](e, s);
          return;
        }

        if (!dart.notNull(isDone)) {
          dispatch[_sendData](this[_iterator$].current);
        } else {
          this[_iterator$] = null;
          dispatch[_sendDone]();
        }
      }
      clear() {
        if (dart.notNull(this.isScheduled)) this.cancelSchedule();
        this[_iterator$] = null;
      }
    }
    dart.setSignature(_IterablePendingEvents, {
      constructors: () => ({_IterablePendingEvents: [async._IterablePendingEvents$(T), [core.Iterable$(T)]]}),
      methods: () => ({
        handleNext: [dart.void, [async._EventDispatch$(T)]],
        clear: [dart.void, []]
      })
    });
    return _IterablePendingEvents;
  });
  async._IterablePendingEvents = async._IterablePendingEvents$();
  async._DataHandler$ = dart.generic(T => {
    const _DataHandler = dart.typedef('_DataHandler', () => dart.functionType(dart.void, [T]));
    return _DataHandler;
  });
  async._DataHandler = async._DataHandler$();
  async._DoneHandler = dart.typedef('_DoneHandler', () => dart.functionType(dart.void, []));
  async._nullDataHandler = function(value) {
  };
  dart.fn(async._nullDataHandler, dart.void, [dart.dynamic]);
  async._nullErrorHandler = function(error, stackTrace) {
    if (stackTrace === void 0) stackTrace = null;
    async.Zone.current.handleUncaughtError(dart.dynamic)(error, stackTrace);
  };
  dart.lazyFn(async._nullErrorHandler, () => [dart.void, [dart.dynamic], [core.StackTrace]]);
  async._nullDoneHandler = function() {
  };
  dart.fn(async._nullDoneHandler, dart.void, []);
  async._DelayedEvent$ = dart.generic(T => {
    class _DelayedEvent extends core.Object {
      _DelayedEvent() {
        this.next = null;
      }
    }
    return _DelayedEvent;
  });
  async._DelayedEvent = async._DelayedEvent$();
  async._DelayedData$ = dart.generic(T => {
    class _DelayedData extends async._DelayedEvent$(T) {
      _DelayedData(value) {
        this.value = value;
        super._DelayedEvent();
      }
      perform(dispatch) {
        dart.as(dispatch, async._EventDispatch$(T));
        dispatch[_sendData](this.value);
      }
    }
    dart.setSignature(_DelayedData, {
      constructors: () => ({_DelayedData: [async._DelayedData$(T), [T]]}),
      methods: () => ({perform: [dart.void, [async._EventDispatch$(T)]]})
    });
    return _DelayedData;
  });
  async._DelayedData = async._DelayedData$();
  async._DelayedError = class _DelayedError extends async._DelayedEvent {
    _DelayedError(error, stackTrace) {
      this.error = error;
      this.stackTrace = stackTrace;
      super._DelayedEvent();
    }
    perform(dispatch) {
      dispatch[_sendError](this.error, this.stackTrace);
    }
  };
  dart.setSignature(async._DelayedError, {
    constructors: () => ({_DelayedError: [async._DelayedError, [dart.dynamic, core.StackTrace]]}),
    methods: () => ({perform: [dart.void, [async._EventDispatch]]})
  });
  async._DelayedDone = class _DelayedDone extends core.Object {
    _DelayedDone() {
    }
    perform(dispatch) {
      dispatch[_sendDone]();
    }
    get next() {
      return null;
    }
    set next(_) {
      dart.throw(new core.StateError("No events after a done."));
    }
  };
  async._DelayedDone[dart.implements] = () => [async._DelayedEvent];
  dart.setSignature(async._DelayedDone, {
    constructors: () => ({_DelayedDone: [async._DelayedDone, []]}),
    methods: () => ({perform: [dart.void, [async._EventDispatch]]})
  });
  async._StreamImplEvents$ = dart.generic(T => {
    class _StreamImplEvents extends async._PendingEvents$(T) {
      _StreamImplEvents() {
        this.firstPendingEvent = null;
        this.lastPendingEvent = null;
        super._PendingEvents();
      }
      get isEmpty() {
        return this.lastPendingEvent == null;
      }
      add(event) {
        if (this.lastPendingEvent == null) {
          this.firstPendingEvent = this.lastPendingEvent = event;
        } else {
          this.lastPendingEvent = this.lastPendingEvent.next = event;
        }
      }
      handleNext(dispatch) {
        dart.as(dispatch, async._EventDispatch$(T));
        dart.assert(!dart.notNull(this.isScheduled));
        let event = this.firstPendingEvent;
        this.firstPendingEvent = event.next;
        if (this.firstPendingEvent == null) {
          this.lastPendingEvent = null;
        }
        event.perform(dispatch);
      }
      clear() {
        if (dart.notNull(this.isScheduled)) this.cancelSchedule();
        this.firstPendingEvent = this.lastPendingEvent = null;
      }
    }
    dart.setSignature(_StreamImplEvents, {
      methods: () => ({
        add: [dart.void, [async._DelayedEvent]],
        handleNext: [dart.void, [async._EventDispatch$(T)]],
        clear: [dart.void, []]
      })
    });
    return _StreamImplEvents;
  });
  async._StreamImplEvents = async._StreamImplEvents$();
  const _unlink = Symbol('_unlink');
  const _insertBefore = Symbol('_insertBefore');
  async._BroadcastLinkedList = class _BroadcastLinkedList extends core.Object {
    _BroadcastLinkedList() {
      this[_next$] = null;
      this[_previous$] = null;
    }
    [_unlink]() {
      this[_previous$][_next$] = this[_next$];
      this[_next$][_previous$] = this[_previous$];
      this[_next$] = this[_previous$] = this;
    }
    [_insertBefore](newNext) {
      let newPrevious = newNext[_previous$];
      newPrevious[_next$] = this;
      newNext[_previous$] = this[_previous$];
      this[_previous$][_next$] = newNext;
      this[_previous$] = newPrevious;
    }
  };
  dart.setSignature(async._BroadcastLinkedList, {
    methods: () => ({
      [_unlink]: [dart.void, []],
      [_insertBefore]: [dart.void, [async._BroadcastLinkedList]]
    })
  });
  async._BroadcastCallback$ = dart.generic(T => {
    const _BroadcastCallback = dart.typedef('_BroadcastCallback', () => dart.functionType(dart.void, [async.StreamSubscription$(T)]));
    return _BroadcastCallback;
  });
  async._BroadcastCallback = async._BroadcastCallback$();
  const _schedule = Symbol('_schedule');
  const _isSent = Symbol('_isSent');
  const _isScheduled = Symbol('_isScheduled');
  async._DoneStreamSubscription$ = dart.generic(T => {
    class _DoneStreamSubscription extends core.Object {
      _DoneStreamSubscription(onDone) {
        this[_onDone] = onDone;
        this[_zone] = async.Zone.current;
        this[_state] = 0;
        this[_schedule]();
      }
      get [_isSent]() {
        return (dart.notNull(this[_state]) & dart.notNull(async._DoneStreamSubscription._DONE_SENT)) >>> 0 != 0;
      }
      get [_isScheduled]() {
        return (dart.notNull(this[_state]) & dart.notNull(async._DoneStreamSubscription._SCHEDULED)) >>> 0 != 0;
      }
      get isPaused() {
        return dart.notNull(this[_state]) >= dart.notNull(async._DoneStreamSubscription._PAUSED);
      }
      [_schedule]() {
        if (dart.notNull(this[_isScheduled])) return;
        this[_zone].scheduleMicrotask(dart.bind(this, _sendDone));
        this[_state] = (dart.notNull(this[_state]) | dart.notNull(async._DoneStreamSubscription._SCHEDULED)) >>> 0;
      }
      onData(handleData) {
        dart.as(handleData, dart.functionType(dart.void, [T]));
      }
      onError(handleError) {}
      onDone(handleDone) {
        dart.as(handleDone, dart.functionType(dart.void, []));
        this[_onDone] = handleDone;
      }
      pause(resumeSignal) {
        if (resumeSignal === void 0) resumeSignal = null;
        this[_state] = dart.notNull(this[_state]) + dart.notNull(async._DoneStreamSubscription._PAUSED);
        if (resumeSignal != null) resumeSignal.whenComplete(dart.bind(this, 'resume'));
      }
      resume() {
        if (dart.notNull(this.isPaused)) {
          this[_state] = dart.notNull(this[_state]) - dart.notNull(async._DoneStreamSubscription._PAUSED);
          if (!dart.notNull(this.isPaused) && !dart.notNull(this[_isSent])) {
            this[_schedule]();
          }
        }
      }
      cancel() {
        return null;
      }
      asFuture(E) {
        return futureValue => {
          if (futureValue === void 0) futureValue = null;
          let result = new (async._Future$(E))();
          this[_onDone] = dart.fn(() => {
            result[_completeWithValue](null);
          }, dart.void, []);
          return result;
        };
      }
      [_sendDone]() {
        this[_state] = (dart.notNull(this[_state]) & ~dart.notNull(async._DoneStreamSubscription._SCHEDULED)) >>> 0;
        if (dart.notNull(this.isPaused)) return;
        this[_state] = (dart.notNull(this[_state]) | dart.notNull(async._DoneStreamSubscription._DONE_SENT)) >>> 0;
        if (this[_onDone] != null) this[_zone].runGuarded(dart.dynamic)(this[_onDone]);
      }
    }
    _DoneStreamSubscription[dart.implements] = () => [async.StreamSubscription$(T)];
    dart.setSignature(_DoneStreamSubscription, {
      constructors: () => ({_DoneStreamSubscription: [async._DoneStreamSubscription$(T), [async._DoneHandler]]}),
      methods: () => ({
        [_schedule]: [dart.void, []],
        onData: [dart.void, [dart.functionType(dart.void, [T])]],
        onError: [dart.void, [core.Function]],
        onDone: [dart.void, [dart.functionType(dart.void, [])]],
        pause: [dart.void, [], [async.Future]],
        resume: [dart.void, []],
        cancel: [async.Future, []],
        asFuture: [E => [async.Future$(E), [], [E]]],
        [_sendDone]: [dart.void, []]
      })
    });
    return _DoneStreamSubscription;
  });
  async._DoneStreamSubscription = async._DoneStreamSubscription$();
  async._DoneStreamSubscription._DONE_SENT = 1;
  async._DoneStreamSubscription._SCHEDULED = 2;
  async._DoneStreamSubscription._PAUSED = 4;
  const _source$ = Symbol('_source');
  const _onListenHandler = Symbol('_onListenHandler');
  const _onCancelHandler = Symbol('_onCancelHandler');
  const _cancelSubscription = Symbol('_cancelSubscription');
  const _pauseSubscription = Symbol('_pauseSubscription');
  const _resumeSubscription = Symbol('_resumeSubscription');
  const _isSubscriptionPaused = Symbol('_isSubscriptionPaused');
  async._AsBroadcastStream$ = dart.generic(T => {
    class _AsBroadcastStream extends async.Stream$(T) {
      _AsBroadcastStream(source, onListenHandler, onCancelHandler) {
        this[_source$] = source;
        this[_onListenHandler] = async.Zone.current.registerUnaryCallback(dart.dynamic, async.StreamSubscription$(T))(onListenHandler);
        this[_onCancelHandler] = async.Zone.current.registerUnaryCallback(dart.dynamic, async.StreamSubscription$(T))(onCancelHandler);
        this[_zone] = async.Zone.current;
        this[_controller$] = null;
        this[_subscription] = null;
        super.Stream();
        this[_controller$] = new (async._AsBroadcastStreamController$(T))(dart.bind(this, _onListen), dart.bind(this, _onCancel));
      }
      get isBroadcast() {
        return true;
      }
      listen(onData, opts) {
        dart.as(onData, dart.functionType(dart.void, [T]));
        let onError = opts && 'onError' in opts ? opts.onError : null;
        let onDone = opts && 'onDone' in opts ? opts.onDone : null;
        dart.as(onDone, dart.functionType(dart.void, []));
        let cancelOnError = opts && 'cancelOnError' in opts ? opts.cancelOnError : null;
        if (this[_controller$] == null || dart.notNull(this[_controller$].isClosed)) {
          return new (async._DoneStreamSubscription$(T))(onDone);
        }
        if (this[_subscription] == null) {
          this[_subscription] = this[_source$].listen(dart.bind(this[_controller$], 'add'), {onError: dart.bind(this[_controller$], 'addError'), onDone: dart.bind(this[_controller$], 'close')});
        }
        cancelOnError = core.identical(true, cancelOnError);
        return this[_controller$][_subscribe](onData, onError, onDone, cancelOnError);
      }
      [_onCancel]() {
        let shutdown = this[_controller$] == null || dart.notNull(this[_controller$].isClosed);
        if (this[_onCancelHandler] != null) {
          this[_zone].runUnary(dart.dynamic, async._BroadcastSubscriptionWrapper$(T))(this[_onCancelHandler], new (async._BroadcastSubscriptionWrapper$(T))(this));
        }
        if (shutdown) {
          if (this[_subscription] != null) {
            this[_subscription].cancel();
            this[_subscription] = null;
          }
        }
      }
      [_onListen]() {
        if (this[_onListenHandler] != null) {
          this[_zone].runUnary(dart.dynamic, async._BroadcastSubscriptionWrapper$(T))(this[_onListenHandler], new (async._BroadcastSubscriptionWrapper$(T))(this));
        }
      }
      [_cancelSubscription]() {
        if (this[_subscription] == null) return;
        let subscription = this[_subscription];
        this[_subscription] = null;
        this[_controller$] = null;
        subscription.cancel();
      }
      [_pauseSubscription](resumeSignal) {
        if (this[_subscription] == null) return;
        this[_subscription].pause(resumeSignal);
      }
      [_resumeSubscription]() {
        if (this[_subscription] == null) return;
        this[_subscription].resume();
      }
      get [_isSubscriptionPaused]() {
        if (this[_subscription] == null) return false;
        return this[_subscription].isPaused;
      }
    }
    dart.setSignature(_AsBroadcastStream, {
      constructors: () => ({_AsBroadcastStream: [async._AsBroadcastStream$(T), [async.Stream$(T), dart.functionType(dart.void, [async.StreamSubscription$(T)]), dart.functionType(dart.void, [async.StreamSubscription$(T)])]]}),
      methods: () => ({
        listen: [async.StreamSubscription$(T), [dart.functionType(dart.void, [T])], {onError: core.Function, onDone: dart.functionType(dart.void, []), cancelOnError: core.bool}],
        [_onCancel]: [dart.void, []],
        [_onListen]: [dart.void, []],
        [_cancelSubscription]: [dart.void, []],
        [_pauseSubscription]: [dart.void, [async.Future]],
        [_resumeSubscription]: [dart.void, []]
      })
    });
    return _AsBroadcastStream;
  });
  async._AsBroadcastStream = async._AsBroadcastStream$();
  async._BroadcastSubscriptionWrapper$ = dart.generic(T => {
    class _BroadcastSubscriptionWrapper extends core.Object {
      _BroadcastSubscriptionWrapper(stream) {
        this[_stream] = stream;
      }
      onData(handleData) {
        dart.as(handleData, dart.functionType(dart.void, [T]));
        dart.throw(new core.UnsupportedError("Cannot change handlers of asBroadcastStream source subscription."));
      }
      onError(handleError) {
        dart.throw(new core.UnsupportedError("Cannot change handlers of asBroadcastStream source subscription."));
      }
      onDone(handleDone) {
        dart.as(handleDone, dart.functionType(dart.void, []));
        dart.throw(new core.UnsupportedError("Cannot change handlers of asBroadcastStream source subscription."));
      }
      pause(resumeSignal) {
        if (resumeSignal === void 0) resumeSignal = null;
        this[_stream][_pauseSubscription](resumeSignal);
      }
      resume() {
        this[_stream][_resumeSubscription]();
      }
      cancel() {
        this[_stream][_cancelSubscription]();
        return null;
      }
      get isPaused() {
        return this[_stream][_isSubscriptionPaused];
      }
      asFuture(E) {
        return futureValue => {
          if (futureValue === void 0) futureValue = null;
          dart.throw(new core.UnsupportedError("Cannot change handlers of asBroadcastStream source subscription."));
        };
      }
    }
    _BroadcastSubscriptionWrapper[dart.implements] = () => [async.StreamSubscription$(T)];
    dart.setSignature(_BroadcastSubscriptionWrapper, {
      constructors: () => ({_BroadcastSubscriptionWrapper: [async._BroadcastSubscriptionWrapper$(T), [async._AsBroadcastStream]]}),
      methods: () => ({
        onData: [dart.void, [dart.functionType(dart.void, [T])]],
        onError: [dart.void, [core.Function]],
        onDone: [dart.void, [dart.functionType(dart.void, [])]],
        pause: [dart.void, [], [async.Future]],
        resume: [dart.void, []],
        cancel: [async.Future, []],
        asFuture: [E => [async.Future$(E), [], [E]]]
      })
    });
    return _BroadcastSubscriptionWrapper;
  });
  async._BroadcastSubscriptionWrapper = async._BroadcastSubscriptionWrapper$();
  const _current$1 = Symbol('_current');
  const _futureOrPrefetch = Symbol('_futureOrPrefetch');
  const _clear = Symbol('_clear');
  async._StreamIteratorImpl$ = dart.generic(T => {
    class _StreamIteratorImpl extends core.Object {
      _StreamIteratorImpl(stream) {
        this[_subscription] = null;
        this[_current$1] = null;
        this[_futureOrPrefetch] = null;
        this[_state] = async._StreamIteratorImpl._STATE_FOUND;
        this[_subscription] = stream.listen(dart.bind(this, _onData), {onError: dart.bind(this, _onError), onDone: dart.bind(this, _onDone), cancelOnError: true});
      }
      get current() {
        return this[_current$1];
      }
      moveNext() {
        if (this[_state] == async._StreamIteratorImpl._STATE_DONE) {
          return new (async._Future$(core.bool)).immediate(false);
        }
        if (this[_state] == async._StreamIteratorImpl._STATE_MOVING) {
          dart.throw(new core.StateError("Already waiting for next."));
        }
        if (this[_state] == async._StreamIteratorImpl._STATE_FOUND) {
          this[_state] = async._StreamIteratorImpl._STATE_MOVING;
          this[_current$1] = null;
          let result = new (async._Future$(core.bool))();
          this[_futureOrPrefetch] = result;
          return result;
        } else {
          dart.assert(dart.notNull(this[_state]) >= dart.notNull(async._StreamIteratorImpl._STATE_EXTRA_DATA));
          switch (this[_state]) {
            case async._StreamIteratorImpl._STATE_EXTRA_DATA:
            {
              this[_state] = async._StreamIteratorImpl._STATE_FOUND;
              this[_current$1] = dart.as(this[_futureOrPrefetch], T);
              this[_futureOrPrefetch] = null;
              this[_subscription].resume();
              return new (async._Future$(core.bool)).immediate(true);
            }
            case async._StreamIteratorImpl._STATE_EXTRA_ERROR:
            {
              let prefetch = dart.as(this[_futureOrPrefetch], async.AsyncError);
              this[_clear]();
              return new (async._Future$(core.bool)).immediateError(prefetch.error, prefetch.stackTrace);
            }
            case async._StreamIteratorImpl._STATE_EXTRA_DONE:
            {
              this[_clear]();
              return new (async._Future$(core.bool)).immediate(false);
            }
          }
        }
      }
      [_clear]() {
        this[_subscription] = null;
        this[_futureOrPrefetch] = null;
        this[_current$1] = null;
        this[_state] = async._StreamIteratorImpl._STATE_DONE;
      }
      cancel() {
        let subscription = this[_subscription];
        if (subscription == null) return null;
        if (this[_state] == async._StreamIteratorImpl._STATE_MOVING) {
          let hasNext = dart.as(this[_futureOrPrefetch], async._Future$(core.bool));
          this[_clear]();
          hasNext[_complete](false);
        } else {
          this[_clear]();
        }
        return subscription.cancel();
      }
      [_onData](data) {
        dart.as(data, T);
        if (this[_state] == async._StreamIteratorImpl._STATE_MOVING) {
          this[_current$1] = data;
          let hasNext = dart.as(this[_futureOrPrefetch], async._Future$(core.bool));
          this[_futureOrPrefetch] = null;
          this[_state] = async._StreamIteratorImpl._STATE_FOUND;
          hasNext[_complete](true);
          return;
        }
        this[_subscription].pause();
        dart.assert(this[_futureOrPrefetch] == null);
        this[_futureOrPrefetch] = data;
        this[_state] = async._StreamIteratorImpl._STATE_EXTRA_DATA;
      }
      [_onError](error, stackTrace) {
        if (stackTrace === void 0) stackTrace = null;
        if (this[_state] == async._StreamIteratorImpl._STATE_MOVING) {
          let hasNext = dart.as(this[_futureOrPrefetch], async._Future$(core.bool));
          this[_clear]();
          hasNext[_completeError](error, stackTrace);
          return;
        }
        this[_subscription].pause();
        dart.assert(this[_futureOrPrefetch] == null);
        this[_futureOrPrefetch] = new async.AsyncError(error, stackTrace);
        this[_state] = async._StreamIteratorImpl._STATE_EXTRA_ERROR;
      }
      [_onDone]() {
        if (this[_state] == async._StreamIteratorImpl._STATE_MOVING) {
          let hasNext = dart.as(this[_futureOrPrefetch], async._Future$(core.bool));
          this[_clear]();
          hasNext[_complete](false);
          return;
        }
        this[_subscription].pause();
        this[_futureOrPrefetch] = null;
        this[_state] = async._StreamIteratorImpl._STATE_EXTRA_DONE;
      }
    }
    _StreamIteratorImpl[dart.implements] = () => [async.StreamIterator$(T)];
    dart.setSignature(_StreamIteratorImpl, {
      constructors: () => ({_StreamIteratorImpl: [async._StreamIteratorImpl$(T), [async.Stream$(T)]]}),
      methods: () => ({
        moveNext: [async.Future$(core.bool), []],
        [_clear]: [dart.void, []],
        cancel: [async.Future, []],
        [_onData]: [dart.void, [T]],
        [_onError]: [dart.void, [core.Object], [core.StackTrace]],
        [_onDone]: [dart.void, []]
      })
    });
    return _StreamIteratorImpl;
  });
  async._StreamIteratorImpl = async._StreamIteratorImpl$();
  async._StreamIteratorImpl._STATE_FOUND = 0;
  async._StreamIteratorImpl._STATE_DONE = 1;
  async._StreamIteratorImpl._STATE_MOVING = 2;
  async._StreamIteratorImpl._STATE_EXTRA_DATA = 3;
  async._StreamIteratorImpl._STATE_EXTRA_ERROR = 4;
  async._StreamIteratorImpl._STATE_EXTRA_DONE = 5;
  async._EmptyStream$ = dart.generic(T => {
    class _EmptyStream extends async.Stream$(T) {
      _EmptyStream() {
        super._internal();
      }
      get isBroadcast() {
        return true;
      }
      listen(onData, opts) {
        dart.as(onData, dart.functionType(dart.void, [T]));
        let onError = opts && 'onError' in opts ? opts.onError : null;
        let onDone = opts && 'onDone' in opts ? opts.onDone : null;
        dart.as(onDone, dart.functionType(dart.void, []));
        let cancelOnError = opts && 'cancelOnError' in opts ? opts.cancelOnError : null;
        return new (async._DoneStreamSubscription$(T))(onDone);
      }
    }
    dart.setSignature(_EmptyStream, {
      constructors: () => ({_EmptyStream: [async._EmptyStream$(T), []]}),
      methods: () => ({listen: [async.StreamSubscription$(T), [dart.functionType(dart.void, [T])], {onError: core.Function, onDone: dart.functionType(dart.void, []), cancelOnError: core.bool}]})
    });
    return _EmptyStream;
  });
  async._EmptyStream = async._EmptyStream$();
  async._runUserCode = function(userCode, onSuccess, onError) {
    try {
      dart.dcall(onSuccess, userCode());
    } catch (e) {
      let s = dart.stackTrace(e);
      let replacement = async.Zone.current.errorCallback(e, s);
      if (replacement == null) {
        dart.dcall(onError, e, s);
      } else {
        let error = async._nonNullError(replacement.error);
        let stackTrace = replacement.stackTrace;
        dart.dcall(onError, error, stackTrace);
      }
    }

  };
  dart.lazyFn(async._runUserCode, () => [dart.dynamic, [dart.functionType(dart.dynamic, []), dart.functionType(dart.dynamic, [dart.dynamic]), dart.functionType(dart.dynamic, [dart.dynamic, core.StackTrace])]]);
  async._cancelAndError = function(subscription, future, error, stackTrace) {
    let cancelFuture = subscription.cancel();
    if (dart.is(cancelFuture, async.Future)) {
      cancelFuture.whenComplete(dart.fn(() => future[_completeError](error, stackTrace), dart.void, []));
    } else {
      future[_completeError](error, stackTrace);
    }
  };
  dart.lazyFn(async._cancelAndError, () => [dart.void, [async.StreamSubscription, async._Future, dart.dynamic, core.StackTrace]]);
  async._cancelAndErrorWithReplacement = function(subscription, future, error, stackTrace) {
    let replacement = async.Zone.current.errorCallback(error, stackTrace);
    if (replacement != null) {
      error = async._nonNullError(replacement.error);
      stackTrace = replacement.stackTrace;
    }
    async._cancelAndError(subscription, future, error, stackTrace);
  };
  dart.lazyFn(async._cancelAndErrorWithReplacement, () => [dart.void, [async.StreamSubscription, async._Future, dart.dynamic, core.StackTrace]]);
  async._ErrorCallback = dart.typedef('_ErrorCallback', () => dart.functionType(dart.void, [dart.dynamic, core.StackTrace]));
  async._cancelAndErrorClosure = function(subscription, future) {
    return dart.fn((error, stackTrace) => {
      async._cancelAndError(subscription, future, error, stackTrace);
    }, dart.void, [dart.dynamic, core.StackTrace]);
  };
  dart.fn(async._cancelAndErrorClosure, async._ErrorCallback, [async.StreamSubscription, async._Future]);
  async._cancelAndValue = function(subscription, future, value) {
    let cancelFuture = subscription.cancel();
    if (dart.is(cancelFuture, async.Future)) {
      cancelFuture.whenComplete(dart.fn(() => future[_complete](value), dart.void, []));
    } else {
      future[_complete](value);
    }
  };
  dart.fn(async._cancelAndValue, dart.void, [async.StreamSubscription, async._Future, dart.dynamic]);
  const _handleData = Symbol('_handleData');
  const _handleError = Symbol('_handleError');
  const _handleDone = Symbol('_handleDone');
  async._ForwardingStream$ = dart.generic((S, T) => {
    class _ForwardingStream extends async.Stream$(T) {
      _ForwardingStream(source) {
        this[_source$] = source;
        super.Stream();
      }
      get isBroadcast() {
        return this[_source$].isBroadcast;
      }
      listen(onData, opts) {
        dart.as(onData, dart.functionType(dart.void, [T]));
        let onError = opts && 'onError' in opts ? opts.onError : null;
        let onDone = opts && 'onDone' in opts ? opts.onDone : null;
        dart.as(onDone, dart.functionType(dart.void, []));
        let cancelOnError = opts && 'cancelOnError' in opts ? opts.cancelOnError : null;
        cancelOnError = core.identical(true, cancelOnError);
        return this[_createSubscription](onData, onError, onDone, cancelOnError);
      }
      [_createSubscription](onData, onError, onDone, cancelOnError) {
        dart.as(onData, dart.functionType(dart.void, [T]));
        dart.as(onDone, dart.functionType(dart.void, []));
        return new (async._ForwardingStreamSubscription$(S, T))(this, onData, onError, onDone, cancelOnError);
      }
      [_handleData](data, sink) {
        dart.as(data, S);
        dart.as(sink, async._EventSink$(T));
        sink[_add$](dart.as(data, T));
      }
      [_handleError](error, stackTrace, sink) {
        dart.as(sink, async._EventSink$(T));
        sink[_addError](error, stackTrace);
      }
      [_handleDone](sink) {
        dart.as(sink, async._EventSink$(T));
        sink[_close$]();
      }
    }
    dart.setSignature(_ForwardingStream, {
      constructors: () => ({_ForwardingStream: [async._ForwardingStream$(S, T), [async.Stream$(S)]]}),
      methods: () => ({
        listen: [async.StreamSubscription$(T), [dart.functionType(dart.void, [T])], {onError: core.Function, onDone: dart.functionType(dart.void, []), cancelOnError: core.bool}],
        [_createSubscription]: [async.StreamSubscription$(T), [dart.functionType(dart.void, [T]), core.Function, dart.functionType(dart.void, []), core.bool]],
        [_handleData]: [dart.void, [S, async._EventSink$(T)]],
        [_handleError]: [dart.void, [dart.dynamic, core.StackTrace, async._EventSink$(T)]],
        [_handleDone]: [dart.void, [async._EventSink$(T)]]
      })
    });
    return _ForwardingStream;
  });
  async._ForwardingStream = async._ForwardingStream$();
  async._ForwardingStreamSubscription$ = dart.generic((S, T) => {
    class _ForwardingStreamSubscription extends async._BufferingStreamSubscription$(T) {
      _ForwardingStreamSubscription(stream, onData, onError, onDone, cancelOnError) {
        this[_stream] = stream;
        this[_subscription] = null;
        super._BufferingStreamSubscription(onData, onError, onDone, cancelOnError);
        this[_subscription] = this[_stream][_source$].listen(dart.bind(this, _handleData), {onError: dart.bind(this, _handleError), onDone: dart.bind(this, _handleDone)});
      }
      [_add$](data) {
        dart.as(data, T);
        if (dart.notNull(this[_isClosed$])) return;
        super[_add$](data);
      }
      [_addError](error, stackTrace) {
        if (dart.notNull(this[_isClosed$])) return;
        super[_addError](error, stackTrace);
      }
      [_onPause]() {
        if (this[_subscription] == null) return;
        this[_subscription].pause();
      }
      [_onResume]() {
        if (this[_subscription] == null) return;
        this[_subscription].resume();
      }
      [_onCancel]() {
        if (this[_subscription] != null) {
          let subscription = this[_subscription];
          this[_subscription] = null;
          return subscription.cancel();
        }
        return null;
      }
      [_handleData](data) {
        dart.as(data, S);
        this[_stream][_handleData](data, this);
      }
      [_handleError](error, stackTrace) {
        this[_stream][_handleError](error, stackTrace, this);
      }
      [_handleDone]() {
        this[_stream][_handleDone](this);
      }
    }
    dart.setSignature(_ForwardingStreamSubscription, {
      constructors: () => ({_ForwardingStreamSubscription: [async._ForwardingStreamSubscription$(S, T), [async._ForwardingStream$(S, T), dart.functionType(dart.void, [T]), core.Function, dart.functionType(dart.void, []), core.bool]]}),
      methods: () => ({
        [_add$]: [dart.void, [T]],
        [_handleData]: [dart.void, [S]],
        [_handleError]: [dart.void, [dart.dynamic, core.StackTrace]],
        [_handleDone]: [dart.void, []]
      })
    });
    return _ForwardingStreamSubscription;
  });
  async._ForwardingStreamSubscription = async._ForwardingStreamSubscription$();
  async._Predicate$ = dart.generic(T => {
    const _Predicate = dart.typedef('_Predicate', () => dart.functionType(core.bool, [T]));
    return _Predicate;
  });
  async._Predicate = async._Predicate$();
  async._addErrorWithReplacement = function(sink, error, stackTrace) {
    let replacement = async.Zone.current.errorCallback(error, dart.as(stackTrace, core.StackTrace));
    if (replacement != null) {
      error = async._nonNullError(replacement.error);
      stackTrace = replacement.stackTrace;
    }
    sink[_addError](error, dart.as(stackTrace, core.StackTrace));
  };
  dart.fn(async._addErrorWithReplacement, dart.void, [async._EventSink, dart.dynamic, dart.dynamic]);
  const _test = Symbol('_test');
  async._WhereStream$ = dart.generic(T => {
    class _WhereStream extends async._ForwardingStream$(T, T) {
      _WhereStream(source, test) {
        this[_test] = test;
        super._ForwardingStream(source);
      }
      [_handleData](inputEvent, sink) {
        dart.as(inputEvent, T);
        dart.as(sink, async._EventSink$(T));
        let satisfies = null;
        try {
          satisfies = this[_test](inputEvent);
        } catch (e) {
          let s = dart.stackTrace(e);
          async._addErrorWithReplacement(sink, e, s);
          return;
        }

        if (dart.notNull(satisfies)) {
          sink[_add$](inputEvent);
        }
      }
    }
    dart.setSignature(_WhereStream, {
      constructors: () => ({_WhereStream: [async._WhereStream$(T), [async.Stream$(T), dart.functionType(core.bool, [T])]]}),
      methods: () => ({[_handleData]: [dart.void, [T, async._EventSink$(T)]]})
    });
    return _WhereStream;
  });
  async._WhereStream = async._WhereStream$();
  async._Transformation$ = dart.generic((S, T) => {
    const _Transformation = dart.typedef('_Transformation', () => dart.functionType(T, [S]));
    return _Transformation;
  });
  async._Transformation = async._Transformation$();
  const _transform = Symbol('_transform');
  async._MapStream$ = dart.generic((S, T) => {
    class _MapStream extends async._ForwardingStream$(S, T) {
      _MapStream(source, transform) {
        this[_transform] = transform;
        super._ForwardingStream(source);
      }
      [_handleData](inputEvent, sink) {
        dart.as(inputEvent, S);
        dart.as(sink, async._EventSink$(T));
        let outputEvent = null;
        try {
          outputEvent = this[_transform](inputEvent);
        } catch (e) {
          let s = dart.stackTrace(e);
          async._addErrorWithReplacement(sink, e, s);
          return;
        }

        sink[_add$](outputEvent);
      }
    }
    dart.setSignature(_MapStream, {
      constructors: () => ({_MapStream: [async._MapStream$(S, T), [async.Stream$(S), dart.functionType(T, [S])]]}),
      methods: () => ({[_handleData]: [dart.void, [S, async._EventSink$(T)]]})
    });
    return _MapStream;
  });
  async._MapStream = async._MapStream$();
  const _expand = Symbol('_expand');
  async._ExpandStream$ = dart.generic((S, T) => {
    class _ExpandStream extends async._ForwardingStream$(S, T) {
      _ExpandStream(source, expand) {
        this[_expand] = expand;
        super._ForwardingStream(source);
      }
      [_handleData](inputEvent, sink) {
        dart.as(inputEvent, S);
        dart.as(sink, async._EventSink$(T));
        try {
          for (let value of this[_expand](inputEvent)) {
            sink[_add$](value);
          }
        } catch (e) {
          let s = dart.stackTrace(e);
          async._addErrorWithReplacement(sink, e, s);
        }

      }
    }
    dart.setSignature(_ExpandStream, {
      constructors: () => ({_ExpandStream: [async._ExpandStream$(S, T), [async.Stream$(S), dart.functionType(core.Iterable$(T), [S])]]}),
      methods: () => ({[_handleData]: [dart.void, [S, async._EventSink$(T)]]})
    });
    return _ExpandStream;
  });
  async._ExpandStream = async._ExpandStream$();
  async._ErrorTest = dart.typedef('_ErrorTest', () => dart.functionType(core.bool, [dart.dynamic]));
  async._HandleErrorStream$ = dart.generic(T => {
    class _HandleErrorStream extends async._ForwardingStream$(T, T) {
      _HandleErrorStream(source, onError, test) {
        this[_transform] = onError;
        this[_test] = test;
        super._ForwardingStream(source);
      }
      [_handleError](error, stackTrace, sink) {
        dart.as(sink, async._EventSink$(T));
        let matches = true;
        if (this[_test] != null) {
          try {
            matches = dart.dcall(this[_test], error);
          } catch (e) {
            let s = dart.stackTrace(e);
            async._addErrorWithReplacement(sink, e, s);
            return;
          }

        }
        if (dart.notNull(matches)) {
          try {
            async._invokeErrorHandler(this[_transform], error, stackTrace);
          } catch (e) {
            let s = dart.stackTrace(e);
            if (core.identical(e, error)) {
              sink[_addError](error, stackTrace);
            } else {
              async._addErrorWithReplacement(sink, e, s);
            }
            return;
          }

        } else {
          sink[_addError](error, stackTrace);
        }
      }
    }
    dart.setSignature(_HandleErrorStream, {
      constructors: () => ({_HandleErrorStream: [async._HandleErrorStream$(T), [async.Stream$(T), core.Function, dart.functionType(core.bool, [dart.dynamic])]]}),
      methods: () => ({[_handleError]: [dart.void, [core.Object, core.StackTrace, async._EventSink$(T)]]})
    });
    return _HandleErrorStream;
  });
  async._HandleErrorStream = async._HandleErrorStream$();
  const _count = Symbol('_count');
  async._TakeStream$ = dart.generic(T => {
    class _TakeStream extends async._ForwardingStream$(T, T) {
      _TakeStream(source, count) {
        this[_count] = count;
        super._ForwardingStream(source);
        if (!(typeof count == 'number')) dart.throw(new core.ArgumentError(count));
      }
      [_createSubscription](onData, onError, onDone, cancelOnError) {
        dart.as(onData, dart.functionType(dart.void, [T]));
        dart.as(onDone, dart.functionType(dart.void, []));
        return new (async._StateStreamSubscription$(T))(this, onData, onError, onDone, cancelOnError, this[_count]);
      }
      [_handleData](inputEvent, sink) {
        dart.as(inputEvent, T);
        dart.as(sink, async._EventSink$(T));
        let subscription = dart.as(sink, async._StateStreamSubscription$(T));
        let count = subscription[_count];
        if (dart.notNull(count) > 0) {
          sink[_add$](inputEvent);
          count = dart.notNull(count) - 1;
          subscription[_count] = count;
          if (count == 0) {
            sink[_close$]();
          }
        }
      }
    }
    dart.setSignature(_TakeStream, {
      constructors: () => ({_TakeStream: [async._TakeStream$(T), [async.Stream$(T), core.int]]}),
      methods: () => ({
        [_createSubscription]: [async.StreamSubscription$(T), [dart.functionType(dart.void, [T]), core.Function, dart.functionType(dart.void, []), core.bool]],
        [_handleData]: [dart.void, [T, async._EventSink$(T)]]
      })
    });
    return _TakeStream;
  });
  async._TakeStream = async._TakeStream$();
  const _sharedState = Symbol('_sharedState');
  const _flag = Symbol('_flag');
  async._StateStreamSubscription$ = dart.generic(T => {
    class _StateStreamSubscription extends async._ForwardingStreamSubscription$(T, T) {
      _StateStreamSubscription(stream, onData, onError, onDone, cancelOnError, sharedState) {
        this[_sharedState] = sharedState;
        super._ForwardingStreamSubscription(stream, onData, onError, onDone, cancelOnError);
      }
      get [_flag]() {
        return dart.as(this[_sharedState], core.bool);
      }
      set [_flag](flag) {
        this[_sharedState] = flag;
      }
      get [_count]() {
        return dart.as(this[_sharedState], core.int);
      }
      set [_count](count) {
        this[_sharedState] = count;
      }
    }
    dart.setSignature(_StateStreamSubscription, {
      constructors: () => ({_StateStreamSubscription: [async._StateStreamSubscription$(T), [async._ForwardingStream$(T, T), dart.functionType(dart.void, [T]), core.Function, dart.functionType(dart.void, []), core.bool, dart.dynamic]]})
    });
    return _StateStreamSubscription;
  });
  async._StateStreamSubscription = async._StateStreamSubscription$();
  async._TakeWhileStream$ = dart.generic(T => {
    class _TakeWhileStream extends async._ForwardingStream$(T, T) {
      _TakeWhileStream(source, test) {
        this[_test] = test;
        super._ForwardingStream(source);
      }
      [_handleData](inputEvent, sink) {
        dart.as(inputEvent, T);
        dart.as(sink, async._EventSink$(T));
        let satisfies = null;
        try {
          satisfies = this[_test](inputEvent);
        } catch (e) {
          let s = dart.stackTrace(e);
          async._addErrorWithReplacement(sink, e, s);
          sink[_close$]();
          return;
        }

        if (dart.notNull(satisfies)) {
          sink[_add$](inputEvent);
        } else {
          sink[_close$]();
        }
      }
    }
    dart.setSignature(_TakeWhileStream, {
      constructors: () => ({_TakeWhileStream: [async._TakeWhileStream$(T), [async.Stream$(T), dart.functionType(core.bool, [T])]]}),
      methods: () => ({[_handleData]: [dart.void, [T, async._EventSink$(T)]]})
    });
    return _TakeWhileStream;
  });
  async._TakeWhileStream = async._TakeWhileStream$();
  async._SkipStream$ = dart.generic(T => {
    class _SkipStream extends async._ForwardingStream$(T, T) {
      _SkipStream(source, count) {
        this[_count] = count;
        super._ForwardingStream(source);
        if (!(typeof count == 'number') || dart.notNull(count) < 0) dart.throw(new core.ArgumentError(count));
      }
      [_createSubscription](onData, onError, onDone, cancelOnError) {
        dart.as(onData, dart.functionType(dart.void, [T]));
        dart.as(onDone, dart.functionType(dart.void, []));
        return new (async._StateStreamSubscription$(T))(this, onData, onError, onDone, cancelOnError, this[_count]);
      }
      [_handleData](inputEvent, sink) {
        dart.as(inputEvent, T);
        dart.as(sink, async._EventSink$(T));
        let subscription = dart.as(sink, async._StateStreamSubscription$(T));
        let count = subscription[_count];
        if (dart.notNull(count) > 0) {
          subscription[_count] = dart.notNull(count) - 1;
          return;
        }
        sink[_add$](inputEvent);
      }
    }
    dart.setSignature(_SkipStream, {
      constructors: () => ({_SkipStream: [async._SkipStream$(T), [async.Stream$(T), core.int]]}),
      methods: () => ({
        [_createSubscription]: [async.StreamSubscription$(T), [dart.functionType(dart.void, [T]), core.Function, dart.functionType(dart.void, []), core.bool]],
        [_handleData]: [dart.void, [T, async._EventSink$(T)]]
      })
    });
    return _SkipStream;
  });
  async._SkipStream = async._SkipStream$();
  async._SkipWhileStream$ = dart.generic(T => {
    class _SkipWhileStream extends async._ForwardingStream$(T, T) {
      _SkipWhileStream(source, test) {
        this[_test] = test;
        super._ForwardingStream(source);
      }
      [_createSubscription](onData, onError, onDone, cancelOnError) {
        dart.as(onData, dart.functionType(dart.void, [T]));
        dart.as(onDone, dart.functionType(dart.void, []));
        return new (async._StateStreamSubscription$(T))(this, onData, onError, onDone, cancelOnError, false);
      }
      [_handleData](inputEvent, sink) {
        dart.as(inputEvent, T);
        dart.as(sink, async._EventSink$(T));
        let subscription = dart.as(sink, async._StateStreamSubscription$(T));
        let hasFailed = subscription[_flag];
        if (dart.notNull(hasFailed)) {
          sink[_add$](inputEvent);
          return;
        }
        let satisfies = null;
        try {
          satisfies = this[_test](inputEvent);
        } catch (e) {
          let s = dart.stackTrace(e);
          async._addErrorWithReplacement(sink, e, s);
          subscription[_flag] = true;
          return;
        }

        if (!dart.notNull(satisfies)) {
          subscription[_flag] = true;
          sink[_add$](inputEvent);
        }
      }
    }
    dart.setSignature(_SkipWhileStream, {
      constructors: () => ({_SkipWhileStream: [async._SkipWhileStream$(T), [async.Stream$(T), dart.functionType(core.bool, [T])]]}),
      methods: () => ({
        [_createSubscription]: [async.StreamSubscription$(T), [dart.functionType(dart.void, [T]), core.Function, dart.functionType(dart.void, []), core.bool]],
        [_handleData]: [dart.void, [T, async._EventSink$(T)]]
      })
    });
    return _SkipWhileStream;
  });
  async._SkipWhileStream = async._SkipWhileStream$();
  async._Equality$ = dart.generic(T => {
    const _Equality = dart.typedef('_Equality', () => dart.functionType(core.bool, [T, T]));
    return _Equality;
  });
  async._Equality = async._Equality$();
  const _equals = Symbol('_equals');
  async._DistinctStream$ = dart.generic(T => {
    class _DistinctStream extends async._ForwardingStream$(T, T) {
      _DistinctStream(source, equals) {
        this[_previous$] = async._DistinctStream._SENTINEL;
        this[_equals] = equals;
        super._ForwardingStream(source);
      }
      [_handleData](inputEvent, sink) {
        dart.as(inputEvent, T);
        dart.as(sink, async._EventSink$(T));
        if (core.identical(this[_previous$], async._DistinctStream._SENTINEL)) {
          this[_previous$] = inputEvent;
          return sink[_add$](inputEvent);
        } else {
          let isEqual = null;
          try {
            if (this[_equals] == null) {
              isEqual = dart.equals(this[_previous$], inputEvent);
            } else {
              isEqual = this[_equals](dart.as(this[_previous$], T), inputEvent);
            }
          } catch (e) {
            let s = dart.stackTrace(e);
            async._addErrorWithReplacement(sink, e, s);
            return null;
          }

          if (!dart.notNull(isEqual)) {
            sink[_add$](inputEvent);
            this[_previous$] = inputEvent;
          }
        }
      }
    }
    dart.setSignature(_DistinctStream, {
      constructors: () => ({_DistinctStream: [async._DistinctStream$(T), [async.Stream$(T), dart.functionType(core.bool, [T, T])]]}),
      methods: () => ({[_handleData]: [dart.void, [T, async._EventSink$(T)]]})
    });
    return _DistinctStream;
  });
  async._DistinctStream = async._DistinctStream$();
  dart.defineLazy(async._DistinctStream, {
    get _SENTINEL() {
      return new core.Object();
    },
    set _SENTINEL(_) {}
  });
  async._EventSinkWrapper$ = dart.generic(T => {
    class _EventSinkWrapper extends core.Object {
      _EventSinkWrapper(sink) {
        this[_sink] = sink;
      }
      add(data) {
        dart.as(data, T);
        this[_sink][_add$](data);
      }
      addError(error, stackTrace) {
        if (stackTrace === void 0) stackTrace = null;
        this[_sink][_addError](error, stackTrace);
      }
      close() {
        this[_sink][_close$]();
      }
    }
    _EventSinkWrapper[dart.implements] = () => [async.EventSink$(T)];
    dart.setSignature(_EventSinkWrapper, {
      constructors: () => ({_EventSinkWrapper: [async._EventSinkWrapper$(T), [async._EventSink]]}),
      methods: () => ({
        add: [dart.void, [T]],
        addError: [dart.void, [dart.dynamic], [core.StackTrace]],
        close: [dart.void, []]
      })
    });
    return _EventSinkWrapper;
  });
  async._EventSinkWrapper = async._EventSinkWrapper$();
  const _transformerSink = Symbol('_transformerSink');
  const _isSubscribed = Symbol('_isSubscribed');
  async._SinkTransformerStreamSubscription$ = dart.generic((S, T) => {
    class _SinkTransformerStreamSubscription extends async._BufferingStreamSubscription$(T) {
      _SinkTransformerStreamSubscription(source, mapper, onData, onError, onDone, cancelOnError) {
        this[_transformerSink] = null;
        this[_subscription] = null;
        super._BufferingStreamSubscription(onData, onError, onDone, cancelOnError);
        let eventSink = new (async._EventSinkWrapper$(T))(this);
        this[_transformerSink] = mapper(eventSink);
        this[_subscription] = source.listen(dart.bind(this, _handleData), {onError: dart.bind(this, _handleError), onDone: dart.bind(this, _handleDone)});
      }
      get [_isSubscribed]() {
        return this[_subscription] != null;
      }
      [_add$](data) {
        dart.as(data, T);
        if (dart.notNull(this[_isClosed$])) {
          dart.throw(new core.StateError("Stream is already closed"));
        }
        super[_add$](data);
      }
      [_addError](error, stackTrace) {
        if (dart.notNull(this[_isClosed$])) {
          dart.throw(new core.StateError("Stream is already closed"));
        }
        super[_addError](error, stackTrace);
      }
      [_close$]() {
        if (dart.notNull(this[_isClosed$])) {
          dart.throw(new core.StateError("Stream is already closed"));
        }
        super[_close$]();
      }
      [_onPause]() {
        if (dart.notNull(this[_isSubscribed])) this[_subscription].pause();
      }
      [_onResume]() {
        if (dart.notNull(this[_isSubscribed])) this[_subscription].resume();
      }
      [_onCancel]() {
        if (dart.notNull(this[_isSubscribed])) {
          let subscription = this[_subscription];
          this[_subscription] = null;
          subscription.cancel();
        }
        return null;
      }
      [_handleData](data) {
        dart.as(data, S);
        try {
          this[_transformerSink].add(data);
        } catch (e) {
          let s = dart.stackTrace(e);
          this[_addError](e, s);
        }

      }
      [_handleError](error, stackTrace) {
        if (stackTrace === void 0) stackTrace = null;
        try {
          this[_transformerSink].addError(error, dart.as(stackTrace, core.StackTrace));
        } catch (e) {
          let s = dart.stackTrace(e);
          if (core.identical(e, error)) {
            this[_addError](error, dart.as(stackTrace, core.StackTrace));
          } else {
            this[_addError](e, s);
          }
        }

      }
      [_handleDone]() {
        try {
          this[_subscription] = null;
          this[_transformerSink].close();
        } catch (e) {
          let s = dart.stackTrace(e);
          this[_addError](e, s);
        }

      }
    }
    dart.setSignature(_SinkTransformerStreamSubscription, {
      constructors: () => ({_SinkTransformerStreamSubscription: [async._SinkTransformerStreamSubscription$(S, T), [async.Stream$(S), async._SinkMapper$(S, T), dart.functionType(dart.void, [T]), core.Function, dart.functionType(dart.void, []), core.bool]]}),
      methods: () => ({
        [_add$]: [dart.void, [T]],
        [_handleData]: [dart.void, [S]],
        [_handleError]: [dart.void, [dart.dynamic], [dart.dynamic]],
        [_handleDone]: [dart.void, []]
      })
    });
    return _SinkTransformerStreamSubscription;
  });
  async._SinkTransformerStreamSubscription = async._SinkTransformerStreamSubscription$();
  async._SinkMapper$ = dart.generic((S, T) => {
    const _SinkMapper = dart.typedef('_SinkMapper', () => dart.functionType(async.EventSink$(S), [async.EventSink$(T)]));
    return _SinkMapper;
  });
  async._SinkMapper = async._SinkMapper$();
  const _sinkMapper = Symbol('_sinkMapper');
  async._StreamSinkTransformer$ = dart.generic((S, T) => {
    class _StreamSinkTransformer extends core.Object {
      _StreamSinkTransformer(sinkMapper) {
        this[_sinkMapper] = sinkMapper;
      }
      bind(stream) {
        dart.as(stream, async.Stream$(S));
        return new (async._BoundSinkStream$(S, T))(stream, this[_sinkMapper]);
      }
    }
    _StreamSinkTransformer[dart.implements] = () => [async.StreamTransformer$(S, T)];
    dart.setSignature(_StreamSinkTransformer, {
      constructors: () => ({_StreamSinkTransformer: [async._StreamSinkTransformer$(S, T), [async._SinkMapper$(S, T)]]}),
      methods: () => ({bind: [async.Stream$(T), [async.Stream$(S)]]})
    });
    return _StreamSinkTransformer;
  });
  async._StreamSinkTransformer = async._StreamSinkTransformer$();
  async._BoundSinkStream$ = dart.generic((S, T) => {
    class _BoundSinkStream extends async.Stream$(T) {
      get isBroadcast() {
        return this[_stream].isBroadcast;
      }
      _BoundSinkStream(stream, sinkMapper) {
        this[_stream] = stream;
        this[_sinkMapper] = sinkMapper;
        super.Stream();
      }
      listen(onData, opts) {
        dart.as(onData, dart.functionType(dart.void, [T]));
        let onError = opts && 'onError' in opts ? opts.onError : null;
        let onDone = opts && 'onDone' in opts ? opts.onDone : null;
        dart.as(onDone, dart.functionType(dart.void, []));
        let cancelOnError = opts && 'cancelOnError' in opts ? opts.cancelOnError : null;
        cancelOnError = core.identical(true, cancelOnError);
        let subscription = new (async._SinkTransformerStreamSubscription$(S, T))(this[_stream], this[_sinkMapper], onData, onError, onDone, cancelOnError);
        return subscription;
      }
    }
    dart.setSignature(_BoundSinkStream, {
      constructors: () => ({_BoundSinkStream: [async._BoundSinkStream$(S, T), [async.Stream$(S), async._SinkMapper$(S, T)]]}),
      methods: () => ({listen: [async.StreamSubscription$(T), [dart.functionType(dart.void, [T])], {onError: core.Function, onDone: dart.functionType(dart.void, []), cancelOnError: core.bool}]})
    });
    return _BoundSinkStream;
  });
  async._BoundSinkStream = async._BoundSinkStream$();
  async._TransformDataHandler$ = dart.generic((S, T) => {
    const _TransformDataHandler = dart.typedef('_TransformDataHandler', () => dart.functionType(dart.void, [S, async.EventSink$(T)]));
    return _TransformDataHandler;
  });
  async._TransformDataHandler = async._TransformDataHandler$();
  async._TransformErrorHandler$ = dart.generic(T => {
    const _TransformErrorHandler = dart.typedef('_TransformErrorHandler', () => dart.functionType(dart.void, [core.Object, core.StackTrace, async.EventSink$(T)]));
    return _TransformErrorHandler;
  });
  async._TransformErrorHandler = async._TransformErrorHandler$();
  async._TransformDoneHandler$ = dart.generic(T => {
    const _TransformDoneHandler = dart.typedef('_TransformDoneHandler', () => dart.functionType(dart.void, [async.EventSink$(T)]));
    return _TransformDoneHandler;
  });
  async._TransformDoneHandler = async._TransformDoneHandler$();
  async._HandlerEventSink$ = dart.generic((S, T) => {
    class _HandlerEventSink extends core.Object {
      _HandlerEventSink(handleData, handleError, handleDone, sink) {
        this[_handleData] = handleData;
        this[_handleError] = handleError;
        this[_handleDone] = handleDone;
        this[_sink] = sink;
      }
      add(data) {
        dart.as(data, S);
        this[_handleData](data, this[_sink]);
      }
      addError(error, stackTrace) {
        if (stackTrace === void 0) stackTrace = null;
        this[_handleError](error, stackTrace, this[_sink]);
      }
      close() {
        this[_handleDone](this[_sink]);
      }
    }
    _HandlerEventSink[dart.implements] = () => [async.EventSink$(S)];
    dart.setSignature(_HandlerEventSink, {
      constructors: () => ({_HandlerEventSink: [async._HandlerEventSink$(S, T), [async._TransformDataHandler$(S, T), async._TransformErrorHandler$(T), async._TransformDoneHandler$(T), async.EventSink$(T)]]}),
      methods: () => ({
        add: [dart.void, [S]],
        addError: [dart.void, [core.Object], [core.StackTrace]],
        close: [dart.void, []]
      })
    });
    return _HandlerEventSink;
  });
  async._HandlerEventSink = async._HandlerEventSink$();
  async._StreamHandlerTransformer$ = dart.generic((S, T) => {
    class _StreamHandlerTransformer extends async._StreamSinkTransformer$(S, T) {
      _StreamHandlerTransformer(opts) {
        let handleData = opts && 'handleData' in opts ? opts.handleData : null;
        let handleError = opts && 'handleError' in opts ? opts.handleError : null;
        let handleDone = opts && 'handleDone' in opts ? opts.handleDone : null;
        super._StreamSinkTransformer(dart.fn(outputSink => {
          dart.as(outputSink, async.EventSink$(T));
          if (handleData == null) handleData = async._StreamHandlerTransformer._defaultHandleData;
          if (handleError == null) handleError = async._StreamHandlerTransformer._defaultHandleError;
          if (handleDone == null) handleDone = async._StreamHandlerTransformer._defaultHandleDone;
          return new (async._HandlerEventSink$(S, T))(handleData, handleError, handleDone, outputSink);
        }, async.EventSink$(S), [async.EventSink$(T)]));
      }
      bind(stream) {
        dart.as(stream, async.Stream$(S));
        return super.bind(stream);
      }
      static _defaultHandleData(data, sink) {
        sink.add(data);
      }
      static _defaultHandleError(error, stackTrace, sink) {
        sink.addError(error, stackTrace);
      }
      static _defaultHandleDone(sink) {
        sink.close();
      }
    }
    dart.setSignature(_StreamHandlerTransformer, {
      constructors: () => ({_StreamHandlerTransformer: [async._StreamHandlerTransformer$(S, T), [], {handleData: dart.functionType(dart.void, [S, async.EventSink$(T)]), handleError: dart.functionType(dart.void, [core.Object, core.StackTrace, async.EventSink$(T)]), handleDone: dart.functionType(dart.void, [async.EventSink$(T)])}]}),
      methods: () => ({bind: [async.Stream$(T), [async.Stream$(S)]]}),
      statics: () => ({
        _defaultHandleData: [dart.void, [dart.dynamic, async.EventSink]],
        _defaultHandleError: [dart.void, [dart.dynamic, core.StackTrace, async.EventSink]],
        _defaultHandleDone: [dart.void, [async.EventSink]]
      }),
      names: ['_defaultHandleData', '_defaultHandleError', '_defaultHandleDone']
    });
    return _StreamHandlerTransformer;
  });
  async._StreamHandlerTransformer = async._StreamHandlerTransformer$();
  async._SubscriptionTransformer$ = dart.generic((S, T) => {
    const _SubscriptionTransformer = dart.typedef('_SubscriptionTransformer', () => dart.functionType(async.StreamSubscription$(T), [async.Stream$(S), core.bool]));
    return _SubscriptionTransformer;
  });
  async._SubscriptionTransformer = async._SubscriptionTransformer$();
  const _transformer = Symbol('_transformer');
  async._StreamSubscriptionTransformer$ = dart.generic((S, T) => {
    class _StreamSubscriptionTransformer extends core.Object {
      _StreamSubscriptionTransformer(transformer) {
        this[_transformer] = transformer;
      }
      bind(stream) {
        dart.as(stream, async.Stream$(S));
        return new (async._BoundSubscriptionStream$(S, T))(stream, this[_transformer]);
      }
    }
    _StreamSubscriptionTransformer[dart.implements] = () => [async.StreamTransformer$(S, T)];
    dart.setSignature(_StreamSubscriptionTransformer, {
      constructors: () => ({_StreamSubscriptionTransformer: [async._StreamSubscriptionTransformer$(S, T), [async._SubscriptionTransformer$(S, T)]]}),
      methods: () => ({bind: [async.Stream$(T), [async.Stream$(S)]]})
    });
    return _StreamSubscriptionTransformer;
  });
  async._StreamSubscriptionTransformer = async._StreamSubscriptionTransformer$();
  async._BoundSubscriptionStream$ = dart.generic((S, T) => {
    class _BoundSubscriptionStream extends async.Stream$(T) {
      _BoundSubscriptionStream(stream, transformer) {
        this[_stream] = stream;
        this[_transformer] = transformer;
        super.Stream();
      }
      listen(onData, opts) {
        dart.as(onData, dart.functionType(dart.void, [T]));
        let onError = opts && 'onError' in opts ? opts.onError : null;
        let onDone = opts && 'onDone' in opts ? opts.onDone : null;
        dart.as(onDone, dart.functionType(dart.void, []));
        let cancelOnError = opts && 'cancelOnError' in opts ? opts.cancelOnError : null;
        cancelOnError = core.identical(true, cancelOnError);
        let result = this[_transformer](this[_stream], cancelOnError);
        result.onData(onData);
        result.onError(onError);
        result.onDone(onDone);
        return result;
      }
    }
    dart.setSignature(_BoundSubscriptionStream, {
      constructors: () => ({_BoundSubscriptionStream: [async._BoundSubscriptionStream$(S, T), [async.Stream$(S), async._SubscriptionTransformer$(S, T)]]}),
      methods: () => ({listen: [async.StreamSubscription$(T), [dart.functionType(dart.void, [T])], {onError: core.Function, onDone: dart.functionType(dart.void, []), cancelOnError: core.bool}]})
    });
    return _BoundSubscriptionStream;
  });
  async._BoundSubscriptionStream = async._BoundSubscriptionStream$();
  async.Timer = class Timer extends core.Object {
    static new(duration, callback) {
      if (dart.equals(async.Zone.current, async.Zone.ROOT)) {
        return async.Zone.current.createTimer(duration, callback);
      }
      return async.Zone.current.createTimer(duration, async.Zone.current.bindCallback(dart.dynamic)(callback, {runGuarded: true}));
    }
    static periodic(duration, callback) {
      if (dart.equals(async.Zone.current, async.Zone.ROOT)) {
        return async.Zone.current.createPeriodicTimer(duration, callback);
      }
      let boundCallback = async.Zone.current.bindUnaryCallback(dart.dynamic, async.Timer)(callback, {runGuarded: true});
      return async.Zone.current.createPeriodicTimer(duration, boundCallback);
    }
    static run(callback) {
      async.Timer.new(core.Duration.ZERO, callback);
    }
    static _createTimer(duration, callback) {
      let milliseconds = duration.inMilliseconds;
      if (dart.notNull(milliseconds) < 0) milliseconds = 0;
      return new _isolate_helper.TimerImpl(milliseconds, callback);
    }
    static _createPeriodicTimer(duration, callback) {
      let milliseconds = duration.inMilliseconds;
      if (dart.notNull(milliseconds) < 0) milliseconds = 0;
      return new _isolate_helper.TimerImpl.periodic(milliseconds, callback);
    }
  };
  dart.setSignature(async.Timer, {
    constructors: () => ({
      new: [async.Timer, [core.Duration, dart.functionType(dart.void, [])]],
      periodic: [async.Timer, [core.Duration, dart.functionType(dart.void, [async.Timer])]]
    }),
    statics: () => ({
      run: [dart.void, [dart.functionType(dart.void, [])]],
      _createTimer: [async.Timer, [core.Duration, dart.functionType(dart.void, [])]],
      _createPeriodicTimer: [async.Timer, [core.Duration, dart.functionType(dart.void, [async.Timer])]]
    }),
    names: ['run', '_createTimer', '_createPeriodicTimer']
  });
  async.ZoneCallback$ = dart.generic(R => {
    const ZoneCallback = dart.typedef('ZoneCallback', () => dart.functionType(R, []));
    return ZoneCallback;
  });
  async.ZoneCallback = async.ZoneCallback$();
  async.ZoneUnaryCallback$ = dart.generic((R, T) => {
    const ZoneUnaryCallback = dart.typedef('ZoneUnaryCallback', () => dart.functionType(R, [T]));
    return ZoneUnaryCallback;
  });
  async.ZoneUnaryCallback = async.ZoneUnaryCallback$();
  async.ZoneBinaryCallback$ = dart.generic((R, T1, T2) => {
    const ZoneBinaryCallback = dart.typedef('ZoneBinaryCallback', () => dart.functionType(R, [T1, T2]));
    return ZoneBinaryCallback;
  });
  async.ZoneBinaryCallback = async.ZoneBinaryCallback$();
  async.HandleUncaughtErrorHandler$ = dart.generic(R => {
    const HandleUncaughtErrorHandler = dart.typedef('HandleUncaughtErrorHandler', () => dart.functionType(R, [async.Zone, async.ZoneDelegate, async.Zone, dart.dynamic, core.StackTrace]));
    return HandleUncaughtErrorHandler;
  });
  async.HandleUncaughtErrorHandler = async.HandleUncaughtErrorHandler$();
  async.RunHandler$ = dart.generic(R => {
    const RunHandler = dart.typedef('RunHandler', () => dart.functionType(R, [async.Zone, async.ZoneDelegate, async.Zone, dart.functionType(R, [])]));
    return RunHandler;
  });
  async.RunHandler = async.RunHandler$();
  async.RunUnaryHandler$ = dart.generic((R, T) => {
    const RunUnaryHandler = dart.typedef('RunUnaryHandler', () => dart.functionType(R, [async.Zone, async.ZoneDelegate, async.Zone, dart.functionType(R, [T]), T]));
    return RunUnaryHandler;
  });
  async.RunUnaryHandler = async.RunUnaryHandler$();
  async.RunBinaryHandler$ = dart.generic((R, T1, T2) => {
    const RunBinaryHandler = dart.typedef('RunBinaryHandler', () => dart.functionType(R, [async.Zone, async.ZoneDelegate, async.Zone, dart.functionType(R, [T1, T2]), T1, T2]));
    return RunBinaryHandler;
  });
  async.RunBinaryHandler = async.RunBinaryHandler$();
  async.RegisterCallbackHandler$ = dart.generic(R => {
    const RegisterCallbackHandler = dart.typedef('RegisterCallbackHandler', () => dart.functionType(async.ZoneCallback$(R), [async.Zone, async.ZoneDelegate, async.Zone, dart.functionType(R, [])]));
    return RegisterCallbackHandler;
  });
  async.RegisterCallbackHandler = async.RegisterCallbackHandler$();
  async.RegisterUnaryCallbackHandler$ = dart.generic((R, T) => {
    const RegisterUnaryCallbackHandler = dart.typedef('RegisterUnaryCallbackHandler', () => dart.functionType(async.ZoneUnaryCallback$(R, T), [async.Zone, async.ZoneDelegate, async.Zone, dart.functionType(R, [T])]));
    return RegisterUnaryCallbackHandler;
  });
  async.RegisterUnaryCallbackHandler = async.RegisterUnaryCallbackHandler$();
  async.RegisterBinaryCallbackHandler$ = dart.generic((R, T1, T2) => {
    const RegisterBinaryCallbackHandler = dart.typedef('RegisterBinaryCallbackHandler', () => dart.functionType(async.ZoneBinaryCallback$(R, T1, T2), [async.Zone, async.ZoneDelegate, async.Zone, dart.functionType(R, [T1, T2])]));
    return RegisterBinaryCallbackHandler;
  });
  async.RegisterBinaryCallbackHandler = async.RegisterBinaryCallbackHandler$();
  async.ErrorCallbackHandler = dart.typedef('ErrorCallbackHandler', () => dart.functionType(async.AsyncError, [async.Zone, async.ZoneDelegate, async.Zone, core.Object, core.StackTrace]));
  async.ScheduleMicrotaskHandler = dart.typedef('ScheduleMicrotaskHandler', () => dart.functionType(dart.void, [async.Zone, async.ZoneDelegate, async.Zone, dart.functionType(dart.void, [])]));
  async.CreateTimerHandler = dart.typedef('CreateTimerHandler', () => dart.functionType(async.Timer, [async.Zone, async.ZoneDelegate, async.Zone, core.Duration, dart.functionType(dart.void, [])]));
  async.CreatePeriodicTimerHandler = dart.typedef('CreatePeriodicTimerHandler', () => dart.functionType(async.Timer, [async.Zone, async.ZoneDelegate, async.Zone, core.Duration, dart.functionType(dart.void, [async.Timer])]));
  async.PrintHandler = dart.typedef('PrintHandler', () => dart.functionType(dart.void, [async.Zone, async.ZoneDelegate, async.Zone, core.String]));
  async.ForkHandler = dart.typedef('ForkHandler', () => dart.functionType(async.Zone, [async.Zone, async.ZoneDelegate, async.Zone, async.ZoneSpecification, core.Map]));
  async._ZoneFunction$ = dart.generic(T => {
    class _ZoneFunction extends core.Object {
      _ZoneFunction(zone, func) {
        this.zone = zone;
        this.function = func;
      }
    }
    dart.setSignature(_ZoneFunction, {
      constructors: () => ({_ZoneFunction: [async._ZoneFunction$(T), [async._Zone, T]]})
    });
    return _ZoneFunction;
  });
  async._ZoneFunction = async._ZoneFunction$();
  async.ZoneSpecification = class ZoneSpecification extends core.Object {
    static new(opts) {
      return new async._ZoneSpecification(opts);
    }
    static from(other, opts) {
      let handleUncaughtError = opts && 'handleUncaughtError' in opts ? opts.handleUncaughtError : null;
      let run = opts && 'run' in opts ? opts.run : null;
      let runUnary = opts && 'runUnary' in opts ? opts.runUnary : null;
      let runBinary = opts && 'runBinary' in opts ? opts.runBinary : null;
      let registerCallback = opts && 'registerCallback' in opts ? opts.registerCallback : null;
      let registerUnaryCallback = opts && 'registerUnaryCallback' in opts ? opts.registerUnaryCallback : null;
      let registerBinaryCallback = opts && 'registerBinaryCallback' in opts ? opts.registerBinaryCallback : null;
      let errorCallback = opts && 'errorCallback' in opts ? opts.errorCallback : null;
      let scheduleMicrotask = opts && 'scheduleMicrotask' in opts ? opts.scheduleMicrotask : null;
      let createTimer = opts && 'createTimer' in opts ? opts.createTimer : null;
      let createPeriodicTimer = opts && 'createPeriodicTimer' in opts ? opts.createPeriodicTimer : null;
      let print = opts && 'print' in opts ? opts.print : null;
      let fork = opts && 'fork' in opts ? opts.fork : null;
      return async.ZoneSpecification.new({handleUncaughtError: (handleUncaughtError != null ? handleUncaughtError : other.handleUncaughtError), run: (run != null ? run : other.run), runUnary: (runUnary != null ? runUnary : other.runUnary), runBinary: (runBinary != null ? runBinary : other.runBinary), registerCallback: (registerCallback != null ? registerCallback : other.registerCallback), registerUnaryCallback: (registerUnaryCallback != null ? registerUnaryCallback : other.registerUnaryCallback), registerBinaryCallback: (registerBinaryCallback != null ? registerBinaryCallback : other.registerBinaryCallback), errorCallback: (errorCallback != null ? errorCallback : other.errorCallback), scheduleMicrotask: (scheduleMicrotask != null ? scheduleMicrotask : other.scheduleMicrotask), createTimer: (createTimer != null ? createTimer : other.createTimer), createPeriodicTimer: (createPeriodicTimer != null ? createPeriodicTimer : other.createPeriodicTimer), print: (print != null ? print : other.print), fork: (fork != null ? fork : other.fork)});
    }
  };
  dart.setSignature(async.ZoneSpecification, {
    constructors: () => ({
      new: [async.ZoneSpecification, [], {handleUncaughtError: async.HandleUncaughtErrorHandler, run: async.RunHandler, runUnary: async.RunUnaryHandler, runBinary: async.RunBinaryHandler, registerCallback: async.RegisterCallbackHandler, registerUnaryCallback: async.RegisterUnaryCallbackHandler, registerBinaryCallback: async.RegisterBinaryCallbackHandler, errorCallback: async.ErrorCallbackHandler, scheduleMicrotask: async.ScheduleMicrotaskHandler, createTimer: async.CreateTimerHandler, createPeriodicTimer: async.CreatePeriodicTimerHandler, print: async.PrintHandler, fork: async.ForkHandler}],
      from: [async.ZoneSpecification, [async.ZoneSpecification], {handleUncaughtError: async.HandleUncaughtErrorHandler, run: async.RunHandler, runUnary: async.RunUnaryHandler, runBinary: async.RunBinaryHandler, registerCallback: async.RegisterCallbackHandler, registerUnaryCallback: async.RegisterUnaryCallbackHandler, registerBinaryCallback: async.RegisterBinaryCallbackHandler, errorCallback: async.ErrorCallbackHandler, scheduleMicrotask: async.ScheduleMicrotaskHandler, createTimer: async.CreateTimerHandler, createPeriodicTimer: async.CreatePeriodicTimerHandler, print: async.PrintHandler, fork: async.ForkHandler}]
    })
  });
  async._ZoneSpecification = class _ZoneSpecification extends core.Object {
    _ZoneSpecification(opts) {
      let handleUncaughtError = opts && 'handleUncaughtError' in opts ? opts.handleUncaughtError : null;
      let run = opts && 'run' in opts ? opts.run : null;
      let runUnary = opts && 'runUnary' in opts ? opts.runUnary : null;
      let runBinary = opts && 'runBinary' in opts ? opts.runBinary : null;
      let registerCallback = opts && 'registerCallback' in opts ? opts.registerCallback : null;
      let registerUnaryCallback = opts && 'registerUnaryCallback' in opts ? opts.registerUnaryCallback : null;
      let registerBinaryCallback = opts && 'registerBinaryCallback' in opts ? opts.registerBinaryCallback : null;
      let errorCallback = opts && 'errorCallback' in opts ? opts.errorCallback : null;
      let scheduleMicrotask = opts && 'scheduleMicrotask' in opts ? opts.scheduleMicrotask : null;
      let createTimer = opts && 'createTimer' in opts ? opts.createTimer : null;
      let createPeriodicTimer = opts && 'createPeriodicTimer' in opts ? opts.createPeriodicTimer : null;
      let print = opts && 'print' in opts ? opts.print : null;
      let fork = opts && 'fork' in opts ? opts.fork : null;
      this.handleUncaughtError = handleUncaughtError;
      this.run = run;
      this.runUnary = runUnary;
      this.runBinary = runBinary;
      this.registerCallback = registerCallback;
      this.registerUnaryCallback = registerUnaryCallback;
      this.registerBinaryCallback = registerBinaryCallback;
      this.errorCallback = errorCallback;
      this.scheduleMicrotask = scheduleMicrotask;
      this.createTimer = createTimer;
      this.createPeriodicTimer = createPeriodicTimer;
      this.print = print;
      this.fork = fork;
    }
  };
  async._ZoneSpecification[dart.implements] = () => [async.ZoneSpecification];
  dart.setSignature(async._ZoneSpecification, {
    constructors: () => ({_ZoneSpecification: [async._ZoneSpecification, [], {handleUncaughtError: async.HandleUncaughtErrorHandler, run: async.RunHandler, runUnary: async.RunUnaryHandler, runBinary: async.RunBinaryHandler, registerCallback: async.RegisterCallbackHandler, registerUnaryCallback: async.RegisterUnaryCallbackHandler, registerBinaryCallback: async.RegisterBinaryCallbackHandler, errorCallback: async.ErrorCallbackHandler, scheduleMicrotask: async.ScheduleMicrotaskHandler, createTimer: async.CreateTimerHandler, createPeriodicTimer: async.CreatePeriodicTimerHandler, print: async.PrintHandler, fork: async.ForkHandler}]})
  });
  async.ZoneDelegate = class ZoneDelegate extends core.Object {};
  async.Zone = class Zone extends core.Object {
    _() {
    }
    static get current() {
      return async.Zone._current;
    }
    static _enter(zone) {
      dart.assert(zone != null);
      dart.assert(!core.identical(zone, async.Zone._current));
      let previous = async.Zone._current;
      async.Zone._current = zone;
      return previous;
    }
    static _leave(previous) {
      dart.assert(previous != null);
      async.Zone._current = previous;
    }
  };
  dart.defineNamedConstructor(async.Zone, '_');
  dart.setSignature(async.Zone, {
    constructors: () => ({_: [async.Zone, []]}),
    statics: () => ({
      _enter: [async.Zone, [async.Zone]],
      _leave: [dart.void, [async.Zone]]
    }),
    names: ['_enter', '_leave']
  });
  dart.defineLazy(async.Zone, {
    get ROOT() {
      return async._ROOT_ZONE;
    },
    get _current() {
      return async._ROOT_ZONE;
    },
    set _current(_) {}
  });
  const _delegate = Symbol('_delegate');
  async._parentDelegate = function(zone) {
    if (zone.parent == null) return null;
    return zone.parent[_delegate];
  };
  dart.lazyFn(async._parentDelegate, () => [async.ZoneDelegate, [async._Zone]]);
  const _delegationTarget = Symbol('_delegationTarget');
  const _handleUncaughtError = Symbol('_handleUncaughtError');
  const _run = Symbol('_run');
  const _runUnary = Symbol('_runUnary');
  const _runBinary = Symbol('_runBinary');
  const _registerCallback = Symbol('_registerCallback');
  const _registerUnaryCallback = Symbol('_registerUnaryCallback');
  const _registerBinaryCallback = Symbol('_registerBinaryCallback');
  const _errorCallback = Symbol('_errorCallback');
  const _createTimer = Symbol('_createTimer');
  const _createPeriodicTimer = Symbol('_createPeriodicTimer');
  const _print = Symbol('_print');
  const _fork = Symbol('_fork');
  async._ZoneDelegate = class _ZoneDelegate extends core.Object {
    _ZoneDelegate(delegationTarget) {
      this[_delegationTarget] = delegationTarget;
    }
    handleUncaughtError(R) {
      return (zone, error, stackTrace) => {
        let implementation = this[_delegationTarget][_handleUncaughtError];
        let implZone = implementation.zone;
        let handler = implementation.function;
        return dart.as(dart.dcall(handler, implZone, async._parentDelegate(implZone), zone, error, stackTrace), R);
      };
    }
    run(R) {
      return (zone, f) => {
        let implementation = this[_delegationTarget][_run];
        let implZone = implementation.zone;
        let handler = implementation.function;
        return dart.as(handler(implZone, async._parentDelegate(implZone), zone, f), R);
      };
    }
    runUnary(R, T) {
      return (zone, f, arg) => {
        let implementation = this[_delegationTarget][_runUnary];
        let implZone = implementation.zone;
        let handler = implementation.function;
        return dart.as(dart.dcall(handler, implZone, async._parentDelegate(implZone), zone, f, arg), R);
      };
    }
    runBinary(R, T1, T2) {
      return (zone, f, arg1, arg2) => {
        let implementation = this[_delegationTarget][_runBinary];
        let implZone = implementation.zone;
        let handler = implementation.function;
        return dart.as(dart.dcall(handler, implZone, async._parentDelegate(implZone), zone, f, arg1, arg2), R);
      };
    }
    registerCallback(R) {
      return (zone, f) => {
        let implementation = this[_delegationTarget][_registerCallback];
        let implZone = implementation.zone;
        let handler = implementation.function;
        return dart.as(handler(implZone, async._parentDelegate(implZone), zone, f), async.ZoneCallback$(R));
      };
    }
    registerUnaryCallback(R, T) {
      return (zone, f) => {
        let implementation = this[_delegationTarget][_registerUnaryCallback];
        let implZone = implementation.zone;
        let handler = implementation.function;
        return dart.as(handler(implZone, async._parentDelegate(implZone), zone, f), async.ZoneUnaryCallback$(R, T));
      };
    }
    registerBinaryCallback(R, T1, T2) {
      return (zone, f) => {
        let implementation = this[_delegationTarget][_registerBinaryCallback];
        let implZone = implementation.zone;
        let handler = implementation.function;
        return dart.as(handler(implZone, async._parentDelegate(implZone), zone, f), async.ZoneBinaryCallback$(R, T1, T2));
      };
    }
    errorCallback(zone, error, stackTrace) {
      let implementation = this[_delegationTarget][_errorCallback];
      let implZone = implementation.zone;
      if (core.identical(implZone, async._ROOT_ZONE)) return null;
      let handler = implementation.function;
      return handler(implZone, async._parentDelegate(implZone), zone, error, stackTrace);
    }
    scheduleMicrotask(zone, f) {
      let implementation = this[_delegationTarget][_scheduleMicrotask];
      let implZone = implementation.zone;
      let handler = implementation.function;
      handler(implZone, async._parentDelegate(implZone), zone, f);
    }
    createTimer(zone, duration, f) {
      let implementation = this[_delegationTarget][_createTimer];
      let implZone = implementation.zone;
      let handler = implementation.function;
      return handler(implZone, async._parentDelegate(implZone), zone, duration, f);
    }
    createPeriodicTimer(zone, period, f) {
      let implementation = this[_delegationTarget][_createPeriodicTimer];
      let implZone = implementation.zone;
      let handler = implementation.function;
      return handler(implZone, async._parentDelegate(implZone), zone, period, f);
    }
    print(zone, line) {
      let implementation = this[_delegationTarget][_print];
      let implZone = implementation.zone;
      let handler = implementation.function;
      handler(implZone, async._parentDelegate(implZone), zone, line);
    }
    fork(zone, specification, zoneValues) {
      let implementation = this[_delegationTarget][_fork];
      let implZone = implementation.zone;
      let handler = implementation.function;
      return handler(implZone, async._parentDelegate(implZone), zone, specification, zoneValues);
    }
  };
  async._ZoneDelegate[dart.implements] = () => [async.ZoneDelegate];
  dart.setSignature(async._ZoneDelegate, {
    constructors: () => ({_ZoneDelegate: [async._ZoneDelegate, [async._Zone]]}),
    methods: () => ({
      handleUncaughtError: [R => [R, [async.Zone, dart.dynamic, core.StackTrace]]],
      run: [R => [R, [async.Zone, dart.functionType(R, [])]]],
      runUnary: [(R, T) => [R, [async.Zone, dart.functionType(R, [T]), T]]],
      runBinary: [(R, T1, T2) => [R, [async.Zone, dart.functionType(R, [T1, T2]), T1, T2]]],
      registerCallback: [R => [async.ZoneCallback$(R), [async.Zone, dart.functionType(R, [])]]],
      registerUnaryCallback: [(R, T) => [async.ZoneUnaryCallback$(R, T), [async.Zone, dart.functionType(R, [T])]]],
      registerBinaryCallback: [(R, T1, T2) => [async.ZoneBinaryCallback$(R, T1, T2), [async.Zone, dart.functionType(R, [T1, T2])]]],
      errorCallback: [async.AsyncError, [async.Zone, core.Object, core.StackTrace]],
      scheduleMicrotask: [dart.void, [async.Zone, dart.functionType(dart.dynamic, [])]],
      createTimer: [async.Timer, [async.Zone, core.Duration, dart.functionType(dart.void, [])]],
      createPeriodicTimer: [async.Timer, [async.Zone, core.Duration, dart.functionType(dart.void, [async.Timer])]],
      print: [dart.void, [async.Zone, core.String]],
      fork: [async.Zone, [async.Zone, async.ZoneSpecification, core.Map]]
    })
  });
  const _map$ = Symbol('_map');
  async._Zone = class _Zone extends core.Object {
    _Zone() {
    }
    inSameErrorZone(otherZone) {
      return core.identical(this, otherZone) || core.identical(this.errorZone, otherZone.errorZone);
    }
  };
  async._Zone[dart.implements] = () => [async.Zone];
  dart.setSignature(async._Zone, {
    constructors: () => ({_Zone: [async._Zone, []]}),
    methods: () => ({inSameErrorZone: [core.bool, [async.Zone]]})
  });
  const _delegateCache = Symbol('_delegateCache');
  async._CustomZone = class _CustomZone extends async._Zone {
    get [_delegate]() {
      if (this[_delegateCache] != null) return this[_delegateCache];
      this[_delegateCache] = new async._ZoneDelegate(this);
      return this[_delegateCache];
    }
    _CustomZone(parent, specification, map) {
      this.parent = parent;
      this[_map$] = map;
      this[_run] = null;
      this[_runUnary] = null;
      this[_runBinary] = null;
      this[_registerCallback] = null;
      this[_registerUnaryCallback] = null;
      this[_registerBinaryCallback] = null;
      this[_errorCallback] = null;
      this[_scheduleMicrotask] = null;
      this[_createTimer] = null;
      this[_createPeriodicTimer] = null;
      this[_print] = null;
      this[_fork] = null;
      this[_handleUncaughtError] = null;
      this[_delegateCache] = null;
      super._Zone();
      this[_run] = specification.run != null ? new (async._ZoneFunction$(async.RunHandler))(this, specification.run) : this.parent[_run];
      this[_runUnary] = specification.runUnary != null ? new (async._ZoneFunction$(async.RunUnaryHandler))(this, specification.runUnary) : this.parent[_runUnary];
      this[_runBinary] = specification.runBinary != null ? new (async._ZoneFunction$(async.RunBinaryHandler))(this, specification.runBinary) : this.parent[_runBinary];
      this[_registerCallback] = specification.registerCallback != null ? new (async._ZoneFunction$(async.RegisterCallbackHandler))(this, specification.registerCallback) : this.parent[_registerCallback];
      this[_registerUnaryCallback] = specification.registerUnaryCallback != null ? new (async._ZoneFunction$(async.RegisterUnaryCallbackHandler))(this, specification.registerUnaryCallback) : this.parent[_registerUnaryCallback];
      this[_registerBinaryCallback] = specification.registerBinaryCallback != null ? new (async._ZoneFunction$(async.RegisterBinaryCallbackHandler))(this, specification.registerBinaryCallback) : this.parent[_registerBinaryCallback];
      this[_errorCallback] = specification.errorCallback != null ? new (async._ZoneFunction$(async.ErrorCallbackHandler))(this, specification.errorCallback) : this.parent[_errorCallback];
      this[_scheduleMicrotask] = specification.scheduleMicrotask != null ? new (async._ZoneFunction$(async.ScheduleMicrotaskHandler))(this, specification.scheduleMicrotask) : this.parent[_scheduleMicrotask];
      this[_createTimer] = specification.createTimer != null ? new (async._ZoneFunction$(async.CreateTimerHandler))(this, specification.createTimer) : this.parent[_createTimer];
      this[_createPeriodicTimer] = specification.createPeriodicTimer != null ? new (async._ZoneFunction$(async.CreatePeriodicTimerHandler))(this, specification.createPeriodicTimer) : this.parent[_createPeriodicTimer];
      this[_print] = specification.print != null ? new (async._ZoneFunction$(async.PrintHandler))(this, specification.print) : this.parent[_print];
      this[_fork] = specification.fork != null ? new (async._ZoneFunction$(async.ForkHandler))(this, specification.fork) : this.parent[_fork];
      this[_handleUncaughtError] = specification.handleUncaughtError != null ? new (async._ZoneFunction$(async.HandleUncaughtErrorHandler))(this, specification.handleUncaughtError) : this.parent[_handleUncaughtError];
    }
    get errorZone() {
      return this[_handleUncaughtError].zone;
    }
    runGuarded(R) {
      return f => {
        try {
          return this.run(R)(f);
        } catch (e) {
          let s = dart.stackTrace(e);
          return this.handleUncaughtError(R)(e, s);
        }

      };
    }
    runUnaryGuarded(R, T) {
      return (f, arg) => {
        try {
          return this.runUnary(R, T)(f, arg);
        } catch (e) {
          let s = dart.stackTrace(e);
          return this.handleUncaughtError(R)(e, s);
        }

      };
    }
    runBinaryGuarded(R, T1, T2) {
      return (f, arg1, arg2) => {
        try {
          return this.runBinary(R, T1, T2)(f, arg1, arg2);
        } catch (e) {
          let s = dart.stackTrace(e);
          return this.handleUncaughtError(R)(e, s);
        }

      };
    }
    bindCallback(R) {
      return (f, opts) => {
        let runGuarded = opts && 'runGuarded' in opts ? opts.runGuarded : true;
        let registered = this.registerCallback(R)(f);
        if (dart.notNull(runGuarded)) {
          return dart.fn(() => this.runGuarded(R)(registered), R, []);
        } else {
          return dart.fn(() => this.run(R)(registered), R, []);
        }
      };
    }
    bindUnaryCallback(R, T) {
      return (f, opts) => {
        let runGuarded = opts && 'runGuarded' in opts ? opts.runGuarded : true;
        let registered = this.registerUnaryCallback(R, T)(f);
        if (dart.notNull(runGuarded)) {
          return dart.fn(arg => this.runUnaryGuarded(R, T)(registered, arg), R, [T]);
        } else {
          return dart.fn(arg => this.runUnary(R, T)(registered, arg), R, [T]);
        }
      };
    }
    bindBinaryCallback(R, T1, T2) {
      return (f, opts) => {
        let runGuarded = opts && 'runGuarded' in opts ? opts.runGuarded : true;
        let registered = this.registerBinaryCallback(R, T1, T2)(f);
        if (dart.notNull(runGuarded)) {
          return dart.fn((arg1, arg2) => this.runBinaryGuarded(R, T1, T2)(registered, arg1, arg2), R, [T1, T2]);
        } else {
          return dart.fn((arg1, arg2) => this.runBinary(R, T1, T2)(registered, arg1, arg2), R, [T1, T2]);
        }
      };
    }
    get(key) {
      let result = this[_map$][dartx.get](key);
      if (result != null || dart.notNull(this[_map$][dartx.containsKey](key))) return result;
      if (this.parent != null) {
        let value = this.parent.get(key);
        if (value != null) {
          this[_map$][dartx.set](key, value);
        }
        return value;
      }
      dart.assert(dart.equals(this, async._ROOT_ZONE));
      return null;
    }
    handleUncaughtError(R) {
      return (error, stackTrace) => {
        let implementation = this[_handleUncaughtError];
        dart.assert(implementation != null);
        let parentDelegate = async._parentDelegate(implementation.zone);
        let handler = implementation.function;
        return dart.as(dart.dcall(handler, implementation.zone, parentDelegate, this, error, stackTrace), R);
      };
    }
    fork(opts) {
      let specification = opts && 'specification' in opts ? opts.specification : null;
      let zoneValues = opts && 'zoneValues' in opts ? opts.zoneValues : null;
      let implementation = this[_fork];
      dart.assert(implementation != null);
      let parentDelegate = async._parentDelegate(implementation.zone);
      let handler = implementation.function;
      return handler(implementation.zone, parentDelegate, this, specification, zoneValues);
    }
    run(R) {
      return f => {
        let implementation = this[_run];
        dart.assert(implementation != null);
        let parentDelegate = async._parentDelegate(implementation.zone);
        let handler = implementation.function;
        return dart.as(handler(implementation.zone, parentDelegate, this, f), R);
      };
    }
    runUnary(R, T) {
      return (f, arg) => {
        let implementation = this[_runUnary];
        dart.assert(implementation != null);
        let parentDelegate = async._parentDelegate(implementation.zone);
        let handler = implementation.function;
        return dart.as(dart.dcall(handler, implementation.zone, parentDelegate, this, f, arg), R);
      };
    }
    runBinary(R, T1, T2) {
      return (f, arg1, arg2) => {
        let implementation = this[_runBinary];
        dart.assert(implementation != null);
        let parentDelegate = async._parentDelegate(implementation.zone);
        let handler = implementation.function;
        return dart.as(dart.dcall(handler, implementation.zone, parentDelegate, this, f, arg1, arg2), R);
      };
    }
    registerCallback(R) {
      return callback => {
        let implementation = this[_registerCallback];
        dart.assert(implementation != null);
        let parentDelegate = async._parentDelegate(implementation.zone);
        let handler = implementation.function;
        return dart.as(handler(implementation.zone, parentDelegate, this, callback), async.ZoneCallback$(R));
      };
    }
    registerUnaryCallback(R, T) {
      return callback => {
        let implementation = this[_registerUnaryCallback];
        dart.assert(implementation != null);
        let parentDelegate = async._parentDelegate(implementation.zone);
        let handler = implementation.function;
        return dart.as(handler(implementation.zone, parentDelegate, this, callback), async.ZoneUnaryCallback$(R, T));
      };
    }
    registerBinaryCallback(R, T1, T2) {
      return callback => {
        let implementation = this[_registerBinaryCallback];
        dart.assert(implementation != null);
        let parentDelegate = async._parentDelegate(implementation.zone);
        let handler = implementation.function;
        return dart.as(handler(implementation.zone, parentDelegate, this, callback), async.ZoneBinaryCallback$(R, T1, T2));
      };
    }
    errorCallback(error, stackTrace) {
      let implementation = this[_errorCallback];
      dart.assert(implementation != null);
      let implementationZone = implementation.zone;
      if (core.identical(implementationZone, async._ROOT_ZONE)) return null;
      let parentDelegate = async._parentDelegate(dart.as(implementationZone, async._Zone));
      let handler = implementation.function;
      return handler(implementationZone, parentDelegate, this, error, stackTrace);
    }
    scheduleMicrotask(f) {
      let implementation = this[_scheduleMicrotask];
      dart.assert(implementation != null);
      let parentDelegate = async._parentDelegate(implementation.zone);
      let handler = implementation.function;
      return handler(implementation.zone, parentDelegate, this, f);
    }
    createTimer(duration, f) {
      let implementation = this[_createTimer];
      dart.assert(implementation != null);
      let parentDelegate = async._parentDelegate(implementation.zone);
      let handler = implementation.function;
      return handler(implementation.zone, parentDelegate, this, duration, f);
    }
    createPeriodicTimer(duration, f) {
      let implementation = this[_createPeriodicTimer];
      dart.assert(implementation != null);
      let parentDelegate = async._parentDelegate(implementation.zone);
      let handler = implementation.function;
      return handler(implementation.zone, parentDelegate, this, duration, f);
    }
    print(line) {
      let implementation = this[_print];
      dart.assert(implementation != null);
      let parentDelegate = async._parentDelegate(implementation.zone);
      let handler = implementation.function;
      return handler(implementation.zone, parentDelegate, this, line);
    }
  };
  dart.setSignature(async._CustomZone, {
    constructors: () => ({_CustomZone: [async._CustomZone, [async._Zone, async.ZoneSpecification, core.Map]]}),
    methods: () => ({
      runGuarded: [R => [R, [dart.functionType(R, [])]]],
      runUnaryGuarded: [(R, T) => [R, [dart.functionType(R, [T]), T]]],
      runBinaryGuarded: [(R, T1, T2) => [R, [dart.functionType(R, [T1, T2]), T1, T2]]],
      bindCallback: [R => [async.ZoneCallback$(R), [dart.functionType(R, [])], {runGuarded: core.bool}]],
      bindUnaryCallback: [(R, T) => [async.ZoneUnaryCallback$(R, T), [dart.functionType(R, [T])], {runGuarded: core.bool}]],
      bindBinaryCallback: [(R, T1, T2) => [async.ZoneBinaryCallback$(R, T1, T2), [dart.functionType(R, [T1, T2])], {runGuarded: core.bool}]],
      get: [dart.dynamic, [core.Object]],
      handleUncaughtError: [R => [R, [dart.dynamic, core.StackTrace]]],
      fork: [async.Zone, [], {specification: async.ZoneSpecification, zoneValues: core.Map}],
      run: [R => [R, [dart.functionType(R, [])]]],
      runUnary: [(R, T) => [R, [dart.functionType(R, [T]), T]]],
      runBinary: [(R, T1, T2) => [R, [dart.functionType(R, [T1, T2]), T1, T2]]],
      registerCallback: [R => [async.ZoneCallback$(R), [dart.functionType(R, [])]]],
      registerUnaryCallback: [(R, T) => [async.ZoneUnaryCallback$(R, T), [dart.functionType(R, [T])]]],
      registerBinaryCallback: [(R, T1, T2) => [async.ZoneBinaryCallback$(R, T1, T2), [dart.functionType(R, [T1, T2])]]],
      errorCallback: [async.AsyncError, [core.Object, core.StackTrace]],
      scheduleMicrotask: [dart.void, [dart.functionType(dart.void, [])]],
      createTimer: [async.Timer, [core.Duration, dart.functionType(dart.void, [])]],
      createPeriodicTimer: [async.Timer, [core.Duration, dart.functionType(dart.void, [async.Timer])]],
      print: [dart.void, [core.String]]
    })
  });
  async._rootHandleUncaughtError = function(R) {
    return (self, parent, zone, error, stackTrace) => {
      async._schedulePriorityAsyncCallback(dart.fn(() => {
        if (error == null) error = new core.NullThrownError();
        if (stackTrace == null) dart.throw(error);
        async._rethrow(error, stackTrace);
      }, dart.void, []));
    };
  };
  dart.lazyFn(async._rootHandleUncaughtError, () => [R => [R, [async.Zone, async.ZoneDelegate, async.Zone, dart.dynamic, core.StackTrace]]]);
  async._rethrow = function(error, stackTrace) {
    error.stack = dart.toString(stackTrace);
    throw error;
  };
  dart.lazyFn(async._rethrow, () => [dart.void, [core.Object, core.StackTrace]]);
  async._rootRun = function(R) {
    return (self, parent, zone, f) => {
      if (dart.equals(async.Zone._current, zone)) return f();
      let old = async.Zone._enter(zone);
      try {
        return f();
      } finally {
        async.Zone._leave(old);
      }
    };
  };
  dart.fn(async._rootRun, R => [R, [async.Zone, async.ZoneDelegate, async.Zone, dart.functionType(R, [])]]);
  async._rootRunUnary = function(R, T) {
    return (self, parent, zone, f, arg) => {
      if (dart.equals(async.Zone._current, zone)) return f(arg);
      let old = async.Zone._enter(zone);
      try {
        return f(arg);
      } finally {
        async.Zone._leave(old);
      }
    };
  };
  dart.fn(async._rootRunUnary, (R, T) => [R, [async.Zone, async.ZoneDelegate, async.Zone, dart.functionType(R, [T]), T]]);
  async._rootRunBinary = function(R, T1, T2) {
    return (self, parent, zone, f, arg1, arg2) => {
      if (dart.equals(async.Zone._current, zone)) return f(arg1, arg2);
      let old = async.Zone._enter(zone);
      try {
        return f(arg1, arg2);
      } finally {
        async.Zone._leave(old);
      }
    };
  };
  dart.fn(async._rootRunBinary, (R, T1, T2) => [R, [async.Zone, async.ZoneDelegate, async.Zone, dart.functionType(R, [T1, T2]), T1, T2]]);
  async._rootRegisterCallback = function(R) {
    return (self, parent, zone, f) => {
      return f;
    };
  };
  dart.fn(async._rootRegisterCallback, R => [async.ZoneCallback$(R), [async.Zone, async.ZoneDelegate, async.Zone, dart.functionType(R, [])]]);
  async._rootRegisterUnaryCallback = function(R, T) {
    return (self, parent, zone, f) => {
      return f;
    };
  };
  dart.fn(async._rootRegisterUnaryCallback, (R, T) => [async.ZoneUnaryCallback$(R, T), [async.Zone, async.ZoneDelegate, async.Zone, dart.functionType(R, [T])]]);
  async._rootRegisterBinaryCallback = function(R, T1, T2) {
    return (self, parent, zone, f) => {
      return f;
    };
  };
  dart.fn(async._rootRegisterBinaryCallback, (R, T1, T2) => [async.ZoneBinaryCallback$(R, T1, T2), [async.Zone, async.ZoneDelegate, async.Zone, dart.functionType(R, [T1, T2])]]);
  async._rootErrorCallback = function(self, parent, zone, error, stackTrace) {
    return null;
  };
  dart.lazyFn(async._rootErrorCallback, () => [async.AsyncError, [async.Zone, async.ZoneDelegate, async.Zone, core.Object, core.StackTrace]]);
  async._rootScheduleMicrotask = function(self, parent, zone, f) {
    if (!core.identical(async._ROOT_ZONE, zone)) {
      let hasErrorHandler = !dart.notNull(async._ROOT_ZONE.inSameErrorZone(zone));
      f = zone.bindCallback(dart.dynamic)(f, {runGuarded: hasErrorHandler});
      zone = async._ROOT_ZONE;
    }
    async._scheduleAsyncCallback(f);
  };
  dart.fn(async._rootScheduleMicrotask, dart.void, [async.Zone, async.ZoneDelegate, async.Zone, dart.functionType(dart.dynamic, [])]);
  async._rootCreateTimer = function(self, parent, zone, duration, callback) {
    if (!core.identical(async._ROOT_ZONE, zone)) {
      callback = zone.bindCallback(dart.dynamic)(callback);
    }
    return async.Timer._createTimer(duration, callback);
  };
  dart.lazyFn(async._rootCreateTimer, () => [async.Timer, [async.Zone, async.ZoneDelegate, async.Zone, core.Duration, dart.functionType(dart.void, [])]]);
  async._rootCreatePeriodicTimer = function(self, parent, zone, duration, callback) {
    if (!core.identical(async._ROOT_ZONE, zone)) {
      callback = zone.bindUnaryCallback(dart.dynamic, async.Timer)(callback);
    }
    return async.Timer._createPeriodicTimer(duration, callback);
  };
  dart.lazyFn(async._rootCreatePeriodicTimer, () => [async.Timer, [async.Zone, async.ZoneDelegate, async.Zone, core.Duration, dart.functionType(dart.void, [async.Timer])]]);
  async._rootPrint = function(self, parent, zone, line) {
    _internal.printToConsole(line);
  };
  dart.lazyFn(async._rootPrint, () => [dart.void, [async.Zone, async.ZoneDelegate, async.Zone, core.String]]);
  async._printToZone = function(line) {
    async.Zone.current.print(line);
  };
  dart.lazyFn(async._printToZone, () => [dart.void, [core.String]]);
  async._rootFork = function(self, parent, zone, specification, zoneValues) {
    _internal.printToZone = async._printToZone;
    if (specification == null) {
      specification = dart.const(async.ZoneSpecification.new());
    } else if (!dart.is(specification, async._ZoneSpecification)) {
      dart.throw(new core.ArgumentError("ZoneSpecifications must be instantiated" + " with the provided constructor."));
    }
    let valueMap = null;
    if (zoneValues == null) {
      if (dart.is(zone, async._Zone)) {
        valueMap = zone[_map$];
      } else {
        valueMap = collection.HashMap.new();
      }
    } else {
      valueMap = collection.HashMap.from(zoneValues);
    }
    return new async._CustomZone(dart.as(zone, async._Zone), specification, valueMap);
  };
  dart.lazyFn(async._rootFork, () => [async.Zone, [async.Zone, async.ZoneDelegate, async.Zone, async.ZoneSpecification, core.Map]]);
  async._RootZone = class _RootZone extends async._Zone {
    _RootZone() {
      super._Zone();
    }
    get [_run]() {
      return dart.const(new (async._ZoneFunction$(async.RunHandler))(async._ROOT_ZONE, dart.gbind(async._rootRun, dart.dynamic)));
    }
    get [_runUnary]() {
      return dart.const(new (async._ZoneFunction$(async.RunUnaryHandler))(async._ROOT_ZONE, dart.gbind(async._rootRunUnary, dart.dynamic, dart.dynamic)));
    }
    get [_runBinary]() {
      return dart.const(new (async._ZoneFunction$(async.RunBinaryHandler))(async._ROOT_ZONE, dart.gbind(async._rootRunBinary, dart.dynamic, dart.dynamic, dart.dynamic)));
    }
    get [_registerCallback]() {
      return dart.const(new (async._ZoneFunction$(async.RegisterCallbackHandler))(async._ROOT_ZONE, dart.gbind(async._rootRegisterCallback, dart.dynamic)));
    }
    get [_registerUnaryCallback]() {
      return dart.const(new (async._ZoneFunction$(async.RegisterUnaryCallbackHandler))(async._ROOT_ZONE, dart.gbind(async._rootRegisterUnaryCallback, dart.dynamic, dart.dynamic)));
    }
    get [_registerBinaryCallback]() {
      return dart.const(new (async._ZoneFunction$(async.RegisterBinaryCallbackHandler))(async._ROOT_ZONE, dart.gbind(async._rootRegisterBinaryCallback, dart.dynamic, dart.dynamic, dart.dynamic)));
    }
    get [_errorCallback]() {
      return dart.const(new (async._ZoneFunction$(async.ErrorCallbackHandler))(async._ROOT_ZONE, async._rootErrorCallback));
    }
    get [_scheduleMicrotask]() {
      return dart.const(new (async._ZoneFunction$(async.ScheduleMicrotaskHandler))(async._ROOT_ZONE, async._rootScheduleMicrotask));
    }
    get [_createTimer]() {
      return dart.const(new (async._ZoneFunction$(async.CreateTimerHandler))(async._ROOT_ZONE, async._rootCreateTimer));
    }
    get [_createPeriodicTimer]() {
      return dart.const(new (async._ZoneFunction$(async.CreatePeriodicTimerHandler))(async._ROOT_ZONE, async._rootCreatePeriodicTimer));
    }
    get [_print]() {
      return dart.const(new (async._ZoneFunction$(async.PrintHandler))(async._ROOT_ZONE, async._rootPrint));
    }
    get [_fork]() {
      return dart.const(new (async._ZoneFunction$(async.ForkHandler))(async._ROOT_ZONE, async._rootFork));
    }
    get [_handleUncaughtError]() {
      return dart.const(new (async._ZoneFunction$(async.HandleUncaughtErrorHandler))(async._ROOT_ZONE, dart.gbind(async._rootHandleUncaughtError, dart.dynamic)));
    }
    get parent() {
      return null;
    }
    get [_map$]() {
      return async._RootZone._rootMap;
    }
    get [_delegate]() {
      if (async._RootZone._rootDelegate != null) return async._RootZone._rootDelegate;
      return async._RootZone._rootDelegate = new async._ZoneDelegate(this);
    }
    get errorZone() {
      return this;
    }
    runGuarded(R) {
      return f => {
        try {
          if (core.identical(async._ROOT_ZONE, async.Zone._current)) {
            return f();
          }
          return async._rootRun(R)(null, null, this, f);
        } catch (e) {
          let s = dart.stackTrace(e);
          return this.handleUncaughtError(R)(e, s);
        }

      };
    }
    runUnaryGuarded(R, T) {
      return (f, arg) => {
        try {
          if (core.identical(async._ROOT_ZONE, async.Zone._current)) {
            return f(arg);
          }
          return async._rootRunUnary(R, T)(null, null, this, f, arg);
        } catch (e) {
          let s = dart.stackTrace(e);
          return this.handleUncaughtError(R)(e, s);
        }

      };
    }
    runBinaryGuarded(R, T1, T2) {
      return (f, arg1, arg2) => {
        try {
          if (core.identical(async._ROOT_ZONE, async.Zone._current)) {
            return f(arg1, arg2);
          }
          return async._rootRunBinary(R, T1, T2)(null, null, this, f, arg1, arg2);
        } catch (e) {
          let s = dart.stackTrace(e);
          return this.handleUncaughtError(R)(e, s);
        }

      };
    }
    bindCallback(R) {
      return (f, opts) => {
        let runGuarded = opts && 'runGuarded' in opts ? opts.runGuarded : true;
        if (dart.notNull(runGuarded)) {
          return dart.fn(() => this.runGuarded(R)(f), R, []);
        } else {
          return dart.fn(() => this.run(R)(f), R, []);
        }
      };
    }
    bindUnaryCallback(R, T) {
      return (f, opts) => {
        let runGuarded = opts && 'runGuarded' in opts ? opts.runGuarded : true;
        if (dart.notNull(runGuarded)) {
          return dart.fn(arg => this.runUnaryGuarded(R, T)(f, arg), R, [T]);
        } else {
          return dart.fn(arg => this.runUnary(R, T)(f, arg), R, [T]);
        }
      };
    }
    bindBinaryCallback(R, T1, T2) {
      return (f, opts) => {
        let runGuarded = opts && 'runGuarded' in opts ? opts.runGuarded : true;
        if (dart.notNull(runGuarded)) {
          return dart.fn((arg1, arg2) => this.runBinaryGuarded(R, T1, T2)(f, arg1, arg2), R, [T1, T2]);
        } else {
          return dart.fn((arg1, arg2) => this.runBinary(R, T1, T2)(f, arg1, arg2), R, [T1, T2]);
        }
      };
    }
    get(key) {
      return null;
    }
    handleUncaughtError(R) {
      return (error, stackTrace) => {
        return async._rootHandleUncaughtError(R)(null, null, this, error, stackTrace);
      };
    }
    fork(opts) {
      let specification = opts && 'specification' in opts ? opts.specification : null;
      let zoneValues = opts && 'zoneValues' in opts ? opts.zoneValues : null;
      return async._rootFork(null, null, this, specification, zoneValues);
    }
    run(R) {
      return f => {
        if (core.identical(async.Zone._current, async._ROOT_ZONE)) return f();
        return async._rootRun(R)(null, null, this, f);
      };
    }
    runUnary(R, T) {
      return (f, arg) => {
        if (core.identical(async.Zone._current, async._ROOT_ZONE)) return f(arg);
        return async._rootRunUnary(R, T)(null, null, this, f, arg);
      };
    }
    runBinary(R, T1, T2) {
      return (f, arg1, arg2) => {
        if (core.identical(async.Zone._current, async._ROOT_ZONE)) return f(arg1, arg2);
        return async._rootRunBinary(R, T1, T2)(null, null, this, f, arg1, arg2);
      };
    }
    registerCallback(R) {
      return f => {
        return f;
      };
    }
    registerUnaryCallback(R, T) {
      return f => {
        return f;
      };
    }
    registerBinaryCallback(R, T1, T2) {
      return f => {
        return f;
      };
    }
    errorCallback(error, stackTrace) {
      return null;
    }
    scheduleMicrotask(f) {
      async._rootScheduleMicrotask(null, null, this, f);
    }
    createTimer(duration, f) {
      return async.Timer._createTimer(duration, f);
    }
    createPeriodicTimer(duration, f) {
      return async.Timer._createPeriodicTimer(duration, f);
    }
    print(line) {
      _internal.printToConsole(line);
    }
  };
  dart.setSignature(async._RootZone, {
    constructors: () => ({_RootZone: [async._RootZone, []]}),
    methods: () => ({
      runGuarded: [R => [R, [dart.functionType(R, [])]]],
      runUnaryGuarded: [(R, T) => [R, [dart.functionType(R, [T]), T]]],
      runBinaryGuarded: [(R, T1, T2) => [R, [dart.functionType(R, [T1, T2]), T1, T2]]],
      bindCallback: [R => [async.ZoneCallback$(R), [dart.functionType(R, [])], {runGuarded: core.bool}]],
      bindUnaryCallback: [(R, T) => [async.ZoneUnaryCallback$(R, T), [dart.functionType(R, [T])], {runGuarded: core.bool}]],
      bindBinaryCallback: [(R, T1, T2) => [async.ZoneBinaryCallback$(R, T1, T2), [dart.functionType(R, [T1, T2])], {runGuarded: core.bool}]],
      get: [dart.dynamic, [core.Object]],
      handleUncaughtError: [R => [R, [dart.dynamic, core.StackTrace]]],
      fork: [async.Zone, [], {specification: async.ZoneSpecification, zoneValues: core.Map}],
      run: [R => [R, [dart.functionType(R, [])]]],
      runUnary: [(R, T) => [R, [dart.functionType(R, [T]), T]]],
      runBinary: [(R, T1, T2) => [R, [dart.functionType(R, [T1, T2]), T1, T2]]],
      registerCallback: [R => [async.ZoneCallback$(R), [dart.functionType(R, [])]]],
      registerUnaryCallback: [(R, T) => [async.ZoneUnaryCallback$(R, T), [dart.functionType(R, [T])]]],
      registerBinaryCallback: [(R, T1, T2) => [async.ZoneBinaryCallback$(R, T1, T2), [dart.functionType(R, [T1, T2])]]],
      errorCallback: [async.AsyncError, [core.Object, core.StackTrace]],
      scheduleMicrotask: [dart.void, [dart.functionType(dart.void, [])]],
      createTimer: [async.Timer, [core.Duration, dart.functionType(dart.void, [])]],
      createPeriodicTimer: [async.Timer, [core.Duration, dart.functionType(dart.void, [async.Timer])]],
      print: [dart.void, [core.String]]
    })
  });
  async._RootZone._rootDelegate = null;
  dart.defineLazy(async._RootZone, {
    get _rootMap() {
      return collection.HashMap.new();
    },
    set _rootMap(_) {}
  });
  async._ROOT_ZONE = dart.const(new async._RootZone());
  async.runZoned = function(R) {
    return (body, opts) => {
      let zoneValues = opts && 'zoneValues' in opts ? opts.zoneValues : null;
      let zoneSpecification = opts && 'zoneSpecification' in opts ? opts.zoneSpecification : null;
      let onError = opts && 'onError' in opts ? opts.onError : null;
      let errorHandler = null;
      if (onError != null) {
        errorHandler = dart.fn((self, parent, zone, error, stackTrace) => {
          try {
            if (dart.is(onError, async.ZoneBinaryCallback$(R, dart.dynamic, core.StackTrace))) {
              return self.parent.runBinary(R, dart.dynamic, core.StackTrace)(onError, error, stackTrace);
            }
            return self.parent.runUnary(dart.dynamic, dart.dynamic)(dart.as(onError, dart.functionType(dart.dynamic, [dart.dynamic])), error);
          } catch (e) {
            let s = dart.stackTrace(e);
            if (core.identical(e, error)) {
              return parent.handleUncaughtError(dart.dynamic)(zone, error, stackTrace);
            } else {
              return parent.handleUncaughtError(dart.dynamic)(zone, e, s);
            }
          }

        }, dart.dynamic, [async.Zone, async.ZoneDelegate, async.Zone, dart.dynamic, core.StackTrace]);
      }
      if (zoneSpecification == null) {
        zoneSpecification = async.ZoneSpecification.new({handleUncaughtError: errorHandler});
      } else if (errorHandler != null) {
        zoneSpecification = async.ZoneSpecification.from(zoneSpecification, {handleUncaughtError: errorHandler});
      }
      let zone = async.Zone.current.fork({specification: zoneSpecification, zoneValues: zoneValues});
      if (onError != null) {
        return zone.runGuarded(R)(body);
      } else {
        return zone.run(R)(body);
      }
    };
  };
  dart.lazyFn(async.runZoned, () => [R => [R, [dart.functionType(R, [])], {zoneValues: core.Map, zoneSpecification: async.ZoneSpecification, onError: core.Function}]]);
  const _length$1 = Symbol('_length');
  const _strings$ = Symbol('_strings');
  const _nums$ = Symbol('_nums');
  const _rest$ = Symbol('_rest');
  const _keys = Symbol('_keys');
  const _containsKey = Symbol('_containsKey');
  const _getBucket$ = Symbol('_getBucket');
  const _findBucketIndex = Symbol('_findBucketIndex');
  const _computeKeys = Symbol('_computeKeys');
  const _get = Symbol('_get');
  const _addHashTableEntry$ = Symbol('_addHashTableEntry');
  const _set = Symbol('_set');
  const _computeHashCode = Symbol('_computeHashCode');
  const _removeHashTableEntry$ = Symbol('_removeHashTableEntry');
  const _remove = Symbol('_remove');
  collection._HashMap$ = dart.generic((K, V) => {
    class _HashMap extends core.Object {
      _HashMap() {
        this[_length$1] = 0;
        this[_strings$] = null;
        this[_nums$] = null;
        this[_rest$] = null;
        this[_keys] = null;
      }
      get length() {
        return this[_length$1];
      }
      get isEmpty() {
        return this[_length$1] == 0;
      }
      get isNotEmpty() {
        return !dart.notNull(this.isEmpty);
      }
      get keys() {
        return new (collection.HashMapKeyIterable$(K))(this);
      }
      get values() {
        return _internal.MappedIterable$(K, V).new(this.keys, dart.fn(each => {
          dart.as(each, K);
          return this.get(each);
        }, V, [K]));
      }
      containsKey(key) {
        if (dart.notNull(collection._HashMap._isStringKey(key))) {
          let strings = this[_strings$];
          return strings == null ? false : collection._HashMap._hasTableEntry(strings, key);
        } else if (dart.notNull(collection._HashMap._isNumericKey(key))) {
          let nums = this[_nums$];
          return nums == null ? false : collection._HashMap._hasTableEntry(nums, key);
        } else {
          return this[_containsKey](key);
        }
      }
      [_containsKey](key) {
        let rest = this[_rest$];
        if (rest == null) return false;
        let bucket = this[_getBucket$](rest, key);
        return dart.notNull(this[_findBucketIndex](bucket, key)) >= 0;
      }
      containsValue(value) {
        return this[_computeKeys]()[dartx.any](dart.fn(each => dart.equals(this.get(each), value), core.bool, [dart.dynamic]));
      }
      addAll(other) {
        dart.as(other, core.Map$(K, V));
        other[dartx.forEach](dart.fn((key, value) => {
          dart.as(key, K);
          dart.as(value, V);
          this.set(key, value);
        }, dart.void, [K, V]));
      }
      get(key) {
        if (dart.notNull(collection._HashMap._isStringKey(key))) {
          let strings = this[_strings$];
          return dart.as(strings == null ? null : collection._HashMap._getTableEntry(strings, key), V);
        } else if (dart.notNull(collection._HashMap._isNumericKey(key))) {
          let nums = this[_nums$];
          return dart.as(nums == null ? null : collection._HashMap._getTableEntry(nums, key), V);
        } else {
          return this[_get](key);
        }
      }
      [_get](key) {
        let rest = this[_rest$];
        if (rest == null) return null;
        let bucket = this[_getBucket$](rest, key);
        let index = this[_findBucketIndex](bucket, key);
        return dart.as(dart.notNull(index) < 0 ? null : bucket[dart.notNull(index) + 1], V);
      }
      set(key, value) {
        dart.as(key, K);
        dart.as(value, V);
        if (dart.notNull(collection._HashMap._isStringKey(key))) {
          let strings = this[_strings$];
          if (strings == null) this[_strings$] = strings = collection._HashMap._newHashTable();
          this[_addHashTableEntry$](strings, key, value);
        } else if (dart.notNull(collection._HashMap._isNumericKey(key))) {
          let nums = this[_nums$];
          if (nums == null) this[_nums$] = nums = collection._HashMap._newHashTable();
          this[_addHashTableEntry$](nums, key, value);
        } else {
          this[_set](key, value);
        }
        return value;
      }
      [_set](key, value) {
        dart.as(key, K);
        dart.as(value, V);
        let rest = this[_rest$];
        if (rest == null) this[_rest$] = rest = collection._HashMap._newHashTable();
        let hash = this[_computeHashCode](key);
        let bucket = rest[hash];
        if (bucket == null) {
          collection._HashMap._setTableEntry(rest, hash, [key, value]);
          this[_length$1] = dart.notNull(this[_length$1]) + 1;
          this[_keys] = null;
        } else {
          let index = this[_findBucketIndex](bucket, key);
          if (dart.notNull(index) >= 0) {
            bucket[dart.notNull(index) + 1] = value;
          } else {
            bucket.push(key, value);
            this[_length$1] = dart.notNull(this[_length$1]) + 1;
            this[_keys] = null;
          }
        }
      }
      putIfAbsent(key, ifAbsent) {
        dart.as(key, K);
        dart.as(ifAbsent, dart.functionType(V, []));
        if (dart.notNull(this.containsKey(key))) return this.get(key);
        let value = ifAbsent();
        this.set(key, value);
        return value;
      }
      remove(key) {
        if (dart.notNull(collection._HashMap._isStringKey(key))) {
          return this[_removeHashTableEntry$](this[_strings$], key);
        } else if (dart.notNull(collection._HashMap._isNumericKey(key))) {
          return this[_removeHashTableEntry$](this[_nums$], key);
        } else {
          return this[_remove](key);
        }
      }
      [_remove](key) {
        let rest = this[_rest$];
        if (rest == null) return null;
        let bucket = this[_getBucket$](rest, key);
        let index = this[_findBucketIndex](bucket, key);
        if (dart.notNull(index) < 0) return null;
        this[_length$1] = dart.notNull(this[_length$1]) - 1;
        this[_keys] = null;
        return bucket.splice(index, 2)[1];
      }
      clear() {
        if (dart.notNull(this[_length$1]) > 0) {
          this[_strings$] = this[_nums$] = this[_rest$] = this[_keys] = null;
          this[_length$1] = 0;
        }
      }
      forEach(action) {
        dart.as(action, dart.functionType(dart.void, [K, V]));
        let keys = this[_computeKeys]();
        for (let i = 0, length = keys[dartx.length]; i < dart.notNull(length); i++) {
          let key = keys[i];
          action(dart.as(key, K), this.get(key));
          if (keys !== this[_keys]) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
        }
      }
      [_computeKeys]() {
        if (this[_keys] != null) return this[_keys];
        let result = core.List.new(this[_length$1]);
        let index = 0;
        let strings = this[_strings$];
        if (strings != null) {
          let names = Object.getOwnPropertyNames(strings);
          let entries = names.length;
          for (let i = 0; i < entries; i++) {
            let key = names[i];
            result[index] = key;
            index++;
          }
        }
        let nums = this[_nums$];
        if (nums != null) {
          let names = Object.getOwnPropertyNames(nums);
          let entries = names.length;
          for (let i = 0; i < entries; i++) {
            let key = +names[i];
            result[index] = key;
            index++;
          }
        }
        let rest = this[_rest$];
        if (rest != null) {
          let names = Object.getOwnPropertyNames(rest);
          let entries = names.length;
          for (let i = 0; i < entries; i++) {
            let key = names[i];
            let bucket = rest[key];
            let length = bucket.length;
            for (let i = 0; i < length; i = i + 2) {
              let key = bucket[i];
              result[index] = key;
              index++;
            }
          }
        }
        dart.assert(index == this[_length$1]);
        return this[_keys] = result;
      }
      [_addHashTableEntry$](table, key, value) {
        dart.as(key, K);
        dart.as(value, V);
        if (!dart.notNull(collection._HashMap._hasTableEntry(table, key))) {
          this[_length$1] = dart.notNull(this[_length$1]) + 1;
          this[_keys] = null;
        }
        collection._HashMap._setTableEntry(table, key, value);
      }
      [_removeHashTableEntry$](table, key) {
        if (table != null && dart.notNull(collection._HashMap._hasTableEntry(table, key))) {
          let value = dart.as(collection._HashMap._getTableEntry(table, key), V);
          collection._HashMap._deleteTableEntry(table, key);
          this[_length$1] = dart.notNull(this[_length$1]) - 1;
          this[_keys] = null;
          return value;
        } else {
          return null;
        }
      }
      static _isStringKey(key) {
        return typeof key == 'string' && key != '__proto__';
      }
      static _isNumericKey(key) {
        return typeof key == 'number' && (key & 0x3ffffff) === key;
      }
      [_computeHashCode](key) {
        return dart.hashCode(key) & 0x3ffffff;
      }
      static _hasTableEntry(table, key) {
        let entry = table[key];
        return entry != null;
      }
      static _getTableEntry(table, key) {
        let entry = table[key];
        return entry === table ? null : entry;
      }
      static _setTableEntry(table, key, value) {
        if (value == null) {
          table[key] = table;
        } else {
          table[key] = value;
        }
      }
      static _deleteTableEntry(table, key) {
        delete table[key];
      }
      [_getBucket$](table, key) {
        let hash = this[_computeHashCode](key);
        return table[hash];
      }
      [_findBucketIndex](bucket, key) {
        if (bucket == null) return -1;
        let length = bucket.length;
        for (let i = 0; i < length; i = i + 2) {
          if (dart.equals(bucket[i], key)) return i;
        }
        return -1;
      }
      static _newHashTable() {
        let table = Object.create(null);
        let temporaryKey = '<non-identifier-key>';
        collection._HashMap._setTableEntry(table, temporaryKey, table);
        collection._HashMap._deleteTableEntry(table, temporaryKey);
        return table;
      }
    }
    _HashMap[dart.implements] = () => [collection.HashMap$(K, V)];
    dart.setSignature(_HashMap, {
      constructors: () => ({_HashMap: [collection._HashMap$(K, V), []]}),
      methods: () => ({
        containsKey: [core.bool, [core.Object]],
        [_containsKey]: [core.bool, [core.Object]],
        containsValue: [core.bool, [core.Object]],
        addAll: [dart.void, [core.Map$(K, V)]],
        get: [V, [core.Object]],
        [_get]: [V, [core.Object]],
        set: [dart.void, [K, V]],
        [_set]: [dart.void, [K, V]],
        putIfAbsent: [V, [K, dart.functionType(V, [])]],
        remove: [V, [core.Object]],
        [_remove]: [V, [core.Object]],
        clear: [dart.void, []],
        forEach: [dart.void, [dart.functionType(dart.void, [K, V])]],
        [_computeKeys]: [core.List, []],
        [_addHashTableEntry$]: [dart.void, [dart.dynamic, K, V]],
        [_removeHashTableEntry$]: [V, [dart.dynamic, core.Object]],
        [_computeHashCode]: [core.int, [dart.dynamic]],
        [_getBucket$]: [core.List, [dart.dynamic, dart.dynamic]],
        [_findBucketIndex]: [core.int, [dart.dynamic, dart.dynamic]]
      }),
      statics: () => ({
        _isStringKey: [core.bool, [dart.dynamic]],
        _isNumericKey: [core.bool, [dart.dynamic]],
        _hasTableEntry: [core.bool, [dart.dynamic, dart.dynamic]],
        _getTableEntry: [dart.dynamic, [dart.dynamic, dart.dynamic]],
        _setTableEntry: [dart.void, [dart.dynamic, dart.dynamic, dart.dynamic]],
        _deleteTableEntry: [dart.void, [dart.dynamic, dart.dynamic]],
        _newHashTable: [dart.dynamic, []]
      }),
      names: ['_isStringKey', '_isNumericKey', '_hasTableEntry', '_getTableEntry', '_setTableEntry', '_deleteTableEntry', '_newHashTable']
    });
    dart.defineExtensionMembers(_HashMap, [
      'containsKey',
      'containsValue',
      'addAll',
      'get',
      'set',
      'putIfAbsent',
      'remove',
      'clear',
      'forEach',
      'length',
      'isEmpty',
      'isNotEmpty',
      'keys',
      'values'
    ]);
    return _HashMap;
  });
  collection._HashMap = collection._HashMap$();
  collection._IdentityHashMap$ = dart.generic((K, V) => {
    class _IdentityHashMap extends collection._HashMap$(K, V) {
      _IdentityHashMap() {
        super._HashMap();
      }
      [_computeHashCode](key) {
        return core.identityHashCode(key) & 0x3ffffff;
      }
      [_findBucketIndex](bucket, key) {
        if (bucket == null) return -1;
        let length = bucket.length;
        for (let i = 0; i < length; i = i + 2) {
          if (core.identical(bucket[i], key)) return i;
        }
        return -1;
      }
    }
    return _IdentityHashMap;
  });
  collection._IdentityHashMap = collection._IdentityHashMap$();
  const _equals$ = Symbol('_equals');
  const _hashCode = Symbol('_hashCode');
  const _validKey = Symbol('_validKey');
  collection._CustomHashMap$ = dart.generic((K, V) => {
    class _CustomHashMap extends collection._HashMap$(K, V) {
      _CustomHashMap(equals, hashCode, validKey) {
        this[_equals$] = equals;
        this[_hashCode] = hashCode;
        this[_validKey] = validKey != null ? validKey : dart.fn(v => dart.is(v, K), core.bool, [core.Object]);
        super._HashMap();
      }
      get(key) {
        if (!dart.notNull(this[_validKey](key))) return null;
        return super[_get](key);
      }
      set(key, value) {
        dart.as(key, K);
        dart.as(value, V);
        super[_set](key, value);
        return value;
      }
      containsKey(key) {
        if (!dart.notNull(this[_validKey](key))) return false;
        return super[_containsKey](key);
      }
      remove(key) {
        if (!dart.notNull(this[_validKey](key))) return null;
        return super[_remove](key);
      }
      [_computeHashCode](key) {
        return this[_hashCode](dart.as(key, K)) & 0x3ffffff;
      }
      [_findBucketIndex](bucket, key) {
        if (bucket == null) return -1;
        let length = bucket.length;
        for (let i = 0; i < length; i = i + 2) {
          if (dart.notNull(this[_equals$](bucket[i], dart.as(key, K)))) return i;
        }
        return -1;
      }
      toString() {
        return collection.Maps.mapToString(this);
      }
    }
    dart.setSignature(_CustomHashMap, {
      constructors: () => ({_CustomHashMap: [collection._CustomHashMap$(K, V), [collection._Equality$(K), collection._Hasher$(K), dart.functionType(core.bool, [core.Object])]]}),
      methods: () => ({
        get: [V, [core.Object]],
        set: [dart.void, [K, V]],
        remove: [V, [core.Object]]
      })
    });
    dart.defineExtensionMembers(_CustomHashMap, ['get', 'set', 'containsKey', 'remove']);
    return _CustomHashMap;
  });
  collection._CustomHashMap = collection._CustomHashMap$();
  const _map$0 = Symbol('_map');
  collection.HashMapKeyIterable$ = dart.generic(E => {
    class HashMapKeyIterable extends collection.IterableBase$(E) {
      HashMapKeyIterable(map) {
        this[_map$0] = map;
        super.IterableBase();
      }
      get length() {
        return dart.as(dart.dload(this[_map$0], _length$1), core.int);
      }
      get isEmpty() {
        return dart.equals(dart.dload(this[_map$0], _length$1), 0);
      }
      get iterator() {
        return new (collection.HashMapKeyIterator$(E))(this[_map$0], dart.as(dart.dsend(this[_map$0], _computeKeys), core.List));
      }
      contains(element) {
        return dart.as(dart.dsend(this[_map$0], 'containsKey', element), core.bool);
      }
      forEach(f) {
        dart.as(f, dart.functionType(dart.void, [E]));
        let keys = dart.as(dart.dsend(this[_map$0], _computeKeys), core.List);
        for (let i = 0, length = keys.length; i < length; i++) {
          f(keys[i]);
          if (keys !== dart.dload(this[_map$0], _keys)) {
            dart.throw(new core.ConcurrentModificationError(this[_map$0]));
          }
        }
      }
    }
    HashMapKeyIterable[dart.implements] = () => [_internal.EfficientLength];
    dart.setSignature(HashMapKeyIterable, {
      constructors: () => ({HashMapKeyIterable: [collection.HashMapKeyIterable$(E), [dart.dynamic]]}),
      methods: () => ({forEach: [dart.void, [dart.functionType(dart.void, [E])]]})
    });
    dart.defineExtensionMembers(HashMapKeyIterable, [
      'contains',
      'forEach',
      'length',
      'isEmpty',
      'iterator'
    ]);
    return HashMapKeyIterable;
  });
  collection.HashMapKeyIterable = collection.HashMapKeyIterable$();
  const _offset = Symbol('_offset');
  const _current$2 = Symbol('_current');
  collection.HashMapKeyIterator$ = dart.generic(E => {
    class HashMapKeyIterator extends core.Object {
      HashMapKeyIterator(map, keys) {
        this[_map$0] = map;
        this[_keys] = keys;
        this[_offset] = 0;
        this[_current$2] = null;
      }
      get current() {
        return this[_current$2];
      }
      moveNext() {
        let keys = this[_keys];
        let offset = this[_offset];
        if (keys !== dart.dload(this[_map$0], _keys)) {
          dart.throw(new core.ConcurrentModificationError(this[_map$0]));
        } else if (dart.notNull(offset) >= keys.length) {
          this[_current$2] = null;
          return false;
        } else {
          this[_current$2] = keys[offset];
          this[_offset] = dart.notNull(offset) + 1;
          return true;
        }
      }
    }
    HashMapKeyIterator[dart.implements] = () => [core.Iterator$(E)];
    dart.setSignature(HashMapKeyIterator, {
      constructors: () => ({HashMapKeyIterator: [collection.HashMapKeyIterator$(E), [dart.dynamic, core.List]]}),
      methods: () => ({moveNext: [core.bool, []]})
    });
    return HashMapKeyIterator;
  });
  collection.HashMapKeyIterator = collection.HashMapKeyIterator$();
  const _first$ = Symbol('_first');
  const _last$ = Symbol('_last');
  const _modifications$ = Symbol('_modifications');
  const _value = Symbol('_value');
  const _newLinkedCell$ = Symbol('_newLinkedCell');
  const _unlinkCell$ = Symbol('_unlinkCell');
  const _modified$ = Symbol('_modified');
  const _key = Symbol('_key');
  const _next$0 = Symbol('_next');
  const _previous$0 = Symbol('_previous');
  collection._LinkedHashMap$ = dart.generic((K, V) => {
    class _LinkedHashMap extends core.Object {
      _LinkedHashMap() {
        this[_length$1] = 0;
        this[_strings$] = null;
        this[_nums$] = null;
        this[_rest$] = null;
        this[_first$] = null;
        this[_last$] = null;
        this[_modifications$] = 0;
      }
      get length() {
        return this[_length$1];
      }
      get isEmpty() {
        return this[_length$1] == 0;
      }
      get isNotEmpty() {
        return !dart.notNull(this.isEmpty);
      }
      get keys() {
        return new (collection.LinkedHashMapKeyIterable$(K))(this);
      }
      get values() {
        return _internal.MappedIterable$(K, V).new(this.keys, dart.fn(each => {
          dart.as(each, K);
          return this.get(each);
        }, V, [K]));
      }
      containsKey(key) {
        if (dart.notNull(collection._LinkedHashMap._isStringKey(key))) {
          let strings = this[_strings$];
          if (strings == null) return false;
          let cell = dart.as(collection._LinkedHashMap._getTableEntry(strings, key), collection.LinkedHashMapCell);
          return cell != null;
        } else if (dart.notNull(collection._LinkedHashMap._isNumericKey(key))) {
          let nums = this[_nums$];
          if (nums == null) return false;
          let cell = dart.as(collection._LinkedHashMap._getTableEntry(nums, key), collection.LinkedHashMapCell);
          return cell != null;
        } else {
          return this[_containsKey](key);
        }
      }
      [_containsKey](key) {
        let rest = this[_rest$];
        if (rest == null) return false;
        let bucket = this[_getBucket$](rest, key);
        return dart.notNull(this[_findBucketIndex](bucket, key)) >= 0;
      }
      containsValue(value) {
        return this.keys[dartx.any](dart.fn(each => {
          dart.as(each, K);
          return dart.equals(this.get(each), value);
        }, core.bool, [K]));
      }
      addAll(other) {
        dart.as(other, core.Map$(K, V));
        other[dartx.forEach](dart.fn((key, value) => {
          dart.as(key, K);
          dart.as(value, V);
          this.set(key, value);
        }, dart.void, [K, V]));
      }
      get(key) {
        if (dart.notNull(collection._LinkedHashMap._isStringKey(key))) {
          let strings = this[_strings$];
          if (strings == null) return null;
          let cell = dart.as(collection._LinkedHashMap._getTableEntry(strings, key), collection.LinkedHashMapCell);
          return dart.as(cell == null ? null : cell[_value], V);
        } else if (dart.notNull(collection._LinkedHashMap._isNumericKey(key))) {
          let nums = this[_nums$];
          if (nums == null) return null;
          let cell = dart.as(collection._LinkedHashMap._getTableEntry(nums, key), collection.LinkedHashMapCell);
          return dart.as(cell == null ? null : cell[_value], V);
        } else {
          return this[_get](key);
        }
      }
      [_get](key) {
        let rest = this[_rest$];
        if (rest == null) return null;
        let bucket = this[_getBucket$](rest, key);
        let index = this[_findBucketIndex](bucket, key);
        if (dart.notNull(index) < 0) return null;
        let cell = bucket[index];
        return dart.as(cell[_value], V);
      }
      set(key, value) {
        dart.as(key, K);
        dart.as(value, V);
        if (dart.notNull(collection._LinkedHashMap._isStringKey(key))) {
          let strings = this[_strings$];
          if (strings == null) this[_strings$] = strings = collection._LinkedHashMap._newHashTable();
          this[_addHashTableEntry$](strings, key, value);
        } else if (dart.notNull(collection._LinkedHashMap._isNumericKey(key))) {
          let nums = this[_nums$];
          if (nums == null) this[_nums$] = nums = collection._LinkedHashMap._newHashTable();
          this[_addHashTableEntry$](nums, key, value);
        } else {
          this[_set](key, value);
        }
        return value;
      }
      [_set](key, value) {
        dart.as(key, K);
        dart.as(value, V);
        let rest = this[_rest$];
        if (rest == null) this[_rest$] = rest = collection._LinkedHashMap._newHashTable();
        let hash = this[_computeHashCode](key);
        let bucket = rest[hash];
        if (bucket == null) {
          let cell = this[_newLinkedCell$](key, value);
          collection._LinkedHashMap._setTableEntry(rest, hash, [cell]);
        } else {
          let index = this[_findBucketIndex](bucket, key);
          if (dart.notNull(index) >= 0) {
            let cell = bucket[index];
            cell[_value] = value;
          } else {
            let cell = this[_newLinkedCell$](key, value);
            bucket.push(cell);
          }
        }
      }
      putIfAbsent(key, ifAbsent) {
        dart.as(key, K);
        dart.as(ifAbsent, dart.functionType(V, []));
        if (dart.notNull(this.containsKey(key))) return this.get(key);
        let value = ifAbsent();
        this.set(key, value);
        return value;
      }
      remove(key) {
        if (dart.notNull(collection._LinkedHashMap._isStringKey(key))) {
          return this[_removeHashTableEntry$](this[_strings$], key);
        } else if (dart.notNull(collection._LinkedHashMap._isNumericKey(key))) {
          return this[_removeHashTableEntry$](this[_nums$], key);
        } else {
          return this[_remove](key);
        }
      }
      [_remove](key) {
        let rest = this[_rest$];
        if (rest == null) return null;
        let bucket = this[_getBucket$](rest, key);
        let index = this[_findBucketIndex](bucket, key);
        if (dart.notNull(index) < 0) return null;
        let cell = bucket.splice(index, 1)[0];
        this[_unlinkCell$](cell);
        return dart.as(cell[_value], V);
      }
      clear() {
        if (dart.notNull(this[_length$1]) > 0) {
          this[_strings$] = this[_nums$] = this[_rest$] = this[_first$] = this[_last$] = null;
          this[_length$1] = 0;
          this[_modified$]();
        }
      }
      forEach(action) {
        dart.as(action, dart.functionType(dart.void, [K, V]));
        let cell = this[_first$];
        let modifications = this[_modifications$];
        while (cell != null) {
          action(dart.as(cell[_key], K), dart.as(cell[_value], V));
          if (modifications != this[_modifications$]) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
          cell = cell[_next$0];
        }
      }
      [_addHashTableEntry$](table, key, value) {
        dart.as(key, K);
        dart.as(value, V);
        let cell = dart.as(collection._LinkedHashMap._getTableEntry(table, key), collection.LinkedHashMapCell);
        if (cell == null) {
          collection._LinkedHashMap._setTableEntry(table, key, this[_newLinkedCell$](key, value));
        } else {
          cell[_value] = value;
        }
      }
      [_removeHashTableEntry$](table, key) {
        if (table == null) return null;
        let cell = dart.as(collection._LinkedHashMap._getTableEntry(table, key), collection.LinkedHashMapCell);
        if (cell == null) return null;
        this[_unlinkCell$](cell);
        collection._LinkedHashMap._deleteTableEntry(table, key);
        return dart.as(cell[_value], V);
      }
      [_modified$]() {
        this[_modifications$] = dart.notNull(this[_modifications$]) + 1 & 67108863;
      }
      [_newLinkedCell$](key, value) {
        dart.as(key, K);
        dart.as(value, V);
        let cell = new collection.LinkedHashMapCell(key, value);
        if (this[_first$] == null) {
          this[_first$] = this[_last$] = cell;
        } else {
          let last = this[_last$];
          cell[_previous$0] = last;
          this[_last$] = last[_next$0] = cell;
        }
        this[_length$1] = dart.notNull(this[_length$1]) + 1;
        this[_modified$]();
        return cell;
      }
      [_unlinkCell$](cell) {
        let previous = cell[_previous$0];
        let next = cell[_next$0];
        if (previous == null) {
          dart.assert(dart.equals(cell, this[_first$]));
          this[_first$] = next;
        } else {
          previous[_next$0] = next;
        }
        if (next == null) {
          dart.assert(dart.equals(cell, this[_last$]));
          this[_last$] = previous;
        } else {
          next[_previous$0] = previous;
        }
        this[_length$1] = dart.notNull(this[_length$1]) - 1;
        this[_modified$]();
      }
      static _isStringKey(key) {
        return typeof key == 'string' && key != '__proto__';
      }
      static _isNumericKey(key) {
        return typeof key == 'number' && (key & 0x3ffffff) === key;
      }
      [_computeHashCode](key) {
        return dart.hashCode(key) & 0x3ffffff;
      }
      static _getTableEntry(table, key) {
        return table[key];
      }
      static _setTableEntry(table, key, value) {
        dart.assert(value != null);
        table[key] = value;
      }
      static _deleteTableEntry(table, key) {
        delete table[key];
      }
      [_getBucket$](table, key) {
        let hash = this[_computeHashCode](key);
        return table[hash];
      }
      [_findBucketIndex](bucket, key) {
        if (bucket == null) return -1;
        let length = bucket.length;
        for (let i = 0; i < length; i++) {
          let cell = bucket[i];
          if (dart.equals(cell[_key], key)) return i;
        }
        return -1;
      }
      static _newHashTable() {
        let table = Object.create(null);
        let temporaryKey = '<non-identifier-key>';
        collection._LinkedHashMap._setTableEntry(table, temporaryKey, table);
        collection._LinkedHashMap._deleteTableEntry(table, temporaryKey);
        return table;
      }
      toString() {
        return collection.Maps.mapToString(this);
      }
    }
    _LinkedHashMap[dart.implements] = () => [collection.LinkedHashMap$(K, V), _js_helper.InternalMap];
    dart.setSignature(_LinkedHashMap, {
      constructors: () => ({_LinkedHashMap: [collection._LinkedHashMap$(K, V), []]}),
      methods: () => ({
        containsKey: [core.bool, [core.Object]],
        [_containsKey]: [core.bool, [core.Object]],
        containsValue: [core.bool, [core.Object]],
        addAll: [dart.void, [core.Map$(K, V)]],
        get: [V, [core.Object]],
        [_get]: [V, [core.Object]],
        set: [dart.void, [K, V]],
        [_set]: [dart.void, [K, V]],
        putIfAbsent: [V, [K, dart.functionType(V, [])]],
        remove: [V, [core.Object]],
        [_remove]: [V, [core.Object]],
        clear: [dart.void, []],
        forEach: [dart.void, [dart.functionType(dart.void, [K, V])]],
        [_addHashTableEntry$]: [dart.void, [dart.dynamic, K, V]],
        [_removeHashTableEntry$]: [V, [dart.dynamic, core.Object]],
        [_modified$]: [dart.void, []],
        [_newLinkedCell$]: [collection.LinkedHashMapCell, [K, V]],
        [_unlinkCell$]: [dart.void, [collection.LinkedHashMapCell]],
        [_computeHashCode]: [core.int, [dart.dynamic]],
        [_getBucket$]: [core.List, [dart.dynamic, dart.dynamic]],
        [_findBucketIndex]: [core.int, [dart.dynamic, dart.dynamic]]
      }),
      statics: () => ({
        _isStringKey: [core.bool, [dart.dynamic]],
        _isNumericKey: [core.bool, [dart.dynamic]],
        _getTableEntry: [dart.dynamic, [dart.dynamic, dart.dynamic]],
        _setTableEntry: [dart.void, [dart.dynamic, dart.dynamic, dart.dynamic]],
        _deleteTableEntry: [dart.void, [dart.dynamic, dart.dynamic]],
        _newHashTable: [dart.dynamic, []]
      }),
      names: ['_isStringKey', '_isNumericKey', '_getTableEntry', '_setTableEntry', '_deleteTableEntry', '_newHashTable']
    });
    dart.defineExtensionMembers(_LinkedHashMap, [
      'containsKey',
      'containsValue',
      'addAll',
      'get',
      'set',
      'putIfAbsent',
      'remove',
      'clear',
      'forEach',
      'length',
      'isEmpty',
      'isNotEmpty',
      'keys',
      'values'
    ]);
    return _LinkedHashMap;
  });
  collection._LinkedHashMap = collection._LinkedHashMap$();
  collection._LinkedIdentityHashMap$ = dart.generic((K, V) => {
    class _LinkedIdentityHashMap extends collection._LinkedHashMap$(K, V) {
      _LinkedIdentityHashMap() {
        super._LinkedHashMap();
      }
      [_computeHashCode](key) {
        return core.identityHashCode(key) & 0x3ffffff;
      }
      [_findBucketIndex](bucket, key) {
        if (bucket == null) return -1;
        let length = bucket.length;
        for (let i = 0; i < length; i++) {
          let cell = bucket[i];
          if (core.identical(cell[_key], key)) return i;
        }
        return -1;
      }
    }
    return _LinkedIdentityHashMap;
  });
  collection._LinkedIdentityHashMap = collection._LinkedIdentityHashMap$();
  collection._LinkedCustomHashMap$ = dart.generic((K, V) => {
    class _LinkedCustomHashMap extends collection._LinkedHashMap$(K, V) {
      _LinkedCustomHashMap(equals, hashCode, validKey) {
        this[_equals$] = equals;
        this[_hashCode] = hashCode;
        this[_validKey] = validKey != null ? validKey : dart.fn(v => dart.is(v, K), core.bool, [core.Object]);
        super._LinkedHashMap();
      }
      get(key) {
        if (!dart.notNull(this[_validKey](key))) return null;
        return super[_get](key);
      }
      set(key, value) {
        dart.as(key, K);
        dart.as(value, V);
        super[_set](key, value);
        return value;
      }
      containsKey(key) {
        if (!dart.notNull(this[_validKey](key))) return false;
        return super[_containsKey](key);
      }
      remove(key) {
        if (!dart.notNull(this[_validKey](key))) return null;
        return super[_remove](key);
      }
      [_computeHashCode](key) {
        return this[_hashCode](dart.as(key, K)) & 0x3ffffff;
      }
      [_findBucketIndex](bucket, key) {
        if (bucket == null) return -1;
        let length = bucket.length;
        for (let i = 0; i < length; i++) {
          let cell = bucket[i];
          if (dart.notNull(this[_equals$](dart.as(cell[_key], K), dart.as(key, K)))) return i;
        }
        return -1;
      }
    }
    dart.setSignature(_LinkedCustomHashMap, {
      constructors: () => ({_LinkedCustomHashMap: [collection._LinkedCustomHashMap$(K, V), [collection._Equality$(K), collection._Hasher$(K), dart.functionType(core.bool, [core.Object])]]}),
      methods: () => ({
        get: [V, [core.Object]],
        set: [dart.void, [K, V]],
        remove: [V, [core.Object]]
      })
    });
    dart.defineExtensionMembers(_LinkedCustomHashMap, ['get', 'set', 'containsKey', 'remove']);
    return _LinkedCustomHashMap;
  });
  collection._LinkedCustomHashMap = collection._LinkedCustomHashMap$();
  collection.LinkedHashMapCell = class LinkedHashMapCell extends core.Object {
    LinkedHashMapCell(key, value) {
      this[_key] = key;
      this[_value] = value;
      this[_next$0] = null;
      this[_previous$0] = null;
    }
  };
  dart.setSignature(collection.LinkedHashMapCell, {
    constructors: () => ({LinkedHashMapCell: [collection.LinkedHashMapCell, [dart.dynamic, dart.dynamic]]})
  });
  collection.LinkedHashMapKeyIterable$ = dart.generic(E => {
    class LinkedHashMapKeyIterable extends collection.IterableBase$(E) {
      LinkedHashMapKeyIterable(map) {
        this[_map$0] = map;
        super.IterableBase();
      }
      get length() {
        return dart.as(dart.dload(this[_map$0], _length$1), core.int);
      }
      get isEmpty() {
        return dart.equals(dart.dload(this[_map$0], _length$1), 0);
      }
      get iterator() {
        return new (collection.LinkedHashMapKeyIterator$(E))(this[_map$0], dart.as(dart.dload(this[_map$0], _modifications$), core.int));
      }
      contains(element) {
        return dart.as(dart.dsend(this[_map$0], 'containsKey', element), core.bool);
      }
      forEach(f) {
        dart.as(f, dart.functionType(dart.void, [E]));
        let cell = dart.as(dart.dload(this[_map$0], _first$), collection.LinkedHashMapCell);
        let modifications = dart.as(dart.dload(this[_map$0], _modifications$), core.int);
        while (cell != null) {
          f(dart.as(cell[_key], E));
          if (!dart.equals(modifications, dart.dload(this[_map$0], _modifications$))) {
            dart.throw(new core.ConcurrentModificationError(this[_map$0]));
          }
          cell = cell[_next$0];
        }
      }
    }
    LinkedHashMapKeyIterable[dart.implements] = () => [_internal.EfficientLength];
    dart.setSignature(LinkedHashMapKeyIterable, {
      constructors: () => ({LinkedHashMapKeyIterable: [collection.LinkedHashMapKeyIterable$(E), [dart.dynamic]]}),
      methods: () => ({forEach: [dart.void, [dart.functionType(dart.void, [E])]]})
    });
    dart.defineExtensionMembers(LinkedHashMapKeyIterable, [
      'contains',
      'forEach',
      'length',
      'isEmpty',
      'iterator'
    ]);
    return LinkedHashMapKeyIterable;
  });
  collection.LinkedHashMapKeyIterable = collection.LinkedHashMapKeyIterable$();
  const _cell$ = Symbol('_cell');
  collection.LinkedHashMapKeyIterator$ = dart.generic(E => {
    class LinkedHashMapKeyIterator extends core.Object {
      LinkedHashMapKeyIterator(map, modifications) {
        this[_map$0] = map;
        this[_modifications$] = modifications;
        this[_cell$] = null;
        this[_current$2] = null;
        this[_cell$] = dart.as(dart.dload(this[_map$0], _first$), collection.LinkedHashMapCell);
      }
      get current() {
        return this[_current$2];
      }
      moveNext() {
        if (!dart.equals(this[_modifications$], dart.dload(this[_map$0], _modifications$))) {
          dart.throw(new core.ConcurrentModificationError(this[_map$0]));
        } else if (this[_cell$] == null) {
          this[_current$2] = null;
          return false;
        } else {
          this[_current$2] = dart.as(this[_cell$][_key], E);
          this[_cell$] = this[_cell$][_next$0];
          return true;
        }
      }
    }
    LinkedHashMapKeyIterator[dart.implements] = () => [core.Iterator$(E)];
    dart.setSignature(LinkedHashMapKeyIterator, {
      constructors: () => ({LinkedHashMapKeyIterator: [collection.LinkedHashMapKeyIterator$(E), [dart.dynamic, core.int]]}),
      methods: () => ({moveNext: [core.bool, []]})
    });
    return LinkedHashMapKeyIterator;
  });
  collection.LinkedHashMapKeyIterator = collection.LinkedHashMapKeyIterator$();
  const _elements = Symbol('_elements');
  const _newSet = Symbol('_newSet');
  const _computeElements = Symbol('_computeElements');
  const _contains = Symbol('_contains');
  const _lookup = Symbol('_lookup');
  const _add$0 = Symbol('_add');
  collection.SetMixin$ = dart.generic(E => {
    class SetMixin extends core.Object {
      [Symbol.iterator]() {
        return new dart.JsIterator(this.iterator);
      }
      get isEmpty() {
        return this.length == 0;
      }
      get isNotEmpty() {
        return this.length != 0;
      }
      clear() {
        this.removeAll(this.toList());
      }
      addAll(elements) {
        dart.as(elements, core.Iterable$(E));
        for (let element of elements)
          this.add(element);
      }
      removeAll(elements) {
        for (let element of elements)
          this.remove(element);
      }
      retainAll(elements) {
        let toRemove = this.toSet();
        for (let o of elements) {
          toRemove.remove(o);
        }
        this.removeAll(toRemove);
      }
      removeWhere(test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        let toRemove = [];
        for (let element of this) {
          if (dart.notNull(test(element))) toRemove[dartx.add](element);
        }
        this.removeAll(toRemove);
      }
      retainWhere(test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        let toRemove = [];
        for (let element of this) {
          if (!dart.notNull(test(element))) toRemove[dartx.add](element);
        }
        this.removeAll(toRemove);
      }
      containsAll(other) {
        for (let o of other) {
          if (!dart.notNull(this.contains(o))) return false;
        }
        return true;
      }
      union(other) {
        dart.as(other, core.Set$(E));
        let _ = this.toSet();
        _.addAll(other);
        return _;
      }
      intersection(other) {
        let result = this.toSet();
        for (let element of this) {
          if (!dart.notNull(other.contains(element))) result.remove(element);
        }
        return result;
      }
      difference(other) {
        let result = this.toSet();
        for (let element of this) {
          if (dart.notNull(other.contains(element))) result.remove(element);
        }
        return result;
      }
      toList(opts) {
        let growable = opts && 'growable' in opts ? opts.growable : true;
        let result = dart.notNull(growable) ? (() => {
          let _ = core.List$(E).new();
          _[dartx.length] = this.length;
          return _;
        })() : core.List$(E).new(this.length);
        let i = 0;
        for (let element of this)
          result[dartx.set](i++, element);
        return result;
      }
      map(T) {
        return f => {
          dart.as(f, dart.functionType(T, [E]));
          return new (_internal.EfficientLengthMappedIterable$(E, T))(this, f);
        };
      }
      get single() {
        if (dart.notNull(this.length) > 1) dart.throw(_internal.IterableElementError.tooMany());
        let it = this.iterator;
        if (!dart.notNull(it.moveNext())) dart.throw(_internal.IterableElementError.noElement());
        let result = it.current;
        return result;
      }
      toString() {
        return collection.IterableBase.iterableToFullString(this, '{', '}');
      }
      where(f) {
        dart.as(f, dart.functionType(core.bool, [E]));
        return new (_internal.WhereIterable$(E))(this, f);
      }
      expand(T) {
        return f => {
          dart.as(f, dart.functionType(core.Iterable$(T), [E]));
          return new (_internal.ExpandIterable$(E, T))(this, f);
        };
      }
      forEach(f) {
        dart.as(f, dart.functionType(dart.void, [E]));
        for (let element of this)
          f(element);
      }
      reduce(combine) {
        dart.as(combine, dart.functionType(E, [E, E]));
        let iterator = this.iterator;
        if (!dart.notNull(iterator.moveNext())) {
          dart.throw(_internal.IterableElementError.noElement());
        }
        let value = iterator.current;
        while (dart.notNull(iterator.moveNext())) {
          value = combine(value, iterator.current);
        }
        return value;
      }
      fold(T) {
        return (initialValue, combine) => {
          dart.as(combine, dart.functionType(T, [T, E]));
          let value = initialValue;
          for (let element of this)
            value = combine(value, element);
          return value;
        };
      }
      every(f) {
        dart.as(f, dart.functionType(core.bool, [E]));
        for (let element of this) {
          if (!dart.notNull(f(element))) return false;
        }
        return true;
      }
      join(separator) {
        if (separator === void 0) separator = "";
        let iterator = this.iterator;
        if (!dart.notNull(iterator.moveNext())) return "";
        let buffer = new core.StringBuffer();
        if (separator == null || separator == "") {
          do {
            buffer.write(`${iterator.current}`);
          } while (dart.notNull(iterator.moveNext()));
        } else {
          buffer.write(`${iterator.current}`);
          while (dart.notNull(iterator.moveNext())) {
            buffer.write(separator);
            buffer.write(`${iterator.current}`);
          }
        }
        return buffer.toString();
      }
      any(test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        for (let element of this) {
          if (dart.notNull(test(element))) return true;
        }
        return false;
      }
      take(n) {
        return _internal.TakeIterable$(E).new(this, n);
      }
      takeWhile(test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        return new (_internal.TakeWhileIterable$(E))(this, test);
      }
      skip(n) {
        return _internal.SkipIterable$(E).new(this, n);
      }
      skipWhile(test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        return new (_internal.SkipWhileIterable$(E))(this, test);
      }
      get first() {
        let it = this.iterator;
        if (!dart.notNull(it.moveNext())) {
          dart.throw(_internal.IterableElementError.noElement());
        }
        return it.current;
      }
      get last() {
        let it = this.iterator;
        if (!dart.notNull(it.moveNext())) {
          dart.throw(_internal.IterableElementError.noElement());
        }
        let result = null;
        do {
          result = it.current;
        } while (dart.notNull(it.moveNext()));
        return result;
      }
      firstWhere(test, opts) {
        dart.as(test, dart.functionType(core.bool, [E]));
        let orElse = opts && 'orElse' in opts ? opts.orElse : null;
        dart.as(orElse, dart.functionType(E, []));
        for (let element of this) {
          if (dart.notNull(test(element))) return element;
        }
        if (orElse != null) return orElse();
        dart.throw(_internal.IterableElementError.noElement());
      }
      lastWhere(test, opts) {
        dart.as(test, dart.functionType(core.bool, [E]));
        let orElse = opts && 'orElse' in opts ? opts.orElse : null;
        dart.as(orElse, dart.functionType(E, []));
        let result = null;
        let foundMatching = false;
        for (let element of this) {
          if (dart.notNull(test(element))) {
            result = element;
            foundMatching = true;
          }
        }
        if (foundMatching) return result;
        if (orElse != null) return orElse();
        dart.throw(_internal.IterableElementError.noElement());
      }
      singleWhere(test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        let result = null;
        let foundMatching = false;
        for (let element of this) {
          if (dart.notNull(test(element))) {
            if (foundMatching) {
              dart.throw(_internal.IterableElementError.tooMany());
            }
            result = element;
            foundMatching = true;
          }
        }
        if (foundMatching) return result;
        dart.throw(_internal.IterableElementError.noElement());
      }
      elementAt(index) {
        if (!(typeof index == 'number')) dart.throw(new core.ArgumentError.notNull("index"));
        core.RangeError.checkNotNegative(index, "index");
        let elementIndex = 0;
        for (let element of this) {
          if (index == elementIndex) return element;
          elementIndex++;
        }
        dart.throw(core.RangeError.index(index, this, "index", null, elementIndex));
      }
    }
    SetMixin[dart.implements] = () => [core.Set$(E)];
    dart.setSignature(SetMixin, {
      methods: () => ({
        clear: [dart.void, []],
        addAll: [dart.void, [core.Iterable$(E)]],
        removeAll: [dart.void, [core.Iterable$(core.Object)]],
        retainAll: [dart.void, [core.Iterable$(core.Object)]],
        removeWhere: [dart.void, [dart.functionType(core.bool, [E])]],
        retainWhere: [dart.void, [dart.functionType(core.bool, [E])]],
        containsAll: [core.bool, [core.Iterable$(core.Object)]],
        union: [core.Set$(E), [core.Set$(E)]],
        intersection: [core.Set$(E), [core.Set$(core.Object)]],
        difference: [core.Set$(E), [core.Set$(core.Object)]],
        toList: [core.List$(E), [], {growable: core.bool}],
        map: [T => [core.Iterable$(T), [dart.functionType(T, [E])]]],
        where: [core.Iterable$(E), [dart.functionType(core.bool, [E])]],
        expand: [T => [core.Iterable$(T), [dart.functionType(core.Iterable$(T), [E])]]],
        forEach: [dart.void, [dart.functionType(dart.void, [E])]],
        reduce: [E, [dart.functionType(E, [E, E])]],
        fold: [T => [T, [T, dart.functionType(T, [T, E])]]],
        every: [core.bool, [dart.functionType(core.bool, [E])]],
        join: [core.String, [], [core.String]],
        any: [core.bool, [dart.functionType(core.bool, [E])]],
        take: [core.Iterable$(E), [core.int]],
        takeWhile: [core.Iterable$(E), [dart.functionType(core.bool, [E])]],
        skip: [core.Iterable$(E), [core.int]],
        skipWhile: [core.Iterable$(E), [dart.functionType(core.bool, [E])]],
        firstWhere: [E, [dart.functionType(core.bool, [E])], {orElse: dart.functionType(E, [])}],
        lastWhere: [E, [dart.functionType(core.bool, [E])], {orElse: dart.functionType(E, [])}],
        singleWhere: [E, [dart.functionType(core.bool, [E])]],
        elementAt: [E, [core.int]]
      })
    });
    dart.defineExtensionMembers(SetMixin, [
      'toList',
      'map',
      'toString',
      'where',
      'expand',
      'forEach',
      'reduce',
      'fold',
      'every',
      'join',
      'any',
      'take',
      'takeWhile',
      'skip',
      'skipWhile',
      'firstWhere',
      'lastWhere',
      'singleWhere',
      'elementAt',
      'isEmpty',
      'isNotEmpty',
      'single',
      'first',
      'last'
    ]);
    return SetMixin;
  });
  collection.SetMixin = collection.SetMixin$();
  collection.SetBase$ = dart.generic(E => {
    class SetBase extends collection.SetMixin$(E) {
      static setToString(set) {
        return collection.IterableBase.iterableToFullString(set, '{', '}');
      }
    }
    dart.setSignature(SetBase, {
      statics: () => ({setToString: [core.String, [core.Set]]}),
      names: ['setToString']
    });
    return SetBase;
  });
  collection.SetBase = collection.SetBase$();
  collection._HashSetBase$ = dart.generic(E => {
    class _HashSetBase extends collection.SetBase$(E) {
      difference(other) {
        let result = this[_newSet]();
        for (let element of this) {
          if (!dart.notNull(other.contains(element))) result.add(element);
        }
        return result;
      }
      intersection(other) {
        let result = this[_newSet]();
        for (let element of this) {
          if (dart.notNull(other.contains(element))) result.add(element);
        }
        return result;
      }
      toSet() {
        return (() => {
          let _ = this[_newSet]();
          _.addAll(this);
          return _;
        })();
      }
    }
    dart.setSignature(_HashSetBase, {
      methods: () => ({
        difference: [core.Set$(E), [core.Set$(core.Object)]],
        intersection: [core.Set$(E), [core.Set$(core.Object)]],
        toSet: [core.Set$(E), []]
      })
    });
    dart.defineExtensionMembers(_HashSetBase, ['toSet']);
    return _HashSetBase;
  });
  collection._HashSetBase = collection._HashSetBase$();
  collection._HashSet$ = dart.generic(E => {
    class _HashSet extends collection._HashSetBase$(E) {
      _HashSet() {
        this[_length$1] = 0;
        this[_strings$] = null;
        this[_nums$] = null;
        this[_rest$] = null;
        this[_elements] = null;
      }
      [_newSet]() {
        return new (collection._HashSet$(E))();
      }
      get iterator() {
        return new (collection.HashSetIterator$(E))(this, this[_computeElements]());
      }
      get length() {
        return this[_length$1];
      }
      get isEmpty() {
        return this[_length$1] == 0;
      }
      get isNotEmpty() {
        return !dart.notNull(this.isEmpty);
      }
      contains(object) {
        if (dart.notNull(collection._HashSet._isStringElement(object))) {
          let strings = this[_strings$];
          return strings == null ? false : collection._HashSet._hasTableEntry(strings, object);
        } else if (dart.notNull(collection._HashSet._isNumericElement(object))) {
          let nums = this[_nums$];
          return nums == null ? false : collection._HashSet._hasTableEntry(nums, object);
        } else {
          return this[_contains](object);
        }
      }
      [_contains](object) {
        let rest = this[_rest$];
        if (rest == null) return false;
        let bucket = this[_getBucket$](rest, object);
        return dart.notNull(this[_findBucketIndex](bucket, object)) >= 0;
      }
      lookup(object) {
        if (dart.notNull(collection._HashSet._isStringElement(object)) || dart.notNull(collection._HashSet._isNumericElement(object))) {
          return dart.as(dart.notNull(this.contains(object)) ? object : null, E);
        }
        return this[_lookup](object);
      }
      [_lookup](object) {
        let rest = this[_rest$];
        if (rest == null) return null;
        let bucket = this[_getBucket$](rest, object);
        let index = this[_findBucketIndex](bucket, object);
        if (dart.notNull(index) < 0) return null;
        return dart.as(bucket[dartx.get](index), E);
      }
      add(element) {
        dart.as(element, E);
        if (dart.notNull(collection._HashSet._isStringElement(element))) {
          let strings = this[_strings$];
          if (strings == null) this[_strings$] = strings = collection._HashSet._newHashTable();
          return this[_addHashTableEntry$](strings, element);
        } else if (dart.notNull(collection._HashSet._isNumericElement(element))) {
          let nums = this[_nums$];
          if (nums == null) this[_nums$] = nums = collection._HashSet._newHashTable();
          return this[_addHashTableEntry$](nums, element);
        } else {
          return this[_add$0](element);
        }
      }
      [_add$0](element) {
        dart.as(element, E);
        let rest = this[_rest$];
        if (rest == null) this[_rest$] = rest = collection._HashSet._newHashTable();
        let hash = this[_computeHashCode](element);
        let bucket = rest[hash];
        if (bucket == null) {
          collection._HashSet._setTableEntry(rest, hash, [element]);
        } else {
          let index = this[_findBucketIndex](bucket, element);
          if (dart.notNull(index) >= 0) return false;
          bucket.push(element);
        }
        this[_length$1] = dart.notNull(this[_length$1]) + 1;
        this[_elements] = null;
        return true;
      }
      addAll(objects) {
        dart.as(objects, core.Iterable$(E));
        for (let each of objects) {
          this.add(each);
        }
      }
      remove(object) {
        if (dart.notNull(collection._HashSet._isStringElement(object))) {
          return this[_removeHashTableEntry$](this[_strings$], object);
        } else if (dart.notNull(collection._HashSet._isNumericElement(object))) {
          return this[_removeHashTableEntry$](this[_nums$], object);
        } else {
          return this[_remove](object);
        }
      }
      [_remove](object) {
        let rest = this[_rest$];
        if (rest == null) return false;
        let bucket = this[_getBucket$](rest, object);
        let index = this[_findBucketIndex](bucket, object);
        if (dart.notNull(index) < 0) return false;
        this[_length$1] = dart.notNull(this[_length$1]) - 1;
        this[_elements] = null;
        bucket.splice(index, 1);
        return true;
      }
      clear() {
        if (dart.notNull(this[_length$1]) > 0) {
          this[_strings$] = this[_nums$] = this[_rest$] = this[_elements] = null;
          this[_length$1] = 0;
        }
      }
      [_computeElements]() {
        if (this[_elements] != null) return this[_elements];
        let result = core.List.new(this[_length$1]);
        let index = 0;
        let strings = this[_strings$];
        if (strings != null) {
          let names = Object.getOwnPropertyNames(strings);
          let entries = names.length;
          for (let i = 0; i < entries; i++) {
            let element = names[i];
            result[index] = element;
            index++;
          }
        }
        let nums = this[_nums$];
        if (nums != null) {
          let names = Object.getOwnPropertyNames(nums);
          let entries = names.length;
          for (let i = 0; i < entries; i++) {
            let element = +names[i];
            result[index] = element;
            index++;
          }
        }
        let rest = this[_rest$];
        if (rest != null) {
          let names = Object.getOwnPropertyNames(rest);
          let entries = names.length;
          for (let i = 0; i < entries; i++) {
            let entry = names[i];
            let bucket = rest[entry];
            let length = bucket.length;
            for (let i = 0; i < length; i++) {
              result[index] = bucket[i];
              index++;
            }
          }
        }
        dart.assert(index == this[_length$1]);
        return this[_elements] = result;
      }
      [_addHashTableEntry$](table, element) {
        dart.as(element, E);
        if (dart.notNull(collection._HashSet._hasTableEntry(table, element))) return false;
        collection._HashSet._setTableEntry(table, element, 0);
        this[_length$1] = dart.notNull(this[_length$1]) + 1;
        this[_elements] = null;
        return true;
      }
      [_removeHashTableEntry$](table, element) {
        if (table != null && dart.notNull(collection._HashSet._hasTableEntry(table, element))) {
          collection._HashSet._deleteTableEntry(table, element);
          this[_length$1] = dart.notNull(this[_length$1]) - 1;
          this[_elements] = null;
          return true;
        } else {
          return false;
        }
      }
      static _isStringElement(element) {
        return typeof element == 'string' && element != '__proto__';
      }
      static _isNumericElement(element) {
        return typeof element == 'number' && (element & 0x3ffffff) === element;
      }
      [_computeHashCode](element) {
        return dart.hashCode(element) & 0x3ffffff;
      }
      static _hasTableEntry(table, key) {
        let entry = table[key];
        return entry != null;
      }
      static _setTableEntry(table, key, value) {
        dart.assert(value != null);
        table[key] = value;
      }
      static _deleteTableEntry(table, key) {
        delete table[key];
      }
      [_getBucket$](table, element) {
        let hash = this[_computeHashCode](element);
        return table[hash];
      }
      [_findBucketIndex](bucket, element) {
        if (bucket == null) return -1;
        let length = bucket.length;
        for (let i = 0; i < length; i++) {
          if (dart.equals(bucket[i], element)) return i;
        }
        return -1;
      }
      static _newHashTable() {
        let table = Object.create(null);
        let temporaryKey = '<non-identifier-key>';
        collection._HashSet._setTableEntry(table, temporaryKey, table);
        collection._HashSet._deleteTableEntry(table, temporaryKey);
        return table;
      }
    }
    _HashSet[dart.implements] = () => [collection.HashSet$(E)];
    dart.setSignature(_HashSet, {
      constructors: () => ({_HashSet: [collection._HashSet$(E), []]}),
      methods: () => ({
        [_newSet]: [core.Set$(E), []],
        contains: [core.bool, [core.Object]],
        [_contains]: [core.bool, [core.Object]],
        lookup: [E, [core.Object]],
        [_lookup]: [E, [core.Object]],
        add: [core.bool, [E]],
        [_add$0]: [core.bool, [E]],
        addAll: [dart.void, [core.Iterable$(E)]],
        remove: [core.bool, [core.Object]],
        [_remove]: [core.bool, [core.Object]],
        [_computeElements]: [core.List, []],
        [_addHashTableEntry$]: [core.bool, [dart.dynamic, E]],
        [_removeHashTableEntry$]: [core.bool, [dart.dynamic, core.Object]],
        [_computeHashCode]: [core.int, [dart.dynamic]],
        [_getBucket$]: [core.List, [dart.dynamic, dart.dynamic]],
        [_findBucketIndex]: [core.int, [dart.dynamic, dart.dynamic]]
      }),
      statics: () => ({
        _isStringElement: [core.bool, [dart.dynamic]],
        _isNumericElement: [core.bool, [dart.dynamic]],
        _hasTableEntry: [core.bool, [dart.dynamic, dart.dynamic]],
        _setTableEntry: [dart.void, [dart.dynamic, dart.dynamic, dart.dynamic]],
        _deleteTableEntry: [dart.void, [dart.dynamic, dart.dynamic]],
        _newHashTable: [dart.dynamic, []]
      }),
      names: ['_isStringElement', '_isNumericElement', '_hasTableEntry', '_setTableEntry', '_deleteTableEntry', '_newHashTable']
    });
    dart.defineExtensionMembers(_HashSet, [
      'contains',
      'iterator',
      'length',
      'isEmpty',
      'isNotEmpty'
    ]);
    return _HashSet;
  });
  collection._HashSet = collection._HashSet$();
  collection._IdentityHashSet$ = dart.generic(E => {
    class _IdentityHashSet extends collection._HashSet$(E) {
      _IdentityHashSet() {
        super._HashSet();
      }
      [_newSet]() {
        return new (collection._IdentityHashSet$(E))();
      }
      [_computeHashCode](key) {
        return core.identityHashCode(key) & 0x3ffffff;
      }
      [_findBucketIndex](bucket, element) {
        if (bucket == null) return -1;
        let length = bucket.length;
        for (let i = 0; i < length; i++) {
          if (core.identical(bucket[i], element)) return i;
        }
        return -1;
      }
    }
    dart.setSignature(_IdentityHashSet, {
      methods: () => ({[_newSet]: [core.Set$(E), []]})
    });
    return _IdentityHashSet;
  });
  collection._IdentityHashSet = collection._IdentityHashSet$();
  const _equality = Symbol('_equality');
  const _hasher = Symbol('_hasher');
  collection._CustomHashSet$ = dart.generic(E => {
    class _CustomHashSet extends collection._HashSet$(E) {
      _CustomHashSet(equality, hasher, validKey) {
        this[_equality] = equality;
        this[_hasher] = hasher;
        this[_validKey] = validKey != null ? validKey : dart.fn(x => dart.is(x, E), core.bool, [core.Object]);
        super._HashSet();
      }
      [_newSet]() {
        return new (collection._CustomHashSet$(E))(this[_equality], this[_hasher], this[_validKey]);
      }
      [_findBucketIndex](bucket, element) {
        if (bucket == null) return -1;
        let length = bucket.length;
        for (let i = 0; i < length; i++) {
          if (dart.notNull(this[_equality](bucket[i], dart.as(element, E)))) return i;
        }
        return -1;
      }
      [_computeHashCode](element) {
        return this[_hasher](dart.as(element, E)) & 0x3ffffff;
      }
      add(object) {
        dart.as(object, E);
        return super[_add$0](object);
      }
      contains(object) {
        if (!dart.notNull(this[_validKey](object))) return false;
        return super[_contains](object);
      }
      lookup(object) {
        if (!dart.notNull(this[_validKey](object))) return null;
        return super[_lookup](object);
      }
      remove(object) {
        if (!dart.notNull(this[_validKey](object))) return false;
        return super[_remove](object);
      }
    }
    dart.setSignature(_CustomHashSet, {
      constructors: () => ({_CustomHashSet: [collection._CustomHashSet$(E), [collection._Equality$(E), collection._Hasher$(E), dart.functionType(core.bool, [core.Object])]]}),
      methods: () => ({
        [_newSet]: [core.Set$(E), []],
        add: [core.bool, [E]],
        lookup: [E, [core.Object]]
      })
    });
    dart.defineExtensionMembers(_CustomHashSet, ['contains']);
    return _CustomHashSet;
  });
  collection._CustomHashSet = collection._CustomHashSet$();
  collection.HashSetIterator$ = dart.generic(E => {
    class HashSetIterator extends core.Object {
      HashSetIterator(set, elements) {
        this[_set] = set;
        this[_elements] = elements;
        this[_offset] = 0;
        this[_current$2] = null;
      }
      get current() {
        return this[_current$2];
      }
      moveNext() {
        let elements = this[_elements];
        let offset = this[_offset];
        if (elements !== dart.dload(this[_set], _elements)) {
          dart.throw(new core.ConcurrentModificationError(this[_set]));
        } else if (dart.notNull(offset) >= elements.length) {
          this[_current$2] = null;
          return false;
        } else {
          this[_current$2] = elements[offset];
          this[_offset] = dart.notNull(offset) + 1;
          return true;
        }
      }
    }
    HashSetIterator[dart.implements] = () => [core.Iterator$(E)];
    dart.setSignature(HashSetIterator, {
      constructors: () => ({HashSetIterator: [collection.HashSetIterator$(E), [dart.dynamic, core.List]]}),
      methods: () => ({moveNext: [core.bool, []]})
    });
    return HashSetIterator;
  });
  collection.HashSetIterator = collection.HashSetIterator$();
  const _unsupported = Symbol('_unsupported');
  const _element = Symbol('_element');
  const _filterWhere = Symbol('_filterWhere');
  collection._LinkedHashSet$ = dart.generic(E => {
    class _LinkedHashSet extends collection._HashSetBase$(E) {
      _LinkedHashSet() {
        this[_length$1] = 0;
        this[_strings$] = null;
        this[_nums$] = null;
        this[_rest$] = null;
        this[_first$] = null;
        this[_last$] = null;
        this[_modifications$] = 0;
      }
      [_newSet]() {
        return new (collection._LinkedHashSet$(E))();
      }
      [_unsupported](operation) {
        dart.throw(`LinkedHashSet: unsupported ${operation}`);
      }
      get iterator() {
        return new (collection.LinkedHashSetIterator$(E))(this, this[_modifications$]);
      }
      get length() {
        return this[_length$1];
      }
      get isEmpty() {
        return this[_length$1] == 0;
      }
      get isNotEmpty() {
        return !dart.notNull(this.isEmpty);
      }
      contains(object) {
        if (dart.notNull(collection._LinkedHashSet._isStringElement(object))) {
          let strings = this[_strings$];
          if (strings == null) return false;
          let cell = dart.as(collection._LinkedHashSet._getTableEntry(strings, object), collection.LinkedHashSetCell);
          return cell != null;
        } else if (dart.notNull(collection._LinkedHashSet._isNumericElement(object))) {
          let nums = this[_nums$];
          if (nums == null) return false;
          let cell = dart.as(collection._LinkedHashSet._getTableEntry(nums, object), collection.LinkedHashSetCell);
          return cell != null;
        } else {
          return this[_contains](object);
        }
      }
      [_contains](object) {
        let rest = this[_rest$];
        if (rest == null) return false;
        let bucket = this[_getBucket$](rest, object);
        return dart.notNull(this[_findBucketIndex](bucket, object)) >= 0;
      }
      lookup(object) {
        if (dart.notNull(collection._LinkedHashSet._isStringElement(object)) || dart.notNull(collection._LinkedHashSet._isNumericElement(object))) {
          return dart.as(dart.notNull(this.contains(object)) ? object : null, E);
        } else {
          return this[_lookup](object);
        }
      }
      [_lookup](object) {
        let rest = this[_rest$];
        if (rest == null) return null;
        let bucket = this[_getBucket$](rest, object);
        let index = this[_findBucketIndex](bucket, object);
        if (dart.notNull(index) < 0) return null;
        return dart.as(dart.dload(bucket[dartx.get](index), _element), E);
      }
      forEach(action) {
        dart.as(action, dart.functionType(dart.void, [E]));
        let cell = this[_first$];
        let modifications = this[_modifications$];
        while (cell != null) {
          action(dart.as(cell[_element], E));
          if (modifications != this[_modifications$]) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
          cell = cell[_next$0];
        }
      }
      get first() {
        if (this[_first$] == null) dart.throw(new core.StateError("No elements"));
        return dart.as(this[_first$][_element], E);
      }
      get last() {
        if (this[_last$] == null) dart.throw(new core.StateError("No elements"));
        return dart.as(this[_last$][_element], E);
      }
      add(element) {
        dart.as(element, E);
        if (dart.notNull(collection._LinkedHashSet._isStringElement(element))) {
          let strings = this[_strings$];
          if (strings == null) this[_strings$] = strings = collection._LinkedHashSet._newHashTable();
          return this[_addHashTableEntry$](strings, element);
        } else if (dart.notNull(collection._LinkedHashSet._isNumericElement(element))) {
          let nums = this[_nums$];
          if (nums == null) this[_nums$] = nums = collection._LinkedHashSet._newHashTable();
          return this[_addHashTableEntry$](nums, element);
        } else {
          return this[_add$0](element);
        }
      }
      [_add$0](element) {
        dart.as(element, E);
        let rest = this[_rest$];
        if (rest == null) this[_rest$] = rest = collection._LinkedHashSet._newHashTable();
        let hash = this[_computeHashCode](element);
        let bucket = rest[hash];
        if (bucket == null) {
          let cell = this[_newLinkedCell$](element);
          collection._LinkedHashSet._setTableEntry(rest, hash, [cell]);
        } else {
          let index = this[_findBucketIndex](bucket, element);
          if (dart.notNull(index) >= 0) return false;
          let cell = this[_newLinkedCell$](element);
          bucket.push(cell);
        }
        return true;
      }
      remove(object) {
        if (dart.notNull(collection._LinkedHashSet._isStringElement(object))) {
          return this[_removeHashTableEntry$](this[_strings$], object);
        } else if (dart.notNull(collection._LinkedHashSet._isNumericElement(object))) {
          return this[_removeHashTableEntry$](this[_nums$], object);
        } else {
          return this[_remove](object);
        }
      }
      [_remove](object) {
        let rest = this[_rest$];
        if (rest == null) return false;
        let bucket = this[_getBucket$](rest, object);
        let index = this[_findBucketIndex](bucket, object);
        if (dart.notNull(index) < 0) return false;
        let cell = bucket.splice(index, 1)[0];
        this[_unlinkCell$](cell);
        return true;
      }
      removeWhere(test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        this[_filterWhere](test, true);
      }
      retainWhere(test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        this[_filterWhere](test, false);
      }
      [_filterWhere](test, removeMatching) {
        dart.as(test, dart.functionType(core.bool, [E]));
        let cell = this[_first$];
        while (cell != null) {
          let element = dart.as(cell[_element], E);
          let next = cell[_next$0];
          let modifications = this[_modifications$];
          let shouldRemove = removeMatching == test(element);
          if (modifications != this[_modifications$]) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
          if (shouldRemove) this.remove(element);
          cell = next;
        }
      }
      clear() {
        if (dart.notNull(this[_length$1]) > 0) {
          this[_strings$] = this[_nums$] = this[_rest$] = this[_first$] = this[_last$] = null;
          this[_length$1] = 0;
          this[_modified$]();
        }
      }
      [_addHashTableEntry$](table, element) {
        dart.as(element, E);
        let cell = dart.as(collection._LinkedHashSet._getTableEntry(table, element), collection.LinkedHashSetCell);
        if (cell != null) return false;
        collection._LinkedHashSet._setTableEntry(table, element, this[_newLinkedCell$](element));
        return true;
      }
      [_removeHashTableEntry$](table, element) {
        if (table == null) return false;
        let cell = dart.as(collection._LinkedHashSet._getTableEntry(table, element), collection.LinkedHashSetCell);
        if (cell == null) return false;
        this[_unlinkCell$](cell);
        collection._LinkedHashSet._deleteTableEntry(table, element);
        return true;
      }
      [_modified$]() {
        this[_modifications$] = dart.notNull(this[_modifications$]) + 1 & 67108863;
      }
      [_newLinkedCell$](element) {
        dart.as(element, E);
        let cell = new collection.LinkedHashSetCell(element);
        if (this[_first$] == null) {
          this[_first$] = this[_last$] = cell;
        } else {
          let last = this[_last$];
          cell[_previous$0] = last;
          this[_last$] = last[_next$0] = cell;
        }
        this[_length$1] = dart.notNull(this[_length$1]) + 1;
        this[_modified$]();
        return cell;
      }
      [_unlinkCell$](cell) {
        let previous = cell[_previous$0];
        let next = cell[_next$0];
        if (previous == null) {
          dart.assert(dart.equals(cell, this[_first$]));
          this[_first$] = next;
        } else {
          previous[_next$0] = next;
        }
        if (next == null) {
          dart.assert(dart.equals(cell, this[_last$]));
          this[_last$] = previous;
        } else {
          next[_previous$0] = previous;
        }
        this[_length$1] = dart.notNull(this[_length$1]) - 1;
        this[_modified$]();
      }
      static _isStringElement(element) {
        return typeof element == 'string' && element != '__proto__';
      }
      static _isNumericElement(element) {
        return typeof element == 'number' && (element & 0x3ffffff) === element;
      }
      [_computeHashCode](element) {
        return dart.hashCode(element) & 0x3ffffff;
      }
      static _getTableEntry(table, key) {
        return table[key];
      }
      static _setTableEntry(table, key, value) {
        dart.assert(value != null);
        table[key] = value;
      }
      static _deleteTableEntry(table, key) {
        delete table[key];
      }
      [_getBucket$](table, element) {
        let hash = this[_computeHashCode](element);
        return table[hash];
      }
      [_findBucketIndex](bucket, element) {
        if (bucket == null) return -1;
        let length = bucket.length;
        for (let i = 0; i < length; i++) {
          let cell = bucket[i];
          if (dart.equals(cell[_element], element)) return i;
        }
        return -1;
      }
      static _newHashTable() {
        let table = Object.create(null);
        let temporaryKey = '<non-identifier-key>';
        collection._LinkedHashSet._setTableEntry(table, temporaryKey, table);
        collection._LinkedHashSet._deleteTableEntry(table, temporaryKey);
        return table;
      }
    }
    _LinkedHashSet[dart.implements] = () => [collection.LinkedHashSet$(E)];
    dart.setSignature(_LinkedHashSet, {
      constructors: () => ({_LinkedHashSet: [collection._LinkedHashSet$(E), []]}),
      methods: () => ({
        [_newSet]: [core.Set$(E), []],
        [_unsupported]: [dart.void, [core.String]],
        contains: [core.bool, [core.Object]],
        [_contains]: [core.bool, [core.Object]],
        lookup: [E, [core.Object]],
        [_lookup]: [E, [core.Object]],
        forEach: [dart.void, [dart.functionType(dart.void, [E])]],
        add: [core.bool, [E]],
        [_add$0]: [core.bool, [E]],
        remove: [core.bool, [core.Object]],
        [_remove]: [core.bool, [core.Object]],
        removeWhere: [dart.void, [dart.functionType(core.bool, [E])]],
        retainWhere: [dart.void, [dart.functionType(core.bool, [E])]],
        [_filterWhere]: [dart.void, [dart.functionType(core.bool, [E]), core.bool]],
        [_addHashTableEntry$]: [core.bool, [dart.dynamic, E]],
        [_removeHashTableEntry$]: [core.bool, [dart.dynamic, core.Object]],
        [_modified$]: [dart.void, []],
        [_newLinkedCell$]: [collection.LinkedHashSetCell, [E]],
        [_unlinkCell$]: [dart.void, [collection.LinkedHashSetCell]],
        [_computeHashCode]: [core.int, [dart.dynamic]],
        [_getBucket$]: [core.List, [dart.dynamic, dart.dynamic]],
        [_findBucketIndex]: [core.int, [dart.dynamic, dart.dynamic]]
      }),
      statics: () => ({
        _isStringElement: [core.bool, [dart.dynamic]],
        _isNumericElement: [core.bool, [dart.dynamic]],
        _getTableEntry: [dart.dynamic, [dart.dynamic, dart.dynamic]],
        _setTableEntry: [dart.void, [dart.dynamic, dart.dynamic, dart.dynamic]],
        _deleteTableEntry: [dart.void, [dart.dynamic, dart.dynamic]],
        _newHashTable: [dart.dynamic, []]
      }),
      names: ['_isStringElement', '_isNumericElement', '_getTableEntry', '_setTableEntry', '_deleteTableEntry', '_newHashTable']
    });
    dart.defineExtensionMembers(_LinkedHashSet, [
      'contains',
      'forEach',
      'iterator',
      'length',
      'isEmpty',
      'isNotEmpty',
      'first',
      'last'
    ]);
    return _LinkedHashSet;
  });
  collection._LinkedHashSet = collection._LinkedHashSet$();
  collection._LinkedIdentityHashSet$ = dart.generic(E => {
    class _LinkedIdentityHashSet extends collection._LinkedHashSet$(E) {
      _LinkedIdentityHashSet() {
        super._LinkedHashSet();
      }
      [_newSet]() {
        return new (collection._LinkedIdentityHashSet$(E))();
      }
      [_computeHashCode](key) {
        return core.identityHashCode(key) & 0x3ffffff;
      }
      [_findBucketIndex](bucket, element) {
        if (bucket == null) return -1;
        let length = bucket.length;
        for (let i = 0; i < length; i++) {
          let cell = bucket[i];
          if (core.identical(cell[_element], element)) return i;
        }
        return -1;
      }
    }
    dart.setSignature(_LinkedIdentityHashSet, {
      methods: () => ({[_newSet]: [core.Set$(E), []]})
    });
    return _LinkedIdentityHashSet;
  });
  collection._LinkedIdentityHashSet = collection._LinkedIdentityHashSet$();
  collection._LinkedCustomHashSet$ = dart.generic(E => {
    class _LinkedCustomHashSet extends collection._LinkedHashSet$(E) {
      _LinkedCustomHashSet(equality, hasher, validKey) {
        this[_equality] = equality;
        this[_hasher] = hasher;
        this[_validKey] = validKey != null ? validKey : dart.fn(x => dart.is(x, E), core.bool, [core.Object]);
        super._LinkedHashSet();
      }
      [_newSet]() {
        return new (collection._LinkedCustomHashSet$(E))(this[_equality], this[_hasher], this[_validKey]);
      }
      [_findBucketIndex](bucket, element) {
        if (bucket == null) return -1;
        let length = bucket.length;
        for (let i = 0; i < length; i++) {
          let cell = bucket[i];
          if (dart.notNull(this[_equality](dart.as(cell[_element], E), dart.as(element, E)))) return i;
        }
        return -1;
      }
      [_computeHashCode](element) {
        return this[_hasher](dart.as(element, E)) & 0x3ffffff;
      }
      add(element) {
        dart.as(element, E);
        return super[_add$0](element);
      }
      contains(object) {
        if (!dart.notNull(this[_validKey](object))) return false;
        return super[_contains](object);
      }
      lookup(object) {
        if (!dart.notNull(this[_validKey](object))) return null;
        return super[_lookup](object);
      }
      remove(object) {
        if (!dart.notNull(this[_validKey](object))) return false;
        return super[_remove](object);
      }
      containsAll(elements) {
        for (let element of elements) {
          if (!dart.notNull(this[_validKey](element)) || !dart.notNull(this.contains(element))) return false;
        }
        return true;
      }
      removeAll(elements) {
        for (let element of elements) {
          if (dart.notNull(this[_validKey](element))) {
            super[_remove](element);
          }
        }
      }
    }
    dart.setSignature(_LinkedCustomHashSet, {
      constructors: () => ({_LinkedCustomHashSet: [collection._LinkedCustomHashSet$(E), [collection._Equality$(E), collection._Hasher$(E), dart.functionType(core.bool, [core.Object])]]}),
      methods: () => ({
        [_newSet]: [core.Set$(E), []],
        add: [core.bool, [E]],
        lookup: [E, [core.Object]]
      })
    });
    dart.defineExtensionMembers(_LinkedCustomHashSet, ['contains']);
    return _LinkedCustomHashSet;
  });
  collection._LinkedCustomHashSet = collection._LinkedCustomHashSet$();
  collection.LinkedHashSetCell = class LinkedHashSetCell extends core.Object {
    LinkedHashSetCell(element) {
      this[_element] = element;
      this[_next$0] = null;
      this[_previous$0] = null;
    }
  };
  dart.setSignature(collection.LinkedHashSetCell, {
    constructors: () => ({LinkedHashSetCell: [collection.LinkedHashSetCell, [dart.dynamic]]})
  });
  collection.LinkedHashSetIterator$ = dart.generic(E => {
    class LinkedHashSetIterator extends core.Object {
      LinkedHashSetIterator(set, modifications) {
        this[_set] = set;
        this[_modifications$] = modifications;
        this[_cell$] = null;
        this[_current$2] = null;
        this[_cell$] = dart.as(dart.dload(this[_set], _first$), collection.LinkedHashSetCell);
      }
      get current() {
        return this[_current$2];
      }
      moveNext() {
        if (!dart.equals(this[_modifications$], dart.dload(this[_set], _modifications$))) {
          dart.throw(new core.ConcurrentModificationError(this[_set]));
        } else if (this[_cell$] == null) {
          this[_current$2] = null;
          return false;
        } else {
          this[_current$2] = dart.as(this[_cell$][_element], E);
          this[_cell$] = this[_cell$][_next$0];
          return true;
        }
      }
    }
    LinkedHashSetIterator[dart.implements] = () => [core.Iterator$(E)];
    dart.setSignature(LinkedHashSetIterator, {
      constructors: () => ({LinkedHashSetIterator: [collection.LinkedHashSetIterator$(E), [dart.dynamic, core.int]]}),
      methods: () => ({moveNext: [core.bool, []]})
    });
    return LinkedHashSetIterator;
  });
  collection.LinkedHashSetIterator = collection.LinkedHashSetIterator$();
  const _source$0 = Symbol('_source');
  collection.UnmodifiableListView$ = dart.generic(E => {
    class UnmodifiableListView extends _internal.UnmodifiableListBase$(E) {
      UnmodifiableListView(source) {
        this[_source$0] = source;
      }
      get length() {
        return this[_source$0][dartx.length];
      }
      set length(value) {
        super.length = value;
      }
      get(index) {
        return this[_source$0][dartx.elementAt](index);
      }
    }
    dart.setSignature(UnmodifiableListView, {
      constructors: () => ({UnmodifiableListView: [collection.UnmodifiableListView$(E), [core.Iterable$(E)]]}),
      methods: () => ({get: [E, [core.int]]})
    });
    dart.defineExtensionMembers(UnmodifiableListView, ['get', 'length']);
    return UnmodifiableListView;
  });
  collection.UnmodifiableListView = collection.UnmodifiableListView$();
  collection._defaultEquals = function(a, b) {
    return dart.equals(a, b);
  };
  dart.lazyFn(collection._defaultEquals, () => [core.bool, [dart.dynamic, dart.dynamic]]);
  collection._defaultHashCode = function(a) {
    return dart.hashCode(a);
  };
  dart.fn(collection._defaultHashCode, core.int, [dart.dynamic]);
  collection._Equality$ = dart.generic(K => {
    const _Equality = dart.typedef('_Equality', () => dart.functionType(core.bool, [K, K]));
    return _Equality;
  });
  collection._Equality = collection._Equality$();
  collection._Hasher$ = dart.generic(K => {
    const _Hasher = dart.typedef('_Hasher', () => dart.functionType(core.int, [K]));
    return _Hasher;
  });
  collection._Hasher = collection._Hasher$();
  collection.HashMap$ = dart.generic((K, V) => {
    class HashMap extends core.Object {
      static new(opts) {
        let equals = opts && 'equals' in opts ? opts.equals : null;
        let hashCode = opts && 'hashCode' in opts ? opts.hashCode : null;
        let isValidKey = opts && 'isValidKey' in opts ? opts.isValidKey : null;
        if (isValidKey == null) {
          if (hashCode == null) {
            if (equals == null) {
              return new (collection._HashMap$(K, V))();
            }
            hashCode = collection._defaultHashCode;
          } else {
            if (core.identical(core.identityHashCode, hashCode) && core.identical(core.identical, equals)) {
              return new (collection._IdentityHashMap$(K, V))();
            }
            if (equals == null) {
              equals = collection._defaultEquals;
            }
          }
        } else {
          if (hashCode == null) {
            hashCode = collection._defaultHashCode;
          }
          if (equals == null) {
            equals = collection._defaultEquals;
          }
        }
        return new (collection._CustomHashMap$(K, V))(equals, hashCode, isValidKey);
      }
      static identity() {
        return new (collection._IdentityHashMap$(K, V))();
      }
      static from(other) {
        let result = collection.HashMap$(K, V).new();
        other[dartx.forEach](dart.fn((k, v) => {
          result.set(dart.as(k, K), dart.as(v, V));
        }, dart.void, [dart.dynamic, dart.dynamic]));
        return result;
      }
      static fromIterable(iterable, opts) {
        let key = opts && 'key' in opts ? opts.key : null;
        let value = opts && 'value' in opts ? opts.value : null;
        let map = collection.HashMap$(K, V).new();
        collection.Maps._fillMapWithMappedIterable(map, iterable, key, value);
        return map;
      }
      static fromIterables(keys, values) {
        let map = collection.HashMap$(K, V).new();
        collection.Maps._fillMapWithIterables(map, keys, values);
        return map;
      }
    }
    HashMap[dart.implements] = () => [core.Map$(K, V)];
    dart.setSignature(HashMap, {
      constructors: () => ({
        new: [collection.HashMap$(K, V), [], {equals: dart.functionType(core.bool, [K, K]), hashCode: dart.functionType(core.int, [K]), isValidKey: dart.functionType(core.bool, [core.Object])}],
        identity: [collection.HashMap$(K, V), []],
        from: [collection.HashMap$(K, V), [core.Map]],
        fromIterable: [collection.HashMap$(K, V), [core.Iterable], {key: dart.functionType(K, [dart.dynamic]), value: dart.functionType(V, [dart.dynamic])}],
        fromIterables: [collection.HashMap$(K, V), [core.Iterable$(K), core.Iterable$(V)]]
      })
    });
    return HashMap;
  });
  collection.HashMap = collection.HashMap$();
  collection.HashSet$ = dart.generic(E => {
    class HashSet extends core.Object {
      static new(opts) {
        let equals = opts && 'equals' in opts ? opts.equals : null;
        let hashCode = opts && 'hashCode' in opts ? opts.hashCode : null;
        let isValidKey = opts && 'isValidKey' in opts ? opts.isValidKey : null;
        if (isValidKey == null) {
          if (hashCode == null) {
            if (equals == null) {
              return new (collection._HashSet$(E))();
            }
            hashCode = collection._defaultHashCode;
          } else {
            if (core.identical(core.identityHashCode, hashCode) && core.identical(core.identical, equals)) {
              return new (collection._IdentityHashSet$(E))();
            }
            if (equals == null) {
              equals = collection._defaultEquals;
            }
          }
        } else {
          if (hashCode == null) {
            hashCode = collection._defaultHashCode;
          }
          if (equals == null) {
            equals = collection._defaultEquals;
          }
        }
        return new (collection._CustomHashSet$(E))(equals, hashCode, isValidKey);
      }
      static identity() {
        return new (collection._IdentityHashSet$(E))();
      }
      static from(elements) {
        let result = collection.HashSet$(E).new();
        for (let e of elements)
          result.add(dart.as(e, E));
        return result;
      }
      [Symbol.iterator]() {
        return new dart.JsIterator(this.iterator);
      }
    }
    HashSet[dart.implements] = () => [core.Set$(E)];
    dart.setSignature(HashSet, {
      constructors: () => ({
        new: [collection.HashSet$(E), [], {equals: dart.functionType(core.bool, [E, E]), hashCode: dart.functionType(core.int, [E]), isValidKey: dart.functionType(core.bool, [core.Object])}],
        identity: [collection.HashSet$(E), []],
        from: [collection.HashSet$(E), [core.Iterable]]
      })
    });
    return HashSet;
  });
  collection.HashSet = collection.HashSet$();
  collection.IterableMixin$ = dart.generic(E => {
    class IterableMixin extends core.Object {
      map(T) {
        return f => {
          dart.as(f, dart.functionType(T, [E]));
          return _internal.MappedIterable$(E, T).new(this, f);
        };
      }
      where(f) {
        dart.as(f, dart.functionType(core.bool, [E]));
        return new (_internal.WhereIterable$(E))(this, f);
      }
      expand(T) {
        return f => {
          dart.as(f, dart.functionType(core.Iterable$(T), [E]));
          return new (_internal.ExpandIterable$(E, T))(this, f);
        };
      }
      contains(element) {
        for (let e of this) {
          if (dart.equals(e, element)) return true;
        }
        return false;
      }
      forEach(f) {
        dart.as(f, dart.functionType(dart.void, [E]));
        for (let element of this)
          f(element);
      }
      reduce(combine) {
        dart.as(combine, dart.functionType(E, [E, E]));
        let iterator = this.iterator;
        if (!dart.notNull(iterator.moveNext())) {
          dart.throw(_internal.IterableElementError.noElement());
        }
        let value = iterator.current;
        while (dart.notNull(iterator.moveNext())) {
          value = combine(value, iterator.current);
        }
        return value;
      }
      fold(T) {
        return (initialValue, combine) => {
          dart.as(combine, dart.functionType(T, [T, E]));
          let value = initialValue;
          for (let element of this)
            value = combine(value, element);
          return value;
        };
      }
      every(f) {
        dart.as(f, dart.functionType(core.bool, [E]));
        for (let element of this) {
          if (!dart.notNull(f(element))) return false;
        }
        return true;
      }
      join(separator) {
        if (separator === void 0) separator = "";
        let iterator = this.iterator;
        if (!dart.notNull(iterator.moveNext())) return "";
        let buffer = new core.StringBuffer();
        if (separator == null || separator == "") {
          do {
            buffer.write(`${iterator.current}`);
          } while (dart.notNull(iterator.moveNext()));
        } else {
          buffer.write(`${iterator.current}`);
          while (dart.notNull(iterator.moveNext())) {
            buffer.write(separator);
            buffer.write(`${iterator.current}`);
          }
        }
        return buffer.toString();
      }
      any(f) {
        dart.as(f, dart.functionType(core.bool, [E]));
        for (let element of this) {
          if (dart.notNull(f(element))) return true;
        }
        return false;
      }
      toList(opts) {
        let growable = opts && 'growable' in opts ? opts.growable : true;
        return core.List$(E).from(this, {growable: growable});
      }
      toSet() {
        return core.Set$(E).from(this);
      }
      get length() {
        dart.assert(!dart.is(this, _internal.EfficientLength));
        let count = 0;
        let it = this[dartx.iterator];
        while (dart.notNull(it.moveNext())) {
          count++;
        }
        return count;
      }
      get isEmpty() {
        return !dart.notNull(this[dartx.iterator].moveNext());
      }
      get isNotEmpty() {
        return !dart.notNull(this.isEmpty);
      }
      take(count) {
        return _internal.TakeIterable$(E).new(this, count);
      }
      takeWhile(test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        return new (_internal.TakeWhileIterable$(E))(this, test);
      }
      skip(count) {
        return _internal.SkipIterable$(E).new(this, count);
      }
      skipWhile(test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        return new (_internal.SkipWhileIterable$(E))(this, test);
      }
      get first() {
        let it = this[dartx.iterator];
        if (!dart.notNull(it.moveNext())) {
          dart.throw(_internal.IterableElementError.noElement());
        }
        return it.current;
      }
      get last() {
        let it = this[dartx.iterator];
        if (!dart.notNull(it.moveNext())) {
          dart.throw(_internal.IterableElementError.noElement());
        }
        let result = null;
        do {
          result = it.current;
        } while (dart.notNull(it.moveNext()));
        return result;
      }
      get single() {
        let it = this[dartx.iterator];
        if (!dart.notNull(it.moveNext())) dart.throw(_internal.IterableElementError.noElement());
        let result = it.current;
        if (dart.notNull(it.moveNext())) dart.throw(_internal.IterableElementError.tooMany());
        return result;
      }
      firstWhere(test, opts) {
        dart.as(test, dart.functionType(core.bool, [E]));
        let orElse = opts && 'orElse' in opts ? opts.orElse : null;
        dart.as(orElse, dart.functionType(E, []));
        for (let element of this) {
          if (dart.notNull(test(element))) return element;
        }
        if (orElse != null) return orElse();
        dart.throw(_internal.IterableElementError.noElement());
      }
      lastWhere(test, opts) {
        dart.as(test, dart.functionType(core.bool, [E]));
        let orElse = opts && 'orElse' in opts ? opts.orElse : null;
        dart.as(orElse, dart.functionType(E, []));
        let result = null;
        let foundMatching = false;
        for (let element of this) {
          if (dart.notNull(test(element))) {
            result = element;
            foundMatching = true;
          }
        }
        if (foundMatching) return result;
        if (orElse != null) return orElse();
        dart.throw(_internal.IterableElementError.noElement());
      }
      singleWhere(test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        let result = null;
        let foundMatching = false;
        for (let element of this) {
          if (dart.notNull(test(element))) {
            if (foundMatching) {
              dart.throw(_internal.IterableElementError.tooMany());
            }
            result = element;
            foundMatching = true;
          }
        }
        if (foundMatching) return result;
        dart.throw(_internal.IterableElementError.noElement());
      }
      elementAt(index) {
        if (!(typeof index == 'number')) dart.throw(new core.ArgumentError.notNull("index"));
        core.RangeError.checkNotNegative(index, "index");
        let elementIndex = 0;
        for (let element of this) {
          if (index == elementIndex) return element;
          elementIndex++;
        }
        dart.throw(core.RangeError.index(index, this, "index", null, elementIndex));
      }
      toString() {
        return collection.IterableBase.iterableToShortString(this, '(', ')');
      }
      [Symbol.iterator]() {
        return new dart.JsIterator(this.iterator);
      }
    }
    IterableMixin[dart.implements] = () => [core.Iterable$(E)];
    dart.setSignature(IterableMixin, {
      methods: () => ({
        map: [T => [core.Iterable$(T), [dart.functionType(T, [E])]]],
        where: [core.Iterable$(E), [dart.functionType(core.bool, [E])]],
        expand: [T => [core.Iterable$(T), [dart.functionType(core.Iterable$(T), [E])]]],
        contains: [core.bool, [core.Object]],
        forEach: [dart.void, [dart.functionType(dart.void, [E])]],
        reduce: [E, [dart.functionType(E, [E, E])]],
        fold: [T => [T, [T, dart.functionType(T, [T, E])]]],
        every: [core.bool, [dart.functionType(core.bool, [E])]],
        join: [core.String, [], [core.String]],
        any: [core.bool, [dart.functionType(core.bool, [E])]],
        toList: [core.List$(E), [], {growable: core.bool}],
        toSet: [core.Set$(E), []],
        take: [core.Iterable$(E), [core.int]],
        takeWhile: [core.Iterable$(E), [dart.functionType(core.bool, [E])]],
        skip: [core.Iterable$(E), [core.int]],
        skipWhile: [core.Iterable$(E), [dart.functionType(core.bool, [E])]],
        firstWhere: [E, [dart.functionType(core.bool, [E])], {orElse: dart.functionType(E, [])}],
        lastWhere: [E, [dart.functionType(core.bool, [E])], {orElse: dart.functionType(E, [])}],
        singleWhere: [E, [dart.functionType(core.bool, [E])]],
        elementAt: [E, [core.int]]
      })
    });
    dart.defineExtensionMembers(IterableMixin, [
      'map',
      'where',
      'expand',
      'contains',
      'forEach',
      'reduce',
      'fold',
      'every',
      'join',
      'any',
      'toList',
      'toSet',
      'take',
      'takeWhile',
      'skip',
      'skipWhile',
      'firstWhere',
      'lastWhere',
      'singleWhere',
      'elementAt',
      'toString',
      'length',
      'isEmpty',
      'isNotEmpty',
      'first',
      'last',
      'single'
    ]);
    return IterableMixin;
  });
  collection.IterableMixin = collection.IterableMixin$();
  dart.defineLazy(collection, {
    get _toStringVisiting() {
      return [];
    }
  });
  collection._isToStringVisiting = function(o) {
    for (let i = 0; i < dart.notNull(collection._toStringVisiting[dartx.length]); i++) {
      if (core.identical(o, collection._toStringVisiting[dartx.get](i))) return true;
    }
    return false;
  };
  dart.lazyFn(collection._isToStringVisiting, () => [core.bool, [core.Object]]);
  collection._iterablePartsToStrings = function(iterable, parts) {
    let LENGTH_LIMIT = 80;
    let HEAD_COUNT = 3;
    let TAIL_COUNT = 2;
    let MAX_COUNT = 100;
    let OVERHEAD = 2;
    let ELLIPSIS_SIZE = 3;
    let length = 0;
    let count = 0;
    let it = iterable[dartx.iterator];
    while (dart.notNull(length) < LENGTH_LIMIT || count < HEAD_COUNT) {
      if (!dart.notNull(it.moveNext())) return;
      let next = `${it.current}`;
      parts[dartx.add](next);
      length = dart.notNull(length) + (dart.notNull(next[dartx.length]) + OVERHEAD);
      count++;
    }
    let penultimateString = null;
    let ultimateString = null;
    let penultimate = null;
    let ultimate = null;
    if (!dart.notNull(it.moveNext())) {
      if (count <= HEAD_COUNT + TAIL_COUNT) return;
      ultimateString = dart.as(parts[dartx.removeLast](), core.String);
      penultimateString = dart.as(parts[dartx.removeLast](), core.String);
    } else {
      penultimate = it.current;
      count++;
      if (!dart.notNull(it.moveNext())) {
        if (count <= HEAD_COUNT + 1) {
          parts[dartx.add](`${penultimate}`);
          return;
        }
        ultimateString = `${penultimate}`;
        penultimateString = dart.as(parts[dartx.removeLast](), core.String);
        length = dart.notNull(length) + (dart.notNull(ultimateString[dartx.length]) + OVERHEAD);
      } else {
        ultimate = it.current;
        count++;
        dart.assert(count < MAX_COUNT);
        while (dart.notNull(it.moveNext())) {
          penultimate = ultimate;
          ultimate = it.current;
          count++;
          if (count > MAX_COUNT) {
            while (dart.notNull(length) > LENGTH_LIMIT - ELLIPSIS_SIZE - OVERHEAD && count > HEAD_COUNT) {
              length = dart.notNull(length) - dart.notNull(dart.as(dart.dsend(dart.dload(parts[dartx.removeLast](), 'length'), '+', OVERHEAD), core.int));
              count--;
            }
            parts[dartx.add]("...");
            return;
          }
        }
        penultimateString = `${penultimate}`;
        ultimateString = `${ultimate}`;
        length = dart.notNull(length) + (dart.notNull(ultimateString[dartx.length]) + dart.notNull(penultimateString[dartx.length]) + 2 * OVERHEAD);
      }
    }
    let elision = null;
    if (count > dart.notNull(parts[dartx.length]) + TAIL_COUNT) {
      elision = "...";
      length = dart.notNull(length) + (ELLIPSIS_SIZE + OVERHEAD);
    }
    while (dart.notNull(length) > LENGTH_LIMIT && dart.notNull(parts[dartx.length]) > HEAD_COUNT) {
      length = dart.notNull(length) - dart.notNull(dart.as(dart.dsend(dart.dload(parts[dartx.removeLast](), 'length'), '+', OVERHEAD), core.int));
      if (elision == null) {
        elision = "...";
        length = dart.notNull(length) + (ELLIPSIS_SIZE + OVERHEAD);
      }
    }
    if (elision != null) {
      parts[dartx.add](elision);
    }
    parts[dartx.add](penultimateString);
    parts[dartx.add](ultimateString);
  };
  dart.lazyFn(collection._iterablePartsToStrings, () => [dart.void, [core.Iterable, core.List]]);
  const _iterator$0 = Symbol('_iterator');
  const _state$ = Symbol('_state');
  const _move = Symbol('_move');
  collection.HasNextIterator$ = dart.generic(E => {
    class HasNextIterator extends core.Object {
      HasNextIterator(iterator) {
        this[_iterator$0] = iterator;
        this[_state$] = collection.HasNextIterator._NOT_MOVED_YET;
      }
      get hasNext() {
        if (this[_state$] == collection.HasNextIterator._NOT_MOVED_YET) this[_move]();
        return this[_state$] == collection.HasNextIterator._HAS_NEXT_AND_NEXT_IN_CURRENT;
      }
      next() {
        if (!dart.notNull(this.hasNext)) dart.throw(new core.StateError("No more elements"));
        dart.assert(this[_state$] == collection.HasNextIterator._HAS_NEXT_AND_NEXT_IN_CURRENT);
        let result = this[_iterator$0].current;
        this[_move]();
        return result;
      }
      [_move]() {
        if (dart.notNull(this[_iterator$0].moveNext())) {
          this[_state$] = collection.HasNextIterator._HAS_NEXT_AND_NEXT_IN_CURRENT;
        } else {
          this[_state$] = collection.HasNextIterator._NO_NEXT;
        }
      }
    }
    dart.setSignature(HasNextIterator, {
      constructors: () => ({HasNextIterator: [collection.HasNextIterator$(E), [core.Iterator$(E)]]}),
      methods: () => ({
        next: [E, []],
        [_move]: [dart.void, []]
      })
    });
    return HasNextIterator;
  });
  collection.HasNextIterator = collection.HasNextIterator$();
  collection.HasNextIterator._HAS_NEXT_AND_NEXT_IN_CURRENT = 0;
  collection.HasNextIterator._NO_NEXT = 1;
  collection.HasNextIterator._NOT_MOVED_YET = 2;
  collection.LinkedHashMap$ = dart.generic((K, V) => {
    class LinkedHashMap extends core.Object {
      static new(opts) {
        let equals = opts && 'equals' in opts ? opts.equals : null;
        let hashCode = opts && 'hashCode' in opts ? opts.hashCode : null;
        let isValidKey = opts && 'isValidKey' in opts ? opts.isValidKey : null;
        if (isValidKey == null) {
          if (hashCode == null) {
            if (equals == null) {
              return new (collection._LinkedHashMap$(K, V))();
            }
            hashCode = collection._defaultHashCode;
          } else {
            if (core.identical(core.identityHashCode, hashCode) && core.identical(core.identical, equals)) {
              return new (collection._LinkedIdentityHashMap$(K, V))();
            }
            if (equals == null) {
              equals = collection._defaultEquals;
            }
          }
        } else {
          if (hashCode == null) {
            hashCode = collection._defaultHashCode;
          }
          if (equals == null) {
            equals = collection._defaultEquals;
          }
        }
        return new (collection._LinkedCustomHashMap$(K, V))(equals, hashCode, isValidKey);
      }
      static identity() {
        return new (collection._LinkedIdentityHashMap$(K, V))();
      }
      static from(other) {
        let result = collection.LinkedHashMap$(K, V).new();
        other[dartx.forEach](dart.fn((k, v) => {
          result.set(dart.as(k, K), dart.as(v, V));
        }, dart.void, [dart.dynamic, dart.dynamic]));
        return result;
      }
      static fromIterable(iterable, opts) {
        let key = opts && 'key' in opts ? opts.key : null;
        let value = opts && 'value' in opts ? opts.value : null;
        let map = collection.LinkedHashMap$(K, V).new();
        collection.Maps._fillMapWithMappedIterable(map, iterable, key, value);
        return map;
      }
      static fromIterables(keys, values) {
        let map = collection.LinkedHashMap$(K, V).new();
        collection.Maps._fillMapWithIterables(map, keys, values);
        return map;
      }
      static _literal(keyValuePairs) {
        return dart.as(_js_helper.fillLiteralMap(keyValuePairs, new (collection._LinkedHashMap$(K, V))()), collection.LinkedHashMap$(K, V));
      }
      static _empty() {
        return new (collection._LinkedHashMap$(K, V))();
      }
    }
    LinkedHashMap[dart.implements] = () => [collection.HashMap$(K, V)];
    dart.setSignature(LinkedHashMap, {
      constructors: () => ({
        new: [collection.LinkedHashMap$(K, V), [], {equals: dart.functionType(core.bool, [K, K]), hashCode: dart.functionType(core.int, [K]), isValidKey: dart.functionType(core.bool, [core.Object])}],
        identity: [collection.LinkedHashMap$(K, V), []],
        from: [collection.LinkedHashMap$(K, V), [core.Map]],
        fromIterable: [collection.LinkedHashMap$(K, V), [core.Iterable], {key: dart.functionType(K, [dart.dynamic]), value: dart.functionType(V, [dart.dynamic])}],
        fromIterables: [collection.LinkedHashMap$(K, V), [core.Iterable$(K), core.Iterable$(V)]],
        _literal: [collection.LinkedHashMap$(K, V), [core.List]],
        _empty: [collection.LinkedHashMap$(K, V), []]
      })
    });
    return LinkedHashMap;
  });
  collection.LinkedHashMap = collection.LinkedHashMap$();
  collection.LinkedHashSet$ = dart.generic(E => {
    class LinkedHashSet extends core.Object {
      static new(opts) {
        let equals = opts && 'equals' in opts ? opts.equals : null;
        let hashCode = opts && 'hashCode' in opts ? opts.hashCode : null;
        let isValidKey = opts && 'isValidKey' in opts ? opts.isValidKey : null;
        if (isValidKey == null) {
          if (hashCode == null) {
            if (equals == null) {
              return new (collection._LinkedHashSet$(E))();
            }
            hashCode = collection._defaultHashCode;
          } else {
            if (core.identical(core.identityHashCode, hashCode) && core.identical(core.identical, equals)) {
              return new (collection._LinkedIdentityHashSet$(E))();
            }
            if (equals == null) {
              equals = collection._defaultEquals;
            }
          }
        } else {
          if (hashCode == null) {
            hashCode = collection._defaultHashCode;
          }
          if (equals == null) {
            equals = collection._defaultEquals;
          }
        }
        return new (collection._LinkedCustomHashSet$(E))(equals, hashCode, isValidKey);
      }
      static identity() {
        return new (collection._LinkedIdentityHashSet$(E))();
      }
      static from(elements) {
        let result = collection.LinkedHashSet$(E).new();
        for (let element of elements) {
          result.add(dart.as(element, E));
        }
        return result;
      }
      [Symbol.iterator]() {
        return new dart.JsIterator(this.iterator);
      }
    }
    LinkedHashSet[dart.implements] = () => [collection.HashSet$(E)];
    dart.setSignature(LinkedHashSet, {
      constructors: () => ({
        new: [collection.LinkedHashSet$(E), [], {equals: dart.functionType(core.bool, [E, E]), hashCode: dart.functionType(core.int, [E]), isValidKey: dart.functionType(core.bool, [core.Object])}],
        identity: [collection.LinkedHashSet$(E), []],
        from: [collection.LinkedHashSet$(E), [core.Iterable]]
      })
    });
    return LinkedHashSet;
  });
  collection.LinkedHashSet = collection.LinkedHashSet$();
  const _modificationCount = Symbol('_modificationCount');
  const _insertBefore$ = Symbol('_insertBefore');
  const _list = Symbol('_list');
  const _unlink$ = Symbol('_unlink');
  collection.LinkedList$ = dart.generic(E => {
    class LinkedList extends core.Iterable$(E) {
      LinkedList() {
        this[_modificationCount] = 0;
        this[_length$1] = 0;
        this[_first$] = null;
        super.Iterable();
      }
      addFirst(entry) {
        dart.as(entry, E);
        this[_insertBefore$](this[_first$], entry, {updateFirst: true});
        this[_first$] = entry;
      }
      add(entry) {
        dart.as(entry, E);
        this[_insertBefore$](this[_first$], entry, {updateFirst: false});
      }
      addAll(entries) {
        dart.as(entries, core.Iterable$(E));
        entries[dartx.forEach](dart.bind(this, 'add'));
      }
      remove(entry) {
        dart.as(entry, E);
        if (!dart.equals(entry[_list], this)) return false;
        this[_unlink$](entry);
        return true;
      }
      get iterator() {
        return new (collection._LinkedListIterator$(E))(this);
      }
      get length() {
        return this[_length$1];
      }
      clear() {
        this[_modificationCount] = dart.notNull(this[_modificationCount]) + 1;
        if (dart.notNull(this.isEmpty)) return;
        let next = this[_first$];
        do {
          let entry = next;
          next = entry[_next$0];
          entry[_next$0] = entry[_previous$0] = entry[_list] = null;
        } while (!core.identical(next, this[_first$]));
        this[_first$] = null;
        this[_length$1] = 0;
      }
      get first() {
        if (dart.notNull(this.isEmpty)) {
          dart.throw(new core.StateError('No such element'));
        }
        return this[_first$];
      }
      get last() {
        if (dart.notNull(this.isEmpty)) {
          dart.throw(new core.StateError('No such element'));
        }
        return this[_first$][_previous$0];
      }
      get single() {
        if (dart.notNull(this.isEmpty)) {
          dart.throw(new core.StateError('No such element'));
        }
        if (dart.notNull(this[_length$1]) > 1) {
          dart.throw(new core.StateError('Too many elements'));
        }
        return this[_first$];
      }
      forEach(action) {
        dart.as(action, dart.functionType(dart.void, [E]));
        let modificationCount = this[_modificationCount];
        if (dart.notNull(this.isEmpty)) return;
        let current = this[_first$];
        do {
          action(current);
          if (modificationCount != this[_modificationCount]) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
          current = current[_next$0];
        } while (!core.identical(current, this[_first$]));
      }
      get isEmpty() {
        return this[_length$1] == 0;
      }
      [_insertBefore$](entry, newEntry, opts) {
        dart.as(entry, E);
        dart.as(newEntry, E);
        let updateFirst = opts && 'updateFirst' in opts ? opts.updateFirst : null;
        if (newEntry.list != null) {
          dart.throw(new core.StateError('LinkedListEntry is already in a LinkedList'));
        }
        this[_modificationCount] = dart.notNull(this[_modificationCount]) + 1;
        newEntry[_list] = this;
        if (dart.notNull(this.isEmpty)) {
          dart.assert(entry == null);
          newEntry[_previous$0] = newEntry[_next$0] = newEntry;
          this[_first$] = newEntry;
          this[_length$1] = dart.notNull(this[_length$1]) + 1;
          return;
        }
        let predecessor = entry[_previous$0];
        let successor = entry;
        newEntry[_previous$0] = predecessor;
        newEntry[_next$0] = successor;
        predecessor[_next$0] = newEntry;
        successor[_previous$0] = newEntry;
        if (dart.notNull(updateFirst) && core.identical(entry, this[_first$])) {
          this[_first$] = newEntry;
        }
        this[_length$1] = dart.notNull(this[_length$1]) + 1;
      }
      [_unlink$](entry) {
        dart.as(entry, E);
        this[_modificationCount] = dart.notNull(this[_modificationCount]) + 1;
        entry[_next$0][_previous$0] = entry[_previous$0];
        let next = entry[_previous$0][_next$0] = entry[_next$0];
        this[_length$1] = dart.notNull(this[_length$1]) - 1;
        entry[_list] = entry[_next$0] = entry[_previous$0] = null;
        if (dart.notNull(this.isEmpty)) {
          this[_first$] = null;
        } else if (core.identical(entry, this[_first$])) {
          this[_first$] = next;
        }
      }
    }
    dart.setSignature(LinkedList, {
      constructors: () => ({LinkedList: [collection.LinkedList$(E), []]}),
      methods: () => ({
        addFirst: [dart.void, [E]],
        add: [dart.void, [E]],
        addAll: [dart.void, [core.Iterable$(E)]],
        remove: [core.bool, [E]],
        clear: [dart.void, []],
        forEach: [dart.void, [dart.functionType(dart.void, [E])]],
        [_insertBefore$]: [dart.void, [E, E], {updateFirst: core.bool}],
        [_unlink$]: [dart.void, [E]]
      })
    });
    dart.defineExtensionMembers(LinkedList, [
      'forEach',
      'iterator',
      'length',
      'first',
      'last',
      'single',
      'isEmpty'
    ]);
    return LinkedList;
  });
  collection.LinkedList = collection.LinkedList$();
  const _visitedFirst = Symbol('_visitedFirst');
  collection._LinkedListIterator$ = dart.generic(E => {
    class _LinkedListIterator extends core.Object {
      _LinkedListIterator(list) {
        this[_list] = list;
        this[_modificationCount] = list[_modificationCount];
        this[_next$0] = list[_first$];
        this[_visitedFirst] = false;
        this[_current$2] = null;
      }
      get current() {
        return this[_current$2];
      }
      moveNext() {
        if (this[_modificationCount] != this[_list][_modificationCount]) {
          dart.throw(new core.ConcurrentModificationError(this));
        }
        if (dart.notNull(this[_list].isEmpty) || dart.notNull(this[_visitedFirst]) && core.identical(this[_next$0], this[_list].first)) {
          this[_current$2] = null;
          return false;
        }
        this[_visitedFirst] = true;
        this[_current$2] = dart.as(this[_next$0], E);
        this[_next$0] = this[_next$0][_next$0];
        return true;
      }
    }
    _LinkedListIterator[dart.implements] = () => [core.Iterator$(E)];
    dart.setSignature(_LinkedListIterator, {
      constructors: () => ({_LinkedListIterator: [collection._LinkedListIterator$(E), [collection.LinkedList$(E)]]}),
      methods: () => ({moveNext: [core.bool, []]})
    });
    return _LinkedListIterator;
  });
  collection._LinkedListIterator = collection._LinkedListIterator$();
  collection.LinkedListEntry$ = dart.generic(E => {
    class LinkedListEntry extends core.Object {
      LinkedListEntry() {
        this[_list] = null;
        this[_next$0] = null;
        this[_previous$0] = null;
      }
      get list() {
        return this[_list];
      }
      unlink() {
        this[_list][_unlink$](dart.as(this, E));
      }
      get next() {
        if (core.identical(this, this[_next$0])) return null;
        return this[_next$0];
      }
      get previous() {
        if (core.identical(this, this[_previous$0])) return null;
        return this[_previous$0];
      }
      insertAfter(entry) {
        dart.as(entry, E);
        this[_list][_insertBefore$](this[_next$0], entry, {updateFirst: false});
      }
      insertBefore(entry) {
        dart.as(entry, E);
        this[_list][_insertBefore$](dart.as(this, E), entry, {updateFirst: true});
      }
    }
    dart.setSignature(LinkedListEntry, {
      methods: () => ({
        unlink: [dart.void, []],
        insertAfter: [dart.void, [E]],
        insertBefore: [dart.void, [E]]
      })
    });
    return LinkedListEntry;
  });
  collection.LinkedListEntry = collection.LinkedListEntry$();
  collection.MapMixin$ = dart.generic((K, V) => {
    class MapMixin extends core.Object {
      forEach(action) {
        dart.as(action, dart.functionType(dart.void, [K, V]));
        for (let key of this.keys) {
          action(key, this.get(key));
        }
      }
      addAll(other) {
        dart.as(other, core.Map$(K, V));
        for (let key of other[dartx.keys]) {
          this.set(key, other[dartx.get](key));
        }
      }
      containsValue(value) {
        for (let key of this.keys) {
          if (dart.equals(this.get(key), value)) return true;
        }
        return false;
      }
      putIfAbsent(key, ifAbsent) {
        dart.as(key, K);
        dart.as(ifAbsent, dart.functionType(V, []));
        if (dart.notNull(this.containsKey(key))) {
          return this.get(key);
        }
        return this.set(key, ifAbsent());
      }
      containsKey(key) {
        return this.keys[dartx.contains](key);
      }
      get length() {
        return this.keys[dartx.length];
      }
      get isEmpty() {
        return this.keys[dartx.isEmpty];
      }
      get isNotEmpty() {
        return this.keys[dartx.isNotEmpty];
      }
      get values() {
        return new (collection._MapBaseValueIterable$(K, V))(this);
      }
      toString() {
        return collection.Maps.mapToString(this);
      }
    }
    MapMixin[dart.implements] = () => [core.Map$(K, V)];
    dart.setSignature(MapMixin, {
      methods: () => ({
        forEach: [dart.void, [dart.functionType(dart.void, [K, V])]],
        addAll: [dart.void, [core.Map$(K, V)]],
        containsValue: [core.bool, [core.Object]],
        putIfAbsent: [V, [K, dart.functionType(V, [])]],
        containsKey: [core.bool, [core.Object]]
      })
    });
    dart.defineExtensionMembers(MapMixin, [
      'forEach',
      'addAll',
      'containsValue',
      'putIfAbsent',
      'containsKey',
      'length',
      'isEmpty',
      'isNotEmpty',
      'values'
    ]);
    return MapMixin;
  });
  collection.MapMixin = collection.MapMixin$();
  collection.MapBase$ = dart.generic((K, V) => {
    class MapBase extends dart.mixin(core.Object, collection.MapMixin$(K, V)) {}
    return MapBase;
  });
  collection.MapBase = collection.MapBase$();
  collection._UnmodifiableMapMixin$ = dart.generic((K, V) => {
    class _UnmodifiableMapMixin extends core.Object {
      set(key, value) {
        dart.as(key, K);
        dart.as(value, V);
        dart.throw(new core.UnsupportedError("Cannot modify unmodifiable map"));
        return value;
      }
      addAll(other) {
        dart.as(other, core.Map$(K, V));
        dart.throw(new core.UnsupportedError("Cannot modify unmodifiable map"));
      }
      clear() {
        dart.throw(new core.UnsupportedError("Cannot modify unmodifiable map"));
      }
      remove(key) {
        dart.throw(new core.UnsupportedError("Cannot modify unmodifiable map"));
      }
      putIfAbsent(key, ifAbsent) {
        dart.as(key, K);
        dart.as(ifAbsent, dart.functionType(V, []));
        dart.throw(new core.UnsupportedError("Cannot modify unmodifiable map"));
      }
    }
    _UnmodifiableMapMixin[dart.implements] = () => [core.Map$(K, V)];
    dart.setSignature(_UnmodifiableMapMixin, {
      methods: () => ({
        set: [dart.void, [K, V]],
        addAll: [dart.void, [core.Map$(K, V)]],
        clear: [dart.void, []],
        remove: [V, [core.Object]],
        putIfAbsent: [V, [K, dart.functionType(V, [])]]
      })
    });
    dart.defineExtensionMembers(_UnmodifiableMapMixin, [
      'set',
      'addAll',
      'clear',
      'remove',
      'putIfAbsent'
    ]);
    return _UnmodifiableMapMixin;
  });
  collection._UnmodifiableMapMixin = collection._UnmodifiableMapMixin$();
  collection.UnmodifiableMapBase$ = dart.generic((K, V) => {
    class UnmodifiableMapBase extends dart.mixin(collection.MapBase$(K, V), collection._UnmodifiableMapMixin$(K, V)) {
      UnmodifiableMapBase() {
        super.MapBase();
      }
    }
    return UnmodifiableMapBase;
  });
  collection.UnmodifiableMapBase = collection.UnmodifiableMapBase$();
  collection._MapBaseValueIterable$ = dart.generic((K, V) => {
    class _MapBaseValueIterable extends core.Iterable$(V) {
      _MapBaseValueIterable(map) {
        this[_map$0] = map;
        super.Iterable();
      }
      get length() {
        return this[_map$0][dartx.length];
      }
      get isEmpty() {
        return this[_map$0][dartx.isEmpty];
      }
      get isNotEmpty() {
        return this[_map$0][dartx.isNotEmpty];
      }
      get first() {
        return this[_map$0][dartx.get](this[_map$0][dartx.keys][dartx.first]);
      }
      get single() {
        return this[_map$0][dartx.get](this[_map$0][dartx.keys][dartx.single]);
      }
      get last() {
        return this[_map$0][dartx.get](this[_map$0][dartx.keys][dartx.last]);
      }
      get iterator() {
        return new (collection._MapBaseValueIterator$(K, V))(this[_map$0]);
      }
    }
    _MapBaseValueIterable[dart.implements] = () => [_internal.EfficientLength];
    dart.setSignature(_MapBaseValueIterable, {
      constructors: () => ({_MapBaseValueIterable: [collection._MapBaseValueIterable$(K, V), [core.Map$(K, V)]]})
    });
    dart.defineExtensionMembers(_MapBaseValueIterable, [
      'length',
      'isEmpty',
      'isNotEmpty',
      'first',
      'single',
      'last',
      'iterator'
    ]);
    return _MapBaseValueIterable;
  });
  collection._MapBaseValueIterable = collection._MapBaseValueIterable$();
  collection._MapBaseValueIterator$ = dart.generic((K, V) => {
    class _MapBaseValueIterator extends core.Object {
      _MapBaseValueIterator(map) {
        this[_map$0] = map;
        this[_keys] = map[dartx.keys][dartx.iterator];
        this[_current$2] = null;
      }
      moveNext() {
        if (dart.notNull(this[_keys].moveNext())) {
          this[_current$2] = this[_map$0][dartx.get](this[_keys].current);
          return true;
        }
        this[_current$2] = null;
        return false;
      }
      get current() {
        return this[_current$2];
      }
    }
    _MapBaseValueIterator[dart.implements] = () => [core.Iterator$(V)];
    dart.setSignature(_MapBaseValueIterator, {
      constructors: () => ({_MapBaseValueIterator: [collection._MapBaseValueIterator$(K, V), [core.Map$(K, V)]]}),
      methods: () => ({moveNext: [core.bool, []]})
    });
    return _MapBaseValueIterator;
  });
  collection._MapBaseValueIterator = collection._MapBaseValueIterator$();
  collection.MapView$ = dart.generic((K, V) => {
    class MapView extends core.Object {
      MapView(map) {
        this[_map$0] = map;
      }
      get(key) {
        return this[_map$0][dartx.get](key);
      }
      set(key, value) {
        dart.as(key, K);
        dart.as(value, V);
        this[_map$0][dartx.set](key, value);
        return value;
      }
      addAll(other) {
        dart.as(other, core.Map$(K, V));
        this[_map$0][dartx.addAll](other);
      }
      clear() {
        this[_map$0][dartx.clear]();
      }
      putIfAbsent(key, ifAbsent) {
        dart.as(key, K);
        dart.as(ifAbsent, dart.functionType(V, []));
        return this[_map$0][dartx.putIfAbsent](key, ifAbsent);
      }
      containsKey(key) {
        return this[_map$0][dartx.containsKey](key);
      }
      containsValue(value) {
        return this[_map$0][dartx.containsValue](value);
      }
      forEach(action) {
        dart.as(action, dart.functionType(dart.void, [K, V]));
        this[_map$0][dartx.forEach](action);
      }
      get isEmpty() {
        return this[_map$0][dartx.isEmpty];
      }
      get isNotEmpty() {
        return this[_map$0][dartx.isNotEmpty];
      }
      get length() {
        return this[_map$0][dartx.length];
      }
      get keys() {
        return this[_map$0][dartx.keys];
      }
      remove(key) {
        return this[_map$0][dartx.remove](key);
      }
      toString() {
        return dart.toString(this[_map$0]);
      }
      get values() {
        return this[_map$0][dartx.values];
      }
    }
    MapView[dart.implements] = () => [core.Map$(K, V)];
    dart.setSignature(MapView, {
      constructors: () => ({MapView: [collection.MapView$(K, V), [core.Map$(K, V)]]}),
      methods: () => ({
        get: [V, [core.Object]],
        set: [dart.void, [K, V]],
        addAll: [dart.void, [core.Map$(K, V)]],
        clear: [dart.void, []],
        putIfAbsent: [V, [K, dart.functionType(V, [])]],
        containsKey: [core.bool, [core.Object]],
        containsValue: [core.bool, [core.Object]],
        forEach: [dart.void, [dart.functionType(dart.void, [K, V])]],
        remove: [V, [core.Object]]
      })
    });
    dart.defineExtensionMembers(MapView, [
      'get',
      'set',
      'addAll',
      'clear',
      'putIfAbsent',
      'containsKey',
      'containsValue',
      'forEach',
      'remove',
      'isEmpty',
      'isNotEmpty',
      'length',
      'keys',
      'values'
    ]);
    return MapView;
  });
  collection.MapView = collection.MapView$();
  collection.UnmodifiableMapView$ = dart.generic((K, V) => {
    class UnmodifiableMapView extends dart.mixin(collection.MapView$(K, V), collection._UnmodifiableMapMixin$(K, V)) {
      UnmodifiableMapView(map) {
        super.MapView(map);
      }
    }
    return UnmodifiableMapView;
  });
  collection.UnmodifiableMapView = collection.UnmodifiableMapView$();
  collection.Maps = class Maps extends core.Object {
    static containsValue(map, value) {
      for (let v of map[dartx.values]) {
        if (dart.equals(v, value)) {
          return true;
        }
      }
      return false;
    }
    static containsKey(map, key) {
      for (let k of map[dartx.keys]) {
        if (dart.equals(k, key)) {
          return true;
        }
      }
      return false;
    }
    static putIfAbsent(map, key, ifAbsent) {
      if (dart.notNull(map[dartx.containsKey](key))) {
        return map[dartx.get](key);
      }
      let v = ifAbsent();
      map[dartx.set](key, v);
      return v;
    }
    static clear(map) {
      for (let k of map[dartx.keys][dartx.toList]()) {
        map[dartx.remove](k);
      }
    }
    static forEach(map, f) {
      for (let k of map[dartx.keys]) {
        dart.dcall(f, k, map[dartx.get](k));
      }
    }
    static getValues(map) {
      return map[dartx.keys][dartx.map](dart.dynamic)(dart.fn(key => map[dartx.get](key)));
    }
    static length(map) {
      return map[dartx.keys][dartx.length];
    }
    static isEmpty(map) {
      return map[dartx.keys][dartx.isEmpty];
    }
    static isNotEmpty(map) {
      return map[dartx.keys][dartx.isNotEmpty];
    }
    static mapToString(m) {
      if (dart.notNull(collection._isToStringVisiting(m))) {
        return '{...}';
      }
      let result = new core.StringBuffer();
      try {
        collection._toStringVisiting[dartx.add](m);
        result.write('{');
        let first = true;
        m[dartx.forEach](dart.fn((k, v) => {
          if (!first) {
            result.write(', ');
          }
          first = false;
          result.write(k);
          result.write(': ');
          result.write(v);
        }, dart.void, [dart.dynamic, dart.dynamic]));
        result.write('}');
      } finally {
        dart.assert(core.identical(collection._toStringVisiting[dartx.last], m));
        collection._toStringVisiting[dartx.removeLast]();
      }
      return result.toString();
    }
    static _id(x) {
      return x;
    }
    static _fillMapWithMappedIterable(map, iterable, key, value) {
      if (key == null) key = collection.Maps._id;
      if (value == null) value = collection.Maps._id;
      for (let element of iterable) {
        map[dartx.set](dart.dcall(key, element), dart.dcall(value, element));
      }
    }
    static _fillMapWithIterables(map, keys, values) {
      let keyIterator = keys[dartx.iterator];
      let valueIterator = values[dartx.iterator];
      let hasNextKey = keyIterator.moveNext();
      let hasNextValue = valueIterator.moveNext();
      while (dart.notNull(hasNextKey) && dart.notNull(hasNextValue)) {
        map[dartx.set](keyIterator.current, valueIterator.current);
        hasNextKey = keyIterator.moveNext();
        hasNextValue = valueIterator.moveNext();
      }
      if (dart.notNull(hasNextKey) || dart.notNull(hasNextValue)) {
        dart.throw(new core.ArgumentError("Iterables do not have same length."));
      }
    }
  };
  dart.setSignature(collection.Maps, {
    statics: () => ({
      containsValue: [core.bool, [core.Map, core.Object]],
      containsKey: [core.bool, [core.Map, core.Object]],
      putIfAbsent: [dart.dynamic, [core.Map, dart.dynamic, dart.functionType(dart.dynamic, [])]],
      clear: [dart.dynamic, [core.Map]],
      forEach: [dart.dynamic, [core.Map, dart.functionType(dart.void, [dart.dynamic, dart.dynamic])]],
      getValues: [core.Iterable, [core.Map]],
      length: [core.int, [core.Map]],
      isEmpty: [core.bool, [core.Map]],
      isNotEmpty: [core.bool, [core.Map]],
      mapToString: [core.String, [core.Map]],
      _id: [dart.dynamic, [dart.dynamic]],
      _fillMapWithMappedIterable: [dart.void, [core.Map, core.Iterable, dart.functionType(dart.dynamic, [dart.dynamic]), dart.functionType(dart.dynamic, [dart.dynamic])]],
      _fillMapWithIterables: [dart.void, [core.Map, core.Iterable, core.Iterable]]
    }),
    names: ['containsValue', 'containsKey', 'putIfAbsent', 'clear', 'forEach', 'getValues', 'length', 'isEmpty', 'isNotEmpty', 'mapToString', '_id', '_fillMapWithMappedIterable', '_fillMapWithIterables']
  });
  collection.Queue$ = dart.generic(E => {
    class Queue extends core.Object {
      static new() {
        return new (collection.ListQueue$(E))();
      }
      static from(elements) {
        return collection.ListQueue$(E).from(elements);
      }
      [Symbol.iterator]() {
        return new dart.JsIterator(this.iterator);
      }
    }
    Queue[dart.implements] = () => [core.Iterable$(E), _internal.EfficientLength];
    dart.setSignature(Queue, {
      constructors: () => ({
        new: [collection.Queue$(E), []],
        from: [collection.Queue$(E), [core.Iterable]]
      })
    });
    return Queue;
  });
  collection.Queue = collection.Queue$();
  const _previousLink = Symbol('_previousLink');
  const _nextLink = Symbol('_nextLink');
  const _link = Symbol('_link');
  collection._DoubleLink$ = dart.generic(E => {
    class _DoubleLink extends core.Object {
      _DoubleLink() {
        this[_previousLink] = null;
        this[_nextLink] = null;
      }
      [_link](previous, next) {
        dart.as(previous, E);
        dart.as(next, E);
        this[_nextLink] = next;
        this[_previousLink] = previous;
        if (previous != null) previous[_nextLink] = this;
        if (next != null) next[_previousLink] = this;
      }
      [_unlink$]() {
        if (this[_previousLink] != null) this[_previousLink][_nextLink] = this[_nextLink];
        if (this[_nextLink] != null) this[_nextLink][_previousLink] = this[_previousLink];
        this[_nextLink] = null;
        this[_previousLink] = null;
      }
    }
    dart.setSignature(_DoubleLink, {
      methods: () => ({
        [_link]: [dart.void, [E, E]],
        [_unlink$]: [dart.void, []]
      })
    });
    return _DoubleLink;
  });
  collection._DoubleLink = collection._DoubleLink$();
  collection.DoubleLinkedQueueEntry$ = dart.generic(E => {
    class DoubleLinkedQueueEntry extends core.Object {
      static new(element) {
        return new (collection._UserDoubleLinkedQueueEntry$(E))(element);
      }
    }
    dart.setSignature(DoubleLinkedQueueEntry, {
      constructors: () => ({new: [collection.DoubleLinkedQueueEntry$(E), [E]]})
    });
    return DoubleLinkedQueueEntry;
  });
  collection.DoubleLinkedQueueEntry = collection.DoubleLinkedQueueEntry$();
  collection._UserDoubleLinkedQueueEntry$ = dart.generic(E => {
    class _UserDoubleLinkedQueueEntry extends collection._DoubleLink {
      _UserDoubleLinkedQueueEntry(element) {
        this.element = element;
        super._DoubleLink();
      }
      append(e) {
        dart.as(e, E);
        new (collection._UserDoubleLinkedQueueEntry$(E))(e)[_link](this, this[_nextLink]);
      }
      prepend(e) {
        dart.as(e, E);
        new (collection._UserDoubleLinkedQueueEntry$(E))(e)[_link](this[_previousLink], this);
      }
      remove() {
        this[_unlink$]();
        return this.element;
      }
      previousEntry() {
        return this[_previousLink];
      }
      nextEntry() {
        return this[_nextLink];
      }
    }
    dart.setBaseClass(_UserDoubleLinkedQueueEntry, collection._DoubleLink$(_UserDoubleLinkedQueueEntry));
    _UserDoubleLinkedQueueEntry[dart.implements] = () => [collection.DoubleLinkedQueueEntry$(E)];
    dart.setSignature(_UserDoubleLinkedQueueEntry, {
      constructors: () => ({_UserDoubleLinkedQueueEntry: [collection._UserDoubleLinkedQueueEntry$(E), [E]]}),
      methods: () => ({
        append: [dart.void, [E]],
        prepend: [dart.void, [E]],
        remove: [E, []],
        previousEntry: [collection.DoubleLinkedQueueEntry$(E), []],
        nextEntry: [collection.DoubleLinkedQueueEntry$(E), []]
      })
    });
    return _UserDoubleLinkedQueueEntry;
  });
  collection._UserDoubleLinkedQueueEntry = collection._UserDoubleLinkedQueueEntry$();
  const _queue = Symbol('_queue');
  const _append = Symbol('_append');
  const _prepend = Symbol('_prepend');
  const _asNonSentinelEntry = Symbol('_asNonSentinelEntry');
  collection._DoubleLinkedQueueEntry$ = dart.generic(E => {
    class _DoubleLinkedQueueEntry extends collection._DoubleLink {
      _DoubleLinkedQueueEntry(queue) {
        this[_queue] = queue;
        super._DoubleLink();
      }
      [_append](e) {
        dart.as(e, E);
        new (collection._DoubleLinkedQueueElement$(E))(e, this[_queue])[_link](this, this[_nextLink]);
      }
      [_prepend](e) {
        dart.as(e, E);
        new (collection._DoubleLinkedQueueElement$(E))(e, this[_queue])[_link](this[_previousLink], this);
      }
      nextEntry() {
        return this[_nextLink][_asNonSentinelEntry]();
      }
      previousEntry() {
        return this[_previousLink][_asNonSentinelEntry]();
      }
    }
    dart.setBaseClass(_DoubleLinkedQueueEntry, collection._DoubleLink$(_DoubleLinkedQueueEntry));
    dart.setSignature(_DoubleLinkedQueueEntry, {
      constructors: () => ({_DoubleLinkedQueueEntry: [collection._DoubleLinkedQueueEntry$(E), [collection.DoubleLinkedQueue$(E)]]}),
      methods: () => ({
        [_append]: [dart.void, [E]],
        [_prepend]: [dart.void, [E]],
        nextEntry: [collection.DoubleLinkedQueueEntry$(E), []],
        previousEntry: [collection.DoubleLinkedQueueEntry$(E), []]
      })
    });
    return _DoubleLinkedQueueEntry;
  });
  collection._DoubleLinkedQueueEntry = collection._DoubleLinkedQueueEntry$();
  const _elementCount = Symbol('_elementCount');
  collection._DoubleLinkedQueueElement$ = dart.generic(E => {
    class _DoubleLinkedQueueElement extends collection._DoubleLinkedQueueEntry$(E) {
      _DoubleLinkedQueueElement(element, queue) {
        this.element = element;
        super._DoubleLinkedQueueEntry(queue);
      }
      append(e) {
        dart.as(e, E);
        this[_append](e);
        if (this[_queue] != null) {
          let o = this[_queue];
          o[_elementCount] = dart.notNull(o[_elementCount]) + 1;
        }
      }
      prepend(e) {
        dart.as(e, E);
        this[_prepend](e);
        if (this[_queue] != null) {
          let o = this[_queue];
          o[_elementCount] = dart.notNull(o[_elementCount]) + 1;
        }
      }
      [_remove]() {
        this[_queue] = null;
        this[_unlink$]();
        return this.element;
      }
      remove() {
        if (this[_queue] != null) {
          let o = this[_queue];
          o[_elementCount] = dart.notNull(o[_elementCount]) - 1;
        }
        return this[_remove]();
      }
      [_asNonSentinelEntry]() {
        return this;
      }
    }
    _DoubleLinkedQueueElement[dart.implements] = () => [collection.DoubleLinkedQueueEntry$(E)];
    dart.setSignature(_DoubleLinkedQueueElement, {
      constructors: () => ({_DoubleLinkedQueueElement: [collection._DoubleLinkedQueueElement$(E), [E, collection.DoubleLinkedQueue$(E)]]}),
      methods: () => ({
        append: [dart.void, [E]],
        prepend: [dart.void, [E]],
        [_remove]: [E, []],
        remove: [E, []],
        [_asNonSentinelEntry]: [collection._DoubleLinkedQueueElement$(E), []]
      })
    });
    return _DoubleLinkedQueueElement;
  });
  collection._DoubleLinkedQueueElement = collection._DoubleLinkedQueueElement$();
  collection._DoubleLinkedQueueSentinel$ = dart.generic(E => {
    class _DoubleLinkedQueueSentinel extends collection._DoubleLinkedQueueEntry$(E) {
      _DoubleLinkedQueueSentinel(queue) {
        super._DoubleLinkedQueueEntry(queue);
        this[_previousLink] = this;
        this[_nextLink] = this;
      }
      [_asNonSentinelEntry]() {
        return null;
      }
      [_remove]() {
        dart.throw(_internal.IterableElementError.noElement());
      }
      get element() {
        dart.throw(_internal.IterableElementError.noElement());
      }
    }
    dart.setSignature(_DoubleLinkedQueueSentinel, {
      constructors: () => ({_DoubleLinkedQueueSentinel: [collection._DoubleLinkedQueueSentinel$(E), [collection.DoubleLinkedQueue$(E)]]}),
      methods: () => ({
        [_asNonSentinelEntry]: [collection.DoubleLinkedQueueEntry$(E), []],
        [_remove]: [E, []]
      })
    });
    return _DoubleLinkedQueueSentinel;
  });
  collection._DoubleLinkedQueueSentinel = collection._DoubleLinkedQueueSentinel$();
  const _sentinel = Symbol('_sentinel');
  const _filter = Symbol('_filter');
  collection.DoubleLinkedQueue$ = dart.generic(E => {
    class DoubleLinkedQueue extends core.Iterable$(E) {
      DoubleLinkedQueue() {
        this[_sentinel] = null;
        this[_elementCount] = 0;
        super.Iterable();
        this[_sentinel] = new (collection._DoubleLinkedQueueSentinel$(E))(this);
      }
      static from(elements) {
        let list = new (collection.DoubleLinkedQueue$(E))();
        for (let e of elements) {
          list.addLast(dart.as(e, E));
        }
        return dart.as(list, collection.DoubleLinkedQueue$(E));
      }
      get length() {
        return this[_elementCount];
      }
      addLast(value) {
        dart.as(value, E);
        this[_sentinel][_prepend](value);
        this[_elementCount] = dart.notNull(this[_elementCount]) + 1;
      }
      addFirst(value) {
        dart.as(value, E);
        this[_sentinel][_append](value);
        this[_elementCount] = dart.notNull(this[_elementCount]) + 1;
      }
      add(value) {
        dart.as(value, E);
        this[_sentinel][_prepend](value);
        this[_elementCount] = dart.notNull(this[_elementCount]) + 1;
      }
      addAll(iterable) {
        dart.as(iterable, core.Iterable$(E));
        for (let value of iterable) {
          this[_sentinel][_prepend](value);
          this[_elementCount] = dart.notNull(this[_elementCount]) + 1;
        }
      }
      removeLast() {
        let lastEntry = this[_sentinel][_previousLink];
        let result = lastEntry[_remove]();
        this[_elementCount] = dart.notNull(this[_elementCount]) - 1;
        return result;
      }
      removeFirst() {
        let firstEntry = this[_sentinel][_nextLink];
        let result = firstEntry[_remove]();
        this[_elementCount] = dart.notNull(this[_elementCount]) - 1;
        return result;
      }
      remove(o) {
        let entry = this[_sentinel][_nextLink];
        while (!core.identical(entry, this[_sentinel])) {
          if (dart.equals(entry.element, o)) {
            entry[_remove]();
            this[_elementCount] = dart.notNull(this[_elementCount]) - 1;
            return true;
          }
          entry = entry[_nextLink];
        }
        return false;
      }
      [_filter](test, removeMatching) {
        dart.as(test, dart.functionType(core.bool, [E]));
        let entry = this[_sentinel][_nextLink];
        while (!core.identical(entry, this[_sentinel])) {
          let next = entry[_nextLink];
          if (core.identical(removeMatching, test(entry.element))) {
            entry[_remove]();
            this[_elementCount] = dart.notNull(this[_elementCount]) - 1;
          }
          entry = next;
        }
      }
      removeWhere(test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        this[_filter](test, true);
      }
      retainWhere(test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        this[_filter](test, false);
      }
      get first() {
        let firstEntry = this[_sentinel][_nextLink];
        return firstEntry.element;
      }
      get last() {
        let lastEntry = this[_sentinel][_previousLink];
        return lastEntry.element;
      }
      get single() {
        if (core.identical(this[_sentinel][_nextLink], this[_sentinel][_previousLink])) {
          let entry = this[_sentinel][_nextLink];
          return entry.element;
        }
        dart.throw(_internal.IterableElementError.tooMany());
      }
      lastEntry() {
        return this[_sentinel].previousEntry();
      }
      firstEntry() {
        return this[_sentinel].nextEntry();
      }
      get isEmpty() {
        return core.identical(this[_sentinel][_nextLink], this[_sentinel]);
      }
      clear() {
        this[_sentinel][_nextLink] = this[_sentinel];
        this[_sentinel][_previousLink] = this[_sentinel];
        this[_elementCount] = 0;
      }
      forEachEntry(f) {
        dart.as(f, dart.functionType(dart.void, [collection.DoubleLinkedQueueEntry$(E)]));
        let entry = this[_sentinel][_nextLink];
        while (!core.identical(entry, this[_sentinel])) {
          let nextEntry = entry[_nextLink];
          let element = dart.as(entry, collection._DoubleLinkedQueueElement$(E));
          f(element);
          entry = nextEntry;
        }
      }
      get iterator() {
        return new (collection._DoubleLinkedQueueIterator$(E))(this[_sentinel]);
      }
      toString() {
        return collection.IterableBase.iterableToFullString(this, '{', '}');
      }
    }
    DoubleLinkedQueue[dart.implements] = () => [collection.Queue$(E)];
    dart.setSignature(DoubleLinkedQueue, {
      constructors: () => ({
        DoubleLinkedQueue: [collection.DoubleLinkedQueue$(E), []],
        from: [collection.DoubleLinkedQueue$(E), [core.Iterable]]
      }),
      methods: () => ({
        addLast: [dart.void, [E]],
        addFirst: [dart.void, [E]],
        add: [dart.void, [E]],
        addAll: [dart.void, [core.Iterable$(E)]],
        removeLast: [E, []],
        removeFirst: [E, []],
        remove: [core.bool, [core.Object]],
        [_filter]: [dart.void, [dart.functionType(core.bool, [E]), core.bool]],
        removeWhere: [dart.void, [dart.functionType(core.bool, [E])]],
        retainWhere: [dart.void, [dart.functionType(core.bool, [E])]],
        lastEntry: [collection.DoubleLinkedQueueEntry$(E), []],
        firstEntry: [collection.DoubleLinkedQueueEntry$(E), []],
        clear: [dart.void, []],
        forEachEntry: [dart.void, [dart.functionType(dart.void, [collection.DoubleLinkedQueueEntry$(E)])]]
      })
    });
    dart.defineExtensionMembers(DoubleLinkedQueue, [
      'toString',
      'length',
      'first',
      'last',
      'single',
      'isEmpty',
      'iterator'
    ]);
    return DoubleLinkedQueue;
  });
  collection.DoubleLinkedQueue = collection.DoubleLinkedQueue$();
  const _nextEntry = Symbol('_nextEntry');
  collection._DoubleLinkedQueueIterator$ = dart.generic(E => {
    class _DoubleLinkedQueueIterator extends core.Object {
      _DoubleLinkedQueueIterator(sentinel) {
        this[_sentinel] = sentinel;
        this[_nextEntry] = sentinel[_nextLink];
        this[_current$2] = null;
      }
      moveNext() {
        if (core.identical(this[_nextEntry], this[_sentinel])) {
          this[_current$2] = null;
          this[_nextEntry] = null;
          this[_sentinel] = null;
          return false;
        }
        let elementEntry = dart.as(this[_nextEntry], collection._DoubleLinkedQueueElement$(E));
        if (elementEntry[_queue] == null) {
          dart.throw(new core.ConcurrentModificationError(this[_sentinel][_queue]));
        }
        this[_current$2] = elementEntry.element;
        this[_nextEntry] = elementEntry[_nextLink];
        return true;
      }
      get current() {
        return this[_current$2];
      }
    }
    _DoubleLinkedQueueIterator[dart.implements] = () => [core.Iterator$(E)];
    dart.setSignature(_DoubleLinkedQueueIterator, {
      constructors: () => ({_DoubleLinkedQueueIterator: [collection._DoubleLinkedQueueIterator$(E), [collection._DoubleLinkedQueueSentinel$(E)]]}),
      methods: () => ({moveNext: [core.bool, []]})
    });
    return _DoubleLinkedQueueIterator;
  });
  collection._DoubleLinkedQueueIterator = collection._DoubleLinkedQueueIterator$();
  const _head = Symbol('_head');
  const _tail = Symbol('_tail');
  const _table = Symbol('_table');
  const _checkModification = Symbol('_checkModification');
  const _writeToList = Symbol('_writeToList');
  const _preGrow = Symbol('_preGrow');
  const _grow = Symbol('_grow');
  collection.ListQueue$ = dart.generic(E => {
    class ListQueue extends core.Iterable$(E) {
      ListQueue(initialCapacity) {
        if (initialCapacity === void 0) initialCapacity = null;
        this[_head] = 0;
        this[_tail] = 0;
        this[_table] = null;
        this[_modificationCount] = 0;
        super.Iterable();
        if (initialCapacity == null || dart.notNull(initialCapacity) < dart.notNull(collection.ListQueue._INITIAL_CAPACITY)) {
          initialCapacity = collection.ListQueue._INITIAL_CAPACITY;
        } else if (!dart.notNull(collection.ListQueue._isPowerOf2(initialCapacity))) {
          initialCapacity = collection.ListQueue._nextPowerOf2(initialCapacity);
        }
        dart.assert(collection.ListQueue._isPowerOf2(initialCapacity));
        this[_table] = core.List$(E).new(initialCapacity);
      }
      static from(elements) {
        if (dart.is(elements, core.List)) {
          let length = elements[dartx.length];
          let queue = new (collection.ListQueue$(E))(dart.notNull(length) + 1);
          dart.assert(dart.notNull(queue[_table][dartx.length]) > dart.notNull(length));
          for (let i = 0; i < dart.notNull(length); i++) {
            queue[_table][dartx.set](i, dart.as(elements[dartx.get](i), E));
          }
          queue[_tail] = length;
          return queue;
        } else {
          let capacity = collection.ListQueue._INITIAL_CAPACITY;
          if (dart.is(elements, _internal.EfficientLength)) {
            capacity = elements[dartx.length];
          }
          let result = new (collection.ListQueue$(E))(capacity);
          for (let element of elements) {
            result.addLast(dart.as(element, E));
          }
          return result;
        }
      }
      get iterator() {
        return new (collection._ListQueueIterator$(E))(this);
      }
      forEach(action) {
        dart.as(action, dart.functionType(dart.void, [E]));
        let modificationCount = this[_modificationCount];
        for (let i = this[_head]; i != this[_tail]; i = (dart.notNull(i) + 1 & dart.notNull(this[_table][dartx.length]) - 1) >>> 0) {
          action(this[_table][dartx.get](i));
          this[_checkModification](modificationCount);
        }
      }
      get isEmpty() {
        return this[_head] == this[_tail];
      }
      get length() {
        return (dart.notNull(this[_tail]) - dart.notNull(this[_head]) & dart.notNull(this[_table][dartx.length]) - 1) >>> 0;
      }
      get first() {
        if (this[_head] == this[_tail]) dart.throw(_internal.IterableElementError.noElement());
        return this[_table][dartx.get](this[_head]);
      }
      get last() {
        if (this[_head] == this[_tail]) dart.throw(_internal.IterableElementError.noElement());
        return this[_table][dartx.get]((dart.notNull(this[_tail]) - 1 & dart.notNull(this[_table][dartx.length]) - 1) >>> 0);
      }
      get single() {
        if (this[_head] == this[_tail]) dart.throw(_internal.IterableElementError.noElement());
        if (dart.notNull(this.length) > 1) dart.throw(_internal.IterableElementError.tooMany());
        return this[_table][dartx.get](this[_head]);
      }
      elementAt(index) {
        core.RangeError.checkValidIndex(index, this);
        return this[_table][dartx.get]((dart.notNull(this[_head]) + dart.notNull(index) & dart.notNull(this[_table][dartx.length]) - 1) >>> 0);
      }
      toList(opts) {
        let growable = opts && 'growable' in opts ? opts.growable : true;
        let list = null;
        if (dart.notNull(growable)) {
          list = core.List$(E).new();
          list[dartx.length] = this.length;
        } else {
          list = core.List$(E).new(this.length);
        }
        this[_writeToList](list);
        return list;
      }
      add(value) {
        dart.as(value, E);
        this[_add$0](value);
      }
      addAll(elements) {
        dart.as(elements, core.Iterable$(E));
        if (dart.is(elements, core.List$(E))) {
          let list = elements;
          let addCount = list[dartx.length];
          let length = this.length;
          if (dart.notNull(length) + dart.notNull(addCount) >= dart.notNull(this[_table][dartx.length])) {
            this[_preGrow](dart.notNull(length) + dart.notNull(addCount));
            this[_table][dartx.setRange](length, dart.notNull(length) + dart.notNull(addCount), list, 0);
            this[_tail] = dart.notNull(this[_tail]) + dart.notNull(addCount);
          } else {
            let endSpace = dart.notNull(this[_table][dartx.length]) - dart.notNull(this[_tail]);
            if (dart.notNull(addCount) < endSpace) {
              this[_table][dartx.setRange](this[_tail], dart.notNull(this[_tail]) + dart.notNull(addCount), list, 0);
              this[_tail] = dart.notNull(this[_tail]) + dart.notNull(addCount);
            } else {
              let preSpace = dart.notNull(addCount) - endSpace;
              this[_table][dartx.setRange](this[_tail], dart.notNull(this[_tail]) + endSpace, list, 0);
              this[_table][dartx.setRange](0, preSpace, list, endSpace);
              this[_tail] = preSpace;
            }
          }
          this[_modificationCount] = dart.notNull(this[_modificationCount]) + 1;
        } else {
          for (let element of elements)
            this[_add$0](element);
        }
      }
      remove(value) {
        for (let i = this[_head]; i != this[_tail]; i = (dart.notNull(i) + 1 & dart.notNull(this[_table][dartx.length]) - 1) >>> 0) {
          let element = this[_table][dartx.get](i);
          if (dart.equals(element, value)) {
            this[_remove](i);
            this[_modificationCount] = dart.notNull(this[_modificationCount]) + 1;
            return true;
          }
        }
        return false;
      }
      [_filterWhere](test, removeMatching) {
        dart.as(test, dart.functionType(core.bool, [E]));
        let modificationCount = this[_modificationCount];
        let i = this[_head];
        while (i != this[_tail]) {
          let element = this[_table][dartx.get](i);
          let remove = core.identical(removeMatching, test(element));
          this[_checkModification](modificationCount);
          if (remove) {
            i = this[_remove](i);
            modificationCount = this[_modificationCount] = dart.notNull(this[_modificationCount]) + 1;
          } else {
            i = (dart.notNull(i) + 1 & dart.notNull(this[_table][dartx.length]) - 1) >>> 0;
          }
        }
      }
      removeWhere(test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        this[_filterWhere](test, true);
      }
      retainWhere(test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        this[_filterWhere](test, false);
      }
      clear() {
        if (this[_head] != this[_tail]) {
          for (let i = this[_head]; i != this[_tail]; i = (dart.notNull(i) + 1 & dart.notNull(this[_table][dartx.length]) - 1) >>> 0) {
            this[_table][dartx.set](i, null);
          }
          this[_head] = this[_tail] = 0;
          this[_modificationCount] = dart.notNull(this[_modificationCount]) + 1;
        }
      }
      toString() {
        return collection.IterableBase.iterableToFullString(this, "{", "}");
      }
      addLast(value) {
        dart.as(value, E);
        this[_add$0](value);
      }
      addFirst(value) {
        dart.as(value, E);
        this[_head] = (dart.notNull(this[_head]) - 1 & dart.notNull(this[_table][dartx.length]) - 1) >>> 0;
        this[_table][dartx.set](this[_head], value);
        if (this[_head] == this[_tail]) this[_grow]();
        this[_modificationCount] = dart.notNull(this[_modificationCount]) + 1;
      }
      removeFirst() {
        if (this[_head] == this[_tail]) dart.throw(_internal.IterableElementError.noElement());
        this[_modificationCount] = dart.notNull(this[_modificationCount]) + 1;
        let result = this[_table][dartx.get](this[_head]);
        this[_table][dartx.set](this[_head], null);
        this[_head] = (dart.notNull(this[_head]) + 1 & dart.notNull(this[_table][dartx.length]) - 1) >>> 0;
        return result;
      }
      removeLast() {
        if (this[_head] == this[_tail]) dart.throw(_internal.IterableElementError.noElement());
        this[_modificationCount] = dart.notNull(this[_modificationCount]) + 1;
        this[_tail] = (dart.notNull(this[_tail]) - 1 & dart.notNull(this[_table][dartx.length]) - 1) >>> 0;
        let result = this[_table][dartx.get](this[_tail]);
        this[_table][dartx.set](this[_tail], null);
        return result;
      }
      static _isPowerOf2(number) {
        return (dart.notNull(number) & dart.notNull(number) - 1) >>> 0 == 0;
      }
      static _nextPowerOf2(number) {
        dart.assert(dart.notNull(number) > 0);
        number = (dart.notNull(number) << 1 >>> 0) - 1;
        for (;;) {
          let nextNumber = (dart.notNull(number) & dart.notNull(number) - 1) >>> 0;
          if (nextNumber == 0) return number;
          number = nextNumber;
        }
      }
      [_checkModification](expectedModificationCount) {
        if (expectedModificationCount != this[_modificationCount]) {
          dart.throw(new core.ConcurrentModificationError(this));
        }
      }
      [_add$0](element) {
        dart.as(element, E);
        this[_table][dartx.set](this[_tail], element);
        this[_tail] = (dart.notNull(this[_tail]) + 1 & dart.notNull(this[_table][dartx.length]) - 1) >>> 0;
        if (this[_head] == this[_tail]) this[_grow]();
        this[_modificationCount] = dart.notNull(this[_modificationCount]) + 1;
      }
      [_remove](offset) {
        let mask = dart.notNull(this[_table][dartx.length]) - 1;
        let startDistance = (dart.notNull(offset) - dart.notNull(this[_head]) & mask) >>> 0;
        let endDistance = (dart.notNull(this[_tail]) - dart.notNull(offset) & mask) >>> 0;
        if (startDistance < endDistance) {
          let i = offset;
          while (i != this[_head]) {
            let prevOffset = (dart.notNull(i) - 1 & mask) >>> 0;
            this[_table][dartx.set](i, this[_table][dartx.get](prevOffset));
            i = prevOffset;
          }
          this[_table][dartx.set](this[_head], null);
          this[_head] = (dart.notNull(this[_head]) + 1 & mask) >>> 0;
          return (dart.notNull(offset) + 1 & mask) >>> 0;
        } else {
          this[_tail] = (dart.notNull(this[_tail]) - 1 & mask) >>> 0;
          let i = offset;
          while (i != this[_tail]) {
            let nextOffset = (dart.notNull(i) + 1 & mask) >>> 0;
            this[_table][dartx.set](i, this[_table][dartx.get](nextOffset));
            i = nextOffset;
          }
          this[_table][dartx.set](this[_tail], null);
          return offset;
        }
      }
      [_grow]() {
        let newTable = core.List$(E).new(dart.notNull(this[_table][dartx.length]) * 2);
        let split = dart.notNull(this[_table][dartx.length]) - dart.notNull(this[_head]);
        newTable[dartx.setRange](0, split, this[_table], this[_head]);
        newTable[dartx.setRange](split, split + dart.notNull(this[_head]), this[_table], 0);
        this[_head] = 0;
        this[_tail] = this[_table][dartx.length];
        this[_table] = newTable;
      }
      [_writeToList](target) {
        dart.as(target, core.List$(E));
        dart.assert(dart.notNull(target[dartx.length]) >= dart.notNull(this.length));
        if (dart.notNull(this[_head]) <= dart.notNull(this[_tail])) {
          let length = dart.notNull(this[_tail]) - dart.notNull(this[_head]);
          target[dartx.setRange](0, length, this[_table], this[_head]);
          return length;
        } else {
          let firstPartSize = dart.notNull(this[_table][dartx.length]) - dart.notNull(this[_head]);
          target[dartx.setRange](0, firstPartSize, this[_table], this[_head]);
          target[dartx.setRange](firstPartSize, firstPartSize + dart.notNull(this[_tail]), this[_table], 0);
          return dart.notNull(this[_tail]) + firstPartSize;
        }
      }
      [_preGrow](newElementCount) {
        dart.assert(dart.notNull(newElementCount) >= dart.notNull(this.length));
        newElementCount = dart.notNull(newElementCount) + newElementCount[dartx['>>']](1);
        let newCapacity = collection.ListQueue._nextPowerOf2(newElementCount);
        let newTable = core.List$(E).new(newCapacity);
        this[_tail] = this[_writeToList](newTable);
        this[_table] = newTable;
        this[_head] = 0;
      }
    }
    ListQueue[dart.implements] = () => [collection.Queue$(E)];
    dart.setSignature(ListQueue, {
      constructors: () => ({
        ListQueue: [collection.ListQueue$(E), [], [core.int]],
        from: [collection.ListQueue$(E), [core.Iterable]]
      }),
      methods: () => ({
        forEach: [dart.void, [dart.functionType(dart.void, [E])]],
        elementAt: [E, [core.int]],
        toList: [core.List$(E), [], {growable: core.bool}],
        add: [dart.void, [E]],
        addAll: [dart.void, [core.Iterable$(E)]],
        remove: [core.bool, [core.Object]],
        [_filterWhere]: [dart.void, [dart.functionType(core.bool, [E]), core.bool]],
        removeWhere: [dart.void, [dart.functionType(core.bool, [E])]],
        retainWhere: [dart.void, [dart.functionType(core.bool, [E])]],
        clear: [dart.void, []],
        addLast: [dart.void, [E]],
        addFirst: [dart.void, [E]],
        removeFirst: [E, []],
        removeLast: [E, []],
        [_checkModification]: [dart.void, [core.int]],
        [_add$0]: [dart.void, [E]],
        [_remove]: [core.int, [core.int]],
        [_grow]: [dart.void, []],
        [_writeToList]: [core.int, [core.List$(E)]],
        [_preGrow]: [dart.void, [core.int]]
      }),
      statics: () => ({
        _isPowerOf2: [core.bool, [core.int]],
        _nextPowerOf2: [core.int, [core.int]]
      }),
      names: ['_isPowerOf2', '_nextPowerOf2']
    });
    dart.defineExtensionMembers(ListQueue, [
      'forEach',
      'elementAt',
      'toList',
      'toString',
      'iterator',
      'isEmpty',
      'length',
      'first',
      'last',
      'single'
    ]);
    return ListQueue;
  });
  collection.ListQueue = collection.ListQueue$();
  collection.ListQueue._INITIAL_CAPACITY = 8;
  const _end = Symbol('_end');
  const _position = Symbol('_position');
  collection._ListQueueIterator$ = dart.generic(E => {
    class _ListQueueIterator extends core.Object {
      _ListQueueIterator(queue) {
        this[_queue] = queue;
        this[_end] = queue[_tail];
        this[_modificationCount] = queue[_modificationCount];
        this[_position] = queue[_head];
        this[_current$2] = null;
      }
      get current() {
        return this[_current$2];
      }
      moveNext() {
        this[_queue][_checkModification](this[_modificationCount]);
        if (this[_position] == this[_end]) {
          this[_current$2] = null;
          return false;
        }
        this[_current$2] = this[_queue][_table][dartx.get](this[_position]);
        this[_position] = (dart.notNull(this[_position]) + 1 & dart.notNull(this[_queue][_table][dartx.length]) - 1) >>> 0;
        return true;
      }
    }
    _ListQueueIterator[dart.implements] = () => [core.Iterator$(E)];
    dart.setSignature(_ListQueueIterator, {
      constructors: () => ({_ListQueueIterator: [collection._ListQueueIterator$(E), [collection.ListQueue$(E)]]}),
      methods: () => ({moveNext: [core.bool, []]})
    });
    return _ListQueueIterator;
  });
  collection._ListQueueIterator = collection._ListQueueIterator$();
  collection._Predicate$ = dart.generic(T => {
    const _Predicate = dart.typedef('_Predicate', () => dart.functionType(core.bool, [T]));
    return _Predicate;
  });
  collection._Predicate = collection._Predicate$();
  collection._SplayTreeNode$ = dart.generic(K => {
    class _SplayTreeNode extends core.Object {
      _SplayTreeNode(key) {
        this.key = key;
        this.left = null;
        this.right = null;
      }
    }
    dart.setSignature(_SplayTreeNode, {
      constructors: () => ({_SplayTreeNode: [collection._SplayTreeNode$(K), [K]]})
    });
    return _SplayTreeNode;
  });
  collection._SplayTreeNode = collection._SplayTreeNode$();
  collection._SplayTreeMapNode$ = dart.generic((K, V) => {
    class _SplayTreeMapNode extends collection._SplayTreeNode$(K) {
      _SplayTreeMapNode(key, value) {
        this.value = value;
        super._SplayTreeNode(key);
      }
    }
    dart.setSignature(_SplayTreeMapNode, {
      constructors: () => ({_SplayTreeMapNode: [collection._SplayTreeMapNode$(K, V), [K, V]]})
    });
    return _SplayTreeMapNode;
  });
  collection._SplayTreeMapNode = collection._SplayTreeMapNode$();
  const _count$ = Symbol('_count');
  const _splayCount = Symbol('_splayCount');
  const _root = Symbol('_root');
  const _dummy = Symbol('_dummy');
  const _comparator = Symbol('_comparator');
  const _compare = Symbol('_compare');
  const _splay = Symbol('_splay');
  const _splayMin = Symbol('_splayMin');
  const _splayMax = Symbol('_splayMax');
  const _addNewRoot = Symbol('_addNewRoot');
  const _clear$ = Symbol('_clear');
  collection._SplayTree$ = dart.generic((K, Node) => {
    class _SplayTree extends core.Object {
      _SplayTree() {
        this[_count$] = 0;
        this[_modificationCount] = 0;
        this[_splayCount] = 0;
      }
      [_splay](key) {
        dart.as(key, K);
        if (this[_root] == null) return -1;
        let left = this[_dummy];
        let right = this[_dummy];
        let current = this[_root];
        let comp = null;
        while (true) {
          comp = this[_compare](current.key, key);
          if (dart.notNull(comp) > 0) {
            if (current.left == null) break;
            comp = this[_compare](current.left.key, key);
            if (dart.notNull(comp) > 0) {
              let tmp = current.left;
              current.left = tmp.right;
              tmp.right = current;
              current = dart.as(tmp, Node);
              if (current.left == null) break;
            }
            right.left = current;
            right = current;
            current = dart.as(current.left, Node);
          } else if (dart.notNull(comp) < 0) {
            if (current.right == null) break;
            comp = this[_compare](current.right.key, key);
            if (dart.notNull(comp) < 0) {
              let tmp = dart.as(current.right, Node);
              current.right = tmp.left;
              tmp.left = current;
              current = tmp;
              if (current.right == null) break;
            }
            left.right = current;
            left = current;
            current = dart.as(current.right, Node);
          } else {
            break;
          }
        }
        left.right = current.left;
        right.left = current.right;
        current.left = this[_dummy].right;
        current.right = this[_dummy].left;
        this[_root] = current;
        this[_dummy].right = null;
        this[_dummy].left = null;
        this[_splayCount] = dart.notNull(this[_splayCount]) + 1;
        return comp;
      }
      [_splayMin](node) {
        dart.as(node, Node);
        let current = node;
        while (current.left != null) {
          let left = dart.as(current.left, Node);
          current.left = left.right;
          left.right = current;
          current = left;
        }
        return current;
      }
      [_splayMax](node) {
        dart.as(node, Node);
        let current = node;
        while (current.right != null) {
          let right = dart.as(current.right, Node);
          current.right = right.left;
          right.left = current;
          current = right;
        }
        return current;
      }
      [_remove](key) {
        dart.as(key, K);
        if (this[_root] == null) return null;
        let comp = this[_splay](key);
        if (comp != 0) return null;
        let result = this[_root];
        this[_count$] = dart.notNull(this[_count$]) - 1;
        if (this[_root].left == null) {
          this[_root] = dart.as(this[_root].right, Node);
        } else {
          let right = dart.as(this[_root].right, Node);
          this[_root] = this[_splayMax](dart.as(this[_root].left, Node));
          this[_root].right = right;
        }
        this[_modificationCount] = dart.notNull(this[_modificationCount]) + 1;
        return result;
      }
      [_addNewRoot](node, comp) {
        dart.as(node, Node);
        this[_count$] = dart.notNull(this[_count$]) + 1;
        this[_modificationCount] = dart.notNull(this[_modificationCount]) + 1;
        if (this[_root] == null) {
          this[_root] = node;
          return;
        }
        if (dart.notNull(comp) < 0) {
          node.left = this[_root];
          node.right = this[_root].right;
          this[_root].right = null;
        } else {
          node.right = this[_root];
          node.left = this[_root].left;
          this[_root].left = null;
        }
        this[_root] = node;
      }
      get [_first$]() {
        if (this[_root] == null) return null;
        this[_root] = this[_splayMin](this[_root]);
        return this[_root];
      }
      get [_last$]() {
        if (this[_root] == null) return null;
        this[_root] = this[_splayMax](this[_root]);
        return this[_root];
      }
      [_clear$]() {
        this[_root] = null;
        this[_count$] = 0;
        this[_modificationCount] = dart.notNull(this[_modificationCount]) + 1;
      }
    }
    dart.setSignature(_SplayTree, {
      methods: () => ({
        [_splay]: [core.int, [K]],
        [_splayMin]: [Node, [Node]],
        [_splayMax]: [Node, [Node]],
        [_remove]: [Node, [K]],
        [_addNewRoot]: [dart.void, [Node, core.int]],
        [_clear$]: [dart.void, []]
      })
    });
    return _SplayTree;
  });
  collection._SplayTree = collection._SplayTree$();
  collection._TypeTest$ = dart.generic(T => {
    class _TypeTest extends core.Object {
      test(v) {
        return dart.is(v, T);
      }
    }
    dart.setSignature(_TypeTest, {
      methods: () => ({test: [core.bool, [dart.dynamic]]})
    });
    return _TypeTest;
  });
  collection._TypeTest = collection._TypeTest$();
  collection.SplayTreeMap$ = dart.generic((K, V) => {
    class SplayTreeMap extends collection._SplayTree$(K, collection._SplayTreeMapNode$(K, V)) {
      SplayTreeMap(compare, isValidKey) {
        if (compare === void 0) compare = null;
        if (isValidKey === void 0) isValidKey = null;
        this[_dummy] = new (collection._SplayTreeMapNode$(K, V))(null, null);
        this[_comparator] = (() => {
          let l = compare;
          return l != null ? l : dart.as(core.Comparable.compare, core.Comparator$(K));
        })();
        this[_validKey] = (() => {
          let l = isValidKey;
          return l != null ? l : dart.fn(v => dart.is(v, K), core.bool, [dart.dynamic]);
        })();
        this[_root] = null;
        super._SplayTree();
      }
      static from(other, compare, isValidKey) {
        if (compare === void 0) compare = null;
        if (isValidKey === void 0) isValidKey = null;
        let result = new (collection.SplayTreeMap$(K, V))(compare, isValidKey);
        other[dartx.forEach](dart.fn((k, v) => {
          result.set(dart.as(k, K), dart.as(v, V));
        }, dart.void, [dart.dynamic, dart.dynamic]));
        return result;
      }
      static fromIterable(iterable, opts) {
        let key = opts && 'key' in opts ? opts.key : null;
        let value = opts && 'value' in opts ? opts.value : null;
        let compare = opts && 'compare' in opts ? opts.compare : null;
        let isValidKey = opts && 'isValidKey' in opts ? opts.isValidKey : null;
        let map = new (collection.SplayTreeMap$(K, V))(compare, isValidKey);
        collection.Maps._fillMapWithMappedIterable(map, iterable, key, value);
        return map;
      }
      static fromIterables(keys, values, compare, isValidKey) {
        if (compare === void 0) compare = null;
        if (isValidKey === void 0) isValidKey = null;
        let map = new (collection.SplayTreeMap$(K, V))(compare, isValidKey);
        collection.Maps._fillMapWithIterables(map, keys, values);
        return map;
      }
      [_compare](key1, key2) {
        dart.as(key1, K);
        dart.as(key2, K);
        return this[_comparator](key1, key2);
      }
      _internal() {
        this[_dummy] = new (collection._SplayTreeMapNode$(K, V))(null, null);
        this[_root] = null;
        this[_comparator] = null;
        this[_validKey] = null;
        super._SplayTree();
      }
      get(key) {
        if (!dart.notNull(dart.dcall(this[_validKey], key))) return null;
        if (this[_root] != null) {
          let comp = this[_splay](dart.as(key, K));
          if (comp == 0) {
            return this[_root].value;
          }
        }
        return null;
      }
      remove(key) {
        if (!dart.notNull(dart.dcall(this[_validKey], key))) return null;
        let mapRoot = this[_remove](dart.as(key, K));
        if (mapRoot != null) return mapRoot.value;
        return null;
      }
      set(key, value) {
        (() => {
          dart.as(key, K);
          dart.as(value, V);
          if (key == null) dart.throw(new core.ArgumentError(key));
          let comp = this[_splay](key);
          if (comp == 0) {
            this[_root].value = value;
            return;
          }
          this[_addNewRoot](new (collection._SplayTreeMapNode$(K, V))(key, value), comp);
        })();
        return value;
      }
      putIfAbsent(key, ifAbsent) {
        dart.as(key, K);
        dart.as(ifAbsent, dart.functionType(V, []));
        if (key == null) dart.throw(new core.ArgumentError(key));
        let comp = this[_splay](key);
        if (comp == 0) {
          return this[_root].value;
        }
        let modificationCount = this[_modificationCount];
        let splayCount = this[_splayCount];
        let value = ifAbsent();
        if (modificationCount != this[_modificationCount]) {
          dart.throw(new core.ConcurrentModificationError(this));
        }
        if (splayCount != this[_splayCount]) {
          comp = this[_splay](key);
          dart.assert(comp != 0);
        }
        this[_addNewRoot](new (collection._SplayTreeMapNode$(K, V))(key, value), comp);
        return value;
      }
      addAll(other) {
        dart.as(other, core.Map$(K, V));
        other[dartx.forEach](dart.fn((key, value) => {
          dart.as(key, K);
          dart.as(value, V);
          this.set(key, value);
        }, dart.void, [K, V]));
      }
      get isEmpty() {
        return this[_root] == null;
      }
      get isNotEmpty() {
        return !dart.notNull(this.isEmpty);
      }
      forEach(f) {
        dart.as(f, dart.functionType(dart.void, [K, V]));
        let nodes = new (collection._SplayTreeNodeIterator$(K))(this);
        while (dart.notNull(nodes.moveNext())) {
          let node = dart.as(nodes.current, collection._SplayTreeMapNode$(K, V));
          f(node.key, node.value);
        }
      }
      get length() {
        return this[_count$];
      }
      clear() {
        this[_clear$]();
      }
      containsKey(key) {
        return dart.notNull(dart.dcall(this[_validKey], key)) && this[_splay](dart.as(key, K)) == 0;
      }
      containsValue(value) {
        let found = false;
        let initialSplayCount = this[_splayCount];
        const visit = (function(node) {
          while (node != null) {
            if (dart.equals(node.value, value)) return true;
            if (initialSplayCount != this[_splayCount]) {
              dart.throw(new core.ConcurrentModificationError(this));
            }
            if (node.right != null && dart.notNull(visit(dart.as(node.right, collection._SplayTreeMapNode)))) return true;
            node = dart.as(node.left, collection._SplayTreeMapNode);
          }
          return false;
        }).bind(this);
        dart.fn(visit, core.bool, [collection._SplayTreeMapNode]);
        return visit(this[_root]);
      }
      get keys() {
        return new (collection._SplayTreeKeyIterable$(K))(this);
      }
      get values() {
        return new (collection._SplayTreeValueIterable$(K, V))(this);
      }
      toString() {
        return collection.Maps.mapToString(this);
      }
      firstKey() {
        if (this[_root] == null) return null;
        return this[_first$].key;
      }
      lastKey() {
        if (this[_root] == null) return null;
        return this[_last$].key;
      }
      lastKeyBefore(key) {
        dart.as(key, K);
        if (key == null) dart.throw(new core.ArgumentError(key));
        if (this[_root] == null) return null;
        let comp = this[_splay](key);
        if (dart.notNull(comp) < 0) return this[_root].key;
        let node = this[_root].left;
        if (node == null) return null;
        while (node.right != null) {
          node = node.right;
        }
        return node.key;
      }
      firstKeyAfter(key) {
        dart.as(key, K);
        if (key == null) dart.throw(new core.ArgumentError(key));
        if (this[_root] == null) return null;
        let comp = this[_splay](key);
        if (dart.notNull(comp) > 0) return this[_root].key;
        let node = this[_root].right;
        if (node == null) return null;
        while (node.left != null) {
          node = node.left;
        }
        return node.key;
      }
    }
    dart.defineNamedConstructor(SplayTreeMap, '_internal');
    SplayTreeMap[dart.implements] = () => [core.Map$(K, V)];
    dart.setSignature(SplayTreeMap, {
      constructors: () => ({
        SplayTreeMap: [collection.SplayTreeMap$(K, V), [], [dart.functionType(core.int, [K, K]), dart.functionType(core.bool, [dart.dynamic])]],
        from: [collection.SplayTreeMap$(K, V), [core.Map], [dart.functionType(core.int, [K, K]), dart.functionType(core.bool, [dart.dynamic])]],
        fromIterable: [collection.SplayTreeMap$(K, V), [core.Iterable], {key: dart.functionType(K, [dart.dynamic]), value: dart.functionType(V, [dart.dynamic]), compare: dart.functionType(core.int, [K, K]), isValidKey: dart.functionType(core.bool, [dart.dynamic])}],
        fromIterables: [collection.SplayTreeMap$(K, V), [core.Iterable$(K), core.Iterable$(V)], [dart.functionType(core.int, [K, K]), dart.functionType(core.bool, [dart.dynamic])]],
        _internal: [collection.SplayTreeMap$(K, V), []]
      }),
      methods: () => ({
        [_compare]: [core.int, [K, K]],
        get: [V, [core.Object]],
        remove: [V, [core.Object]],
        set: [dart.void, [K, V]],
        putIfAbsent: [V, [K, dart.functionType(V, [])]],
        addAll: [dart.void, [core.Map$(K, V)]],
        forEach: [dart.void, [dart.functionType(dart.void, [K, V])]],
        clear: [dart.void, []],
        containsKey: [core.bool, [core.Object]],
        containsValue: [core.bool, [core.Object]],
        firstKey: [K, []],
        lastKey: [K, []],
        lastKeyBefore: [K, [K]],
        firstKeyAfter: [K, [K]]
      })
    });
    dart.defineExtensionMembers(SplayTreeMap, [
      'get',
      'remove',
      'set',
      'putIfAbsent',
      'addAll',
      'forEach',
      'clear',
      'containsKey',
      'containsValue',
      'isEmpty',
      'isNotEmpty',
      'length',
      'keys',
      'values'
    ]);
    return SplayTreeMap;
  });
  collection.SplayTreeMap = collection.SplayTreeMap$();
  const _workList = Symbol('_workList');
  const _tree = Symbol('_tree');
  const _currentNode = Symbol('_currentNode');
  const _findLeftMostDescendent = Symbol('_findLeftMostDescendent');
  const _getValue = Symbol('_getValue');
  const _rebuildWorkList = Symbol('_rebuildWorkList');
  collection._SplayTreeIterator$ = dart.generic((K, T) => {
    class _SplayTreeIterator extends core.Object {
      _SplayTreeIterator(tree) {
        this[_workList] = dart.list([], collection._SplayTreeNode$(K));
        this[_tree] = tree;
        this[_modificationCount] = tree[_modificationCount];
        this[_splayCount] = tree[_splayCount];
        this[_currentNode] = null;
        this[_findLeftMostDescendent](tree[_root]);
      }
      startAt(tree, startKey) {
        this[_workList] = dart.list([], collection._SplayTreeNode$(K));
        this[_tree] = tree;
        this[_modificationCount] = tree[_modificationCount];
        this[_splayCount] = null;
        this[_currentNode] = null;
        if (tree[_root] == null) return;
        let compare = tree[_splay](startKey);
        this[_splayCount] = tree[_splayCount];
        if (dart.notNull(compare) < 0) {
          this[_findLeftMostDescendent](tree[_root].right);
        } else {
          this[_workList][dartx.add](tree[_root]);
        }
      }
      get current() {
        if (this[_currentNode] == null) return null;
        return this[_getValue](this[_currentNode]);
      }
      [_findLeftMostDescendent](node) {
        dart.as(node, collection._SplayTreeNode$(K));
        while (node != null) {
          this[_workList][dartx.add](node);
          node = node.left;
        }
      }
      [_rebuildWorkList](currentNode) {
        dart.as(currentNode, collection._SplayTreeNode$(K));
        dart.assert(!dart.notNull(this[_workList][dartx.isEmpty]));
        this[_workList][dartx.clear]();
        if (currentNode == null) {
          this[_findLeftMostDescendent](this[_tree][_root]);
        } else {
          this[_tree][_splay](currentNode.key);
          this[_findLeftMostDescendent](this[_tree][_root].right);
          dart.assert(!dart.notNull(this[_workList][dartx.isEmpty]));
        }
      }
      moveNext() {
        if (this[_modificationCount] != this[_tree][_modificationCount]) {
          dart.throw(new core.ConcurrentModificationError(this[_tree]));
        }
        if (dart.notNull(this[_workList][dartx.isEmpty])) {
          this[_currentNode] = null;
          return false;
        }
        if (this[_tree][_splayCount] != this[_splayCount] && this[_currentNode] != null) {
          this[_rebuildWorkList](this[_currentNode]);
        }
        this[_currentNode] = this[_workList][dartx.removeLast]();
        this[_findLeftMostDescendent](this[_currentNode].right);
        return true;
      }
    }
    dart.defineNamedConstructor(_SplayTreeIterator, 'startAt');
    _SplayTreeIterator[dart.implements] = () => [core.Iterator$(T)];
    dart.setSignature(_SplayTreeIterator, {
      constructors: () => ({
        _SplayTreeIterator: [collection._SplayTreeIterator$(K, T), [collection._SplayTree$(K, collection._SplayTreeNode$(K))]],
        startAt: [collection._SplayTreeIterator$(K, T), [collection._SplayTree$(K, collection._SplayTreeNode$(K)), K]]
      }),
      methods: () => ({
        [_findLeftMostDescendent]: [dart.void, [collection._SplayTreeNode$(K)]],
        [_rebuildWorkList]: [dart.void, [collection._SplayTreeNode$(K)]],
        moveNext: [core.bool, []]
      })
    });
    return _SplayTreeIterator;
  });
  collection._SplayTreeIterator = collection._SplayTreeIterator$();
  const _copyNode = Symbol('_copyNode');
  collection._SplayTreeKeyIterable$ = dart.generic(K => {
    class _SplayTreeKeyIterable extends core.Iterable$(K) {
      _SplayTreeKeyIterable(tree) {
        this[_tree] = tree;
        super.Iterable();
      }
      get length() {
        return this[_tree][_count$];
      }
      get isEmpty() {
        return this[_tree][_count$] == 0;
      }
      get iterator() {
        return new (collection._SplayTreeKeyIterator$(K))(this[_tree]);
      }
      toSet() {
        let set = new (collection.SplayTreeSet$(K))(this[_tree][_comparator], this[_tree][_validKey]);
        set[_count$] = this[_tree][_count$];
        set[_root] = set[_copyNode](this[_tree][_root]);
        return set;
      }
    }
    _SplayTreeKeyIterable[dart.implements] = () => [_internal.EfficientLength];
    dart.setSignature(_SplayTreeKeyIterable, {
      constructors: () => ({_SplayTreeKeyIterable: [collection._SplayTreeKeyIterable$(K), [collection._SplayTree$(K, collection._SplayTreeNode$(K))]]}),
      methods: () => ({toSet: [core.Set$(K), []]})
    });
    dart.defineExtensionMembers(_SplayTreeKeyIterable, ['toSet', 'length', 'isEmpty', 'iterator']);
    return _SplayTreeKeyIterable;
  });
  collection._SplayTreeKeyIterable = collection._SplayTreeKeyIterable$();
  collection._SplayTreeValueIterable$ = dart.generic((K, V) => {
    class _SplayTreeValueIterable extends core.Iterable$(V) {
      _SplayTreeValueIterable(map) {
        this[_map$0] = map;
        super.Iterable();
      }
      get length() {
        return this[_map$0][_count$];
      }
      get isEmpty() {
        return this[_map$0][_count$] == 0;
      }
      get iterator() {
        return new (collection._SplayTreeValueIterator$(K, V))(this[_map$0]);
      }
    }
    _SplayTreeValueIterable[dart.implements] = () => [_internal.EfficientLength];
    dart.setSignature(_SplayTreeValueIterable, {
      constructors: () => ({_SplayTreeValueIterable: [collection._SplayTreeValueIterable$(K, V), [collection.SplayTreeMap$(K, V)]]})
    });
    dart.defineExtensionMembers(_SplayTreeValueIterable, ['length', 'isEmpty', 'iterator']);
    return _SplayTreeValueIterable;
  });
  collection._SplayTreeValueIterable = collection._SplayTreeValueIterable$();
  collection._SplayTreeKeyIterator$ = dart.generic(K => {
    class _SplayTreeKeyIterator extends collection._SplayTreeIterator$(K, K) {
      _SplayTreeKeyIterator(map) {
        super._SplayTreeIterator(map);
      }
      [_getValue](node) {
        dart.as(node, collection._SplayTreeNode$(K));
        return node.key;
      }
    }
    dart.setSignature(_SplayTreeKeyIterator, {
      constructors: () => ({_SplayTreeKeyIterator: [collection._SplayTreeKeyIterator$(K), [collection._SplayTree$(K, collection._SplayTreeNode$(K))]]}),
      methods: () => ({[_getValue]: [K, [collection._SplayTreeNode$(K)]]})
    });
    return _SplayTreeKeyIterator;
  });
  collection._SplayTreeKeyIterator = collection._SplayTreeKeyIterator$();
  collection._SplayTreeValueIterator$ = dart.generic((K, V) => {
    class _SplayTreeValueIterator extends collection._SplayTreeIterator$(K, V) {
      _SplayTreeValueIterator(map) {
        super._SplayTreeIterator(map);
      }
      [_getValue](node) {
        dart.as(node, collection._SplayTreeNode$(K));
        let mapNode = dart.as(node, collection._SplayTreeMapNode$(K, V));
        return mapNode.value;
      }
    }
    dart.setSignature(_SplayTreeValueIterator, {
      constructors: () => ({_SplayTreeValueIterator: [collection._SplayTreeValueIterator$(K, V), [collection.SplayTreeMap$(K, V)]]}),
      methods: () => ({[_getValue]: [V, [collection._SplayTreeNode$(K)]]})
    });
    return _SplayTreeValueIterator;
  });
  collection._SplayTreeValueIterator = collection._SplayTreeValueIterator$();
  collection._SplayTreeNodeIterator$ = dart.generic(K => {
    class _SplayTreeNodeIterator extends collection._SplayTreeIterator$(K, collection._SplayTreeNode$(K)) {
      _SplayTreeNodeIterator(tree) {
        super._SplayTreeIterator(tree);
      }
      startAt(tree, startKey) {
        super.startAt(tree, startKey);
      }
      [_getValue](node) {
        dart.as(node, collection._SplayTreeNode$(K));
        return node;
      }
    }
    dart.defineNamedConstructor(_SplayTreeNodeIterator, 'startAt');
    dart.setSignature(_SplayTreeNodeIterator, {
      constructors: () => ({
        _SplayTreeNodeIterator: [collection._SplayTreeNodeIterator$(K), [collection._SplayTree$(K, collection._SplayTreeNode$(K))]],
        startAt: [collection._SplayTreeNodeIterator$(K), [collection._SplayTree$(K, collection._SplayTreeNode$(K)), K]]
      }),
      methods: () => ({[_getValue]: [collection._SplayTreeNode$(K), [collection._SplayTreeNode$(K)]]})
    });
    return _SplayTreeNodeIterator;
  });
  collection._SplayTreeNodeIterator = collection._SplayTreeNodeIterator$();
  const _clone = Symbol('_clone');
  collection.SplayTreeSet$ = dart.generic(E => {
    class SplayTreeSet extends dart.mixin(collection._SplayTree$(E, collection._SplayTreeNode$(E)), collection.IterableMixin$(E), collection.SetMixin$(E)) {
      SplayTreeSet(compare, isValidKey) {
        if (compare === void 0) compare = null;
        if (isValidKey === void 0) isValidKey = null;
        this[_dummy] = new (collection._SplayTreeNode$(E))(null);
        this[_comparator] = (() => {
          let l = compare;
          return l != null ? l : dart.as(core.Comparable.compare, core.Comparator$(E));
        })();
        this[_validKey] = (() => {
          let l = isValidKey;
          return l != null ? l : dart.fn(v => dart.is(v, E), core.bool, [dart.dynamic]);
        })();
        this[_root] = null;
        super._SplayTree();
      }
      static from(elements, compare, isValidKey) {
        if (compare === void 0) compare = null;
        if (isValidKey === void 0) isValidKey = null;
        let result = new (collection.SplayTreeSet$(E))(compare, isValidKey);
        for (let element of elements) {
          result.add(dart.as(element, E));
        }
        return result;
      }
      [_compare](e1, e2) {
        dart.as(e1, E);
        dart.as(e2, E);
        return this[_comparator](e1, e2);
      }
      get iterator() {
        return new (collection._SplayTreeKeyIterator$(E))(this);
      }
      get length() {
        return this[_count$];
      }
      get isEmpty() {
        return this[_root] == null;
      }
      get isNotEmpty() {
        return this[_root] != null;
      }
      get first() {
        if (this[_count$] == 0) dart.throw(_internal.IterableElementError.noElement());
        return this[_first$].key;
      }
      get last() {
        if (this[_count$] == 0) dart.throw(_internal.IterableElementError.noElement());
        return this[_last$].key;
      }
      get single() {
        if (this[_count$] == 0) dart.throw(_internal.IterableElementError.noElement());
        if (dart.notNull(this[_count$]) > 1) dart.throw(_internal.IterableElementError.tooMany());
        return this[_root].key;
      }
      contains(object) {
        return dart.notNull(dart.dcall(this[_validKey], object)) && this[_splay](dart.as(object, E)) == 0;
      }
      add(element) {
        dart.as(element, E);
        let compare = this[_splay](element);
        if (compare == 0) return false;
        this[_addNewRoot](new (collection._SplayTreeNode$(E))(element), compare);
        return true;
      }
      remove(object) {
        if (!dart.notNull(dart.dcall(this[_validKey], object))) return false;
        return this[_remove](dart.as(object, E)) != null;
      }
      addAll(elements) {
        dart.as(elements, core.Iterable$(E));
        for (let element of elements) {
          let compare = this[_splay](element);
          if (compare != 0) {
            this[_addNewRoot](new (collection._SplayTreeNode$(E))(element), compare);
          }
        }
      }
      removeAll(elements) {
        for (let element of elements) {
          if (dart.notNull(dart.dcall(this[_validKey], element))) this[_remove](dart.as(element, E));
        }
      }
      retainAll(elements) {
        let retainSet = new (collection.SplayTreeSet$(E))(this[_comparator], this[_validKey]);
        let modificationCount = this[_modificationCount];
        for (let object of elements) {
          if (modificationCount != this[_modificationCount]) {
            dart.throw(new core.ConcurrentModificationError(this));
          }
          if (dart.notNull(dart.dcall(this[_validKey], object)) && this[_splay](dart.as(object, E)) == 0) {
            retainSet.add(this[_root].key);
          }
        }
        if (retainSet[_count$] != this[_count$]) {
          this[_root] = retainSet[_root];
          this[_count$] = retainSet[_count$];
          this[_modificationCount] = dart.notNull(this[_modificationCount]) + 1;
        }
      }
      lookup(object) {
        if (!dart.notNull(dart.dcall(this[_validKey], object))) return null;
        let comp = this[_splay](dart.as(object, E));
        if (comp != 0) return null;
        return this[_root].key;
      }
      intersection(other) {
        let result = new (collection.SplayTreeSet$(E))(this[_comparator], this[_validKey]);
        for (let element of this) {
          if (dart.notNull(other.contains(element))) result.add(element);
        }
        return result;
      }
      difference(other) {
        let result = new (collection.SplayTreeSet$(E))(this[_comparator], this[_validKey]);
        for (let element of this) {
          if (!dart.notNull(other.contains(element))) result.add(element);
        }
        return result;
      }
      union(other) {
        dart.as(other, core.Set$(E));
        let _ = this[_clone]();
        _.addAll(other);
        return _;
      }
      [_clone]() {
        let set = new (collection.SplayTreeSet$(E))(this[_comparator], this[_validKey]);
        set[_count$] = this[_count$];
        set[_root] = this[_copyNode](this[_root]);
        return set;
      }
      [_copyNode](node) {
        dart.as(node, collection._SplayTreeNode$(E));
        if (node == null) return null;
        let _ = new (collection._SplayTreeNode$(E))(node.key);
        _.left = this[_copyNode](node.left);
        _.right = this[_copyNode](node.right);
        return _;
      }
      clear() {
        this[_clear$]();
      }
      toSet() {
        return this[_clone]();
      }
      toString() {
        return collection.IterableBase.iterableToFullString(this, '{', '}');
      }
    }
    dart.setSignature(SplayTreeSet, {
      constructors: () => ({
        SplayTreeSet: [collection.SplayTreeSet$(E), [], [dart.functionType(core.int, [E, E]), dart.functionType(core.bool, [dart.dynamic])]],
        from: [collection.SplayTreeSet$(E), [core.Iterable], [dart.functionType(core.int, [E, E]), dart.functionType(core.bool, [dart.dynamic])]]
      }),
      methods: () => ({
        [_compare]: [core.int, [E, E]],
        contains: [core.bool, [core.Object]],
        add: [core.bool, [E]],
        remove: [core.bool, [core.Object]],
        addAll: [dart.void, [core.Iterable$(E)]],
        lookup: [E, [core.Object]],
        intersection: [core.Set$(E), [core.Set$(core.Object)]],
        difference: [core.Set$(E), [core.Set$(core.Object)]],
        union: [core.Set$(E), [core.Set$(E)]],
        [_clone]: [collection.SplayTreeSet$(E), []],
        [_copyNode]: [collection._SplayTreeNode$(E), [collection._SplayTreeNode$(E)]],
        toSet: [core.Set$(E), []]
      })
    });
    dart.defineExtensionMembers(SplayTreeSet, [
      'contains',
      'toSet',
      'toString',
      'iterator',
      'length',
      'isEmpty',
      'isNotEmpty',
      'first',
      'last',
      'single'
    ]);
    return SplayTreeSet;
  });
  collection.SplayTreeSet = collection.SplayTreeSet$();
  const _processed = Symbol('_processed');
  const _computeKeys$ = Symbol('_computeKeys');
  const _original = Symbol('_original');
  convert._convertJsonToDart = function(json, reviver) {
    dart.assert(reviver != null);
    function walk(e) {
      if (e == null || typeof e != "object") {
        return e;
      }
      if (Object.getPrototypeOf(e) === Array.prototype) {
        for (let i = 0; i < e.length; i++) {
          let item = e[i];
          e[i] = dart.dcall(reviver, i, walk(item));
        }
        return e;
      }
      let map = new convert._JsonMap(e);
      let processed = map[_processed];
      let keys = map[_computeKeys$]();
      for (let i = 0; i < dart.notNull(keys[dartx.length]); i++) {
        let key = keys[dartx.get](i);
        let revived = dart.dcall(reviver, key, walk(e[key]));
        processed[key] = revived;
      }
      map[_original] = processed;
      return map;
    }
    dart.fn(walk);
    return dart.dcall(reviver, null, walk(json));
  };
  dart.fn(convert._convertJsonToDart, dart.dynamic, [dart.dynamic, dart.functionType(dart.dynamic, [dart.dynamic, dart.dynamic])]);
  convert._convertJsonToDartLazy = function(object) {
    if (object == null) return null;
    if (typeof object != "object") {
      return object;
    }
    if (Object.getPrototypeOf(object) !== Array.prototype) {
      return new convert._JsonMap(object);
    }
    for (let i = 0; i < object.length; i++) {
      let item = object[i];
      object[i] = convert._convertJsonToDartLazy(item);
    }
    return object;
  };
  dart.fn(convert._convertJsonToDartLazy);
  const _data = Symbol('_data');
  const _isUpgraded = Symbol('_isUpgraded');
  const _upgradedMap = Symbol('_upgradedMap');
  const _process = Symbol('_process');
  const _upgrade = Symbol('_upgrade');
  convert._JsonMap = class _JsonMap extends core.Object {
    _JsonMap(original) {
      this[_processed] = convert._JsonMap._newJavaScriptObject();
      this[_original] = original;
      this[_data] = null;
    }
    get(key) {
      if (dart.notNull(this[_isUpgraded])) {
        return this[_upgradedMap][dartx.get](key);
      } else if (!(typeof key == 'string')) {
        return null;
      } else {
        let result = convert._JsonMap._getProperty(this[_processed], dart.as(key, core.String));
        if (dart.notNull(convert._JsonMap._isUnprocessed(result))) result = this[_process](dart.as(key, core.String));
        return result;
      }
    }
    get length() {
      return dart.notNull(this[_isUpgraded]) ? this[_upgradedMap][dartx.length] : this[_computeKeys$]()[dartx.length];
    }
    get isEmpty() {
      return this.length == 0;
    }
    get isNotEmpty() {
      return dart.notNull(this.length) > 0;
    }
    get keys() {
      if (dart.notNull(this[_isUpgraded])) return this[_upgradedMap][dartx.keys];
      return new convert._JsonMapKeyIterable(this);
    }
    get values() {
      if (dart.notNull(this[_isUpgraded])) return this[_upgradedMap][dartx.values];
      return _internal.MappedIterable.new(this[_computeKeys$](), dart.fn(each => this.get(each)));
    }
    set(key, value) {
      if (dart.notNull(this[_isUpgraded])) {
        this[_upgradedMap][dartx.set](key, value);
      } else if (dart.notNull(this.containsKey(key))) {
        let processed = this[_processed];
        convert._JsonMap._setProperty(processed, dart.as(key, core.String), value);
        let original = this[_original];
        if (!core.identical(original, processed)) {
          convert._JsonMap._setProperty(original, dart.as(key, core.String), null);
        }
      } else {
        this[_upgrade]()[dartx.set](key, value);
      }
      return value;
    }
    addAll(other) {
      other[dartx.forEach](dart.fn((key, value) => {
        this.set(key, value);
      }, dart.void, [dart.dynamic, dart.dynamic]));
    }
    containsValue(value) {
      if (dart.notNull(this[_isUpgraded])) return this[_upgradedMap][dartx.containsValue](value);
      let keys = this[_computeKeys$]();
      for (let i = 0; i < dart.notNull(keys[dartx.length]); i++) {
        let key = keys[dartx.get](i);
        if (dart.equals(this.get(key), value)) return true;
      }
      return false;
    }
    containsKey(key) {
      if (dart.notNull(this[_isUpgraded])) return this[_upgradedMap][dartx.containsKey](key);
      if (!(typeof key == 'string')) return false;
      return convert._JsonMap._hasProperty(this[_original], dart.as(key, core.String));
    }
    putIfAbsent(key, ifAbsent) {
      if (dart.notNull(this.containsKey(key))) return this.get(key);
      let value = ifAbsent();
      this.set(key, value);
      return value;
    }
    remove(key) {
      if (!dart.notNull(this[_isUpgraded]) && !dart.notNull(this.containsKey(key))) return null;
      return this[_upgrade]()[dartx.remove](key);
    }
    clear() {
      if (dart.notNull(this[_isUpgraded])) {
        this[_upgradedMap][dartx.clear]();
      } else {
        if (this[_data] != null) {
          dart.dsend(this[_data], 'clear');
        }
        this[_original] = this[_processed] = null;
        this[_data] = dart.map();
      }
    }
    forEach(f) {
      if (dart.notNull(this[_isUpgraded])) return this[_upgradedMap][dartx.forEach](f);
      let keys = this[_computeKeys$]();
      for (let i = 0; i < dart.notNull(keys[dartx.length]); i++) {
        let key = keys[dartx.get](i);
        let value = convert._JsonMap._getProperty(this[_processed], key);
        if (dart.notNull(convert._JsonMap._isUnprocessed(value))) {
          value = convert._convertJsonToDartLazy(convert._JsonMap._getProperty(this[_original], key));
          convert._JsonMap._setProperty(this[_processed], key, value);
        }
        dart.dcall(f, key, value);
        if (!core.identical(keys, this[_data])) {
          dart.throw(new core.ConcurrentModificationError(this));
        }
      }
    }
    toString() {
      return collection.Maps.mapToString(this);
    }
    get [_isUpgraded]() {
      return this[_processed] == null;
    }
    get [_upgradedMap]() {
      dart.assert(this[_isUpgraded]);
      return this[_data];
    }
    [_computeKeys$]() {
      dart.assert(!dart.notNull(this[_isUpgraded]));
      let keys = dart.as(this[_data], core.List);
      if (keys == null) {
        keys = this[_data] = convert._JsonMap._getPropertyNames(this[_original]);
      }
      return keys;
    }
    [_upgrade]() {
      if (dart.notNull(this[_isUpgraded])) return this[_upgradedMap];
      let result = dart.map();
      let keys = this[_computeKeys$]();
      for (let i = 0; i < dart.notNull(keys[dartx.length]); i++) {
        let key = keys[dartx.get](i);
        result[dartx.set](key, this.get(key));
      }
      if (dart.notNull(keys[dartx.isEmpty])) {
        keys[dartx.add](null);
      } else {
        keys[dartx.clear]();
      }
      this[_original] = this[_processed] = null;
      this[_data] = result;
      dart.assert(this[_isUpgraded]);
      return result;
    }
    [_process](key) {
      if (!dart.notNull(convert._JsonMap._hasProperty(this[_original], key))) return null;
      let result = convert._convertJsonToDartLazy(convert._JsonMap._getProperty(this[_original], key));
      return convert._JsonMap._setProperty(this[_processed], key, result);
    }
    static _hasProperty(object, key) {
      return Object.prototype.hasOwnProperty.call(object, key);
    }
    static _getProperty(object, key) {
      return object[key];
    }
    static _setProperty(object, key, value) {
      return object[key] = value;
    }
    static _getPropertyNames(object) {
      return Object.keys(object);
    }
    static _isUnprocessed(object) {
      return typeof object == "undefined";
    }
    static _newJavaScriptObject() {
      return Object.create(null);
    }
  };
  convert._JsonMap[dart.implements] = () => [collection.LinkedHashMap];
  dart.setSignature(convert._JsonMap, {
    constructors: () => ({_JsonMap: [convert._JsonMap, [dart.dynamic]]}),
    methods: () => ({
      get: [dart.dynamic, [core.Object]],
      set: [dart.void, [dart.dynamic, dart.dynamic]],
      addAll: [dart.void, [core.Map]],
      containsValue: [core.bool, [core.Object]],
      containsKey: [core.bool, [core.Object]],
      putIfAbsent: [dart.dynamic, [dart.dynamic, dart.functionType(dart.dynamic, [])]],
      remove: [dart.dynamic, [core.Object]],
      clear: [dart.void, []],
      forEach: [dart.void, [dart.functionType(dart.void, [dart.dynamic, dart.dynamic])]],
      [_computeKeys$]: [core.List$(core.String), []],
      [_upgrade]: [core.Map, []],
      [_process]: [dart.dynamic, [core.String]]
    }),
    statics: () => ({
      _hasProperty: [core.bool, [dart.dynamic, core.String]],
      _getProperty: [dart.dynamic, [dart.dynamic, core.String]],
      _setProperty: [dart.dynamic, [dart.dynamic, core.String, dart.dynamic]],
      _getPropertyNames: [core.List, [dart.dynamic]],
      _isUnprocessed: [core.bool, [dart.dynamic]],
      _newJavaScriptObject: [dart.dynamic, []]
    }),
    names: ['_hasProperty', '_getProperty', '_setProperty', '_getPropertyNames', '_isUnprocessed', '_newJavaScriptObject']
  });
  dart.defineExtensionMembers(convert._JsonMap, [
    'get',
    'set',
    'addAll',
    'containsValue',
    'containsKey',
    'putIfAbsent',
    'remove',
    'clear',
    'forEach',
    'length',
    'isEmpty',
    'isNotEmpty',
    'keys',
    'values'
  ]);
  const _parent = Symbol('_parent');
  convert._JsonMapKeyIterable = class _JsonMapKeyIterable extends _internal.ListIterable {
    _JsonMapKeyIterable(parent) {
      this[_parent] = parent;
      super.ListIterable();
    }
    get length() {
      return this[_parent].length;
    }
    elementAt(index) {
      return dart.as(dart.notNull(this[_parent][_isUpgraded]) ? this[_parent].keys[dartx.elementAt](index) : this[_parent][_computeKeys$]()[dartx.get](index), core.String);
    }
    get iterator() {
      return dart.notNull(this[_parent][_isUpgraded]) ? this[_parent].keys[dartx.iterator] : this[_parent][_computeKeys$]()[dartx.iterator];
    }
    contains(key) {
      return this[_parent].containsKey(key);
    }
  };
  dart.setSignature(convert._JsonMapKeyIterable, {
    constructors: () => ({_JsonMapKeyIterable: [convert._JsonMapKeyIterable, [convert._JsonMap]]}),
    methods: () => ({elementAt: [core.String, [core.int]]})
  });
  dart.defineExtensionMembers(convert._JsonMapKeyIterable, ['elementAt', 'contains', 'length', 'iterator']);
  const _reviver = Symbol('_reviver');
  const _sink$ = Symbol('_sink');
  const _stringSink = Symbol('_stringSink');
  convert.StringConversionSinkMixin = class StringConversionSinkMixin extends core.Object {
    add(str) {
      this.addSlice(str, 0, str[dartx.length], false);
    }
    asUtf8Sink(allowMalformed) {
      return new convert._Utf8ConversionSink(this, allowMalformed);
    }
    asStringSink() {
      return new convert._StringConversionSinkAsStringSinkAdapter(this);
    }
  };
  convert.StringConversionSinkMixin[dart.implements] = () => [convert.StringConversionSink];
  dart.setSignature(convert.StringConversionSinkMixin, {
    methods: () => ({
      add: [dart.void, [core.String]],
      asUtf8Sink: [convert.ByteConversionSink, [core.bool]],
      asStringSink: [convert.ClosableStringSink, []]
    })
  });
  convert.StringConversionSinkBase = class StringConversionSinkBase extends convert.StringConversionSinkMixin {};
  convert._StringSinkConversionSink = class _StringSinkConversionSink extends convert.StringConversionSinkBase {
    _StringSinkConversionSink(stringSink) {
      this[_stringSink] = stringSink;
    }
    close() {}
    addSlice(str, start, end, isLast) {
      if (start != 0 || end != str[dartx.length]) {
        for (let i = start; dart.notNull(i) < dart.notNull(end); i = dart.notNull(i) + 1) {
          this[_stringSink].writeCharCode(str[dartx.codeUnitAt](i));
        }
      } else {
        this[_stringSink].write(str);
      }
      if (dart.notNull(isLast)) this.close();
    }
    add(str) {
      this[_stringSink].write(str);
    }
    asUtf8Sink(allowMalformed) {
      return new convert._Utf8StringSinkAdapter(this, this[_stringSink], allowMalformed);
    }
    asStringSink() {
      return convert.ClosableStringSink.fromStringSink(this[_stringSink], dart.bind(this, 'close'));
    }
  };
  dart.setSignature(convert._StringSinkConversionSink, {
    constructors: () => ({_StringSinkConversionSink: [convert._StringSinkConversionSink, [core.StringSink]]}),
    methods: () => ({
      close: [dart.void, []],
      addSlice: [dart.void, [core.String, core.int, core.int, core.bool]]
    })
  });
  convert._JsonDecoderSink = class _JsonDecoderSink extends convert._StringSinkConversionSink {
    _JsonDecoderSink(reviver, sink) {
      this[_reviver] = reviver;
      this[_sink$] = sink;
      super._StringSinkConversionSink(new core.StringBuffer());
    }
    close() {
      super.close();
      let buffer = dart.as(this[_stringSink], core.StringBuffer);
      let accumulated = dart.toString(buffer);
      buffer.clear();
      let decoded = convert._parseJson(accumulated, this[_reviver]);
      this[_sink$].add(decoded);
      this[_sink$].close();
    }
  };
  dart.setSignature(convert._JsonDecoderSink, {
    constructors: () => ({_JsonDecoderSink: [convert._JsonDecoderSink, [convert._Reviver, core.Sink$(core.Object)]]})
  });
  const _allowInvalid = Symbol('_allowInvalid');
  convert.Codec$ = dart.generic((S, T) => {
    class Codec extends core.Object {
      Codec() {
      }
      encode(input) {
        dart.as(input, S);
        return this.encoder.convert(input);
      }
      decode(encoded) {
        dart.as(encoded, T);
        return this.decoder.convert(encoded);
      }
      fuse(other) {
        dart.as(other, convert.Codec$(T, dart.dynamic));
        return new (convert._FusedCodec$(S, T, dart.dynamic))(this, other);
      }
      get inverted() {
        return new (convert._InvertedCodec$(T, S))(this);
      }
    }
    dart.setSignature(Codec, {
      constructors: () => ({Codec: [convert.Codec$(S, T), []]}),
      methods: () => ({
        encode: [T, [S]],
        decode: [S, [T]],
        fuse: [convert.Codec$(S, dart.dynamic), [convert.Codec$(T, dart.dynamic)]]
      })
    });
    return Codec;
  });
  convert.Codec = convert.Codec$();
  core.String = class String extends core.Object {
    static fromCharCodes(charCodes, start, end) {
      if (start === void 0) start = 0;
      if (end === void 0) end = null;
      if (dart.is(charCodes, _interceptors.JSArray)) {
        return core.String._stringFromJSArray(dart.as(charCodes, _interceptors.JSArray$(core.int)), start, end);
      }
      if (dart.is(charCodes, _native_typed_data.NativeUint8List)) {
        return core.String._stringFromUint8List(charCodes, start, end);
      }
      return core.String._stringFromIterable(charCodes, start, end);
    }
    static fromCharCode(charCode) {
      return _js_helper.Primitives.stringFromCharCode(charCode);
    }
    static fromEnvironment(name, opts) {
      let defaultValue = opts && 'defaultValue' in opts ? opts.defaultValue : null;
      dart.throw(new core.UnsupportedError('String.fromEnvironment can only be used as a const constructor'));
    }
    static _stringFromJSArray(list, start, endOrNull) {
      let len = list[dartx.length];
      let end = core.RangeError.checkValidRange(start, endOrNull, len);
      if (dart.notNull(start) > 0 || dart.notNull(end) < dart.notNull(len)) {
        list = dart.as(list[dartx.sublist](start, end), _interceptors.JSArray$(core.int));
      }
      return _js_helper.Primitives.stringFromCharCodes(list);
    }
    static _stringFromUint8List(charCodes, start, endOrNull) {
      let len = charCodes[dartx.length];
      let end = core.RangeError.checkValidRange(start, endOrNull, len);
      return _js_helper.Primitives.stringFromNativeUint8List(charCodes, start, end);
    }
    static _stringFromIterable(charCodes, start, end) {
      if (dart.notNull(start) < 0) dart.throw(new core.RangeError.range(start, 0, charCodes[dartx.length]));
      if (end != null && dart.notNull(end) < dart.notNull(start)) {
        dart.throw(new core.RangeError.range(end, start, charCodes[dartx.length]));
      }
      let it = charCodes[dartx.iterator];
      for (let i = 0; i < dart.notNull(start); i++) {
        if (!dart.notNull(it.moveNext())) {
          dart.throw(new core.RangeError.range(start, 0, i));
        }
      }
      let list = dart.list([], core.int);
      if (end == null) {
        while (dart.notNull(it.moveNext()))
          list[dartx.add](it.current);
      } else {
        for (let i = start; dart.notNull(i) < dart.notNull(end); i = dart.notNull(i) + 1) {
          if (!dart.notNull(it.moveNext())) {
            dart.throw(new core.RangeError.range(end, start, i));
          }
          list[dartx.add](it.current);
        }
      }
      return _js_helper.Primitives.stringFromCharCodes(dart.as(list, _interceptors.JSArray$(core.int)));
    }
  };
  core.String[dart.implements] = () => [core.Comparable$(core.String), core.Pattern];
  dart.setSignature(core.String, {
    constructors: () => ({
      fromCharCodes: [core.String, [core.Iterable$(core.int)], [core.int, core.int]],
      fromCharCode: [core.String, [core.int]],
      fromEnvironment: [core.String, [core.String], {defaultValue: core.String}]
    }),
    statics: () => ({
      _stringFromJSArray: [core.String, [_interceptors.JSArray$(core.int), core.int, core.int]],
      _stringFromUint8List: [core.String, [_native_typed_data.NativeUint8List, core.int, core.int]],
      _stringFromIterable: [core.String, [core.Iterable$(core.int), core.int, core.int]]
    }),
    names: ['_stringFromJSArray', '_stringFromUint8List', '_stringFromIterable']
  });
  core.List$ = dart.generic(E => {
    class List extends core.Object {
      static new(length) {
        if (length === void 0) length = null;
        let list = null;
        if (length == null) {
          list = [];
        } else {
          if (!(typeof length == 'number') || dart.notNull(length) < 0) {
            dart.throw(new core.ArgumentError(`Length must be a non-negative integer: ${length}`));
          }
          list = _interceptors.JSArray.markFixedList(new Array(length));
        }
        return _interceptors.JSArray$(E).typed(list);
      }
      static filled(length, fill) {
        let result = core.List$(E).new(length);
        if (length != 0 && fill != null) {
          for (let i = 0; i < dart.notNull(result[dartx.length]); i++) {
            result[dartx.set](i, fill);
          }
        }
        return result;
      }
      static from(elements, opts) {
        let growable = opts && 'growable' in opts ? opts.growable : true;
        let list = core.List$(E).new();
        for (let e of elements) {
          list[dartx.add](dart.as(e, E));
        }
        if (dart.notNull(growable)) return list;
        return _internal.makeListFixedLength(E)(list);
      }
      static generate(length, generator, opts) {
        let growable = opts && 'growable' in opts ? opts.growable : true;
        let result = null;
        if (dart.notNull(growable)) {
          result = dart.list([], E);
          result[dartx.length] = length;
        } else {
          result = core.List$(E).new(length);
        }
        for (let i = 0; i < dart.notNull(length); i++) {
          result[dartx.set](i, generator(i));
        }
        return result;
      }
      static unmodifiable(elements) {
        let result = core.List$(E).from(elements, {growable: false});
        return _internal.makeFixedListUnmodifiable(E)(result);
      }
      [Symbol.iterator]() {
        return new dart.JsIterator(this[dartx.iterator]);
      }
    }
    List[dart.implements] = () => [core.Iterable$(E), _internal.EfficientLength];
    dart.setSignature(List, {
      constructors: () => ({
        new: [core.List$(E), [], [core.int]],
        filled: [core.List$(E), [core.int, E]],
        from: [core.List$(E), [core.Iterable], {growable: core.bool}],
        generate: [core.List$(E), [core.int, dart.functionType(E, [core.int])], {growable: core.bool}],
        unmodifiable: [core.List$(E), [core.Iterable]]
      })
    });
    return List;
  });
  core.List = core.List$();
  convert.Encoding = class Encoding extends convert.Codec$(core.String, core.List$(core.int)) {
    Encoding() {
      super.Codec();
    }
    decodeStream(byteStream) {
      return byteStream.transform(dart.dynamic)(dart.as(this.decoder, async.StreamTransformer$(core.List$(core.int), dart.dynamic))).fold(dart.dynamic)(new core.StringBuffer(), dart.fn((buffer, string) => ((() => {
        dart.dsend(buffer, 'write', string);
        return buffer;
      })()))).then(core.String)(dart.fn(buffer => dart.toString(buffer), core.String, [dart.dynamic]));
    }
    static getByName(name) {
      if (name == null) return null;
      name = name[dartx.toLowerCase]();
      return convert.Encoding._nameToEncoding[dartx.get](name);
    }
  };
  dart.setSignature(convert.Encoding, {
    constructors: () => ({Encoding: [convert.Encoding, []]}),
    methods: () => ({decodeStream: [async.Future$(core.String), [async.Stream$(core.List$(core.int))]]}),
    statics: () => ({getByName: [convert.Encoding, [core.String]]}),
    names: ['getByName']
  });
  dart.defineLazy(convert.Encoding, {
    get _nameToEncoding() {
      return dart.map({"iso_8859-1:1987": convert.LATIN1, "iso-ir-100": convert.LATIN1, "iso_8859-1": convert.LATIN1, "iso-8859-1": convert.LATIN1, latin1: convert.LATIN1, l1: convert.LATIN1, ibm819: convert.LATIN1, cp819: convert.LATIN1, csisolatin1: convert.LATIN1, "iso-ir-6": convert.ASCII, "ansi_x3.4-1968": convert.ASCII, "ansi_x3.4-1986": convert.ASCII, "iso_646.irv:1991": convert.ASCII, "iso646-us": convert.ASCII, "us-ascii": convert.ASCII, us: convert.ASCII, ibm367: convert.ASCII, cp367: convert.ASCII, csascii: convert.ASCII, ascii: convert.ASCII, csutf8: convert.UTF8, "utf-8": convert.UTF8}, core.String, convert.Encoding);
    },
    set _nameToEncoding(_) {}
  });
  convert.AsciiCodec = class AsciiCodec extends convert.Encoding {
    AsciiCodec(opts) {
      let allowInvalid = opts && 'allowInvalid' in opts ? opts.allowInvalid : false;
      this[_allowInvalid] = allowInvalid;
      super.Encoding();
    }
    get name() {
      return "us-ascii";
    }
    decode(bytes, opts) {
      let allowInvalid = opts && 'allowInvalid' in opts ? opts.allowInvalid : null;
      if (allowInvalid == null) allowInvalid = this[_allowInvalid];
      if (dart.notNull(allowInvalid)) {
        return dart.const(new convert.AsciiDecoder({allowInvalid: true})).convert(bytes);
      } else {
        return dart.const(new convert.AsciiDecoder({allowInvalid: false})).convert(bytes);
      }
    }
    get encoder() {
      return dart.const(new convert.AsciiEncoder());
    }
    get decoder() {
      return dart.notNull(this[_allowInvalid]) ? dart.const(new convert.AsciiDecoder({allowInvalid: true})) : dart.const(new convert.AsciiDecoder({allowInvalid: false}));
    }
  };
  dart.setSignature(convert.AsciiCodec, {
    constructors: () => ({AsciiCodec: [convert.AsciiCodec, [], {allowInvalid: core.bool}]}),
    methods: () => ({decode: [core.String, [core.List$(core.int)], {allowInvalid: core.bool}]})
  });
  convert.ASCII = dart.const(new convert.AsciiCodec());
  convert._ASCII_MASK = 127;
  const _subsetMask = Symbol('_subsetMask');
  convert.Converter$ = dart.generic((S, T) => {
    class Converter extends core.Object {
      Converter() {
      }
      fuse(other) {
        dart.as(other, convert.Converter$(T, dart.dynamic));
        return new (convert._FusedConverter$(S, T, dart.dynamic))(this, other);
      }
      startChunkedConversion(sink) {
        dart.throw(new core.UnsupportedError(`This converter does not support chunked conversions: ${this}`));
      }
      bind(stream) {
        return async.Stream.eventTransformed(stream, dart.fn(sink => new convert._ConverterStreamEventSink(dart.as(this, convert.ChunkedConverter), sink), convert._ConverterStreamEventSink, [async.EventSink]));
      }
    }
    Converter[dart.implements] = () => [async.StreamTransformer];
    dart.setSignature(Converter, {
      constructors: () => ({Converter: [convert.Converter$(S, T), []]}),
      methods: () => ({
        fuse: [convert.Converter$(S, dart.dynamic), [convert.Converter$(T, dart.dynamic)]],
        startChunkedConversion: [convert.ChunkedConversionSink, [core.Sink]],
        bind: [async.Stream, [async.Stream]]
      })
    });
    return Converter;
  });
  convert.Converter = convert.Converter$();
  convert.ChunkedConverter$ = dart.generic((S, T, S2, T2) => {
    class ChunkedConverter extends convert.Converter$(S, T) {
      ChunkedConverter() {
        super.Converter();
      }
      startChunkedConversion(sink) {
        dart.as(sink, core.Sink$(T2));
        dart.throw(new core.UnsupportedError(`This converter does not support chunked conversions: ${this}`));
      }
      bind(stream) {
        dart.as(stream, async.Stream$(S2));
        return async.Stream$(T2).eventTransformed(stream, dart.fn(sink => {
          dart.as(sink, async.EventSink$(T2));
          return new (convert._ConverterStreamEventSink$(S2, T2))(this, sink);
        }, convert._ConverterStreamEventSink$(S2, T2), [async.EventSink$(T2)]));
      }
      fuse(other) {
        dart.as(other, convert.Converter$(T, dart.dynamic));
        if (dart.is(other, convert.ChunkedConverter$(T, dart.dynamic, T2, dart.dynamic))) {
          return new (convert._FusedChunkedConverter$(S, T, dart.dynamic, S2, T2, dart.dynamic))(this, other);
        }
        return super.fuse(other);
      }
    }
    dart.setSignature(ChunkedConverter, {
      constructors: () => ({ChunkedConverter: [convert.ChunkedConverter$(S, T, S2, T2), []]}),
      methods: () => ({
        startChunkedConversion: [convert.ChunkedConversionSink$(S2), [core.Sink$(T2)]],
        bind: [async.Stream$(T2), [async.Stream$(S2)]],
        fuse: [convert.Converter$(S, dart.dynamic), [convert.Converter$(T, dart.dynamic)]]
      })
    });
    return ChunkedConverter;
  });
  convert.ChunkedConverter = convert.ChunkedConverter$();
  convert._UnicodeSubsetEncoder = class _UnicodeSubsetEncoder extends convert.ChunkedConverter$(core.String, core.List$(core.int), core.String, core.List$(core.int)) {
    _UnicodeSubsetEncoder(subsetMask) {
      this[_subsetMask] = subsetMask;
      super.ChunkedConverter();
    }
    convert(string, start, end) {
      if (start === void 0) start = 0;
      if (end === void 0) end = null;
      let stringLength = string[dartx.length];
      core.RangeError.checkValidRange(start, end, stringLength);
      if (end == null) end = stringLength;
      let length = dart.notNull(end) - dart.notNull(start);
      let result = typed_data.Uint8List.new(length);
      for (let i = 0; i < length; i++) {
        let codeUnit = string[dartx.codeUnitAt](dart.notNull(start) + i);
        if ((dart.notNull(codeUnit) & ~dart.notNull(this[_subsetMask])) >>> 0 != 0) {
          dart.throw(new core.ArgumentError("String contains invalid characters."));
        }
        result[dartx.set](i, codeUnit);
      }
      return dart.as(result, core.List$(core.int));
    }
    startChunkedConversion(sink) {
      if (!dart.is(sink, convert.ByteConversionSink)) {
        sink = convert.ByteConversionSink.from(sink);
      }
      return new convert._UnicodeSubsetEncoderSink(this[_subsetMask], dart.as(sink, convert.ByteConversionSink));
    }
    bind(stream) {
      return super.bind(stream);
    }
  };
  dart.setSignature(convert._UnicodeSubsetEncoder, {
    constructors: () => ({_UnicodeSubsetEncoder: [convert._UnicodeSubsetEncoder, [core.int]]}),
    methods: () => ({
      convert: [core.List$(core.int), [core.String], [core.int, core.int]],
      startChunkedConversion: [convert.StringConversionSink, [core.Sink$(core.List$(core.int))]],
      bind: [async.Stream$(core.List$(core.int)), [async.Stream$(core.String)]]
    })
  });
  convert.AsciiEncoder = class AsciiEncoder extends convert._UnicodeSubsetEncoder {
    AsciiEncoder() {
      super._UnicodeSubsetEncoder(convert._ASCII_MASK);
    }
  };
  dart.setSignature(convert.AsciiEncoder, {
    constructors: () => ({AsciiEncoder: [convert.AsciiEncoder, []]})
  });
  convert._UnicodeSubsetEncoderSink = class _UnicodeSubsetEncoderSink extends convert.StringConversionSinkBase {
    _UnicodeSubsetEncoderSink(subsetMask, sink) {
      this[_subsetMask] = subsetMask;
      this[_sink$] = sink;
    }
    close() {
      this[_sink$].close();
    }
    addSlice(source, start, end, isLast) {
      core.RangeError.checkValidRange(start, end, source[dartx.length]);
      for (let i = start; dart.notNull(i) < dart.notNull(end); i = dart.notNull(i) + 1) {
        let codeUnit = source[dartx.codeUnitAt](i);
        if ((dart.notNull(codeUnit) & ~dart.notNull(this[_subsetMask])) >>> 0 != 0) {
          dart.throw(new core.ArgumentError(`Source contains invalid character with code point: ${codeUnit}.`));
        }
      }
      this[_sink$].add(source[dartx.codeUnits][dartx.sublist](start, end));
      if (dart.notNull(isLast)) {
        this.close();
      }
    }
  };
  dart.setSignature(convert._UnicodeSubsetEncoderSink, {
    constructors: () => ({_UnicodeSubsetEncoderSink: [convert._UnicodeSubsetEncoderSink, [core.int, convert.ByteConversionSink]]}),
    methods: () => ({
      close: [dart.void, []],
      addSlice: [dart.void, [core.String, core.int, core.int, core.bool]]
    })
  });
  const _convertInvalid = Symbol('_convertInvalid');
  convert._UnicodeSubsetDecoder = class _UnicodeSubsetDecoder extends convert.ChunkedConverter$(core.List$(core.int), core.String, core.List$(core.int), core.String) {
    _UnicodeSubsetDecoder(allowInvalid, subsetMask) {
      this[_allowInvalid] = allowInvalid;
      this[_subsetMask] = subsetMask;
      super.ChunkedConverter();
    }
    convert(bytes, start, end) {
      if (start === void 0) start = 0;
      if (end === void 0) end = null;
      let byteCount = bytes[dartx.length];
      core.RangeError.checkValidRange(start, end, byteCount);
      if (end == null) end = byteCount;
      for (let i = start; dart.notNull(i) < dart.notNull(end); i = dart.notNull(i) + 1) {
        let byte = bytes[dartx.get](i);
        if ((dart.notNull(byte) & ~dart.notNull(this[_subsetMask])) >>> 0 != 0) {
          if (!dart.notNull(this[_allowInvalid])) {
            dart.throw(new core.FormatException(`Invalid value in input: ${byte}`));
          }
          return this[_convertInvalid](bytes, start, end);
        }
      }
      return core.String.fromCharCodes(bytes, start, end);
    }
    [_convertInvalid](bytes, start, end) {
      let buffer = new core.StringBuffer();
      for (let i = start; dart.notNull(i) < dart.notNull(end); i = dart.notNull(i) + 1) {
        let value = bytes[dartx.get](i);
        if ((dart.notNull(value) & ~dart.notNull(this[_subsetMask])) >>> 0 != 0) value = 65533;
        buffer.writeCharCode(value);
      }
      return buffer.toString();
    }
    bind(stream) {
      return super.bind(stream);
    }
  };
  dart.setSignature(convert._UnicodeSubsetDecoder, {
    constructors: () => ({_UnicodeSubsetDecoder: [convert._UnicodeSubsetDecoder, [core.bool, core.int]]}),
    methods: () => ({
      convert: [core.String, [core.List$(core.int)], [core.int, core.int]],
      [_convertInvalid]: [core.String, [core.List$(core.int), core.int, core.int]],
      bind: [async.Stream$(core.String), [async.Stream$(core.List$(core.int))]]
    })
  });
  convert.AsciiDecoder = class AsciiDecoder extends convert._UnicodeSubsetDecoder {
    AsciiDecoder(opts) {
      let allowInvalid = opts && 'allowInvalid' in opts ? opts.allowInvalid : false;
      super._UnicodeSubsetDecoder(allowInvalid, convert._ASCII_MASK);
    }
    startChunkedConversion(sink) {
      let stringSink = null;
      if (dart.is(sink, convert.StringConversionSink)) {
        stringSink = sink;
      } else {
        stringSink = convert.StringConversionSink.from(sink);
      }
      if (dart.notNull(this[_allowInvalid])) {
        return new convert._ErrorHandlingAsciiDecoderSink(stringSink.asUtf8Sink(false));
      } else {
        return new convert._SimpleAsciiDecoderSink(stringSink);
      }
    }
  };
  dart.setSignature(convert.AsciiDecoder, {
    constructors: () => ({AsciiDecoder: [convert.AsciiDecoder, [], {allowInvalid: core.bool}]}),
    methods: () => ({startChunkedConversion: [convert.ByteConversionSink, [core.Sink$(core.String)]]})
  });
  const _utf8Sink = Symbol('_utf8Sink');
  convert.ChunkedConversionSink$ = dart.generic(T => {
    class ChunkedConversionSink extends core.Object {
      ChunkedConversionSink() {
      }
      static withCallback(callback) {
        return new convert._SimpleCallbackSink(callback);
      }
    }
    ChunkedConversionSink[dart.implements] = () => [core.Sink$(T)];
    dart.setSignature(ChunkedConversionSink, {
      constructors: () => ({
        ChunkedConversionSink: [convert.ChunkedConversionSink$(T), []],
        withCallback: [convert.ChunkedConversionSink$(T), [dart.functionType(dart.void, [core.List$(T)])]]
      })
    });
    return ChunkedConversionSink;
  });
  convert.ChunkedConversionSink = convert.ChunkedConversionSink$();
  convert.ByteConversionSink = class ByteConversionSink extends convert.ChunkedConversionSink$(core.List$(core.int)) {
    ByteConversionSink() {
      super.ChunkedConversionSink();
    }
    static withCallback(callback) {
      return new convert._ByteCallbackSink(callback);
    }
    static from(sink) {
      return new convert._ByteAdapterSink(sink);
    }
  };
  dart.setSignature(convert.ByteConversionSink, {
    constructors: () => ({
      ByteConversionSink: [convert.ByteConversionSink, []],
      withCallback: [convert.ByteConversionSink, [dart.functionType(dart.void, [core.List$(core.int)])]],
      from: [convert.ByteConversionSink, [core.Sink$(core.List$(core.int))]]
    })
  });
  convert.ByteConversionSinkBase = class ByteConversionSinkBase extends convert.ByteConversionSink {
    ByteConversionSinkBase() {
      super.ByteConversionSink();
    }
    addSlice(chunk, start, end, isLast) {
      this.add(chunk[dartx.sublist](start, end));
      if (dart.notNull(isLast)) this.close();
    }
  };
  dart.setSignature(convert.ByteConversionSinkBase, {
    methods: () => ({addSlice: [dart.void, [core.List$(core.int), core.int, core.int, core.bool]]})
  });
  convert._ErrorHandlingAsciiDecoderSink = class _ErrorHandlingAsciiDecoderSink extends convert.ByteConversionSinkBase {
    _ErrorHandlingAsciiDecoderSink(utf8Sink) {
      this[_utf8Sink] = utf8Sink;
    }
    close() {
      this[_utf8Sink].close();
    }
    add(source) {
      this.addSlice(source, 0, source[dartx.length], false);
    }
    addSlice(source, start, end, isLast) {
      core.RangeError.checkValidRange(start, end, source[dartx.length]);
      for (let i = start; dart.notNull(i) < dart.notNull(end); i = dart.notNull(i) + 1) {
        if ((dart.notNull(source[dartx.get](i)) & ~dart.notNull(convert._ASCII_MASK)) >>> 0 != 0) {
          if (dart.notNull(i) > dart.notNull(start)) this[_utf8Sink].addSlice(source, start, i, false);
          this[_utf8Sink].add(dart.const(dart.list([239, 191, 189], core.int)));
          start = dart.notNull(i) + 1;
        }
      }
      if (dart.notNull(start) < dart.notNull(end)) {
        this[_utf8Sink].addSlice(source, start, end, isLast);
      } else if (dart.notNull(isLast)) {
        this.close();
      }
    }
  };
  dart.setSignature(convert._ErrorHandlingAsciiDecoderSink, {
    constructors: () => ({_ErrorHandlingAsciiDecoderSink: [convert._ErrorHandlingAsciiDecoderSink, [convert.ByteConversionSink]]}),
    methods: () => ({
      close: [dart.void, []],
      add: [dart.void, [core.List$(core.int)]]
    })
  });
  convert._SimpleAsciiDecoderSink = class _SimpleAsciiDecoderSink extends convert.ByteConversionSinkBase {
    _SimpleAsciiDecoderSink(sink) {
      this[_sink$] = sink;
    }
    close() {
      this[_sink$].close();
    }
    add(source) {
      for (let i = 0; i < dart.notNull(source[dartx.length]); i++) {
        if ((dart.notNull(source[dartx.get](i)) & ~dart.notNull(convert._ASCII_MASK)) >>> 0 != 0) {
          dart.throw(new core.FormatException("Source contains non-ASCII bytes."));
        }
      }
      this[_sink$].add(core.String.fromCharCodes(source));
    }
    addSlice(source, start, end, isLast) {
      let length = source[dartx.length];
      core.RangeError.checkValidRange(start, end, length);
      if (dart.notNull(start) < dart.notNull(end)) {
        if (start != 0 || end != length) {
          source = source[dartx.sublist](start, end);
        }
        this.add(source);
      }
      if (dart.notNull(isLast)) this.close();
    }
  };
  dart.setSignature(convert._SimpleAsciiDecoderSink, {
    constructors: () => ({_SimpleAsciiDecoderSink: [convert._SimpleAsciiDecoderSink, [core.Sink]]}),
    methods: () => ({
      close: [dart.void, []],
      add: [dart.void, [core.List$(core.int)]]
    })
  });
  const _urlSafe = Symbol('_urlSafe');
  convert.Base64Encoder = class Base64Encoder extends convert.ChunkedConverter$(core.List$(core.int), core.String, core.List$(core.int), core.String) {
    Base64Encoder() {
      this[_urlSafe] = false;
      super.ChunkedConverter();
    }
    urlSafe() {
      this[_urlSafe] = true;
      super.ChunkedConverter();
    }
    convert(input) {
      if (dart.notNull(input[dartx.isEmpty])) return "";
      let encoder = new convert._Base64Encoder(this[_urlSafe]);
      let buffer = encoder.encode(input, 0, input[dartx.length], true);
      return core.String.fromCharCodes(buffer);
    }
    startChunkedConversion(sink) {
      if (dart.is(sink, convert.StringConversionSink)) {
        return new convert._Utf8Base64EncoderSink(sink.asUtf8Sink(false), this[_urlSafe]);
      }
      return new convert._AsciiBase64EncoderSink(sink, this[_urlSafe]);
    }
  };
  dart.defineNamedConstructor(convert.Base64Encoder, 'urlSafe');
  dart.setSignature(convert.Base64Encoder, {
    constructors: () => ({
      Base64Encoder: [convert.Base64Encoder, []],
      urlSafe: [convert.Base64Encoder, []]
    }),
    methods: () => ({
      convert: [core.String, [core.List$(core.int)]],
      startChunkedConversion: [convert.ByteConversionSink, [core.Sink$(core.String)]]
    })
  });
  const _encoder = Symbol('_encoder');
  convert.Base64Codec = class Base64Codec extends convert.Codec$(core.List$(core.int), core.String) {
    Base64Codec() {
      this[_encoder] = dart.const(new convert.Base64Encoder());
      super.Codec();
    }
    urlSafe() {
      this[_encoder] = dart.const(new convert.Base64Encoder.urlSafe());
      super.Codec();
    }
    get encoder() {
      return this[_encoder];
    }
    get decoder() {
      return dart.const(new convert.Base64Decoder());
    }
  };
  dart.defineNamedConstructor(convert.Base64Codec, 'urlSafe');
  dart.setSignature(convert.Base64Codec, {
    constructors: () => ({
      Base64Codec: [convert.Base64Codec, []],
      urlSafe: [convert.Base64Codec, []]
    })
  });
  convert.BASE64 = dart.const(new convert.Base64Codec());
  convert.BASE64URL = dart.const(new convert.Base64Codec.urlSafe());
  convert._paddingChar = 61;
  const _alphabet = Symbol('_alphabet');
  const _state$0 = Symbol('_state');
  convert._Base64Encoder = class _Base64Encoder extends core.Object {
    _Base64Encoder(urlSafe) {
      this[_alphabet] = dart.notNull(urlSafe) ? convert._Base64Encoder._base64urlAlphabet : convert._Base64Encoder._base64Alphabet;
      this[_state$0] = 0;
    }
    static _encodeState(count, bits) {
      dart.assert(dart.notNull(count) <= dart.notNull(convert._Base64Encoder._countMask));
      return (bits[dartx['<<']](convert._Base64Encoder._valueShift) | dart.notNull(count)) >>> 0;
    }
    static _stateBits(state) {
      return state[dartx['>>']](convert._Base64Encoder._valueShift);
    }
    static _stateCount(state) {
      return (dart.notNull(state) & dart.notNull(convert._Base64Encoder._countMask)) >>> 0;
    }
    createBuffer(bufferLength) {
      return typed_data.Uint8List.new(bufferLength);
    }
    encode(bytes, start, end, isLast) {
      dart.assert(0 <= dart.notNull(start));
      dart.assert(dart.notNull(start) <= dart.notNull(end));
      dart.assert(bytes == null || dart.notNull(end) <= dart.notNull(bytes[dartx.length]));
      let length = dart.notNull(end) - dart.notNull(start);
      let count = convert._Base64Encoder._stateCount(this[_state$0]);
      let byteCount = dart.notNull(count) + length;
      let fullChunks = (byteCount / 3)[dartx.truncate]();
      let partialChunkLength = byteCount - fullChunks * 3;
      let bufferLength = fullChunks * 4;
      if (dart.notNull(isLast) && partialChunkLength > 0) {
        bufferLength = bufferLength + 4;
      }
      let output = this.createBuffer(bufferLength);
      this[_state$0] = convert._Base64Encoder.encodeChunk(this[_alphabet], bytes, start, end, isLast, output, 0, this[_state$0]);
      if (bufferLength > 0) return output;
      return null;
    }
    static encodeChunk(alphabet, bytes, start, end, isLast, output, outputIndex, state) {
      let bits = convert._Base64Encoder._stateBits(state);
      let expectedChars = 3 - dart.notNull(convert._Base64Encoder._stateCount(state));
      let byteOr = 0;
      for (let i = start; dart.notNull(i) < dart.notNull(end); i = dart.notNull(i) + 1) {
        let byte = bytes[dartx.get](i);
        byteOr = (dart.notNull(byteOr) | dart.notNull(byte)) >>> 0;
        bits = (dart.notNull(bits) << 8 | dart.notNull(byte)) & 16777215;
        expectedChars--;
        if (expectedChars == 0) {
          output[dartx.set]((() => {
            let x = outputIndex;
            outputIndex = dart.notNull(x) + 1;
            return x;
          })(), alphabet[dartx.codeUnitAt]((bits[dartx['>>']](18) & dart.notNull(convert._Base64Encoder._sixBitMask)) >>> 0));
          output[dartx.set]((() => {
            let x = outputIndex;
            outputIndex = dart.notNull(x) + 1;
            return x;
          })(), alphabet[dartx.codeUnitAt]((bits[dartx['>>']](12) & dart.notNull(convert._Base64Encoder._sixBitMask)) >>> 0));
          output[dartx.set]((() => {
            let x = outputIndex;
            outputIndex = dart.notNull(x) + 1;
            return x;
          })(), alphabet[dartx.codeUnitAt]((bits[dartx['>>']](6) & dart.notNull(convert._Base64Encoder._sixBitMask)) >>> 0));
          output[dartx.set]((() => {
            let x = outputIndex;
            outputIndex = dart.notNull(x) + 1;
            return x;
          })(), alphabet[dartx.codeUnitAt]((dart.notNull(bits) & dart.notNull(convert._Base64Encoder._sixBitMask)) >>> 0));
          expectedChars = 3;
          bits = 0;
        }
      }
      if (dart.notNull(byteOr) >= 0 && dart.notNull(byteOr) <= 255) {
        if (dart.notNull(isLast) && expectedChars < 3) {
          convert._Base64Encoder.writeFinalChunk(alphabet, output, outputIndex, 3 - expectedChars, bits);
          return 0;
        }
        return convert._Base64Encoder._encodeState(3 - expectedChars, bits);
      }
      let i = start;
      while (dart.notNull(i) < dart.notNull(end)) {
        let byte = bytes[dartx.get](i);
        if (dart.notNull(byte) < 0 || dart.notNull(byte) > 255) break;
        i = dart.notNull(i) + 1;
      }
      dart.throw(new core.ArgumentError.value(bytes, `Not a byte value at index ${i}: 0x${bytes[dartx.get](i)[dartx.toRadixString](16)}`));
    }
    static writeFinalChunk(alphabet, output, outputIndex, count, bits) {
      dart.assert(dart.notNull(count) > 0);
      if (count == 1) {
        output[dartx.set]((() => {
          let x = outputIndex;
          outputIndex = dart.notNull(x) + 1;
          return x;
        })(), alphabet[dartx.codeUnitAt]((bits[dartx['>>']](2) & dart.notNull(convert._Base64Encoder._sixBitMask)) >>> 0));
        output[dartx.set]((() => {
          let x = outputIndex;
          outputIndex = dart.notNull(x) + 1;
          return x;
        })(), alphabet[dartx.codeUnitAt]((dart.notNull(bits) << 4 & dart.notNull(convert._Base64Encoder._sixBitMask)) >>> 0));
        output[dartx.set]((() => {
          let x = outputIndex;
          outputIndex = dart.notNull(x) + 1;
          return x;
        })(), convert._paddingChar);
        output[dartx.set]((() => {
          let x = outputIndex;
          outputIndex = dart.notNull(x) + 1;
          return x;
        })(), convert._paddingChar);
      } else {
        dart.assert(count == 2);
        output[dartx.set]((() => {
          let x = outputIndex;
          outputIndex = dart.notNull(x) + 1;
          return x;
        })(), alphabet[dartx.codeUnitAt]((bits[dartx['>>']](10) & dart.notNull(convert._Base64Encoder._sixBitMask)) >>> 0));
        output[dartx.set]((() => {
          let x = outputIndex;
          outputIndex = dart.notNull(x) + 1;
          return x;
        })(), alphabet[dartx.codeUnitAt]((bits[dartx['>>']](4) & dart.notNull(convert._Base64Encoder._sixBitMask)) >>> 0));
        output[dartx.set]((() => {
          let x = outputIndex;
          outputIndex = dart.notNull(x) + 1;
          return x;
        })(), alphabet[dartx.codeUnitAt]((dart.notNull(bits) << 2 & dart.notNull(convert._Base64Encoder._sixBitMask)) >>> 0));
        output[dartx.set]((() => {
          let x = outputIndex;
          outputIndex = dart.notNull(x) + 1;
          return x;
        })(), convert._paddingChar);
      }
    }
  };
  dart.setSignature(convert._Base64Encoder, {
    constructors: () => ({_Base64Encoder: [convert._Base64Encoder, [core.bool]]}),
    methods: () => ({
      createBuffer: [typed_data.Uint8List, [core.int]],
      encode: [typed_data.Uint8List, [core.List$(core.int), core.int, core.int, core.bool]]
    }),
    statics: () => ({
      _encodeState: [core.int, [core.int, core.int]],
      _stateBits: [core.int, [core.int]],
      _stateCount: [core.int, [core.int]],
      encodeChunk: [core.int, [core.String, core.List$(core.int), core.int, core.int, core.bool, typed_data.Uint8List, core.int, core.int]],
      writeFinalChunk: [dart.void, [core.String, typed_data.Uint8List, core.int, core.int, core.int]]
    }),
    names: ['_encodeState', '_stateBits', '_stateCount', 'encodeChunk', 'writeFinalChunk']
  });
  convert._Base64Encoder._base64Alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  convert._Base64Encoder._base64urlAlphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
  convert._Base64Encoder._valueShift = 2;
  convert._Base64Encoder._countMask = 3;
  convert._Base64Encoder._sixBitMask = 63;
  convert._BufferCachingBase64Encoder = class _BufferCachingBase64Encoder extends convert._Base64Encoder {
    _BufferCachingBase64Encoder(urlSafe) {
      this.bufferCache = null;
      super._Base64Encoder(urlSafe);
    }
    createBuffer(bufferLength) {
      if (this.bufferCache == null || dart.notNull(this.bufferCache[dartx.length]) < dart.notNull(bufferLength)) {
        this.bufferCache = typed_data.Uint8List.new(bufferLength);
      }
      return typed_data.Uint8List.view(this.bufferCache[dartx.buffer], 0, bufferLength);
    }
  };
  dart.setSignature(convert._BufferCachingBase64Encoder, {
    constructors: () => ({_BufferCachingBase64Encoder: [convert._BufferCachingBase64Encoder, [core.bool]]})
  });
  const _add$1 = Symbol('_add');
  convert._Base64EncoderSink = class _Base64EncoderSink extends convert.ByteConversionSinkBase {
    add(source) {
      this[_add$1](source, 0, source[dartx.length], false);
    }
    close() {
      this[_add$1](null, 0, 0, true);
    }
    addSlice(source, start, end, isLast) {
      if (end == null) dart.throw(new core.ArgumentError.notNull("end"));
      core.RangeError.checkValidRange(start, end, source[dartx.length]);
      this[_add$1](source, start, end, isLast);
    }
  };
  dart.setSignature(convert._Base64EncoderSink, {
    methods: () => ({
      add: [dart.void, [core.List$(core.int)]],
      close: [dart.void, []]
    })
  });
  convert._AsciiBase64EncoderSink = class _AsciiBase64EncoderSink extends convert._Base64EncoderSink {
    _AsciiBase64EncoderSink(sink, urlSafe) {
      this[_sink$] = sink;
      this[_encoder] = new convert._BufferCachingBase64Encoder(urlSafe);
    }
    [_add$1](source, start, end, isLast) {
      let buffer = this[_encoder].encode(source, start, end, isLast);
      if (buffer != null) {
        let string = core.String.fromCharCodes(buffer);
        this[_sink$].add(string);
      }
      if (dart.notNull(isLast)) {
        this[_sink$].close();
      }
    }
  };
  dart.setSignature(convert._AsciiBase64EncoderSink, {
    constructors: () => ({_AsciiBase64EncoderSink: [convert._AsciiBase64EncoderSink, [core.Sink$(core.String), core.bool]]}),
    methods: () => ({[_add$1]: [dart.void, [core.List$(core.int), core.int, core.int, core.bool]]})
  });
  convert._Utf8Base64EncoderSink = class _Utf8Base64EncoderSink extends convert._Base64EncoderSink {
    _Utf8Base64EncoderSink(sink, urlSafe) {
      this[_sink$] = sink;
      this[_encoder] = new convert._Base64Encoder(urlSafe);
    }
    [_add$1](source, start, end, isLast) {
      let buffer = this[_encoder].encode(source, start, end, isLast);
      if (buffer != null) {
        this[_sink$].addSlice(buffer, 0, buffer[dartx.length], isLast);
      }
    }
  };
  dart.setSignature(convert._Utf8Base64EncoderSink, {
    constructors: () => ({_Utf8Base64EncoderSink: [convert._Utf8Base64EncoderSink, [convert.ByteConversionSink, core.bool]]}),
    methods: () => ({[_add$1]: [dart.void, [core.List$(core.int), core.int, core.int, core.bool]]})
  });
  convert.Base64Decoder = class Base64Decoder extends convert.ChunkedConverter$(core.String, core.List$(core.int), core.String, core.List$(core.int)) {
    Base64Decoder() {
      super.ChunkedConverter();
    }
    convert(input, start, end) {
      if (start === void 0) start = 0;
      if (end === void 0) end = null;
      end = core.RangeError.checkValidRange(start, end, input[dartx.length]);
      if (start == end) return typed_data.Uint8List.new(0);
      let decoder = new convert._Base64Decoder();
      let buffer = decoder.decode(input, start, end);
      decoder.close(input, end);
      return buffer;
    }
    startChunkedConversion(sink) {
      return new convert._Base64DecoderSink(sink);
    }
  };
  dart.setSignature(convert.Base64Decoder, {
    constructors: () => ({Base64Decoder: [convert.Base64Decoder, []]}),
    methods: () => ({
      convert: [core.List$(core.int), [core.String], [core.int, core.int]],
      startChunkedConversion: [convert.StringConversionSink, [core.Sink$(core.List$(core.int))]]
    })
  });
  convert._Base64Decoder = class _Base64Decoder extends core.Object {
    _Base64Decoder() {
      this[_state$0] = 0;
    }
    static _encodeCharacterState(count, bits) {
      dart.assert(count == (dart.notNull(count) & dart.notNull(convert._Base64Decoder._countMask)) >>> 0);
      return (bits[dartx['<<']](convert._Base64Decoder._valueShift) | dart.notNull(count)) >>> 0;
    }
    static _stateCount(state) {
      dart.assert(dart.notNull(state) >= 0);
      return (dart.notNull(state) & dart.notNull(convert._Base64Decoder._countMask)) >>> 0;
    }
    static _stateBits(state) {
      dart.assert(dart.notNull(state) >= 0);
      return state[dartx['>>']](convert._Base64Decoder._valueShift);
    }
    static _encodePaddingState(expectedPadding) {
      dart.assert(dart.notNull(expectedPadding) >= 0);
      dart.assert(dart.notNull(expectedPadding) <= 5);
      return -dart.notNull(expectedPadding) - 1;
    }
    static _statePadding(state) {
      dart.assert(dart.notNull(state) < 0);
      return -dart.notNull(state) - 1;
    }
    static _hasSeenPadding(state) {
      return dart.notNull(state) < 0;
    }
    decode(input, start, end) {
      dart.assert(0 <= dart.notNull(start));
      dart.assert(dart.notNull(start) <= dart.notNull(end));
      dart.assert(dart.notNull(end) <= dart.notNull(input[dartx.length]));
      if (dart.notNull(convert._Base64Decoder._hasSeenPadding(this[_state$0]))) {
        this[_state$0] = convert._Base64Decoder._checkPadding(input, start, end, this[_state$0]);
        return null;
      }
      if (start == end) return typed_data.Uint8List.new(0);
      let buffer = convert._Base64Decoder._allocateBuffer(input, start, end, this[_state$0]);
      this[_state$0] = convert._Base64Decoder.decodeChunk(input, start, end, buffer, 0, this[_state$0]);
      return buffer;
    }
    close(input, end) {
      if (dart.notNull(this[_state$0]) < dart.notNull(convert._Base64Decoder._encodePaddingState(0))) {
        dart.throw(new core.FormatException("Missing padding character", input, end));
      }
      if (dart.notNull(this[_state$0]) > 0) {
        dart.throw(new core.FormatException("Invalid length, must be multiple of four", input, end));
      }
      this[_state$0] = convert._Base64Decoder._encodePaddingState(0);
    }
    static decodeChunk(input, start, end, output, outIndex, state) {
      dart.assert(!dart.notNull(convert._Base64Decoder._hasSeenPadding(state)));
      let asciiMask = 127;
      let asciiMax = 127;
      let eightBitMask = 255;
      let bitsPerCharacter = 6;
      let bits = convert._Base64Decoder._stateBits(state);
      let count = convert._Base64Decoder._stateCount(state);
      let charOr = 0;
      for (let i = start; dart.notNull(i) < dart.notNull(end); i = dart.notNull(i) + 1) {
        let char = input[dartx.codeUnitAt](i);
        charOr = (dart.notNull(charOr) | dart.notNull(char)) >>> 0;
        let code = convert._Base64Decoder._inverseAlphabet[dartx.get]((dart.notNull(char) & asciiMask) >>> 0);
        if (dart.notNull(code) >= 0) {
          bits = (bits[dartx['<<']](bitsPerCharacter) | dart.notNull(code)) & 16777215;
          count = dart.notNull(count) + 1 & 3;
          if (count == 0) {
            dart.assert(dart.notNull(outIndex) + 3 <= dart.notNull(output[dartx.length]));
            output[dartx.set]((() => {
              let x = outIndex;
              outIndex = dart.notNull(x) + 1;
              return x;
            })(), (bits[dartx['>>']](16) & eightBitMask) >>> 0);
            output[dartx.set]((() => {
              let x = outIndex;
              outIndex = dart.notNull(x) + 1;
              return x;
            })(), (bits[dartx['>>']](8) & eightBitMask) >>> 0);
            output[dartx.set]((() => {
              let x = outIndex;
              outIndex = dart.notNull(x) + 1;
              return x;
            })(), (dart.notNull(bits) & eightBitMask) >>> 0);
            bits = 0;
          }
          continue;
        } else if (code == convert._Base64Decoder._padding && dart.notNull(count) > 1) {
          if (dart.notNull(charOr) < 0 || dart.notNull(charOr) > asciiMax) break;
          if (count == 3) {
            if ((dart.notNull(bits) & 3) != 0) {
              dart.throw(new core.FormatException("Invalid encoding before padding", input, i));
            }
            output[dartx.set]((() => {
              let x = outIndex;
              outIndex = dart.notNull(x) + 1;
              return x;
            })(), bits[dartx['>>']](10));
            output[dartx.set]((() => {
              let x = outIndex;
              outIndex = dart.notNull(x) + 1;
              return x;
            })(), bits[dartx['>>']](2));
          } else {
            if ((dart.notNull(bits) & 15) != 0) {
              dart.throw(new core.FormatException("Invalid encoding before padding", input, i));
            }
            output[dartx.set]((() => {
              let x = outIndex;
              outIndex = dart.notNull(x) + 1;
              return x;
            })(), bits[dartx['>>']](4));
          }
          let expectedPadding = (3 - dart.notNull(count)) * 3;
          if (char == convert._Base64Decoder._char_percent) {
            expectedPadding = expectedPadding + 2;
          }
          state = convert._Base64Decoder._encodePaddingState(expectedPadding);
          return convert._Base64Decoder._checkPadding(input, dart.notNull(i) + 1, end, state);
        }
        dart.throw(new core.FormatException("Invalid character", input, i));
      }
      if (dart.notNull(charOr) >= 0 && dart.notNull(charOr) <= asciiMax) {
        return convert._Base64Decoder._encodeCharacterState(count, bits);
      }
      let i = null;
      for (i = start; dart.notNull(i) < dart.notNull(end); i = dart.notNull(i) + 1) {
        let char = input[dartx.codeUnitAt](i);
        if (dart.notNull(char) < 0 || dart.notNull(char) > asciiMax) break;
      }
      dart.throw(new core.FormatException("Invalid character", input, i));
    }
    static _allocateBuffer(input, start, end, state) {
      dart.assert(dart.notNull(state) >= 0);
      let paddingStart = convert._Base64Decoder._trimPaddingChars(input, start, end);
      let length = dart.notNull(convert._Base64Decoder._stateCount(state)) + (dart.notNull(paddingStart) - dart.notNull(start));
      let bufferLength = length[dartx['>>']](2) * 3;
      let remainderLength = length & 3;
      if (remainderLength != 0 && dart.notNull(paddingStart) < dart.notNull(end)) {
        bufferLength = bufferLength + (remainderLength - 1);
      }
      if (bufferLength > 0) return typed_data.Uint8List.new(bufferLength);
      return null;
    }
    static _trimPaddingChars(input, start, end) {
      let padding = 0;
      let index = end;
      let newEnd = end;
      while (dart.notNull(index) > dart.notNull(start) && padding < 2) {
        index = dart.notNull(index) - 1;
        let char = input[dartx.codeUnitAt](index);
        if (char == convert._paddingChar) {
          padding++;
          newEnd = index;
          continue;
        }
        if ((dart.notNull(char) | 32) >>> 0 == convert._Base64Decoder._char_d) {
          if (index == start) break;
          index = dart.notNull(index) - 1;
          char = input[dartx.codeUnitAt](index);
        }
        if (char == convert._Base64Decoder._char_3) {
          if (index == start) break;
          index = dart.notNull(index) - 1;
          char = input[dartx.codeUnitAt](index);
        }
        if (char == convert._Base64Decoder._char_percent) {
          padding++;
          newEnd = index;
          continue;
        }
        break;
      }
      return newEnd;
    }
    static _checkPadding(input, start, end, state) {
      dart.assert(convert._Base64Decoder._hasSeenPadding(state));
      if (start == end) return state;
      let expectedPadding = convert._Base64Decoder._statePadding(state);
      dart.assert(dart.notNull(expectedPadding) >= 0);
      dart.assert(dart.notNull(expectedPadding) < 6);
      while (dart.notNull(expectedPadding) > 0) {
        let char = input[dartx.codeUnitAt](start);
        if (expectedPadding == 3) {
          if (char == convert._paddingChar) {
            expectedPadding = dart.notNull(expectedPadding) - 3;
            start = dart.notNull(start) + 1;
            break;
          }
          if (char == convert._Base64Decoder._char_percent) {
            expectedPadding = dart.notNull(expectedPadding) - 1;
            start = dart.notNull(start) + 1;
            if (start == end) break;
            char = input[dartx.codeUnitAt](start);
          } else {
            break;
          }
        }
        let expectedPartialPadding = expectedPadding;
        if (dart.notNull(expectedPartialPadding) > 3) {
          expectedPartialPadding = dart.notNull(expectedPartialPadding) - 3;
        }
        if (expectedPartialPadding == 2) {
          if (char != convert._Base64Decoder._char_3) break;
          start = dart.notNull(start) + 1;
          expectedPadding = dart.notNull(expectedPadding) - 1;
          if (start == end) break;
          char = input[dartx.codeUnitAt](start);
        }
        if ((dart.notNull(char) | 32) >>> 0 != convert._Base64Decoder._char_d) break;
        start = dart.notNull(start) + 1;
        expectedPadding = dart.notNull(expectedPadding) - 1;
        if (start == end) break;
      }
      if (start != end) {
        dart.throw(new core.FormatException("Invalid padding character", input, start));
      }
      return convert._Base64Decoder._encodePaddingState(expectedPadding);
    }
  };
  dart.setSignature(convert._Base64Decoder, {
    methods: () => ({
      decode: [typed_data.Uint8List, [core.String, core.int, core.int]],
      close: [dart.void, [core.String, core.int]]
    }),
    statics: () => ({
      _encodeCharacterState: [core.int, [core.int, core.int]],
      _stateCount: [core.int, [core.int]],
      _stateBits: [core.int, [core.int]],
      _encodePaddingState: [core.int, [core.int]],
      _statePadding: [core.int, [core.int]],
      _hasSeenPadding: [core.bool, [core.int]],
      decodeChunk: [core.int, [core.String, core.int, core.int, typed_data.Uint8List, core.int, core.int]],
      _allocateBuffer: [typed_data.Uint8List, [core.String, core.int, core.int, core.int]],
      _trimPaddingChars: [core.int, [core.String, core.int, core.int]],
      _checkPadding: [core.int, [core.String, core.int, core.int, core.int]]
    }),
    names: ['_encodeCharacterState', '_stateCount', '_stateBits', '_encodePaddingState', '_statePadding', '_hasSeenPadding', 'decodeChunk', '_allocateBuffer', '_trimPaddingChars', '_checkPadding']
  });
  convert._Base64Decoder._valueShift = 2;
  convert._Base64Decoder._countMask = 3;
  convert._Base64Decoder._invalid = -2;
  convert._Base64Decoder._padding = -1;
  convert._Base64Decoder._char_percent = 37;
  convert._Base64Decoder._char_3 = 51;
  convert._Base64Decoder._char_d = 100;
  dart.defineLazy(convert._Base64Decoder, {
    get __() {
      return convert._Base64Decoder._invalid;
    },
    get _p() {
      return convert._Base64Decoder._padding;
    },
    get _inverseAlphabet() {
      return typed_data.Int8List.fromList(dart.list([convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder._p, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, 62, convert._Base64Decoder.__, 62, convert._Base64Decoder.__, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder._p, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, 63, convert._Base64Decoder.__, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__, convert._Base64Decoder.__], core.int));
    }
  });
  const _decoder = Symbol('_decoder');
  convert._Base64DecoderSink = class _Base64DecoderSink extends convert.StringConversionSinkBase {
    _Base64DecoderSink(sink) {
      this[_decoder] = new convert._Base64Decoder();
      this[_sink$] = sink;
    }
    add(string) {
      if (dart.notNull(string[dartx.isEmpty])) return;
      let buffer = this[_decoder].decode(string, 0, string[dartx.length]);
      if (buffer != null) this[_sink$].add(buffer);
    }
    close() {
      this[_decoder].close(null, null);
      this[_sink$].close();
    }
    addSlice(string, start, end, isLast) {
      end = core.RangeError.checkValidRange(start, end, string[dartx.length]);
      if (start == end) return;
      let buffer = this[_decoder].decode(string, start, end);
      if (buffer != null) this[_sink$].add(buffer);
      if (dart.notNull(isLast)) {
        this[_decoder].close(string, end);
        this[_sink$].close();
      }
    }
  };
  dart.setSignature(convert._Base64DecoderSink, {
    constructors: () => ({_Base64DecoderSink: [convert._Base64DecoderSink, [core.Sink$(core.List$(core.int))]]}),
    methods: () => ({
      close: [dart.void, []],
      addSlice: [dart.void, [core.String, core.int, core.int, core.bool]]
    })
  });
  convert._ByteAdapterSink = class _ByteAdapterSink extends convert.ByteConversionSinkBase {
    _ByteAdapterSink(sink) {
      this[_sink$] = sink;
    }
    add(chunk) {
      this[_sink$].add(chunk);
    }
    close() {
      this[_sink$].close();
    }
  };
  dart.setSignature(convert._ByteAdapterSink, {
    constructors: () => ({_ByteAdapterSink: [convert._ByteAdapterSink, [core.Sink$(core.List$(core.int))]]}),
    methods: () => ({
      add: [dart.void, [core.List$(core.int)]],
      close: [dart.void, []]
    })
  });
  const _buffer = Symbol('_buffer');
  const _callback = Symbol('_callback');
  const _bufferIndex = Symbol('_bufferIndex');
  convert._ByteCallbackSink = class _ByteCallbackSink extends convert.ByteConversionSinkBase {
    _ByteCallbackSink(callback) {
      this[_buffer] = typed_data.Uint8List.new(convert._ByteCallbackSink._INITIAL_BUFFER_SIZE);
      this[_callback] = callback;
      this[_bufferIndex] = 0;
    }
    add(chunk) {
      let freeCount = dart.notNull(this[_buffer][dartx.length]) - dart.notNull(this[_bufferIndex]);
      if (dart.notNull(chunk[dartx.length]) > freeCount) {
        let oldLength = this[_buffer][dartx.length];
        let newLength = dart.notNull(convert._ByteCallbackSink._roundToPowerOf2(dart.notNull(chunk[dartx.length]) + dart.notNull(oldLength))) * 2;
        let grown = typed_data.Uint8List.new(newLength);
        grown[dartx.setRange](0, this[_buffer][dartx.length], this[_buffer]);
        this[_buffer] = grown;
      }
      this[_buffer][dartx.setRange](this[_bufferIndex], dart.notNull(this[_bufferIndex]) + dart.notNull(chunk[dartx.length]), chunk);
      this[_bufferIndex] = dart.notNull(this[_bufferIndex]) + dart.notNull(chunk[dartx.length]);
    }
    static _roundToPowerOf2(v) {
      dart.assert(dart.notNull(v) > 0);
      v = dart.notNull(v) - 1;
      v = (dart.notNull(v) | v[dartx['>>']](1)) >>> 0;
      v = (dart.notNull(v) | v[dartx['>>']](2)) >>> 0;
      v = (dart.notNull(v) | v[dartx['>>']](4)) >>> 0;
      v = (dart.notNull(v) | v[dartx['>>']](8)) >>> 0;
      v = (dart.notNull(v) | v[dartx['>>']](16)) >>> 0;
      v = dart.notNull(v) + 1;
      return v;
    }
    close() {
      this[_callback](this[_buffer][dartx.sublist](0, this[_bufferIndex]));
    }
  };
  dart.setSignature(convert._ByteCallbackSink, {
    constructors: () => ({_ByteCallbackSink: [convert._ByteCallbackSink, [dart.functionType(dart.void, [core.List$(core.int)])]]}),
    methods: () => ({
      add: [dart.void, [core.Iterable$(core.int)]],
      close: [dart.void, []]
    }),
    statics: () => ({_roundToPowerOf2: [core.int, [core.int]]}),
    names: ['_roundToPowerOf2']
  });
  convert._ByteCallbackSink._INITIAL_BUFFER_SIZE = 1024;
  convert._ChunkedConversionCallback$ = dart.generic(T => {
    const _ChunkedConversionCallback = dart.typedef('_ChunkedConversionCallback', () => dart.functionType(dart.void, [T]));
    return _ChunkedConversionCallback;
  });
  convert._ChunkedConversionCallback = convert._ChunkedConversionCallback$();
  const _accumulated = Symbol('_accumulated');
  convert._SimpleCallbackSink$ = dart.generic(T => {
    class _SimpleCallbackSink extends convert.ChunkedConversionSink$(T) {
      _SimpleCallbackSink(callback) {
        this[_accumulated] = dart.list([], T);
        this[_callback] = callback;
        super.ChunkedConversionSink();
      }
      add(chunk) {
        dart.as(chunk, T);
        this[_accumulated][dartx.add](chunk);
      }
      close() {
        this[_callback](this[_accumulated]);
      }
    }
    dart.setSignature(_SimpleCallbackSink, {
      constructors: () => ({_SimpleCallbackSink: [convert._SimpleCallbackSink$(T), [convert._ChunkedConversionCallback$(core.List$(T))]]}),
      methods: () => ({
        add: [dart.void, [T]],
        close: [dart.void, []]
      })
    });
    return _SimpleCallbackSink;
  });
  convert._SimpleCallbackSink = convert._SimpleCallbackSink$();
  const _eventSink = Symbol('_eventSink');
  const _chunkedSink = Symbol('_chunkedSink');
  convert._ConverterStreamEventSink$ = dart.generic((S, T) => {
    class _ConverterStreamEventSink extends core.Object {
      _ConverterStreamEventSink(converter, sink) {
        this[_eventSink] = sink;
        this[_chunkedSink] = converter.startChunkedConversion(sink);
      }
      add(o) {
        dart.as(o, S);
        this[_chunkedSink].add(o);
      }
      addError(error, stackTrace) {
        if (stackTrace === void 0) stackTrace = null;
        this[_eventSink].addError(error, stackTrace);
      }
      close() {
        this[_chunkedSink].close();
      }
    }
    _ConverterStreamEventSink[dart.implements] = () => [async.EventSink$(S)];
    dart.setSignature(_ConverterStreamEventSink, {
      constructors: () => ({_ConverterStreamEventSink: [convert._ConverterStreamEventSink$(S, T), [convert.ChunkedConverter$(dart.dynamic, dart.dynamic, S, T), async.EventSink$(T)]]}),
      methods: () => ({
        add: [dart.void, [S]],
        addError: [dart.void, [core.Object], [core.StackTrace]],
        close: [dart.void, []]
      })
    });
    return _ConverterStreamEventSink;
  });
  convert._ConverterStreamEventSink = convert._ConverterStreamEventSink$();
  const _first$0 = Symbol('_first');
  const _second = Symbol('_second');
  convert._FusedChunkedConverter$ = dart.generic((S, M, T, S2, M2, T2) => {
    class _FusedChunkedConverter extends convert.ChunkedConverter$(S, T, S2, T2) {
      _FusedChunkedConverter(first, second) {
        this[_first$0] = first;
        this[_second] = second;
        super.ChunkedConverter();
      }
      convert(input) {
        dart.as(input, S);
        return this[_second].convert(this[_first$0].convert(input));
      }
      startChunkedConversion(sink) {
        dart.as(sink, core.Sink$(T2));
        return this[_first$0].startChunkedConversion(this[_second].startChunkedConversion(sink));
      }
    }
    dart.setSignature(_FusedChunkedConverter, {
      constructors: () => ({_FusedChunkedConverter: [convert._FusedChunkedConverter$(S, M, T, S2, M2, T2), [convert.ChunkedConverter$(S, M, S2, M2), convert.ChunkedConverter$(M, T, M2, T2)]]}),
      methods: () => ({
        convert: [T, [S]],
        startChunkedConversion: [convert.ChunkedConversionSink$(S2), [core.Sink$(T2)]]
      })
    });
    return _FusedChunkedConverter;
  });
  convert._FusedChunkedConverter = convert._FusedChunkedConverter$();
  convert._FusedCodec$ = dart.generic((S, M, T) => {
    class _FusedCodec extends convert.Codec$(S, T) {
      get encoder() {
        return dart.as(this[_first$0].encoder.fuse(this[_second].encoder), convert.Converter$(S, T));
      }
      get decoder() {
        return dart.as(this[_second].decoder.fuse(this[_first$0].decoder), convert.Converter$(T, S));
      }
      _FusedCodec(first, second) {
        this[_first$0] = first;
        this[_second] = second;
        super.Codec();
      }
    }
    dart.setSignature(_FusedCodec, {
      constructors: () => ({_FusedCodec: [convert._FusedCodec$(S, M, T), [convert.Codec$(S, M), convert.Codec$(M, T)]]})
    });
    return _FusedCodec;
  });
  convert._FusedCodec = convert._FusedCodec$();
  const _codec = Symbol('_codec');
  convert._InvertedCodec$ = dart.generic((T, S) => {
    class _InvertedCodec extends convert.Codec$(T, S) {
      _InvertedCodec(codec) {
        this[_codec] = codec;
        super.Codec();
      }
      get encoder() {
        return this[_codec].decoder;
      }
      get decoder() {
        return this[_codec].encoder;
      }
      get inverted() {
        return this[_codec];
      }
    }
    dart.setSignature(_InvertedCodec, {
      constructors: () => ({_InvertedCodec: [convert._InvertedCodec$(T, S), [convert.Codec$(S, T)]]})
    });
    return _InvertedCodec;
  });
  convert._InvertedCodec = convert._InvertedCodec$();
  convert._FusedConverter$ = dart.generic((S, M, T) => {
    class _FusedConverter extends convert.Converter$(S, T) {
      _FusedConverter(first, second) {
        this[_first$0] = first;
        this[_second] = second;
        super.Converter();
      }
      convert(input) {
        dart.as(input, S);
        return this[_second].convert(this[_first$0].convert(input));
      }
    }
    dart.setSignature(_FusedConverter, {
      constructors: () => ({_FusedConverter: [convert._FusedConverter$(S, M, T), [convert.Converter$(S, M), convert.Converter$(M, T)]]}),
      methods: () => ({convert: [T, [S]]})
    });
    return _FusedConverter;
  });
  convert._FusedConverter = convert._FusedConverter$();
  const _name$0 = Symbol('_name');
  convert.HtmlEscapeMode = class HtmlEscapeMode extends core.Object {
    _(name, escapeLtGt, escapeQuot, escapeApos, escapeSlash) {
      this[_name$0] = name;
      this.escapeLtGt = escapeLtGt;
      this.escapeQuot = escapeQuot;
      this.escapeApos = escapeApos;
      this.escapeSlash = escapeSlash;
    }
    HtmlEscapeMode(opts) {
      let name = opts && 'name' in opts ? opts.name : "custom";
      let escapeLtGt = opts && 'escapeLtGt' in opts ? opts.escapeLtGt : false;
      let escapeQuot = opts && 'escapeQuot' in opts ? opts.escapeQuot : false;
      let escapeApos = opts && 'escapeApos' in opts ? opts.escapeApos : false;
      let escapeSlash = opts && 'escapeSlash' in opts ? opts.escapeSlash : false;
      this.escapeLtGt = escapeLtGt;
      this.escapeQuot = escapeQuot;
      this.escapeApos = escapeApos;
      this.escapeSlash = escapeSlash;
      this[_name$0] = name;
    }
    toString() {
      return this[_name$0];
    }
  };
  dart.defineNamedConstructor(convert.HtmlEscapeMode, '_');
  dart.setSignature(convert.HtmlEscapeMode, {
    constructors: () => ({
      _: [convert.HtmlEscapeMode, [core.String, core.bool, core.bool, core.bool, core.bool]],
      HtmlEscapeMode: [convert.HtmlEscapeMode, [], {name: core.String, escapeLtGt: core.bool, escapeQuot: core.bool, escapeApos: core.bool, escapeSlash: core.bool}]
    })
  });
  dart.defineLazy(convert.HtmlEscapeMode, {
    get UNKNOWN() {
      return dart.const(new convert.HtmlEscapeMode._('unknown', true, true, true, true));
    },
    get ATTRIBUTE() {
      return dart.const(new convert.HtmlEscapeMode._('attribute', true, true, false, false));
    },
    get SQ_ATTRIBUTE() {
      return dart.const(new convert.HtmlEscapeMode._('attribute', true, false, true, false));
    },
    get ELEMENT() {
      return dart.const(new convert.HtmlEscapeMode._('element', true, false, false, false));
    }
  });
  const _convert = Symbol('_convert');
  convert.HtmlEscape = class HtmlEscape extends convert.ChunkedConverter$(core.String, core.String, core.String, core.String) {
    HtmlEscape(mode) {
      if (mode === void 0) mode = convert.HtmlEscapeMode.UNKNOWN;
      this.mode = mode;
      super.ChunkedConverter();
    }
    convert(text) {
      let val = this[_convert](text, 0, text[dartx.length]);
      return val == null ? text : val;
    }
    [_convert](text, start, end) {
      let result = null;
      for (let i = start; dart.notNull(i) < dart.notNull(end); i = dart.notNull(i) + 1) {
        let ch = text[dartx.get](i);
        let replacement = null;
        switch (ch) {
          case '&':
          {
            replacement = '&amp;';
            break;
          }
          case '"':
          {
            if (dart.notNull(this.mode.escapeQuot)) replacement = '&quot;';
            break;
          }
          case "'":
          {
            if (dart.notNull(this.mode.escapeApos)) replacement = '&#39;';
            break;
          }
          case '<':
          {
            if (dart.notNull(this.mode.escapeLtGt)) replacement = '&lt;';
            break;
          }
          case '>':
          {
            if (dart.notNull(this.mode.escapeLtGt)) replacement = '&gt;';
            break;
          }
          case '/':
          {
            if (dart.notNull(this.mode.escapeSlash)) replacement = '&#47;';
            break;
          }
        }
        if (replacement != null) {
          if (result == null) result = new core.StringBuffer();
          if (dart.notNull(i) > dart.notNull(start)) result.write(text[dartx.substring](start, i));
          result.write(replacement);
          start = dart.notNull(i) + 1;
        }
      }
      if (result == null) return null;
      if (dart.notNull(end) > dart.notNull(start)) result.write(text[dartx.substring](start, end));
      return dart.toString(result);
    }
    startChunkedConversion(sink) {
      if (!dart.is(sink, convert.StringConversionSink)) {
        sink = convert.StringConversionSink.from(sink);
      }
      return new convert._HtmlEscapeSink(this, dart.as(sink, convert.StringConversionSink));
    }
  };
  dart.setSignature(convert.HtmlEscape, {
    constructors: () => ({HtmlEscape: [convert.HtmlEscape, [], [convert.HtmlEscapeMode]]}),
    methods: () => ({
      convert: [core.String, [core.String]],
      [_convert]: [core.String, [core.String, core.int, core.int]],
      startChunkedConversion: [convert.StringConversionSink, [core.Sink$(core.String)]]
    })
  });
  convert.HTML_ESCAPE = dart.const(new convert.HtmlEscape());
  const _escape = Symbol('_escape');
  convert._HtmlEscapeSink = class _HtmlEscapeSink extends convert.StringConversionSinkBase {
    _HtmlEscapeSink(escape, sink) {
      this[_escape] = escape;
      this[_sink$] = sink;
    }
    addSlice(chunk, start, end, isLast) {
      let val = this[_escape][_convert](chunk, start, end);
      if (val == null) {
        this[_sink$].addSlice(chunk, start, end, isLast);
      } else {
        this[_sink$].add(val);
        if (dart.notNull(isLast)) this[_sink$].close();
      }
    }
    close() {
      this[_sink$].close();
    }
  };
  dart.setSignature(convert._HtmlEscapeSink, {
    constructors: () => ({_HtmlEscapeSink: [convert._HtmlEscapeSink, [convert.HtmlEscape, convert.StringConversionSink]]}),
    methods: () => ({
      addSlice: [dart.void, [core.String, core.int, core.int, core.bool]],
      close: [dart.void, []]
    })
  });
  convert.JsonUnsupportedObjectError = class JsonUnsupportedObjectError extends core.Error {
    JsonUnsupportedObjectError(unsupportedObject, opts) {
      let cause = opts && 'cause' in opts ? opts.cause : null;
      this.unsupportedObject = unsupportedObject;
      this.cause = cause;
      super.Error();
    }
    toString() {
      if (this.cause != null) {
        return "Converting object to an encodable object failed.";
      } else {
        return "Converting object did not return an encodable object.";
      }
    }
  };
  dart.setSignature(convert.JsonUnsupportedObjectError, {
    constructors: () => ({JsonUnsupportedObjectError: [convert.JsonUnsupportedObjectError, [dart.dynamic], {cause: dart.dynamic}]})
  });
  convert.JsonCyclicError = class JsonCyclicError extends convert.JsonUnsupportedObjectError {
    JsonCyclicError(object) {
      super.JsonUnsupportedObjectError(object);
    }
    toString() {
      return "Cyclic error in JSON stringify";
    }
  };
  dart.setSignature(convert.JsonCyclicError, {
    constructors: () => ({JsonCyclicError: [convert.JsonCyclicError, [core.Object]]})
  });
  const _toEncodable$ = Symbol('_toEncodable');
  convert.JsonCodec = class JsonCodec extends convert.Codec$(core.Object, core.String) {
    JsonCodec(opts) {
      let reviver = opts && 'reviver' in opts ? opts.reviver : null;
      let toEncodable = opts && 'toEncodable' in opts ? opts.toEncodable : null;
      this[_reviver] = reviver;
      this[_toEncodable$] = toEncodable;
      super.Codec();
    }
    withReviver(reviver) {
      this.JsonCodec({reviver: reviver});
    }
    decode(source, opts) {
      let reviver = opts && 'reviver' in opts ? opts.reviver : null;
      if (reviver == null) reviver = this[_reviver];
      if (reviver == null) return this.decoder.convert(source);
      return new convert.JsonDecoder(reviver).convert(source);
    }
    encode(value, opts) {
      let toEncodable = opts && 'toEncodable' in opts ? opts.toEncodable : null;
      if (toEncodable == null) toEncodable = this[_toEncodable$];
      if (toEncodable == null) return this.encoder.convert(value);
      return new convert.JsonEncoder(dart.as(toEncodable, dart.functionType(core.Object, [core.Object]))).convert(value);
    }
    get encoder() {
      if (this[_toEncodable$] == null) return dart.const(new convert.JsonEncoder());
      return new convert.JsonEncoder(dart.as(this[_toEncodable$], dart.functionType(core.Object, [core.Object])));
    }
    get decoder() {
      if (this[_reviver] == null) return dart.const(new convert.JsonDecoder());
      return new convert.JsonDecoder(this[_reviver]);
    }
  };
  dart.defineNamedConstructor(convert.JsonCodec, 'withReviver');
  dart.setSignature(convert.JsonCodec, {
    constructors: () => ({
      JsonCodec: [convert.JsonCodec, [], {reviver: dart.functionType(dart.dynamic, [dart.dynamic, dart.dynamic]), toEncodable: dart.functionType(dart.dynamic, [dart.dynamic])}],
      withReviver: [convert.JsonCodec, [dart.functionType(dart.dynamic, [dart.dynamic, dart.dynamic])]]
    }),
    methods: () => ({
      decode: [dart.dynamic, [core.String], {reviver: dart.functionType(dart.dynamic, [dart.dynamic, dart.dynamic])}],
      encode: [core.String, [core.Object], {toEncodable: dart.functionType(dart.dynamic, [dart.dynamic])}]
    })
  });
  convert.JSON = dart.const(new convert.JsonCodec());
  convert._Reviver = dart.typedef('_Reviver', () => dart.functionType(dart.dynamic, [dart.dynamic, dart.dynamic]));
  convert._ToEncodable = dart.typedef('_ToEncodable', () => dart.functionType(dart.dynamic, [dart.dynamic]));
  convert.JsonEncoder = class JsonEncoder extends convert.ChunkedConverter$(core.Object, core.String, core.Object, core.String) {
    JsonEncoder(toEncodable) {
      if (toEncodable === void 0) toEncodable = null;
      this.indent = null;
      this[_toEncodable$] = toEncodable;
      super.ChunkedConverter();
    }
    withIndent(indent, toEncodable) {
      if (toEncodable === void 0) toEncodable = null;
      this.indent = indent;
      this[_toEncodable$] = toEncodable;
      super.ChunkedConverter();
    }
    convert(object) {
      return convert._JsonStringStringifier.stringify(object, dart.as(this[_toEncodable$], dart.functionType(dart.dynamic, [dart.dynamic])), this.indent);
    }
    startChunkedConversion(sink) {
      if (!dart.is(sink, convert.StringConversionSink)) {
        sink = convert.StringConversionSink.from(sink);
      } else if (dart.is(sink, convert._Utf8EncoderSink)) {
        return new convert._JsonUtf8EncoderSink(sink[_sink$], this[_toEncodable$], convert.JsonUtf8Encoder._utf8Encode(this.indent), convert.JsonUtf8Encoder.DEFAULT_BUFFER_SIZE);
      }
      return new convert._JsonEncoderSink(dart.as(sink, convert.StringConversionSink), this[_toEncodable$], this.indent);
    }
    bind(stream) {
      return super.bind(stream);
    }
    fuse(other) {
      if (dart.is(other, convert.Utf8Encoder)) {
        return new convert.JsonUtf8Encoder(this.indent, dart.as(this[_toEncodable$], dart.functionType(dart.dynamic, [core.Object])));
      }
      return super.fuse(other);
    }
  };
  dart.defineNamedConstructor(convert.JsonEncoder, 'withIndent');
  dart.setSignature(convert.JsonEncoder, {
    constructors: () => ({
      JsonEncoder: [convert.JsonEncoder, [], [dart.functionType(core.Object, [core.Object])]],
      withIndent: [convert.JsonEncoder, [core.String], [dart.functionType(core.Object, [core.Object])]]
    }),
    methods: () => ({
      convert: [core.String, [core.Object]],
      startChunkedConversion: [convert.ChunkedConversionSink$(core.Object), [core.Sink$(core.String)]],
      bind: [async.Stream$(core.String), [async.Stream$(core.Object)]],
      fuse: [convert.Converter$(core.Object, dart.dynamic), [convert.Converter$(core.String, dart.dynamic)]]
    })
  });
  const _indent = Symbol('_indent');
  const _bufferSize = Symbol('_bufferSize');
  convert.JsonUtf8Encoder = class JsonUtf8Encoder extends convert.ChunkedConverter$(core.Object, core.List$(core.int), core.Object, core.List$(core.int)) {
    JsonUtf8Encoder(indent, toEncodable, bufferSize) {
      if (indent === void 0) indent = null;
      if (toEncodable === void 0) toEncodable = null;
      if (bufferSize === void 0) bufferSize = convert.JsonUtf8Encoder.DEFAULT_BUFFER_SIZE;
      this[_indent] = convert.JsonUtf8Encoder._utf8Encode(indent);
      this[_toEncodable$] = toEncodable;
      this[_bufferSize] = bufferSize;
      super.ChunkedConverter();
    }
    static _utf8Encode(string) {
      if (string == null) return null;
      if (dart.notNull(string[dartx.isEmpty])) return typed_data.Uint8List.new(0);
      checkAscii: {
        for (let i = 0; i < dart.notNull(string[dartx.length]); i++) {
          if (dart.notNull(string[dartx.codeUnitAt](i)) >= 128) break checkAscii;
        }
        return string[dartx.codeUnits];
      }
      return convert.UTF8.encode(string);
    }
    convert(object) {
      let bytes = dart.list([], core.List$(core.int));
      function addChunk(chunk, start, end) {
        if (dart.notNull(start) > 0 || dart.notNull(end) < dart.notNull(chunk[dartx.length])) {
          let length = dart.notNull(end) - dart.notNull(start);
          chunk = typed_data.Uint8List.view(chunk[dartx.buffer], dart.notNull(chunk[dartx.offsetInBytes]) + dart.notNull(start), length);
        }
        bytes[dartx.add](chunk);
      }
      dart.fn(addChunk, dart.void, [typed_data.Uint8List, core.int, core.int]);
      convert._JsonUtf8Stringifier.stringify(object, this[_indent], dart.as(this[_toEncodable$], dart.functionType(dart.dynamic, [core.Object])), this[_bufferSize], addChunk);
      if (bytes[dartx.length] == 1) return bytes[dartx.get](0);
      let length = 0;
      for (let i = 0; i < dart.notNull(bytes[dartx.length]); i++) {
        length = dart.notNull(length) + dart.notNull(bytes[dartx.get](i)[dartx.length]);
      }
      let result = typed_data.Uint8List.new(length);
      for (let i = 0, offset = 0; i < dart.notNull(bytes[dartx.length]); i++) {
        let byteList = bytes[dartx.get](i);
        let end = offset + dart.notNull(byteList[dartx.length]);
        result[dartx.setRange](offset, end, byteList);
        offset = end;
      }
      return result;
    }
    startChunkedConversion(sink) {
      let byteSink = null;
      if (dart.is(sink, convert.ByteConversionSink)) {
        byteSink = sink;
      } else {
        byteSink = convert.ByteConversionSink.from(sink);
      }
      return new convert._JsonUtf8EncoderSink(byteSink, this[_toEncodable$], this[_indent], this[_bufferSize]);
    }
    bind(stream) {
      return super.bind(stream);
    }
    fuse(other) {
      return super.fuse(other);
    }
  };
  dart.setSignature(convert.JsonUtf8Encoder, {
    constructors: () => ({JsonUtf8Encoder: [convert.JsonUtf8Encoder, [], [core.String, dart.functionType(dart.dynamic, [core.Object]), core.int]]}),
    methods: () => ({
      convert: [core.List$(core.int), [core.Object]],
      startChunkedConversion: [convert.ChunkedConversionSink$(core.Object), [core.Sink$(core.List$(core.int))]],
      bind: [async.Stream$(core.List$(core.int)), [async.Stream$(core.Object)]],
      fuse: [convert.Converter$(core.Object, dart.dynamic), [convert.Converter$(core.List$(core.int), dart.dynamic)]]
    }),
    statics: () => ({_utf8Encode: [core.List$(core.int), [core.String]]}),
    names: ['_utf8Encode']
  });
  convert.JsonUtf8Encoder.DEFAULT_BUFFER_SIZE = 256;
  const _isDone = Symbol('_isDone');
  convert._JsonEncoderSink = class _JsonEncoderSink extends convert.ChunkedConversionSink$(core.Object) {
    _JsonEncoderSink(sink, toEncodable, indent) {
      this[_sink$] = sink;
      this[_toEncodable$] = toEncodable;
      this[_indent] = indent;
      this[_isDone] = false;
      super.ChunkedConversionSink();
    }
    add(o) {
      if (dart.notNull(this[_isDone])) {
        dart.throw(new core.StateError("Only one call to add allowed"));
      }
      this[_isDone] = true;
      let stringSink = this[_sink$].asStringSink();
      convert._JsonStringStringifier.printOn(o, stringSink, dart.as(this[_toEncodable$], dart.functionType(dart.dynamic, [dart.dynamic])), this[_indent]);
      stringSink.close();
    }
    close() {}
  };
  dart.setSignature(convert._JsonEncoderSink, {
    constructors: () => ({_JsonEncoderSink: [convert._JsonEncoderSink, [convert.StringConversionSink, core.Function, core.String]]}),
    methods: () => ({
      add: [dart.void, [core.Object]],
      close: [dart.void, []]
    })
  });
  const _addChunk = Symbol('_addChunk');
  convert._JsonUtf8EncoderSink = class _JsonUtf8EncoderSink extends convert.ChunkedConversionSink$(core.Object) {
    _JsonUtf8EncoderSink(sink, toEncodable, indent, bufferSize) {
      this[_sink$] = sink;
      this[_toEncodable$] = toEncodable;
      this[_indent] = indent;
      this[_bufferSize] = bufferSize;
      this[_isDone] = false;
      super.ChunkedConversionSink();
    }
    [_addChunk](chunk, start, end) {
      this[_sink$].addSlice(chunk, start, end, false);
    }
    add(object) {
      if (dart.notNull(this[_isDone])) {
        dart.throw(new core.StateError("Only one call to add allowed"));
      }
      this[_isDone] = true;
      convert._JsonUtf8Stringifier.stringify(object, this[_indent], dart.as(this[_toEncodable$], dart.functionType(dart.dynamic, [core.Object])), this[_bufferSize], dart.bind(this, _addChunk));
      this[_sink$].close();
    }
    close() {
      if (!dart.notNull(this[_isDone])) {
        this[_isDone] = true;
        this[_sink$].close();
      }
    }
  };
  dart.setSignature(convert._JsonUtf8EncoderSink, {
    constructors: () => ({_JsonUtf8EncoderSink: [convert._JsonUtf8EncoderSink, [convert.ByteConversionSink, core.Function, core.List$(core.int), core.int]]}),
    methods: () => ({
      [_addChunk]: [dart.void, [typed_data.Uint8List, core.int, core.int]],
      add: [dart.void, [core.Object]],
      close: [dart.void, []]
    })
  });
  convert.JsonDecoder = class JsonDecoder extends convert.ChunkedConverter$(core.String, core.Object, core.String, core.Object) {
    JsonDecoder(reviver) {
      if (reviver === void 0) reviver = null;
      this[_reviver] = reviver;
      super.ChunkedConverter();
    }
    convert(input) {
      return convert._parseJson(input, this[_reviver]);
    }
    startChunkedConversion(sink) {
      return new convert._JsonDecoderSink(this[_reviver], sink);
    }
    bind(stream) {
      return super.bind(stream);
    }
  };
  dart.setSignature(convert.JsonDecoder, {
    constructors: () => ({JsonDecoder: [convert.JsonDecoder, [], [dart.functionType(dart.dynamic, [dart.dynamic, dart.dynamic])]]}),
    methods: () => ({
      convert: [dart.dynamic, [core.String]],
      startChunkedConversion: [convert.StringConversionSink, [core.Sink$(core.Object)]],
      bind: [async.Stream$(core.Object), [async.Stream$(core.String)]]
    })
  });
  convert._parseJson = function(source, reviver) {
    if (!(typeof source == 'string')) dart.throw(_js_helper.argumentErrorValue(source));
    let parsed = null;
    try {
      parsed = JSON.parse(source);
    } catch (e) {
      dart.throw(new core.FormatException(String(e)));
    }

    if (reviver == null) {
      return convert._convertJsonToDartLazy(parsed);
    } else {
      return convert._convertJsonToDart(parsed, reviver);
    }
  };
  dart.fn(convert._parseJson, dart.dynamic, [core.String, dart.functionType(dart.dynamic, [dart.dynamic, dart.dynamic])]);
  convert._defaultToEncodable = function(object) {
    return dart.dsend(object, 'toJson');
  };
  dart.fn(convert._defaultToEncodable, core.Object, [dart.dynamic]);
  const _seen = Symbol('_seen');
  const _checkCycle = Symbol('_checkCycle');
  const _removeSeen = Symbol('_removeSeen');
  convert._JsonStringifier = class _JsonStringifier extends core.Object {
    _JsonStringifier(_toEncodable) {
      this[_seen] = core.List.new();
      this[_toEncodable$] = _toEncodable != null ? _toEncodable : convert._defaultToEncodable;
    }
    static hexDigit(x) {
      return dart.notNull(x) < 10 ? 48 + dart.notNull(x) : 87 + dart.notNull(x);
    }
    writeStringContent(s) {
      let offset = 0;
      let length = s[dartx.length];
      for (let i = 0; i < dart.notNull(length); i++) {
        let charCode = s[dartx.codeUnitAt](i);
        if (dart.notNull(charCode) > dart.notNull(convert._JsonStringifier.BACKSLASH)) continue;
        if (dart.notNull(charCode) < 32) {
          if (i > offset) this.writeStringSlice(s, offset, i);
          offset = i + 1;
          this.writeCharCode(convert._JsonStringifier.BACKSLASH);
          switch (charCode) {
            case convert._JsonStringifier.BACKSPACE:
            {
              this.writeCharCode(convert._JsonStringifier.CHAR_b);
              break;
            }
            case convert._JsonStringifier.TAB:
            {
              this.writeCharCode(convert._JsonStringifier.CHAR_t);
              break;
            }
            case convert._JsonStringifier.NEWLINE:
            {
              this.writeCharCode(convert._JsonStringifier.CHAR_n);
              break;
            }
            case convert._JsonStringifier.FORM_FEED:
            {
              this.writeCharCode(convert._JsonStringifier.CHAR_f);
              break;
            }
            case convert._JsonStringifier.CARRIAGE_RETURN:
            {
              this.writeCharCode(convert._JsonStringifier.CHAR_r);
              break;
            }
            default:
            {
              this.writeCharCode(convert._JsonStringifier.CHAR_u);
              this.writeCharCode(convert._JsonStringifier.CHAR_0);
              this.writeCharCode(convert._JsonStringifier.CHAR_0);
              this.writeCharCode(convert._JsonStringifier.hexDigit(charCode[dartx['>>']](4) & 15));
              this.writeCharCode(convert._JsonStringifier.hexDigit(dart.notNull(charCode) & 15));
              break;
            }
          }
        } else if (charCode == convert._JsonStringifier.QUOTE || charCode == convert._JsonStringifier.BACKSLASH) {
          if (i > offset) this.writeStringSlice(s, offset, i);
          offset = i + 1;
          this.writeCharCode(convert._JsonStringifier.BACKSLASH);
          this.writeCharCode(charCode);
        }
      }
      if (offset == 0) {
        this.writeString(s);
      } else if (offset < dart.notNull(length)) {
        this.writeStringSlice(s, offset, length);
      }
    }
    [_checkCycle](object) {
      for (let i = 0; i < dart.notNull(this[_seen][dartx.length]); i++) {
        if (core.identical(object, this[_seen][dartx.get](i))) {
          dart.throw(new convert.JsonCyclicError(object));
        }
      }
      this[_seen][dartx.add](object);
    }
    [_removeSeen](object) {
      dart.assert(!dart.notNull(this[_seen][dartx.isEmpty]));
      dart.assert(core.identical(this[_seen][dartx.last], object));
      this[_seen][dartx.removeLast]();
    }
    writeObject(object) {
      if (dart.notNull(this.writeJsonValue(object))) return;
      this[_checkCycle](object);
      try {
        let customJson = dart.dcall(this[_toEncodable$], object);
        if (!dart.notNull(this.writeJsonValue(customJson))) {
          dart.throw(new convert.JsonUnsupportedObjectError(object));
        }
        this[_removeSeen](object);
      } catch (e) {
        dart.throw(new convert.JsonUnsupportedObjectError(object, {cause: e}));
      }

    }
    writeJsonValue(object) {
      if (typeof object == 'number') {
        if (!dart.notNull(object[dartx.isFinite])) return false;
        this.writeNumber(object);
        return true;
      } else if (core.identical(object, true)) {
        this.writeString('true');
        return true;
      } else if (core.identical(object, false)) {
        this.writeString('false');
        return true;
      } else if (object == null) {
        this.writeString('null');
        return true;
      } else if (typeof object == 'string') {
        this.writeString('"');
        this.writeStringContent(object);
        this.writeString('"');
        return true;
      } else if (dart.is(object, core.List)) {
        this[_checkCycle](object);
        this.writeList(object);
        this[_removeSeen](object);
        return true;
      } else if (dart.is(object, core.Map)) {
        this[_checkCycle](object);
        let success = this.writeMap(dart.as(object, core.Map$(core.String, core.Object)));
        this[_removeSeen](object);
        return success;
      } else {
        return false;
      }
    }
    writeList(list) {
      this.writeString('[');
      if (dart.notNull(list[dartx.length]) > 0) {
        this.writeObject(list[dartx.get](0));
        for (let i = 1; i < dart.notNull(list[dartx.length]); i++) {
          this.writeString(',');
          this.writeObject(list[dartx.get](i));
        }
      }
      this.writeString(']');
    }
    writeMap(map) {
      if (dart.notNull(map[dartx.isEmpty])) {
        this.writeString("{}");
        return true;
      }
      let keyValueList = core.List.new(dart.notNull(map[dartx.length]) * 2);
      let i = 0;
      let allStringKeys = true;
      map[dartx.forEach](dart.fn((key, value) => {
        if (!(typeof key == 'string')) {
          allStringKeys = false;
        }
        keyValueList[dartx.set](i++, key);
        keyValueList[dartx.set](i++, value);
      }, dart.void, [core.String, core.Object]));
      if (!allStringKeys) return false;
      this.writeString('{');
      let separator = '"';
      for (let i = 0; i < dart.notNull(keyValueList[dartx.length]); i = i + 2) {
        this.writeString(separator);
        separator = ',"';
        this.writeStringContent(dart.as(keyValueList[dartx.get](i), core.String));
        this.writeString('":');
        this.writeObject(keyValueList[dartx.get](i + 1));
      }
      this.writeString('}');
      return true;
    }
  };
  dart.setSignature(convert._JsonStringifier, {
    constructors: () => ({_JsonStringifier: [convert._JsonStringifier, [dart.functionType(core.Object, [core.Object])]]}),
    methods: () => ({
      writeStringContent: [dart.void, [core.String]],
      [_checkCycle]: [dart.void, [dart.dynamic]],
      [_removeSeen]: [dart.void, [dart.dynamic]],
      writeObject: [dart.void, [dart.dynamic]],
      writeJsonValue: [core.bool, [dart.dynamic]],
      writeList: [dart.void, [core.List]],
      writeMap: [core.bool, [core.Map$(core.String, core.Object)]]
    }),
    statics: () => ({hexDigit: [core.int, [core.int]]}),
    names: ['hexDigit']
  });
  convert._JsonStringifier.BACKSPACE = 8;
  convert._JsonStringifier.TAB = 9;
  convert._JsonStringifier.NEWLINE = 10;
  convert._JsonStringifier.CARRIAGE_RETURN = 13;
  convert._JsonStringifier.FORM_FEED = 12;
  convert._JsonStringifier.QUOTE = 34;
  convert._JsonStringifier.CHAR_0 = 48;
  convert._JsonStringifier.BACKSLASH = 92;
  convert._JsonStringifier.CHAR_b = 98;
  convert._JsonStringifier.CHAR_f = 102;
  convert._JsonStringifier.CHAR_n = 110;
  convert._JsonStringifier.CHAR_r = 114;
  convert._JsonStringifier.CHAR_t = 116;
  convert._JsonStringifier.CHAR_u = 117;
  const _indentLevel = Symbol('_indentLevel');
  convert._JsonPrettyPrintMixin = class _JsonPrettyPrintMixin extends core.Object {
    _JsonPrettyPrintMixin() {
      this[_indentLevel] = 0;
    }
    writeList(list) {
      if (dart.notNull(list[dartx.isEmpty])) {
        this.writeString('[]');
      } else {
        this.writeString('[\n');
        this[_indentLevel] = dart.notNull(this[_indentLevel]) + 1;
        this.writeIndentation(this[_indentLevel]);
        this.writeObject(list[dartx.get](0));
        for (let i = 1; i < dart.notNull(list[dartx.length]); i++) {
          this.writeString(',\n');
          this.writeIndentation(this[_indentLevel]);
          this.writeObject(list[dartx.get](i));
        }
        this.writeString('\n');
        this[_indentLevel] = dart.notNull(this[_indentLevel]) - 1;
        this.writeIndentation(this[_indentLevel]);
        this.writeString(']');
      }
    }
    writeMap(map) {
      if (dart.notNull(map[dartx.isEmpty])) {
        this.writeString("{}");
        return true;
      }
      let keyValueList = core.List.new(dart.notNull(map[dartx.length]) * 2);
      let i = 0;
      let allStringKeys = true;
      map[dartx.forEach](dart.fn((key, value) => {
        if (!(typeof key == 'string')) {
          allStringKeys = false;
        }
        keyValueList[dartx.set](i++, key);
        keyValueList[dartx.set](i++, value);
      }, dart.void, [dart.dynamic, dart.dynamic]));
      if (!allStringKeys) return false;
      this.writeString('{\n');
      this[_indentLevel] = dart.notNull(this[_indentLevel]) + 1;
      let separator = "";
      for (let i = 0; i < dart.notNull(keyValueList[dartx.length]); i = i + 2) {
        this.writeString(separator);
        separator = ",\n";
        this.writeIndentation(this[_indentLevel]);
        this.writeString('"');
        this.writeStringContent(dart.as(keyValueList[dartx.get](i), core.String));
        this.writeString('": ');
        this.writeObject(keyValueList[dartx.get](i + 1));
      }
      this.writeString('\n');
      this[_indentLevel] = dart.notNull(this[_indentLevel]) - 1;
      this.writeIndentation(this[_indentLevel]);
      this.writeString('}');
      return true;
    }
  };
  convert._JsonPrettyPrintMixin[dart.implements] = () => [convert._JsonStringifier];
  dart.setSignature(convert._JsonPrettyPrintMixin, {
    methods: () => ({
      writeList: [dart.void, [core.List]],
      writeMap: [core.bool, [core.Map]]
    })
  });
  convert._JsonStringStringifier = class _JsonStringStringifier extends convert._JsonStringifier {
    _JsonStringStringifier(sink, _toEncodable) {
      this[_sink$] = sink;
      super._JsonStringifier(dart.as(_toEncodable, dart.functionType(core.Object, [core.Object])));
    }
    static stringify(object, toEncodable, indent) {
      let output = new core.StringBuffer();
      convert._JsonStringStringifier.printOn(object, output, toEncodable, indent);
      return output.toString();
    }
    static printOn(object, output, toEncodable, indent) {
      let stringifier = null;
      if (indent == null) {
        stringifier = new convert._JsonStringStringifier(output, toEncodable);
      } else {
        stringifier = new convert._JsonStringStringifierPretty(output, toEncodable, indent);
      }
      dart.dsend(stringifier, 'writeObject', object);
    }
    writeNumber(number) {
      this[_sink$].write(dart.toString(number));
    }
    writeString(string) {
      this[_sink$].write(string);
    }
    writeStringSlice(string, start, end) {
      this[_sink$].write(string[dartx.substring](start, end));
    }
    writeCharCode(charCode) {
      this[_sink$].writeCharCode(charCode);
    }
  };
  dart.setSignature(convert._JsonStringStringifier, {
    constructors: () => ({_JsonStringStringifier: [convert._JsonStringStringifier, [core.StringSink, dart.dynamic]]}),
    methods: () => ({
      writeNumber: [dart.void, [core.num]],
      writeString: [dart.void, [core.String]],
      writeStringSlice: [dart.void, [core.String, core.int, core.int]],
      writeCharCode: [dart.void, [core.int]]
    }),
    statics: () => ({
      stringify: [core.String, [dart.dynamic, dart.functionType(dart.dynamic, [dart.dynamic]), core.String]],
      printOn: [dart.void, [dart.dynamic, core.StringSink, dart.functionType(dart.dynamic, [dart.dynamic]), core.String]]
    }),
    names: ['stringify', 'printOn']
  });
  convert._JsonStringStringifierPretty = class _JsonStringStringifierPretty extends dart.mixin(convert._JsonStringStringifier, convert._JsonPrettyPrintMixin) {
    _JsonStringStringifierPretty(sink, toEncodable, indent) {
      this[_indent] = indent;
      super._JsonStringStringifier(sink, toEncodable);
    }
    writeIndentation(count) {
      for (let i = 0; i < dart.notNull(count); i++)
        this.writeString(this[_indent]);
    }
  };
  dart.setSignature(convert._JsonStringStringifierPretty, {
    constructors: () => ({_JsonStringStringifierPretty: [convert._JsonStringStringifierPretty, [core.StringSink, core.Function, core.String]]}),
    methods: () => ({writeIndentation: [dart.void, [core.int]]})
  });
  convert._JsonUtf8Stringifier = class _JsonUtf8Stringifier extends convert._JsonStringifier {
    _JsonUtf8Stringifier(toEncodable, bufferSize, addChunk) {
      this.addChunk = addChunk;
      this.bufferSize = bufferSize;
      this.buffer = typed_data.Uint8List.new(bufferSize);
      this.index = 0;
      super._JsonStringifier(dart.as(toEncodable, dart.functionType(core.Object, [core.Object])));
    }
    static stringify(object, indent, toEncodableFunction, bufferSize, addChunk) {
      let stringifier = null;
      if (indent != null) {
        stringifier = new convert._JsonUtf8StringifierPretty(toEncodableFunction, indent, bufferSize, addChunk);
      } else {
        stringifier = new convert._JsonUtf8Stringifier(toEncodableFunction, bufferSize, addChunk);
      }
      stringifier.writeObject(object);
      stringifier.flush();
    }
    flush() {
      if (dart.notNull(this.index) > 0) {
        dart.dcall(this.addChunk, this.buffer, 0, this.index);
      }
      this.buffer = null;
      this.index = 0;
    }
    writeNumber(number) {
      this.writeAsciiString(dart.toString(number));
    }
    writeAsciiString(string) {
      for (let i = 0; i < dart.notNull(string[dartx.length]); i++) {
        let char = string[dartx.codeUnitAt](i);
        dart.assert(dart.notNull(char) <= 127);
        this.writeByte(char);
      }
    }
    writeString(string) {
      this.writeStringSlice(string, 0, string[dartx.length]);
    }
    writeStringSlice(string, start, end) {
      for (let i = start; dart.notNull(i) < dart.notNull(end); i = dart.notNull(i) + 1) {
        let char = string[dartx.codeUnitAt](i);
        if (dart.notNull(char) <= 127) {
          this.writeByte(char);
        } else {
          if ((dart.notNull(char) & 64512) == 55296 && dart.notNull(i) + 1 < dart.notNull(end)) {
            let nextChar = string[dartx.codeUnitAt](dart.notNull(i) + 1);
            if ((dart.notNull(nextChar) & 64512) == 56320) {
              char = 65536 + ((dart.notNull(char) & 1023) << 10) + (dart.notNull(nextChar) & 1023);
              this.writeFourByteCharCode(char);
              i = dart.notNull(i) + 1;
              continue;
            }
          }
          this.writeMultiByteCharCode(char);
        }
      }
    }
    writeCharCode(charCode) {
      if (dart.notNull(charCode) <= 127) {
        this.writeByte(charCode);
        return;
      }
      this.writeMultiByteCharCode(charCode);
    }
    writeMultiByteCharCode(charCode) {
      if (dart.notNull(charCode) <= 2047) {
        this.writeByte((192 | charCode[dartx['>>']](6)) >>> 0);
        this.writeByte(128 | dart.notNull(charCode) & 63);
        return;
      }
      if (dart.notNull(charCode) <= 65535) {
        this.writeByte((224 | charCode[dartx['>>']](12)) >>> 0);
        this.writeByte(128 | charCode[dartx['>>']](6) & 63);
        this.writeByte(128 | dart.notNull(charCode) & 63);
        return;
      }
      this.writeFourByteCharCode(charCode);
    }
    writeFourByteCharCode(charCode) {
      dart.assert(dart.notNull(charCode) <= 1114111);
      this.writeByte((240 | charCode[dartx['>>']](18)) >>> 0);
      this.writeByte(128 | charCode[dartx['>>']](12) & 63);
      this.writeByte(128 | charCode[dartx['>>']](6) & 63);
      this.writeByte(128 | dart.notNull(charCode) & 63);
    }
    writeByte(byte) {
      dart.assert(dart.notNull(byte) <= 255);
      if (this.index == this.buffer[dartx.length]) {
        dart.dcall(this.addChunk, this.buffer, 0, this.index);
        this.buffer = typed_data.Uint8List.new(this.bufferSize);
        this.index = 0;
      }
      this.buffer[dartx.set]((() => {
        let x = this.index;
        this.index = dart.notNull(x) + 1;
        return x;
      })(), byte);
    }
  };
  dart.setSignature(convert._JsonUtf8Stringifier, {
    constructors: () => ({_JsonUtf8Stringifier: [convert._JsonUtf8Stringifier, [dart.dynamic, core.int, core.Function]]}),
    methods: () => ({
      flush: [dart.void, []],
      writeNumber: [dart.void, [core.num]],
      writeAsciiString: [dart.void, [core.String]],
      writeString: [dart.void, [core.String]],
      writeStringSlice: [dart.void, [core.String, core.int, core.int]],
      writeCharCode: [dart.void, [core.int]],
      writeMultiByteCharCode: [dart.void, [core.int]],
      writeFourByteCharCode: [dart.void, [core.int]],
      writeByte: [dart.void, [core.int]]
    }),
    statics: () => ({stringify: [dart.void, [core.Object, core.List$(core.int), dart.functionType(dart.dynamic, [core.Object]), core.int, dart.functionType(dart.void, [typed_data.Uint8List, core.int, core.int])]]}),
    names: ['stringify']
  });
  convert._JsonUtf8StringifierPretty = class _JsonUtf8StringifierPretty extends dart.mixin(convert._JsonUtf8Stringifier, convert._JsonPrettyPrintMixin) {
    _JsonUtf8StringifierPretty(toEncodableFunction, indent, bufferSize, addChunk) {
      this.indent = indent;
      super._JsonUtf8Stringifier(toEncodableFunction, dart.as(bufferSize, core.int), dart.as(addChunk, core.Function));
    }
    writeIndentation(count) {
      let indent = this.indent;
      let indentLength = indent[dartx.length];
      if (indentLength == 1) {
        let char = indent[dartx.get](0);
        while (dart.notNull(count) > 0) {
          this.writeByte(char);
          count = dart.notNull(count) - 1;
        }
        return;
      }
      while (dart.notNull(count) > 0) {
        count = dart.notNull(count) - 1;
        let end = dart.notNull(this.index) + dart.notNull(indentLength);
        if (end <= dart.notNull(this.buffer[dartx.length])) {
          this.buffer[dartx.setRange](this.index, end, indent);
          this.index = end;
        } else {
          for (let i = 0; i < dart.notNull(indentLength); i++) {
            this.writeByte(indent[dartx.get](i));
          }
        }
      }
    }
  };
  dart.setSignature(convert._JsonUtf8StringifierPretty, {
    constructors: () => ({_JsonUtf8StringifierPretty: [convert._JsonUtf8StringifierPretty, [dart.dynamic, core.List$(core.int), dart.dynamic, dart.dynamic]]}),
    methods: () => ({writeIndentation: [dart.void, [core.int]]})
  });
  convert.Latin1Codec = class Latin1Codec extends convert.Encoding {
    Latin1Codec(opts) {
      let allowInvalid = opts && 'allowInvalid' in opts ? opts.allowInvalid : false;
      this[_allowInvalid] = allowInvalid;
      super.Encoding();
    }
    get name() {
      return "iso-8859-1";
    }
    decode(bytes, opts) {
      let allowInvalid = opts && 'allowInvalid' in opts ? opts.allowInvalid : null;
      if (allowInvalid == null) allowInvalid = this[_allowInvalid];
      if (dart.notNull(allowInvalid)) {
        return dart.const(new convert.Latin1Decoder({allowInvalid: true})).convert(bytes);
      } else {
        return dart.const(new convert.Latin1Decoder({allowInvalid: false})).convert(bytes);
      }
    }
    get encoder() {
      return dart.const(new convert.Latin1Encoder());
    }
    get decoder() {
      return dart.notNull(this[_allowInvalid]) ? dart.const(new convert.Latin1Decoder({allowInvalid: true})) : dart.const(new convert.Latin1Decoder({allowInvalid: false}));
    }
  };
  dart.setSignature(convert.Latin1Codec, {
    constructors: () => ({Latin1Codec: [convert.Latin1Codec, [], {allowInvalid: core.bool}]}),
    methods: () => ({decode: [core.String, [core.List$(core.int)], {allowInvalid: core.bool}]})
  });
  convert.LATIN1 = dart.const(new convert.Latin1Codec());
  convert._LATIN1_MASK = 255;
  convert.Latin1Encoder = class Latin1Encoder extends convert._UnicodeSubsetEncoder {
    Latin1Encoder() {
      super._UnicodeSubsetEncoder(convert._LATIN1_MASK);
    }
  };
  dart.setSignature(convert.Latin1Encoder, {
    constructors: () => ({Latin1Encoder: [convert.Latin1Encoder, []]})
  });
  convert.Latin1Decoder = class Latin1Decoder extends convert._UnicodeSubsetDecoder {
    Latin1Decoder(opts) {
      let allowInvalid = opts && 'allowInvalid' in opts ? opts.allowInvalid : false;
      super._UnicodeSubsetDecoder(allowInvalid, convert._LATIN1_MASK);
    }
    startChunkedConversion(sink) {
      let stringSink = null;
      if (dart.is(sink, convert.StringConversionSink)) {
        stringSink = sink;
      } else {
        stringSink = convert.StringConversionSink.from(sink);
      }
      if (!dart.notNull(this[_allowInvalid])) return new convert._Latin1DecoderSink(stringSink);
      return new convert._Latin1AllowInvalidDecoderSink(stringSink);
    }
  };
  dart.setSignature(convert.Latin1Decoder, {
    constructors: () => ({Latin1Decoder: [convert.Latin1Decoder, [], {allowInvalid: core.bool}]}),
    methods: () => ({startChunkedConversion: [convert.ByteConversionSink, [core.Sink$(core.String)]]})
  });
  const _addSliceToSink = Symbol('_addSliceToSink');
  convert._Latin1DecoderSink = class _Latin1DecoderSink extends convert.ByteConversionSinkBase {
    _Latin1DecoderSink(sink) {
      this[_sink$] = sink;
    }
    close() {
      this[_sink$].close();
      this[_sink$] = null;
    }
    add(source) {
      this.addSlice(source, 0, source[dartx.length], false);
    }
    [_addSliceToSink](source, start, end, isLast) {
      this[_sink$].add(core.String.fromCharCodes(source, start, end));
      if (dart.notNull(isLast)) this.close();
    }
    addSlice(source, start, end, isLast) {
      end = core.RangeError.checkValidRange(start, end, source[dartx.length]);
      if (start == end) return;
      if (!dart.is(source, typed_data.Uint8List)) {
        convert._Latin1DecoderSink._checkValidLatin1(source, start, end);
      }
      this[_addSliceToSink](source, start, end, isLast);
    }
    static _checkValidLatin1(source, start, end) {
      let mask = 0;
      for (let i = start; dart.notNull(i) < dart.notNull(end); i = dart.notNull(i) + 1) {
        mask = (dart.notNull(mask) | dart.notNull(source[dartx.get](i))) >>> 0;
      }
      if (dart.notNull(mask) >= 0 && dart.notNull(mask) <= dart.notNull(convert._LATIN1_MASK)) {
        return;
      }
      convert._Latin1DecoderSink._reportInvalidLatin1(source, start, end);
    }
    static _reportInvalidLatin1(source, start, end) {
      for (let i = start; dart.notNull(i) < dart.notNull(end); i = dart.notNull(i) + 1) {
        let char = source[dartx.get](i);
        if (dart.notNull(char) < 0 || dart.notNull(char) > dart.notNull(convert._LATIN1_MASK)) {
          dart.throw(new core.FormatException("Source contains non-Latin-1 characters.", source, i));
        }
      }
      dart.assert(false);
    }
  };
  dart.setSignature(convert._Latin1DecoderSink, {
    constructors: () => ({_Latin1DecoderSink: [convert._Latin1DecoderSink, [convert.StringConversionSink]]}),
    methods: () => ({
      close: [dart.void, []],
      add: [dart.void, [core.List$(core.int)]],
      [_addSliceToSink]: [dart.void, [core.List$(core.int), core.int, core.int, core.bool]]
    }),
    statics: () => ({
      _checkValidLatin1: [dart.void, [core.List$(core.int), core.int, core.int]],
      _reportInvalidLatin1: [dart.void, [core.List$(core.int), core.int, core.int]]
    }),
    names: ['_checkValidLatin1', '_reportInvalidLatin1']
  });
  convert._Latin1AllowInvalidDecoderSink = class _Latin1AllowInvalidDecoderSink extends convert._Latin1DecoderSink {
    _Latin1AllowInvalidDecoderSink(sink) {
      super._Latin1DecoderSink(sink);
    }
    addSlice(source, start, end, isLast) {
      core.RangeError.checkValidRange(start, end, source[dartx.length]);
      for (let i = start; dart.notNull(i) < dart.notNull(end); i = dart.notNull(i) + 1) {
        let char = source[dartx.get](i);
        if (dart.notNull(char) > dart.notNull(convert._LATIN1_MASK) || dart.notNull(char) < 0) {
          if (dart.notNull(i) > dart.notNull(start)) this[_addSliceToSink](source, start, i, false);
          this[_addSliceToSink](dart.const(dart.list([65533], core.int)), 0, 1, false);
          start = dart.notNull(i) + 1;
        }
      }
      if (dart.notNull(start) < dart.notNull(end)) {
        this[_addSliceToSink](source, start, end, isLast);
      }
      if (dart.notNull(isLast)) {
        this.close();
      }
    }
  };
  dart.setSignature(convert._Latin1AllowInvalidDecoderSink, {
    constructors: () => ({_Latin1AllowInvalidDecoderSink: [convert._Latin1AllowInvalidDecoderSink, [convert.StringConversionSink]]})
  });
  convert._LF = 10;
  convert._CR = 13;
  convert.LineSplitter = class LineSplitter extends convert.ChunkedConverter$(core.String, core.List$(core.String), core.String, core.String) {
    LineSplitter() {
      super.ChunkedConverter();
    }
    static split(lines, start, end) {
      return dart.syncStar(function*(lines, start, end) {
        if (start === void 0) start = 0;
        if (end === void 0) end = null;
        end = core.RangeError.checkValidRange(start, end, lines[dartx.length]);
        let sliceStart = start;
        let char = 0;
        for (let i = start; dart.notNull(i) < dart.notNull(end); i = dart.notNull(i) + 1) {
          let previousChar = char;
          char = lines[dartx.codeUnitAt](i);
          if (char != convert._CR) {
            if (char != convert._LF) continue;
            if (previousChar == convert._CR) {
              sliceStart = dart.notNull(i) + 1;
              continue;
            }
          }
          yield lines[dartx.substring](sliceStart, i);
          sliceStart = dart.notNull(i) + 1;
        }
        if (dart.notNull(sliceStart) < dart.notNull(end)) {
          yield lines[dartx.substring](sliceStart, end);
        }
      }, core.String, lines, start, end);
    }
    convert(data) {
      let lines = dart.list([], core.String);
      let end = data[dartx.length];
      let sliceStart = 0;
      let char = 0;
      for (let i = 0; i < dart.notNull(end); i++) {
        let previousChar = char;
        char = data[dartx.codeUnitAt](i);
        if (char != convert._CR) {
          if (char != convert._LF) continue;
          if (previousChar == convert._CR) {
            sliceStart = i + 1;
            continue;
          }
        }
        lines[dartx.add](data[dartx.substring](sliceStart, i));
        sliceStart = i + 1;
      }
      if (sliceStart < dart.notNull(end)) {
        lines[dartx.add](data[dartx.substring](sliceStart, end));
      }
      return lines;
    }
    startChunkedConversion(sink) {
      if (!dart.is(sink, convert.StringConversionSink)) {
        sink = convert.StringConversionSink.from(sink);
      }
      return new convert._LineSplitterSink(dart.as(sink, convert.StringConversionSink));
    }
  };
  dart.setSignature(convert.LineSplitter, {
    constructors: () => ({LineSplitter: [convert.LineSplitter, []]}),
    methods: () => ({
      convert: [core.List$(core.String), [core.String]],
      startChunkedConversion: [convert.StringConversionSink, [core.Sink$(core.String)]]
    }),
    statics: () => ({split: [core.Iterable$(core.String), [core.String], [core.int, core.int]]}),
    names: ['split']
  });
  const _carry = Symbol('_carry');
  const _skipLeadingLF = Symbol('_skipLeadingLF');
  const _addLines = Symbol('_addLines');
  convert._LineSplitterSink = class _LineSplitterSink extends convert.StringConversionSinkBase {
    _LineSplitterSink(sink) {
      this[_sink$] = sink;
      this[_carry] = null;
      this[_skipLeadingLF] = false;
    }
    addSlice(chunk, start, end, isLast) {
      end = core.RangeError.checkValidRange(start, end, chunk[dartx.length]);
      if (dart.notNull(start) >= dart.notNull(end)) {
        if (dart.notNull(isLast)) this.close();
        return;
      }
      if (this[_carry] != null) {
        dart.assert(!dart.notNull(this[_skipLeadingLF]));
        chunk = dart.notNull(this[_carry]) + dart.notNull(chunk[dartx.substring](start, end));
        start = 0;
        end = chunk[dartx.length];
        this[_carry] = null;
      } else if (dart.notNull(this[_skipLeadingLF])) {
        if (chunk[dartx.codeUnitAt](start) == convert._LF) {
          start = dart.notNull(start) + 1;
        }
        this[_skipLeadingLF] = false;
      }
      this[_addLines](chunk, start, end);
      if (dart.notNull(isLast)) this.close();
    }
    close() {
      if (this[_carry] != null) {
        this[_sink$].add(this[_carry]);
        this[_carry] = null;
      }
      this[_sink$].close();
    }
    [_addLines](lines, start, end) {
      let sliceStart = start;
      let char = 0;
      for (let i = start; dart.notNull(i) < dart.notNull(end); i = dart.notNull(i) + 1) {
        let previousChar = char;
        char = lines[dartx.codeUnitAt](i);
        if (char != convert._CR) {
          if (char != convert._LF) continue;
          if (previousChar == convert._CR) {
            sliceStart = dart.notNull(i) + 1;
            continue;
          }
        }
        this[_sink$].add(lines[dartx.substring](sliceStart, i));
        sliceStart = dart.notNull(i) + 1;
      }
      if (dart.notNull(sliceStart) < dart.notNull(end)) {
        this[_carry] = lines[dartx.substring](sliceStart, end);
      } else {
        this[_skipLeadingLF] = char == convert._CR;
      }
    }
  };
  dart.setSignature(convert._LineSplitterSink, {
    constructors: () => ({_LineSplitterSink: [convert._LineSplitterSink, [convert.StringConversionSink]]}),
    methods: () => ({
      addSlice: [dart.void, [core.String, core.int, core.int, core.bool]],
      close: [dart.void, []],
      [_addLines]: [dart.void, [core.String, core.int, core.int]]
    })
  });
  convert.StringConversionSink = class StringConversionSink extends convert.ChunkedConversionSink$(core.String) {
    StringConversionSink() {
      super.ChunkedConversionSink();
    }
    static withCallback(callback) {
      return new convert._StringCallbackSink(callback);
    }
    static from(sink) {
      return new convert._StringAdapterSink(sink);
    }
    static fromStringSink(sink) {
      return new convert._StringSinkConversionSink(sink);
    }
  };
  dart.setSignature(convert.StringConversionSink, {
    constructors: () => ({
      StringConversionSink: [convert.StringConversionSink, []],
      withCallback: [convert.StringConversionSink, [dart.functionType(dart.void, [core.String])]],
      from: [convert.StringConversionSink, [core.Sink$(core.String)]],
      fromStringSink: [convert.StringConversionSink, [core.StringSink]]
    })
  });
  core.StringSink = class StringSink extends core.Object {};
  convert.ClosableStringSink = class ClosableStringSink extends core.StringSink {
    static fromStringSink(sink, onClose) {
      return new convert._ClosableStringSink(sink, onClose);
    }
  };
  dart.setSignature(convert.ClosableStringSink, {
    constructors: () => ({fromStringSink: [convert.ClosableStringSink, [core.StringSink, dart.functionType(dart.void, [])]]})
  });
  convert._StringSinkCloseCallback = dart.typedef('_StringSinkCloseCallback', () => dart.functionType(dart.void, []));
  convert._ClosableStringSink = class _ClosableStringSink extends core.Object {
    _ClosableStringSink(sink, callback) {
      this[_sink$] = sink;
      this[_callback] = callback;
    }
    close() {
      this[_callback]();
    }
    writeCharCode(charCode) {
      this[_sink$].writeCharCode(charCode);
    }
    write(o) {
      this[_sink$].write(o);
    }
    writeln(o) {
      if (o === void 0) o = "";
      this[_sink$].writeln(o);
    }
    writeAll(objects, separator) {
      if (separator === void 0) separator = "";
      this[_sink$].writeAll(objects, separator);
    }
  };
  convert._ClosableStringSink[dart.implements] = () => [convert.ClosableStringSink];
  dart.setSignature(convert._ClosableStringSink, {
    constructors: () => ({_ClosableStringSink: [convert._ClosableStringSink, [core.StringSink, convert._StringSinkCloseCallback]]}),
    methods: () => ({
      close: [dart.void, []],
      writeCharCode: [dart.void, [core.int]],
      write: [dart.void, [core.Object]],
      writeln: [dart.void, [], [core.Object]],
      writeAll: [dart.void, [core.Iterable], [core.String]]
    })
  });
  const _flush = Symbol('_flush');
  convert._StringConversionSinkAsStringSinkAdapter = class _StringConversionSinkAsStringSinkAdapter extends core.Object {
    _StringConversionSinkAsStringSinkAdapter(chunkedSink) {
      this[_chunkedSink] = chunkedSink;
      this[_buffer] = new core.StringBuffer();
    }
    close() {
      if (dart.notNull(this[_buffer].isNotEmpty)) this[_flush]();
      this[_chunkedSink].close();
    }
    writeCharCode(charCode) {
      this[_buffer].writeCharCode(charCode);
      if (dart.notNull(this[_buffer].length) > dart.notNull(convert._StringConversionSinkAsStringSinkAdapter._MIN_STRING_SIZE)) this[_flush]();
    }
    write(o) {
      if (dart.notNull(this[_buffer].isNotEmpty)) this[_flush]();
      this[_chunkedSink].add(dart.toString(o));
    }
    writeln(o) {
      if (o === void 0) o = "";
      this[_buffer].writeln(o);
      if (dart.notNull(this[_buffer].length) > dart.notNull(convert._StringConversionSinkAsStringSinkAdapter._MIN_STRING_SIZE)) this[_flush]();
    }
    writeAll(objects, separator) {
      if (separator === void 0) separator = "";
      if (dart.notNull(this[_buffer].isNotEmpty)) this[_flush]();
      let iterator = objects[dartx.iterator];
      if (!dart.notNull(iterator.moveNext())) return;
      if (dart.notNull(separator[dartx.isEmpty])) {
        do {
          this[_chunkedSink].add(dart.toString(iterator.current));
        } while (dart.notNull(iterator.moveNext()));
      } else {
        this[_chunkedSink].add(dart.toString(iterator.current));
        while (dart.notNull(iterator.moveNext())) {
          this.write(separator);
          this[_chunkedSink].add(dart.toString(iterator.current));
        }
      }
    }
    [_flush]() {
      let accumulated = dart.toString(this[_buffer]);
      this[_buffer].clear();
      this[_chunkedSink].add(accumulated);
    }
  };
  convert._StringConversionSinkAsStringSinkAdapter[dart.implements] = () => [convert.ClosableStringSink];
  dart.setSignature(convert._StringConversionSinkAsStringSinkAdapter, {
    constructors: () => ({_StringConversionSinkAsStringSinkAdapter: [convert._StringConversionSinkAsStringSinkAdapter, [convert.StringConversionSink]]}),
    methods: () => ({
      close: [dart.void, []],
      writeCharCode: [dart.void, [core.int]],
      write: [dart.void, [core.Object]],
      writeln: [dart.void, [], [core.Object]],
      writeAll: [dart.void, [core.Iterable], [core.String]],
      [_flush]: [dart.void, []]
    })
  });
  convert._StringConversionSinkAsStringSinkAdapter._MIN_STRING_SIZE = 16;
  convert._StringCallbackSink = class _StringCallbackSink extends convert._StringSinkConversionSink {
    _StringCallbackSink(callback) {
      this[_callback] = callback;
      super._StringSinkConversionSink(new core.StringBuffer());
    }
    close() {
      let buffer = dart.as(this[_stringSink], core.StringBuffer);
      let accumulated = dart.toString(buffer);
      buffer.clear();
      this[_callback](accumulated);
    }
    asUtf8Sink(allowMalformed) {
      return new convert._Utf8StringSinkAdapter(this, this[_stringSink], allowMalformed);
    }
  };
  dart.setSignature(convert._StringCallbackSink, {
    constructors: () => ({_StringCallbackSink: [convert._StringCallbackSink, [convert._ChunkedConversionCallback$(core.String)]]})
  });
  convert._StringAdapterSink = class _StringAdapterSink extends convert.StringConversionSinkBase {
    _StringAdapterSink(sink) {
      this[_sink$] = sink;
    }
    add(str) {
      this[_sink$].add(str);
    }
    addSlice(str, start, end, isLast) {
      if (start == 0 && end == str[dartx.length]) {
        this.add(str);
      } else {
        this.add(str[dartx.substring](start, end));
      }
      if (dart.notNull(isLast)) this.close();
    }
    close() {
      this[_sink$].close();
    }
  };
  dart.setSignature(convert._StringAdapterSink, {
    constructors: () => ({_StringAdapterSink: [convert._StringAdapterSink, [core.Sink$(core.String)]]}),
    methods: () => ({
      addSlice: [dart.void, [core.String, core.int, core.int, core.bool]],
      close: [dart.void, []]
    })
  });
  convert._Utf8StringSinkAdapter = class _Utf8StringSinkAdapter extends convert.ByteConversionSink {
    _Utf8StringSinkAdapter(sink, stringSink, allowMalformed) {
      this[_sink$] = sink;
      this[_decoder] = new convert._Utf8Decoder(stringSink, allowMalformed);
      super.ByteConversionSink();
    }
    close() {
      this[_decoder].close();
      if (this[_sink$] != null) this[_sink$].close();
    }
    add(chunk) {
      this.addSlice(chunk, 0, chunk[dartx.length], false);
    }
    addSlice(codeUnits, startIndex, endIndex, isLast) {
      this[_decoder].convert(codeUnits, startIndex, endIndex);
      if (dart.notNull(isLast)) this.close();
    }
  };
  dart.setSignature(convert._Utf8StringSinkAdapter, {
    constructors: () => ({_Utf8StringSinkAdapter: [convert._Utf8StringSinkAdapter, [core.Sink, core.StringSink, core.bool]]}),
    methods: () => ({
      close: [dart.void, []],
      add: [dart.void, [core.List$(core.int)]],
      addSlice: [dart.void, [core.List$(core.int), core.int, core.int, core.bool]]
    })
  });
  convert._Utf8ConversionSink = class _Utf8ConversionSink extends convert.ByteConversionSink {
    _Utf8ConversionSink(sink, allowMalformed) {
      this._(sink, new core.StringBuffer(), allowMalformed);
    }
    _(chunkedSink, stringBuffer, allowMalformed) {
      this[_chunkedSink] = chunkedSink;
      this[_decoder] = new convert._Utf8Decoder(stringBuffer, allowMalformed);
      this[_buffer] = stringBuffer;
      super.ByteConversionSink();
    }
    close() {
      this[_decoder].close();
      if (dart.notNull(this[_buffer].isNotEmpty)) {
        let accumulated = dart.toString(this[_buffer]);
        this[_buffer].clear();
        this[_chunkedSink].addSlice(accumulated, 0, accumulated[dartx.length], true);
      } else {
        this[_chunkedSink].close();
      }
    }
    add(chunk) {
      this.addSlice(chunk, 0, chunk[dartx.length], false);
    }
    addSlice(chunk, startIndex, endIndex, isLast) {
      this[_decoder].convert(chunk, startIndex, endIndex);
      if (dart.notNull(this[_buffer].isNotEmpty)) {
        let accumulated = dart.toString(this[_buffer]);
        this[_chunkedSink].addSlice(accumulated, 0, accumulated[dartx.length], isLast);
        this[_buffer].clear();
        return;
      }
      if (dart.notNull(isLast)) this.close();
    }
  };
  dart.defineNamedConstructor(convert._Utf8ConversionSink, '_');
  dart.setSignature(convert._Utf8ConversionSink, {
    constructors: () => ({
      _Utf8ConversionSink: [convert._Utf8ConversionSink, [convert.StringConversionSink, core.bool]],
      _: [convert._Utf8ConversionSink, [convert.StringConversionSink, core.StringBuffer, core.bool]]
    }),
    methods: () => ({
      close: [dart.void, []],
      add: [dart.void, [core.List$(core.int)]],
      addSlice: [dart.void, [core.List$(core.int), core.int, core.int, core.bool]]
    })
  });
  convert.UNICODE_REPLACEMENT_CHARACTER_RUNE = 65533;
  convert.UNICODE_BOM_CHARACTER_RUNE = 65279;
  const _allowMalformed = Symbol('_allowMalformed');
  convert.Utf8Codec = class Utf8Codec extends convert.Encoding {
    Utf8Codec(opts) {
      let allowMalformed = opts && 'allowMalformed' in opts ? opts.allowMalformed : false;
      this[_allowMalformed] = allowMalformed;
      super.Encoding();
    }
    get name() {
      return "utf-8";
    }
    decode(codeUnits, opts) {
      let allowMalformed = opts && 'allowMalformed' in opts ? opts.allowMalformed : null;
      if (allowMalformed == null) allowMalformed = this[_allowMalformed];
      return new convert.Utf8Decoder({allowMalformed: allowMalformed}).convert(codeUnits);
    }
    get encoder() {
      return dart.const(new convert.Utf8Encoder());
    }
    get decoder() {
      return new convert.Utf8Decoder({allowMalformed: this[_allowMalformed]});
    }
  };
  dart.setSignature(convert.Utf8Codec, {
    constructors: () => ({Utf8Codec: [convert.Utf8Codec, [], {allowMalformed: core.bool}]}),
    methods: () => ({decode: [core.String, [core.List$(core.int)], {allowMalformed: core.bool}]})
  });
  convert.UTF8 = dart.const(new convert.Utf8Codec());
  const _fillBuffer = Symbol('_fillBuffer');
  const _writeSurrogate = Symbol('_writeSurrogate');
  convert.Utf8Encoder = class Utf8Encoder extends convert.ChunkedConverter$(core.String, core.List$(core.int), core.String, core.List$(core.int)) {
    Utf8Encoder() {
      super.ChunkedConverter();
    }
    convert(string, start, end) {
      if (start === void 0) start = 0;
      if (end === void 0) end = null;
      let stringLength = string[dartx.length];
      core.RangeError.checkValidRange(start, end, stringLength);
      if (end == null) end = stringLength;
      let length = dart.notNull(end) - dart.notNull(start);
      if (length == 0) return typed_data.Uint8List.new(0);
      let encoder = new convert._Utf8Encoder.withBufferSize(length * 3);
      let endPosition = encoder[_fillBuffer](string, start, end);
      dart.assert(dart.notNull(endPosition) >= dart.notNull(end) - 1);
      if (endPosition != end) {
        let lastCodeUnit = string[dartx.codeUnitAt](dart.notNull(end) - 1);
        dart.assert(convert._isLeadSurrogate(lastCodeUnit));
        let wasCombined = encoder[_writeSurrogate](lastCodeUnit, 0);
        dart.assert(!dart.notNull(wasCombined));
      }
      return encoder[_buffer][dartx.sublist](0, encoder[_bufferIndex]);
    }
    startChunkedConversion(sink) {
      if (!dart.is(sink, convert.ByteConversionSink)) {
        sink = convert.ByteConversionSink.from(sink);
      }
      return new convert._Utf8EncoderSink(dart.as(sink, convert.ByteConversionSink));
    }
    bind(stream) {
      return super.bind(stream);
    }
  };
  dart.setSignature(convert.Utf8Encoder, {
    constructors: () => ({Utf8Encoder: [convert.Utf8Encoder, []]}),
    methods: () => ({
      convert: [core.List$(core.int), [core.String], [core.int, core.int]],
      startChunkedConversion: [convert.StringConversionSink, [core.Sink$(core.List$(core.int))]],
      bind: [async.Stream$(core.List$(core.int)), [async.Stream$(core.String)]]
    })
  });
  convert._Utf8Encoder = class _Utf8Encoder extends core.Object {
    _Utf8Encoder() {
      this.withBufferSize(convert._Utf8Encoder._DEFAULT_BYTE_BUFFER_SIZE);
    }
    withBufferSize(bufferSize) {
      this[_buffer] = convert._Utf8Encoder._createBuffer(bufferSize);
      this[_carry] = 0;
      this[_bufferIndex] = 0;
    }
    static _createBuffer(size) {
      return typed_data.Uint8List.new(size);
    }
    [_writeSurrogate](leadingSurrogate, nextCodeUnit) {
      if (dart.notNull(convert._isTailSurrogate(nextCodeUnit))) {
        let rune = convert._combineSurrogatePair(leadingSurrogate, nextCodeUnit);
        dart.assert(dart.notNull(rune) > dart.notNull(convert._THREE_BYTE_LIMIT));
        dart.assert(dart.notNull(rune) <= dart.notNull(convert._FOUR_BYTE_LIMIT));
        this[_buffer][dartx.set]((() => {
          let x = this[_bufferIndex];
          this[_bufferIndex] = dart.notNull(x) + 1;
          return x;
        })(), (240 | rune[dartx['>>']](18)) >>> 0);
        this[_buffer][dartx.set]((() => {
          let x = this[_bufferIndex];
          this[_bufferIndex] = dart.notNull(x) + 1;
          return x;
        })(), 128 | rune[dartx['>>']](12) & 63);
        this[_buffer][dartx.set]((() => {
          let x = this[_bufferIndex];
          this[_bufferIndex] = dart.notNull(x) + 1;
          return x;
        })(), 128 | rune[dartx['>>']](6) & 63);
        this[_buffer][dartx.set]((() => {
          let x = this[_bufferIndex];
          this[_bufferIndex] = dart.notNull(x) + 1;
          return x;
        })(), 128 | dart.notNull(rune) & 63);
        return true;
      } else {
        this[_buffer][dartx.set]((() => {
          let x = this[_bufferIndex];
          this[_bufferIndex] = dart.notNull(x) + 1;
          return x;
        })(), (224 | leadingSurrogate[dartx['>>']](12)) >>> 0);
        this[_buffer][dartx.set]((() => {
          let x = this[_bufferIndex];
          this[_bufferIndex] = dart.notNull(x) + 1;
          return x;
        })(), 128 | leadingSurrogate[dartx['>>']](6) & 63);
        this[_buffer][dartx.set]((() => {
          let x = this[_bufferIndex];
          this[_bufferIndex] = dart.notNull(x) + 1;
          return x;
        })(), 128 | dart.notNull(leadingSurrogate) & 63);
        return false;
      }
    }
    [_fillBuffer](str, start, end) {
      if (start != end && dart.notNull(convert._isLeadSurrogate(str[dartx.codeUnitAt](dart.notNull(end) - 1)))) {
        end = dart.notNull(end) - 1;
      }
      let stringIndex = null;
      for (stringIndex = start; dart.notNull(stringIndex) < dart.notNull(end); stringIndex = dart.notNull(stringIndex) + 1) {
        let codeUnit = str[dartx.codeUnitAt](stringIndex);
        if (dart.notNull(codeUnit) <= dart.notNull(convert._ONE_BYTE_LIMIT)) {
          if (dart.notNull(this[_bufferIndex]) >= dart.notNull(this[_buffer][dartx.length])) break;
          this[_buffer][dartx.set]((() => {
            let x = this[_bufferIndex];
            this[_bufferIndex] = dart.notNull(x) + 1;
            return x;
          })(), codeUnit);
        } else if (dart.notNull(convert._isLeadSurrogate(codeUnit))) {
          if (dart.notNull(this[_bufferIndex]) + 3 >= dart.notNull(this[_buffer][dartx.length])) break;
          let nextCodeUnit = str[dartx.codeUnitAt](dart.notNull(stringIndex) + 1);
          let wasCombined = this[_writeSurrogate](codeUnit, nextCodeUnit);
          if (dart.notNull(wasCombined)) {
            stringIndex = dart.notNull(stringIndex) + 1;
          }
        } else {
          let rune = codeUnit;
          if (dart.notNull(rune) <= dart.notNull(convert._TWO_BYTE_LIMIT)) {
            if (dart.notNull(this[_bufferIndex]) + 1 >= dart.notNull(this[_buffer][dartx.length])) break;
            this[_buffer][dartx.set]((() => {
              let x = this[_bufferIndex];
              this[_bufferIndex] = dart.notNull(x) + 1;
              return x;
            })(), (192 | rune[dartx['>>']](6)) >>> 0);
            this[_buffer][dartx.set]((() => {
              let x = this[_bufferIndex];
              this[_bufferIndex] = dart.notNull(x) + 1;
              return x;
            })(), 128 | dart.notNull(rune) & 63);
          } else {
            dart.assert(dart.notNull(rune) <= dart.notNull(convert._THREE_BYTE_LIMIT));
            if (dart.notNull(this[_bufferIndex]) + 2 >= dart.notNull(this[_buffer][dartx.length])) break;
            this[_buffer][dartx.set]((() => {
              let x = this[_bufferIndex];
              this[_bufferIndex] = dart.notNull(x) + 1;
              return x;
            })(), (224 | rune[dartx['>>']](12)) >>> 0);
            this[_buffer][dartx.set]((() => {
              let x = this[_bufferIndex];
              this[_bufferIndex] = dart.notNull(x) + 1;
              return x;
            })(), 128 | rune[dartx['>>']](6) & 63);
            this[_buffer][dartx.set]((() => {
              let x = this[_bufferIndex];
              this[_bufferIndex] = dart.notNull(x) + 1;
              return x;
            })(), 128 | dart.notNull(rune) & 63);
          }
        }
      }
      return stringIndex;
    }
  };
  dart.defineNamedConstructor(convert._Utf8Encoder, 'withBufferSize');
  dart.setSignature(convert._Utf8Encoder, {
    constructors: () => ({
      _Utf8Encoder: [convert._Utf8Encoder, []],
      withBufferSize: [convert._Utf8Encoder, [core.int]]
    }),
    methods: () => ({
      [_writeSurrogate]: [core.bool, [core.int, core.int]],
      [_fillBuffer]: [core.int, [core.String, core.int, core.int]]
    }),
    statics: () => ({_createBuffer: [core.List$(core.int), [core.int]]}),
    names: ['_createBuffer']
  });
  convert._Utf8Encoder._DEFAULT_BYTE_BUFFER_SIZE = 1024;
  convert._Utf8EncoderSink = class _Utf8EncoderSink extends dart.mixin(convert._Utf8Encoder, convert.StringConversionSinkMixin) {
    _Utf8EncoderSink(sink) {
      this[_sink$] = sink;
      super._Utf8Encoder();
    }
    close() {
      if (this[_carry] != 0) {
        this.addSlice("", 0, 0, true);
        return;
      }
      this[_sink$].close();
    }
    addSlice(str, start, end, isLast) {
      this[_bufferIndex] = 0;
      if (start == end && !dart.notNull(isLast)) {
        return;
      }
      if (this[_carry] != 0) {
        let nextCodeUnit = 0;
        if (start != end) {
          nextCodeUnit = str[dartx.codeUnitAt](start);
        } else {
          dart.assert(isLast);
        }
        let wasCombined = this[_writeSurrogate](this[_carry], nextCodeUnit);
        dart.assert(!dart.notNull(wasCombined) || start != end);
        if (dart.notNull(wasCombined)) {
          start = dart.notNull(start) + 1;
        }
        this[_carry] = 0;
      }
      do {
        start = this[_fillBuffer](str, start, end);
        let isLastSlice = dart.notNull(isLast) && start == end;
        if (start == dart.notNull(end) - 1 && dart.notNull(convert._isLeadSurrogate(str[dartx.codeUnitAt](start)))) {
          if (dart.notNull(isLast) && dart.notNull(this[_bufferIndex]) < dart.notNull(this[_buffer][dartx.length]) - 3) {
            let hasBeenCombined = this[_writeSurrogate](str[dartx.codeUnitAt](start), 0);
            dart.assert(!dart.notNull(hasBeenCombined));
          } else {
            this[_carry] = str[dartx.codeUnitAt](start);
          }
          start = dart.notNull(start) + 1;
        }
        this[_sink$].addSlice(this[_buffer], 0, this[_bufferIndex], isLastSlice);
        this[_bufferIndex] = 0;
      } while (dart.notNull(start) < dart.notNull(end));
      if (dart.notNull(isLast)) this.close();
    }
  };
  dart.setSignature(convert._Utf8EncoderSink, {
    constructors: () => ({_Utf8EncoderSink: [convert._Utf8EncoderSink, [convert.ByteConversionSink]]}),
    methods: () => ({
      close: [dart.void, []],
      addSlice: [dart.void, [core.String, core.int, core.int, core.bool]]
    })
  });
  convert.Utf8Decoder = class Utf8Decoder extends convert.ChunkedConverter$(core.List$(core.int), core.String, core.List$(core.int), core.String) {
    Utf8Decoder(opts) {
      let allowMalformed = opts && 'allowMalformed' in opts ? opts.allowMalformed : false;
      this[_allowMalformed] = allowMalformed;
      super.ChunkedConverter();
    }
    convert(codeUnits, start, end) {
      if (start === void 0) start = 0;
      if (end === void 0) end = null;
      let result = convert.Utf8Decoder._convertIntercepted(this[_allowMalformed], codeUnits, start, end);
      if (result != null) {
        return result;
      }
      let length = codeUnits[dartx.length];
      core.RangeError.checkValidRange(start, end, length);
      if (end == null) end = length;
      let buffer = new core.StringBuffer();
      let decoder = new convert._Utf8Decoder(buffer, this[_allowMalformed]);
      decoder.convert(codeUnits, start, end);
      decoder.close();
      return buffer.toString();
    }
    startChunkedConversion(sink) {
      let stringSink = null;
      if (dart.is(sink, convert.StringConversionSink)) {
        stringSink = sink;
      } else {
        stringSink = convert.StringConversionSink.from(sink);
      }
      return stringSink.asUtf8Sink(this[_allowMalformed]);
    }
    bind(stream) {
      return super.bind(stream);
    }
    fuse(next) {
      return super.fuse(next);
    }
    static _convertIntercepted(allowMalformed, codeUnits, start, end) {
      return null;
    }
  };
  dart.setSignature(convert.Utf8Decoder, {
    constructors: () => ({Utf8Decoder: [convert.Utf8Decoder, [], {allowMalformed: core.bool}]}),
    methods: () => ({
      convert: [core.String, [core.List$(core.int)], [core.int, core.int]],
      startChunkedConversion: [convert.ByteConversionSink, [core.Sink$(core.String)]],
      bind: [async.Stream$(core.String), [async.Stream$(core.List$(core.int))]],
      fuse: [convert.Converter$(core.List$(core.int), dart.dynamic), [convert.Converter$(core.String, dart.dynamic)]]
    }),
    statics: () => ({_convertIntercepted: [core.String, [core.bool, core.List$(core.int), core.int, core.int]]}),
    names: ['_convertIntercepted']
  });
  convert._ONE_BYTE_LIMIT = 127;
  convert._TWO_BYTE_LIMIT = 2047;
  convert._THREE_BYTE_LIMIT = 65535;
  convert._FOUR_BYTE_LIMIT = 1114111;
  convert._SURROGATE_MASK = 63488;
  convert._SURROGATE_TAG_MASK = 64512;
  convert._SURROGATE_VALUE_MASK = 1023;
  convert._LEAD_SURROGATE_MIN = 55296;
  convert._TAIL_SURROGATE_MIN = 56320;
  convert._isLeadSurrogate = function(codeUnit) {
    return (dart.notNull(codeUnit) & dart.notNull(convert._SURROGATE_TAG_MASK)) >>> 0 == convert._LEAD_SURROGATE_MIN;
  };
  dart.lazyFn(convert._isLeadSurrogate, () => [core.bool, [core.int]]);
  convert._isTailSurrogate = function(codeUnit) {
    return (dart.notNull(codeUnit) & dart.notNull(convert._SURROGATE_TAG_MASK)) >>> 0 == convert._TAIL_SURROGATE_MIN;
  };
  dart.lazyFn(convert._isTailSurrogate, () => [core.bool, [core.int]]);
  convert._combineSurrogatePair = function(lead, tail) {
    return (65536 + ((dart.notNull(lead) & dart.notNull(convert._SURROGATE_VALUE_MASK)) >>> 0 << 10 >>> 0) | dart.notNull(tail) & dart.notNull(convert._SURROGATE_VALUE_MASK)) >>> 0;
  };
  dart.fn(convert._combineSurrogatePair, core.int, [core.int, core.int]);
  const _isFirstCharacter = Symbol('_isFirstCharacter');
  const _value$ = Symbol('_value');
  const _expectedUnits = Symbol('_expectedUnits');
  const _extraUnits = Symbol('_extraUnits');
  convert._Utf8Decoder = class _Utf8Decoder extends core.Object {
    _Utf8Decoder(stringSink, allowMalformed) {
      this[_stringSink] = stringSink;
      this[_allowMalformed] = allowMalformed;
      this[_isFirstCharacter] = true;
      this[_value$] = 0;
      this[_expectedUnits] = 0;
      this[_extraUnits] = 0;
    }
    get hasPartialInput() {
      return dart.notNull(this[_expectedUnits]) > 0;
    }
    close() {
      this.flush();
    }
    flush() {
      if (dart.notNull(this.hasPartialInput)) {
        if (!dart.notNull(this[_allowMalformed])) {
          dart.throw(new core.FormatException("Unfinished UTF-8 octet sequence"));
        }
        this[_stringSink].writeCharCode(convert.UNICODE_REPLACEMENT_CHARACTER_RUNE);
        this[_value$] = 0;
        this[_expectedUnits] = 0;
        this[_extraUnits] = 0;
      }
    }
    convert(codeUnits, startIndex, endIndex) {
      let value = this[_value$];
      let expectedUnits = this[_expectedUnits];
      let extraUnits = this[_extraUnits];
      this[_value$] = 0;
      this[_expectedUnits] = 0;
      this[_extraUnits] = 0;
      function scanOneByteCharacters(units, from) {
        let to = endIndex;
        let mask = convert._ONE_BYTE_LIMIT;
        for (let i = from; dart.notNull(i) < dart.notNull(to); i = dart.notNull(i) + 1) {
          let unit = dart.dindex(units, i);
          if (!dart.equals(dart.dsend(unit, '&', mask), unit)) return dart.notNull(i) - dart.notNull(from);
        }
        return dart.notNull(to) - dart.notNull(from);
      }
      dart.fn(scanOneByteCharacters, core.int, [dart.dynamic, core.int]);
      const addSingleBytes = (function(from, to) {
        dart.assert(dart.notNull(from) >= dart.notNull(startIndex) && dart.notNull(from) <= dart.notNull(endIndex));
        dart.assert(dart.notNull(to) >= dart.notNull(startIndex) && dart.notNull(to) <= dart.notNull(endIndex));
        this[_stringSink].write(core.String.fromCharCodes(codeUnits, from, to));
      }).bind(this);
      dart.fn(addSingleBytes, dart.void, [core.int, core.int]);
      let i = startIndex;
      loop:
        while (true) {
          multibyte:
            if (dart.notNull(expectedUnits) > 0) {
              do {
                if (i == endIndex) {
                  break loop;
                }
                let unit = codeUnits[dartx.get](i);
                if ((dart.notNull(unit) & 192) != 128) {
                  expectedUnits = 0;
                  if (!dart.notNull(this[_allowMalformed])) {
                    dart.throw(new core.FormatException(`Bad UTF-8 encoding 0x${unit[dartx.toRadixString](16)}`));
                  }
                  this[_isFirstCharacter] = false;
                  this[_stringSink].writeCharCode(convert.UNICODE_REPLACEMENT_CHARACTER_RUNE);
                  break multibyte;
                } else {
                  value = (dart.notNull(value) << 6 | dart.notNull(unit) & 63) >>> 0;
                  expectedUnits = dart.notNull(expectedUnits) - 1;
                  i = dart.notNull(i) + 1;
                }
              } while (dart.notNull(expectedUnits) > 0);
              if (dart.notNull(value) <= dart.notNull(convert._Utf8Decoder._LIMITS[dartx.get](dart.notNull(extraUnits) - 1))) {
                if (!dart.notNull(this[_allowMalformed])) {
                  dart.throw(new core.FormatException(`Overlong encoding of 0x${value[dartx.toRadixString](16)}`));
                }
                expectedUnits = extraUnits = 0;
                value = convert.UNICODE_REPLACEMENT_CHARACTER_RUNE;
              }
              if (dart.notNull(value) > dart.notNull(convert._FOUR_BYTE_LIMIT)) {
                if (!dart.notNull(this[_allowMalformed])) {
                  dart.throw(new core.FormatException("Character outside valid Unicode range: " + `0x${value[dartx.toRadixString](16)}`));
                }
                value = convert.UNICODE_REPLACEMENT_CHARACTER_RUNE;
              }
              if (!dart.notNull(this[_isFirstCharacter]) || value != convert.UNICODE_BOM_CHARACTER_RUNE) {
                this[_stringSink].writeCharCode(value);
              }
              this[_isFirstCharacter] = false;
            }
          while (dart.notNull(i) < dart.notNull(endIndex)) {
            let oneBytes = scanOneByteCharacters(codeUnits, i);
            if (dart.notNull(oneBytes) > 0) {
              this[_isFirstCharacter] = false;
              addSingleBytes(i, dart.notNull(i) + dart.notNull(oneBytes));
              i = dart.notNull(i) + dart.notNull(oneBytes);
              if (i == endIndex) break;
            }
            let unit = codeUnits[dartx.get]((() => {
              let x = i;
              i = dart.notNull(x) + 1;
              return x;
            })());
            if (dart.notNull(unit) < 0) {
              if (!dart.notNull(this[_allowMalformed])) {
                dart.throw(new core.FormatException(`Negative UTF-8 code unit: -0x${(-dart.notNull(unit))[dartx.toRadixString](16)}`));
              }
              this[_stringSink].writeCharCode(convert.UNICODE_REPLACEMENT_CHARACTER_RUNE);
            } else {
              dart.assert(dart.notNull(unit) > dart.notNull(convert._ONE_BYTE_LIMIT));
              if ((dart.notNull(unit) & 224) == 192) {
                value = dart.notNull(unit) & 31;
                expectedUnits = extraUnits = 1;
                continue loop;
              }
              if ((dart.notNull(unit) & 240) == 224) {
                value = dart.notNull(unit) & 15;
                expectedUnits = extraUnits = 2;
                continue loop;
              }
              if ((dart.notNull(unit) & 248) == 240 && dart.notNull(unit) < 245) {
                value = dart.notNull(unit) & 7;
                expectedUnits = extraUnits = 3;
                continue loop;
              }
              if (!dart.notNull(this[_allowMalformed])) {
                dart.throw(new core.FormatException(`Bad UTF-8 encoding 0x${unit[dartx.toRadixString](16)}`));
              }
              value = convert.UNICODE_REPLACEMENT_CHARACTER_RUNE;
              expectedUnits = extraUnits = 0;
              this[_isFirstCharacter] = false;
              this[_stringSink].writeCharCode(value);
            }
          }
          break loop;
        }
      if (dart.notNull(expectedUnits) > 0) {
        this[_value$] = value;
        this[_expectedUnits] = expectedUnits;
        this[_extraUnits] = extraUnits;
      }
    }
  };
  dart.setSignature(convert._Utf8Decoder, {
    constructors: () => ({_Utf8Decoder: [convert._Utf8Decoder, [core.StringSink, core.bool]]}),
    methods: () => ({
      close: [dart.void, []],
      flush: [dart.void, []],
      convert: [dart.void, [core.List$(core.int), core.int, core.int]]
    })
  });
  convert._Utf8Decoder._LIMITS = dart.const(dart.list([convert._ONE_BYTE_LIMIT, convert._TWO_BYTE_LIMIT, convert._THREE_BYTE_LIMIT, convert._FOUR_BYTE_LIMIT], core.int));
  core._symbolToString = function(symbol) {
    return _internal.Symbol.getName(dart.as(symbol, _internal.Symbol));
  };
  dart.lazyFn(core._symbolToString, () => [core.String, [core.Symbol]]);
  core.Deprecated = class Deprecated extends core.Object {
    Deprecated(expires) {
      this.expires = expires;
    }
    toString() {
      return `Deprecated feature. Will be removed ${this.expires}`;
    }
  };
  dart.setSignature(core.Deprecated, {
    constructors: () => ({Deprecated: [core.Deprecated, [core.String]]})
  });
  core._Override = class _Override extends core.Object {
    _Override() {
    }
  };
  dart.setSignature(core._Override, {
    constructors: () => ({_Override: [core._Override, []]})
  });
  core.deprecated = dart.const(new core.Deprecated("next release"));
  core.override = dart.const(new core._Override());
  core._Proxy = class _Proxy extends core.Object {
    _Proxy() {
    }
  };
  dart.setSignature(core._Proxy, {
    constructors: () => ({_Proxy: [core._Proxy, []]})
  });
  core.proxy = dart.const(new core._Proxy());
  dart.defineExtensionNames([
    'toString'
  ]);
  core.bool = class bool extends core.Object {
    static fromEnvironment(name, opts) {
      let defaultValue = opts && 'defaultValue' in opts ? opts.defaultValue : false;
      dart.throw(new core.UnsupportedError('bool.fromEnvironment can only be used as a const constructor'));
    }
    [dartx.toString]() {
      return this ? "true" : "false";
    }
  };
  dart.setSignature(core.bool, {
    constructors: () => ({fromEnvironment: [core.bool, [core.String], {defaultValue: core.bool}]})
  });
  core.Comparator$ = dart.generic(T => {
    const Comparator = dart.typedef('Comparator', () => dart.functionType(core.int, [T, T]));
    return Comparator;
  });
  core.Comparator = core.Comparator$();
  core.Comparable$ = dart.generic(T => {
    class Comparable extends core.Object {
      static compare(a, b) {
        return a[dartx.compareTo](b);
      }
    }
    dart.setSignature(Comparable, {
      statics: () => ({compare: [core.int, [core.Comparable, core.Comparable]]}),
      names: ['compare']
    });
    return Comparable;
  });
  core.Comparable = core.Comparable$();
  const _value$0 = Symbol('_value');
  core.DateTime = class DateTime extends core.Object {
    DateTime(year, month, day, hour, minute, second, millisecond, microsecond) {
      if (month === void 0) month = 1;
      if (day === void 0) day = 1;
      if (hour === void 0) hour = 0;
      if (minute === void 0) minute = 0;
      if (second === void 0) second = 0;
      if (millisecond === void 0) millisecond = 0;
      if (microsecond === void 0) microsecond = 0;
      this._internal(year, month, day, hour, minute, second, millisecond, microsecond, false);
    }
    utc(year, month, day, hour, minute, second, millisecond, microsecond) {
      if (month === void 0) month = 1;
      if (day === void 0) day = 1;
      if (hour === void 0) hour = 0;
      if (minute === void 0) minute = 0;
      if (second === void 0) second = 0;
      if (millisecond === void 0) millisecond = 0;
      if (microsecond === void 0) microsecond = 0;
      this._internal(year, month, day, hour, minute, second, millisecond, microsecond, true);
    }
    now() {
      this._now();
    }
    static parse(formattedString) {
      let re = core.RegExp.new('^([+-]?\\d{4,6})-?(\\d\\d)-?(\\d\\d)' + '(?:[ T](\\d\\d)(?::?(\\d\\d)(?::?(\\d\\d)(?:\\.(\\d{1,6}))?)?)?' + '( ?[zZ]| ?([-+])(\\d\\d)(?::?(\\d\\d))?)?)?$');
      let match = re.firstMatch(formattedString);
      if (match != null) {
        function parseIntOrZero(matched) {
          if (matched == null) return 0;
          return core.int.parse(matched);
        }
        dart.fn(parseIntOrZero, core.int, [core.String]);
        function parseMilliAndMicroseconds(matched) {
          if (matched == null) return 0;
          let length = matched[dartx.length];
          dart.assert(dart.notNull(length) >= 1);
          dart.assert(dart.notNull(length) <= 6);
          let result = 0;
          for (let i = 0; i < 6; i++) {
            result = result * 10;
            if (i < dart.notNull(matched[dartx.length])) {
              result = result + ((dart.notNull(matched[dartx.codeUnitAt](i)) ^ 48) >>> 0);
            }
          }
          return result;
        }
        dart.fn(parseMilliAndMicroseconds, core.int, [core.String]);
        let years = core.int.parse(match.get(1));
        let month = core.int.parse(match.get(2));
        let day = core.int.parse(match.get(3));
        let hour = parseIntOrZero(match.get(4));
        let minute = parseIntOrZero(match.get(5));
        let second = parseIntOrZero(match.get(6));
        let addOneMillisecond = false;
        let milliAndMicroseconds = parseMilliAndMicroseconds(match.get(7));
        let millisecond = (dart.notNull(milliAndMicroseconds) / dart.notNull(core.Duration.MICROSECONDS_PER_MILLISECOND))[dartx.truncate]();
        let microsecond = dart.asInt(milliAndMicroseconds[dartx.remainder](core.Duration.MICROSECONDS_PER_MILLISECOND));
        let isUtc = false;
        if (match.get(8) != null) {
          isUtc = true;
          if (match.get(9) != null) {
            let sign = match.get(9) == '-' ? -1 : 1;
            let hourDifference = core.int.parse(match.get(10));
            let minuteDifference = parseIntOrZero(match.get(11));
            minuteDifference = dart.notNull(minuteDifference) + 60 * dart.notNull(hourDifference);
            minute = dart.notNull(minute) - sign * dart.notNull(minuteDifference);
          }
        }
        let value = core.DateTime._brokenDownDateToValue(years, month, day, hour, minute, second, millisecond, microsecond, isUtc);
        if (value == null) {
          dart.throw(new core.FormatException("Time out of range", formattedString));
        }
        return new core.DateTime._withValue(value, {isUtc: isUtc});
      } else {
        dart.throw(new core.FormatException("Invalid date format", formattedString));
      }
    }
    fromMillisecondsSinceEpoch(millisecondsSinceEpoch, opts) {
      let isUtc = opts && 'isUtc' in opts ? opts.isUtc : false;
      this._withValue(millisecondsSinceEpoch, {isUtc: isUtc});
    }
    fromMicrosecondsSinceEpoch(microsecondsSinceEpoch, opts) {
      let isUtc = opts && 'isUtc' in opts ? opts.isUtc : false;
      this._withValue(core.DateTime._microsecondInRoundedMilliseconds(microsecondsSinceEpoch), {isUtc: isUtc});
    }
    _withValue(value, opts) {
      let isUtc = opts && 'isUtc' in opts ? opts.isUtc : null;
      this[_value$0] = value;
      this.isUtc = isUtc;
      if (dart.notNull(this.millisecondsSinceEpoch[dartx.abs]()) > dart.notNull(core.DateTime._MAX_MILLISECONDS_SINCE_EPOCH) || this.millisecondsSinceEpoch[dartx.abs]() == core.DateTime._MAX_MILLISECONDS_SINCE_EPOCH && this.microsecond != 0) {
        dart.throw(new core.ArgumentError(this.millisecondsSinceEpoch));
      }
      if (this.isUtc == null) dart.throw(new core.ArgumentError(this.isUtc));
    }
    ['=='](other) {
      if (!dart.is(other, core.DateTime)) return false;
      return dart.equals(this[_value$0], dart.dload(other, _value$0)) && dart.equals(this.isUtc, dart.dload(other, 'isUtc'));
    }
    isBefore(other) {
      return dart.notNull(this[_value$0]) < dart.notNull(other[_value$0]);
    }
    isAfter(other) {
      return dart.notNull(this[_value$0]) > dart.notNull(other[_value$0]);
    }
    isAtSameMomentAs(other) {
      return this[_value$0] == other[_value$0];
    }
    compareTo(other) {
      return this[_value$0][dartx.compareTo](other[_value$0]);
    }
    get hashCode() {
      return (dart.notNull(this[_value$0]) ^ this[_value$0][dartx['>>']](30)) & 1073741823;
    }
    toLocal() {
      if (dart.notNull(this.isUtc)) {
        return new core.DateTime._withValue(this[_value$0], {isUtc: false});
      }
      return this;
    }
    toUtc() {
      if (dart.notNull(this.isUtc)) return this;
      return new core.DateTime._withValue(this[_value$0], {isUtc: true});
    }
    static _fourDigits(n) {
      let absN = n[dartx.abs]();
      let sign = dart.notNull(n) < 0 ? "-" : "";
      if (dart.notNull(absN) >= 1000) return `${n}`;
      if (dart.notNull(absN) >= 100) return `${sign}0${absN}`;
      if (dart.notNull(absN) >= 10) return `${sign}00${absN}`;
      return `${sign}000${absN}`;
    }
    static _sixDigits(n) {
      dart.assert(dart.notNull(n) < -9999 || dart.notNull(n) > 9999);
      let absN = n[dartx.abs]();
      let sign = dart.notNull(n) < 0 ? "-" : "+";
      if (dart.notNull(absN) >= 100000) return `${sign}${absN}`;
      return `${sign}0${absN}`;
    }
    static _threeDigits(n) {
      if (dart.notNull(n) >= 100) return `${n}`;
      if (dart.notNull(n) >= 10) return `0${n}`;
      return `00${n}`;
    }
    static _twoDigits(n) {
      if (dart.notNull(n) >= 10) return `${n}`;
      return `0${n}`;
    }
    toString() {
      let y = core.DateTime._fourDigits(this.year);
      let m = core.DateTime._twoDigits(this.month);
      let d = core.DateTime._twoDigits(this.day);
      let h = core.DateTime._twoDigits(this.hour);
      let min = core.DateTime._twoDigits(this.minute);
      let sec = core.DateTime._twoDigits(this.second);
      let ms = core.DateTime._threeDigits(this.millisecond);
      let us = this.microsecond == 0 ? "" : core.DateTime._threeDigits(this.microsecond);
      if (dart.notNull(this.isUtc)) {
        return `${y}-${m}-${d} ${h}:${min}:${sec}.${ms}${us}Z`;
      } else {
        return `${y}-${m}-${d} ${h}:${min}:${sec}.${ms}${us}`;
      }
    }
    toIso8601String() {
      let y = dart.notNull(this.year) >= -9999 && dart.notNull(this.year) <= 9999 ? core.DateTime._fourDigits(this.year) : core.DateTime._sixDigits(this.year);
      let m = core.DateTime._twoDigits(this.month);
      let d = core.DateTime._twoDigits(this.day);
      let h = core.DateTime._twoDigits(this.hour);
      let min = core.DateTime._twoDigits(this.minute);
      let sec = core.DateTime._twoDigits(this.second);
      let ms = core.DateTime._threeDigits(this.millisecond);
      let us = this.microsecond == 0 ? "" : core.DateTime._threeDigits(this.microsecond);
      if (dart.notNull(this.isUtc)) {
        return `${y}-${m}-${d}T${h}:${min}:${sec}.${ms}${us}Z`;
      } else {
        return `${y}-${m}-${d}T${h}:${min}:${sec}.${ms}${us}`;
      }
    }
    add(duration) {
      return new core.DateTime._withValue(dart.notNull(this[_value$0]) + dart.notNull(duration.inMilliseconds), {isUtc: this.isUtc});
    }
    subtract(duration) {
      return new core.DateTime._withValue(dart.notNull(this[_value$0]) - dart.notNull(duration.inMilliseconds), {isUtc: this.isUtc});
    }
    difference(other) {
      return new core.Duration({milliseconds: dart.notNull(this[_value$0]) - dart.notNull(other[_value$0])});
    }
    _internal(year, month, day, hour, minute, second, millisecond, microsecond, isUtc) {
      this.isUtc = typeof isUtc == 'boolean' ? isUtc : dart.throw(new core.ArgumentError.value(isUtc, 'isUtc'));
      this[_value$0] = dart.as(_js_helper.checkInt(_js_helper.Primitives.valueFromDecomposedDate(year, month, day, hour, minute, second, dart.notNull(millisecond) + dart.notNull(core.DateTime._microsecondInRoundedMilliseconds(microsecond)), isUtc)), core.int);
    }
    _now() {
      this.isUtc = false;
      this[_value$0] = _js_helper.Primitives.dateNow();
    }
    static _brokenDownDateToValue(year, month, day, hour, minute, second, millisecond, microsecond, isUtc) {
      return dart.as(_js_helper.Primitives.valueFromDecomposedDate(year, month, day, hour, minute, second, dart.notNull(millisecond) + dart.notNull(core.DateTime._microsecondInRoundedMilliseconds(microsecond)), isUtc), core.int);
    }
    get millisecondsSinceEpoch() {
      return this[_value$0];
    }
    get microsecondsSinceEpoch() {
      return dart.notNull(this[_value$0]) * 1000;
    }
    get timeZoneName() {
      if (dart.notNull(this.isUtc)) return "UTC";
      return _js_helper.Primitives.getTimeZoneName(this);
    }
    get timeZoneOffset() {
      if (dart.notNull(this.isUtc)) return new core.Duration();
      return new core.Duration({minutes: _js_helper.Primitives.getTimeZoneOffsetInMinutes(this)});
    }
    get year() {
      return dart.as(_js_helper.Primitives.getYear(this), core.int);
    }
    get month() {
      return dart.as(_js_helper.Primitives.getMonth(this), core.int);
    }
    get day() {
      return dart.as(_js_helper.Primitives.getDay(this), core.int);
    }
    get hour() {
      return dart.as(_js_helper.Primitives.getHours(this), core.int);
    }
    get minute() {
      return dart.as(_js_helper.Primitives.getMinutes(this), core.int);
    }
    get second() {
      return dart.as(_js_helper.Primitives.getSeconds(this), core.int);
    }
    get millisecond() {
      return dart.as(_js_helper.Primitives.getMilliseconds(this), core.int);
    }
    get microsecond() {
      return 0;
    }
    get weekday() {
      return dart.as(_js_helper.Primitives.getWeekday(this), core.int);
    }
    static _microsecondInRoundedMilliseconds(microsecond) {
      return (dart.notNull(microsecond) / 1000)[dartx.round]();
    }
  };
  dart.defineNamedConstructor(core.DateTime, 'utc');
  dart.defineNamedConstructor(core.DateTime, 'now');
  dart.defineNamedConstructor(core.DateTime, 'fromMillisecondsSinceEpoch');
  dart.defineNamedConstructor(core.DateTime, 'fromMicrosecondsSinceEpoch');
  dart.defineNamedConstructor(core.DateTime, '_withValue');
  dart.defineNamedConstructor(core.DateTime, '_internal');
  dart.defineNamedConstructor(core.DateTime, '_now');
  core.DateTime[dart.implements] = () => [core.Comparable];
  dart.setSignature(core.DateTime, {
    constructors: () => ({
      DateTime: [core.DateTime, [core.int], [core.int, core.int, core.int, core.int, core.int, core.int, core.int]],
      utc: [core.DateTime, [core.int], [core.int, core.int, core.int, core.int, core.int, core.int, core.int]],
      now: [core.DateTime, []],
      fromMillisecondsSinceEpoch: [core.DateTime, [core.int], {isUtc: core.bool}],
      fromMicrosecondsSinceEpoch: [core.DateTime, [core.int], {isUtc: core.bool}],
      _withValue: [core.DateTime, [core.int], {isUtc: core.bool}],
      _internal: [core.DateTime, [core.int, core.int, core.int, core.int, core.int, core.int, core.int, core.int, core.bool]],
      _now: [core.DateTime, []]
    }),
    methods: () => ({
      isBefore: [core.bool, [core.DateTime]],
      isAfter: [core.bool, [core.DateTime]],
      isAtSameMomentAs: [core.bool, [core.DateTime]],
      compareTo: [core.int, [core.DateTime]],
      toLocal: [core.DateTime, []],
      toUtc: [core.DateTime, []],
      toIso8601String: [core.String, []],
      add: [core.DateTime, [core.Duration]],
      subtract: [core.DateTime, [core.Duration]],
      difference: [core.Duration, [core.DateTime]]
    }),
    statics: () => ({
      parse: [core.DateTime, [core.String]],
      _fourDigits: [core.String, [core.int]],
      _sixDigits: [core.String, [core.int]],
      _threeDigits: [core.String, [core.int]],
      _twoDigits: [core.String, [core.int]],
      _brokenDownDateToValue: [core.int, [core.int, core.int, core.int, core.int, core.int, core.int, core.int, core.int, core.bool]],
      _microsecondInRoundedMilliseconds: [core.int, [core.int]]
    }),
    names: ['parse', '_fourDigits', '_sixDigits', '_threeDigits', '_twoDigits', '_brokenDownDateToValue', '_microsecondInRoundedMilliseconds']
  });
  dart.defineExtensionMembers(core.DateTime, ['compareTo']);
  core.DateTime.MONDAY = 1;
  core.DateTime.TUESDAY = 2;
  core.DateTime.WEDNESDAY = 3;
  core.DateTime.THURSDAY = 4;
  core.DateTime.FRIDAY = 5;
  core.DateTime.SATURDAY = 6;
  core.DateTime.SUNDAY = 7;
  core.DateTime.DAYS_PER_WEEK = 7;
  core.DateTime.JANUARY = 1;
  core.DateTime.FEBRUARY = 2;
  core.DateTime.MARCH = 3;
  core.DateTime.APRIL = 4;
  core.DateTime.MAY = 5;
  core.DateTime.JUNE = 6;
  core.DateTime.JULY = 7;
  core.DateTime.AUGUST = 8;
  core.DateTime.SEPTEMBER = 9;
  core.DateTime.OCTOBER = 10;
  core.DateTime.NOVEMBER = 11;
  core.DateTime.DECEMBER = 12;
  core.DateTime.MONTHS_PER_YEAR = 12;
  core.DateTime._MAX_MILLISECONDS_SINCE_EPOCH = 8640000000000000;
  const _duration = Symbol('_duration');
  core.Duration = class Duration extends core.Object {
    Duration(opts) {
      let days = opts && 'days' in opts ? opts.days : 0;
      let hours = opts && 'hours' in opts ? opts.hours : 0;
      let minutes = opts && 'minutes' in opts ? opts.minutes : 0;
      let seconds = opts && 'seconds' in opts ? opts.seconds : 0;
      let milliseconds = opts && 'milliseconds' in opts ? opts.milliseconds : 0;
      let microseconds = opts && 'microseconds' in opts ? opts.microseconds : 0;
      this._microseconds(dart.notNull(core.Duration.MICROSECONDS_PER_DAY) * dart.notNull(days) + dart.notNull(core.Duration.MICROSECONDS_PER_HOUR) * dart.notNull(hours) + dart.notNull(core.Duration.MICROSECONDS_PER_MINUTE) * dart.notNull(minutes) + dart.notNull(core.Duration.MICROSECONDS_PER_SECOND) * dart.notNull(seconds) + dart.notNull(core.Duration.MICROSECONDS_PER_MILLISECOND) * dart.notNull(milliseconds) + dart.notNull(microseconds));
    }
    _microseconds(duration) {
      this[_duration] = duration;
    }
    ['+'](other) {
      return new core.Duration._microseconds(dart.notNull(this[_duration]) + dart.notNull(other[_duration]));
    }
    ['-'](other) {
      return new core.Duration._microseconds(dart.notNull(this[_duration]) - dart.notNull(other[_duration]));
    }
    ['*'](factor) {
      return new core.Duration._microseconds((dart.notNull(this[_duration]) * dart.notNull(factor))[dartx.round]());
    }
    ['~/'](quotient) {
      if (quotient == 0) dart.throw(new core.IntegerDivisionByZeroException());
      return new core.Duration._microseconds((dart.notNull(this[_duration]) / dart.notNull(quotient))[dartx.truncate]());
    }
    ['<'](other) {
      return dart.notNull(this[_duration]) < dart.notNull(other[_duration]);
    }
    ['>'](other) {
      return dart.notNull(this[_duration]) > dart.notNull(other[_duration]);
    }
    ['<='](other) {
      return dart.notNull(this[_duration]) <= dart.notNull(other[_duration]);
    }
    ['>='](other) {
      return dart.notNull(this[_duration]) >= dart.notNull(other[_duration]);
    }
    get inDays() {
      return (dart.notNull(this[_duration]) / dart.notNull(core.Duration.MICROSECONDS_PER_DAY))[dartx.truncate]();
    }
    get inHours() {
      return (dart.notNull(this[_duration]) / dart.notNull(core.Duration.MICROSECONDS_PER_HOUR))[dartx.truncate]();
    }
    get inMinutes() {
      return (dart.notNull(this[_duration]) / dart.notNull(core.Duration.MICROSECONDS_PER_MINUTE))[dartx.truncate]();
    }
    get inSeconds() {
      return (dart.notNull(this[_duration]) / dart.notNull(core.Duration.MICROSECONDS_PER_SECOND))[dartx.truncate]();
    }
    get inMilliseconds() {
      return (dart.notNull(this[_duration]) / dart.notNull(core.Duration.MICROSECONDS_PER_MILLISECOND))[dartx.truncate]();
    }
    get inMicroseconds() {
      return this[_duration];
    }
    ['=='](other) {
      if (!dart.is(other, core.Duration)) return false;
      return dart.equals(this[_duration], dart.dload(other, _duration));
    }
    get hashCode() {
      return dart.hashCode(this[_duration]);
    }
    compareTo(other) {
      return this[_duration][dartx.compareTo](other[_duration]);
    }
    toString() {
      function sixDigits(n) {
        if (dart.notNull(n) >= 100000) return `${n}`;
        if (dart.notNull(n) >= 10000) return `0${n}`;
        if (dart.notNull(n) >= 1000) return `00${n}`;
        if (dart.notNull(n) >= 100) return `000${n}`;
        if (dart.notNull(n) >= 10) return `0000${n}`;
        return `00000${n}`;
      }
      dart.fn(sixDigits, core.String, [core.int]);
      function twoDigits(n) {
        if (dart.notNull(n) >= 10) return `${n}`;
        return `0${n}`;
      }
      dart.fn(twoDigits, core.String, [core.int]);
      if (dart.notNull(this.inMicroseconds) < 0) {
        return `-${this['unary-']()}`;
      }
      let twoDigitMinutes = twoDigits(dart.asInt(this.inMinutes[dartx.remainder](core.Duration.MINUTES_PER_HOUR)));
      let twoDigitSeconds = twoDigits(dart.asInt(this.inSeconds[dartx.remainder](core.Duration.SECONDS_PER_MINUTE)));
      let sixDigitUs = sixDigits(dart.asInt(this.inMicroseconds[dartx.remainder](core.Duration.MICROSECONDS_PER_SECOND)));
      return `${this.inHours}:${twoDigitMinutes}:${twoDigitSeconds}.${sixDigitUs}`;
    }
    get isNegative() {
      return dart.notNull(this[_duration]) < 0;
    }
    abs() {
      return new core.Duration._microseconds(this[_duration][dartx.abs]());
    }
    ['unary-']() {
      return new core.Duration._microseconds(-dart.notNull(this[_duration]));
    }
  };
  dart.defineNamedConstructor(core.Duration, '_microseconds');
  core.Duration[dart.implements] = () => [core.Comparable$(core.Duration)];
  dart.setSignature(core.Duration, {
    constructors: () => ({
      Duration: [core.Duration, [], {days: core.int, hours: core.int, minutes: core.int, seconds: core.int, milliseconds: core.int, microseconds: core.int}],
      _microseconds: [core.Duration, [core.int]]
    }),
    methods: () => ({
      '+': [core.Duration, [core.Duration]],
      '-': [core.Duration, [core.Duration]],
      '*': [core.Duration, [core.num]],
      '~/': [core.Duration, [core.int]],
      '<': [core.bool, [core.Duration]],
      '>': [core.bool, [core.Duration]],
      '<=': [core.bool, [core.Duration]],
      '>=': [core.bool, [core.Duration]],
      compareTo: [core.int, [core.Duration]],
      abs: [core.Duration, []],
      'unary-': [core.Duration, []]
    })
  });
  dart.defineExtensionMembers(core.Duration, ['compareTo']);
  core.Duration.MICROSECONDS_PER_MILLISECOND = 1000;
  core.Duration.MILLISECONDS_PER_SECOND = 1000;
  core.Duration.SECONDS_PER_MINUTE = 60;
  core.Duration.MINUTES_PER_HOUR = 60;
  core.Duration.HOURS_PER_DAY = 24;
  dart.defineLazy(core.Duration, {
    get MICROSECONDS_PER_SECOND() {
      return dart.notNull(core.Duration.MICROSECONDS_PER_MILLISECOND) * dart.notNull(core.Duration.MILLISECONDS_PER_SECOND);
    },
    get MICROSECONDS_PER_MINUTE() {
      return dart.notNull(core.Duration.MICROSECONDS_PER_SECOND) * dart.notNull(core.Duration.SECONDS_PER_MINUTE);
    },
    get MICROSECONDS_PER_HOUR() {
      return dart.notNull(core.Duration.MICROSECONDS_PER_MINUTE) * dart.notNull(core.Duration.MINUTES_PER_HOUR);
    },
    get MICROSECONDS_PER_DAY() {
      return dart.notNull(core.Duration.MICROSECONDS_PER_HOUR) * dart.notNull(core.Duration.HOURS_PER_DAY);
    },
    get MILLISECONDS_PER_MINUTE() {
      return dart.notNull(core.Duration.MILLISECONDS_PER_SECOND) * dart.notNull(core.Duration.SECONDS_PER_MINUTE);
    },
    get MILLISECONDS_PER_HOUR() {
      return dart.notNull(core.Duration.MILLISECONDS_PER_MINUTE) * dart.notNull(core.Duration.MINUTES_PER_HOUR);
    },
    get MILLISECONDS_PER_DAY() {
      return dart.notNull(core.Duration.MILLISECONDS_PER_HOUR) * dart.notNull(core.Duration.HOURS_PER_DAY);
    },
    get SECONDS_PER_HOUR() {
      return dart.notNull(core.Duration.SECONDS_PER_MINUTE) * dart.notNull(core.Duration.MINUTES_PER_HOUR);
    },
    get SECONDS_PER_DAY() {
      return dart.notNull(core.Duration.SECONDS_PER_HOUR) * dart.notNull(core.Duration.HOURS_PER_DAY);
    },
    get MINUTES_PER_DAY() {
      return dart.notNull(core.Duration.MINUTES_PER_HOUR) * dart.notNull(core.Duration.HOURS_PER_DAY);
    },
    get ZERO() {
      return dart.const(new core.Duration({seconds: 0}));
    }
  });
  core.AssertionError = class AssertionError extends core.Error {
    AssertionError() {
      super.Error();
    }
    toString() {
      return "Assertion failed";
    }
  };
  dart.setSignature(core.AssertionError, {
    constructors: () => ({AssertionError: [core.AssertionError, []]})
  });
  core.TypeError = class TypeError extends core.AssertionError {
    TypeError() {
      super.AssertionError();
    }
  };
  core.CastError = class CastError extends core.Error {
    CastError() {
      super.Error();
    }
  };
  core.NullThrownError = class NullThrownError extends core.Error {
    NullThrownError() {
      super.Error();
    }
    toString() {
      return "Throw of null.";
    }
  };
  const _hasValue = Symbol('_hasValue');
  const _errorName = Symbol('_errorName');
  const _errorExplanation = Symbol('_errorExplanation');
  core.ArgumentError = class ArgumentError extends core.Error {
    ArgumentError(message) {
      if (message === void 0) message = null;
      this.message = message;
      this.invalidValue = null;
      this[_hasValue] = false;
      this.name = null;
      super.Error();
    }
    value(value, name, message) {
      if (name === void 0) name = null;
      if (message === void 0) message = null;
      this.name = name;
      this.message = message;
      this.invalidValue = value;
      this[_hasValue] = true;
      super.Error();
    }
    notNull(name) {
      if (name === void 0) name = null;
      this.name = name;
      this[_hasValue] = false;
      this.message = "Must not be null";
      this.invalidValue = null;
      super.Error();
    }
    get [_errorName]() {
      return `Invalid argument${!dart.notNull(this[_hasValue]) ? "(s)" : ""}`;
    }
    get [_errorExplanation]() {
      return "";
    }
    toString() {
      let nameString = "";
      if (this.name != null) {
        nameString = ` (${this.name})`;
      }
      let message = this.message == null ? "" : `: ${this.message}`;
      let prefix = `${this[_errorName]}${nameString}${message}`;
      if (!dart.notNull(this[_hasValue])) return prefix;
      let explanation = this[_errorExplanation];
      let errorValue = core.Error.safeToString(this.invalidValue);
      return `${prefix}${explanation}: ${errorValue}`;
    }
  };
  dart.defineNamedConstructor(core.ArgumentError, 'value');
  dart.defineNamedConstructor(core.ArgumentError, 'notNull');
  dart.setSignature(core.ArgumentError, {
    constructors: () => ({
      ArgumentError: [core.ArgumentError, [], [dart.dynamic]],
      value: [core.ArgumentError, [dart.dynamic], [core.String, core.String]],
      notNull: [core.ArgumentError, [], [core.String]]
    })
  });
  core.RangeError = class RangeError extends core.ArgumentError {
    RangeError(message) {
      this.start = null;
      this.end = null;
      super.ArgumentError(message);
    }
    value(value, name, message) {
      if (name === void 0) name = null;
      if (message === void 0) message = null;
      this.start = null;
      this.end = null;
      super.value(value, name, message != null ? message : "Value not in range");
    }
    range(invalidValue, minValue, maxValue, name, message) {
      if (name === void 0) name = null;
      if (message === void 0) message = null;
      this.start = minValue;
      this.end = maxValue;
      super.value(invalidValue, name, message != null ? message : "Invalid value");
    }
    static index(index, indexable, name, message, length) {
      return new core.IndexError(index, indexable, name, message, length);
    }
    static checkValueInInterval(value, minValue, maxValue, name, message) {
      if (name === void 0) name = null;
      if (message === void 0) message = null;
      if (dart.notNull(value) < dart.notNull(minValue) || dart.notNull(value) > dart.notNull(maxValue)) {
        dart.throw(new core.RangeError.range(value, minValue, maxValue, name, message));
      }
    }
    static checkValidIndex(index, indexable, name, length, message) {
      if (name === void 0) name = null;
      if (length === void 0) length = null;
      if (message === void 0) message = null;
      if (length == null) length = dart.as(dart.dload(indexable, 'length'), core.int);
      if (0 > dart.notNull(index) || dart.notNull(index) >= dart.notNull(length)) {
        if (name == null) name = "index";
        dart.throw(core.RangeError.index(index, indexable, name, message, length));
      }
    }
    static checkValidRange(start, end, length, startName, endName, message) {
      if (startName === void 0) startName = null;
      if (endName === void 0) endName = null;
      if (message === void 0) message = null;
      if (0 > dart.notNull(start) || dart.notNull(start) > dart.notNull(length)) {
        if (startName == null) startName = "start";
        dart.throw(new core.RangeError.range(start, 0, length, startName, message));
      }
      if (end != null) {
        if (dart.notNull(start) > dart.notNull(end) || dart.notNull(end) > dart.notNull(length)) {
          if (endName == null) endName = "end";
          dart.throw(new core.RangeError.range(end, start, length, endName, message));
        }
        return end;
      }
      return length;
    }
    static checkNotNegative(value, name, message) {
      if (name === void 0) name = null;
      if (message === void 0) message = null;
      if (dart.notNull(value) < 0) dart.throw(new core.RangeError.range(value, 0, null, name, message));
    }
    get [_errorName]() {
      return "RangeError";
    }
    get [_errorExplanation]() {
      dart.assert(this[_hasValue]);
      let explanation = "";
      if (this.start == null) {
        if (this.end != null) {
          explanation = `: Not less than or equal to ${this.end}`;
        }
      } else if (this.end == null) {
        explanation = `: Not greater than or equal to ${this.start}`;
      } else if (dart.notNull(this.end) > dart.notNull(this.start)) {
        explanation = `: Not in range ${this.start}..${this.end}, inclusive`;
      } else if (dart.notNull(this.end) < dart.notNull(this.start)) {
        explanation = ": Valid value range is empty";
      } else {
        explanation = `: Only valid value is ${this.start}`;
      }
      return explanation;
    }
  };
  dart.defineNamedConstructor(core.RangeError, 'value');
  dart.defineNamedConstructor(core.RangeError, 'range');
  dart.setSignature(core.RangeError, {
    constructors: () => ({
      RangeError: [core.RangeError, [dart.dynamic]],
      value: [core.RangeError, [core.num], [core.String, core.String]],
      range: [core.RangeError, [core.num, core.int, core.int], [core.String, core.String]],
      index: [core.RangeError, [core.int, dart.dynamic], [core.String, core.String, core.int]]
    }),
    statics: () => ({
      checkValueInInterval: [dart.void, [core.int, core.int, core.int], [core.String, core.String]],
      checkValidIndex: [dart.void, [core.int, dart.dynamic], [core.String, core.int, core.String]],
      checkValidRange: [core.int, [core.int, core.int, core.int], [core.String, core.String, core.String]],
      checkNotNegative: [dart.void, [core.int], [core.String, core.String]]
    }),
    names: ['checkValueInInterval', 'checkValidIndex', 'checkValidRange', 'checkNotNegative']
  });
  core.IndexError = class IndexError extends core.ArgumentError {
    IndexError(invalidValue, indexable, name, message, length) {
      if (name === void 0) name = null;
      if (message === void 0) message = null;
      if (length === void 0) length = null;
      this.indexable = indexable;
      this.length = dart.as(length != null ? length : dart.dload(indexable, 'length'), core.int);
      super.value(invalidValue, name, message != null ? message : "Index out of range");
    }
    get start() {
      return 0;
    }
    get end() {
      return dart.notNull(this.length) - 1;
    }
    get [_errorName]() {
      return "RangeError";
    }
    get [_errorExplanation]() {
      dart.assert(this[_hasValue]);
      if (dart.test(dart.dsend(this.invalidValue, '<', 0))) {
        return ": index must not be negative";
      }
      if (this.length == 0) {
        return ": no indices are valid";
      }
      return `: index should be less than ${this.length}`;
    }
  };
  core.IndexError[dart.implements] = () => [core.RangeError];
  dart.setSignature(core.IndexError, {
    constructors: () => ({IndexError: [core.IndexError, [core.int, dart.dynamic], [core.String, core.String, core.int]]})
  });
  const _className = Symbol('_className');
  core.AbstractClassInstantiationError = class AbstractClassInstantiationError extends core.Error {
    AbstractClassInstantiationError(className) {
      this[_className] = className;
      super.Error();
    }
    toString() {
      return `Cannot instantiate abstract class: '${this[_className]}'`;
    }
  };
  dart.setSignature(core.AbstractClassInstantiationError, {
    constructors: () => ({AbstractClassInstantiationError: [core.AbstractClassInstantiationError, [core.String]]})
  });
  const _receiver$ = Symbol('_receiver');
  const _memberName = Symbol('_memberName');
  const _arguments = Symbol('_arguments');
  const _namedArguments = Symbol('_namedArguments');
  const _existingArgumentNames = Symbol('_existingArgumentNames');
  core.NoSuchMethodError = class NoSuchMethodError extends core.Error {
    NoSuchMethodError(receiver, memberName, positionalArguments, namedArguments, existingArgumentNames) {
      if (existingArgumentNames === void 0) existingArgumentNames = null;
      this[_receiver$] = receiver;
      this[_memberName] = memberName;
      this[_arguments] = positionalArguments;
      this[_namedArguments] = namedArguments;
      this[_existingArgumentNames] = existingArgumentNames;
      super.Error();
    }
    toString() {
      let sb = new core.StringBuffer();
      let i = 0;
      if (this[_arguments] != null) {
        for (; i < dart.notNull(this[_arguments][dartx.length]); i++) {
          if (i > 0) {
            sb.write(", ");
          }
          sb.write(core.Error.safeToString(this[_arguments][dartx.get](i)));
        }
      }
      if (this[_namedArguments] != null) {
        this[_namedArguments][dartx.forEach](dart.fn((key, value) => {
          if (i > 0) {
            sb.write(", ");
          }
          sb.write(core._symbolToString(key));
          sb.write(": ");
          sb.write(core.Error.safeToString(value));
          i++;
        }, dart.void, [core.Symbol, dart.dynamic]));
      }
      if (this[_existingArgumentNames] == null) {
        return `NoSuchMethodError : method not found: '${this[_memberName]}'\n` + `Receiver: ${core.Error.safeToString(this[_receiver$])}\n` + `Arguments: [${sb}]`;
      } else {
        let actualParameters = sb.toString();
        sb = new core.StringBuffer();
        for (let i = 0; i < dart.notNull(this[_existingArgumentNames][dartx.length]); i++) {
          if (i > 0) {
            sb.write(", ");
          }
          sb.write(this[_existingArgumentNames][dartx.get](i));
        }
        let formalParameters = sb.toString();
        return "NoSuchMethodError: incorrect number of arguments passed to " + `method named '${this[_memberName]}'\n` + `Receiver: ${core.Error.safeToString(this[_receiver$])}\n` + `Tried calling: ${this[_memberName]}(${actualParameters})\n` + `Found: ${this[_memberName]}(${formalParameters})`;
      }
    }
  };
  dart.setSignature(core.NoSuchMethodError, {
    constructors: () => ({NoSuchMethodError: [core.NoSuchMethodError, [core.Object, core.Symbol, core.List, core.Map$(core.Symbol, dart.dynamic)], [core.List]]})
  });
  core.UnsupportedError = class UnsupportedError extends core.Error {
    UnsupportedError(message) {
      this.message = message;
      super.Error();
    }
    toString() {
      return `Unsupported operation: ${this.message}`;
    }
  };
  dart.setSignature(core.UnsupportedError, {
    constructors: () => ({UnsupportedError: [core.UnsupportedError, [core.String]]})
  });
  core.UnimplementedError = class UnimplementedError extends core.Error {
    UnimplementedError(message) {
      if (message === void 0) message = null;
      this.message = message;
      super.Error();
    }
    toString() {
      return this.message != null ? `UnimplementedError: ${this.message}` : "UnimplementedError";
    }
  };
  core.UnimplementedError[dart.implements] = () => [core.UnsupportedError];
  dart.setSignature(core.UnimplementedError, {
    constructors: () => ({UnimplementedError: [core.UnimplementedError, [], [core.String]]})
  });
  core.StateError = class StateError extends core.Error {
    StateError(message) {
      this.message = message;
      super.Error();
    }
    toString() {
      return `Bad state: ${this.message}`;
    }
  };
  dart.setSignature(core.StateError, {
    constructors: () => ({StateError: [core.StateError, [core.String]]})
  });
  core.ConcurrentModificationError = class ConcurrentModificationError extends core.Error {
    ConcurrentModificationError(modifiedObject) {
      if (modifiedObject === void 0) modifiedObject = null;
      this.modifiedObject = modifiedObject;
      super.Error();
    }
    toString() {
      if (this.modifiedObject == null) {
        return "Concurrent modification during iteration.";
      }
      return "Concurrent modification during iteration: " + `${core.Error.safeToString(this.modifiedObject)}.`;
    }
  };
  dart.setSignature(core.ConcurrentModificationError, {
    constructors: () => ({ConcurrentModificationError: [core.ConcurrentModificationError, [], [core.Object]]})
  });
  core.OutOfMemoryError = class OutOfMemoryError extends core.Object {
    OutOfMemoryError() {
    }
    toString() {
      return "Out of Memory";
    }
    get stackTrace() {
      return null;
    }
  };
  core.OutOfMemoryError[dart.implements] = () => [core.Error];
  dart.setSignature(core.OutOfMemoryError, {
    constructors: () => ({OutOfMemoryError: [core.OutOfMemoryError, []]})
  });
  core.StackOverflowError = class StackOverflowError extends core.Object {
    StackOverflowError() {
    }
    toString() {
      return "Stack Overflow";
    }
    get stackTrace() {
      return null;
    }
  };
  core.StackOverflowError[dart.implements] = () => [core.Error];
  dart.setSignature(core.StackOverflowError, {
    constructors: () => ({StackOverflowError: [core.StackOverflowError, []]})
  });
  core.CyclicInitializationError = class CyclicInitializationError extends core.Error {
    CyclicInitializationError(variableName) {
      if (variableName === void 0) variableName = null;
      this.variableName = variableName;
      super.Error();
    }
    toString() {
      return this.variableName == null ? "Reading static variable during its initialization" : `Reading static variable '${this.variableName}' during its initialization`;
    }
  };
  dart.setSignature(core.CyclicInitializationError, {
    constructors: () => ({CyclicInitializationError: [core.CyclicInitializationError, [], [core.String]]})
  });
  core.Exception = class Exception extends core.Object {
    static new(message) {
      if (message === void 0) message = null;
      return new core._Exception(message);
    }
  };
  dart.setSignature(core.Exception, {
    constructors: () => ({new: [core.Exception, [], [dart.dynamic]]})
  });
  core._Exception = class _Exception extends core.Object {
    _Exception(message) {
      if (message === void 0) message = null;
      this.message = message;
    }
    toString() {
      if (this.message == null) return "Exception";
      return `Exception: ${this.message}`;
    }
  };
  core._Exception[dart.implements] = () => [core.Exception];
  dart.setSignature(core._Exception, {
    constructors: () => ({_Exception: [core._Exception, [], [dart.dynamic]]})
  });
  core.FormatException = class FormatException extends core.Object {
    FormatException(message, source, offset) {
      if (message === void 0) message = "";
      if (source === void 0) source = null;
      if (offset === void 0) offset = null;
      this.message = message;
      this.source = source;
      this.offset = offset;
    }
    toString() {
      let report = "FormatException";
      if (this.message != null && "" != this.message) {
        report = `${report}: ${this.message}`;
      }
      let offset = this.offset;
      if (!(typeof this.source == 'string')) {
        if (offset != null) {
          report = report + ` (at offset ${offset})`;
        }
        return report;
      }
      if (offset != null && (dart.notNull(offset) < 0 || dart.notNull(offset) > dart.notNull(dart.as(dart.dload(this.source, 'length'), core.num)))) {
        offset = null;
      }
      if (offset == null) {
        let source = dart.as(this.source, core.String);
        if (dart.notNull(source[dartx.length]) > 78) {
          source = dart.notNull(source[dartx.substring](0, 75)) + "...";
        }
        return `${report}\n${source}`;
      }
      let lineNum = 1;
      let lineStart = 0;
      let lastWasCR = null;
      for (let i = 0; i < dart.notNull(offset); i++) {
        let char = dart.as(dart.dsend(this.source, 'codeUnitAt', i), core.int);
        if (char == 10) {
          if (lineStart != i || !dart.notNull(lastWasCR)) {
            lineNum++;
          }
          lineStart = i + 1;
          lastWasCR = false;
        } else if (char == 13) {
          lineNum++;
          lineStart = i + 1;
          lastWasCR = true;
        }
      }
      if (lineNum > 1) {
        report = report + ` (at line ${lineNum}, character ${dart.notNull(offset) - lineStart + 1})\n`;
      } else {
        report = report + ` (at character ${dart.notNull(offset) + 1})\n`;
      }
      let lineEnd = dart.as(dart.dload(this.source, 'length'), core.int);
      for (let i = offset; dart.notNull(i) < dart.notNull(dart.as(dart.dload(this.source, 'length'), core.num)); i = dart.notNull(i) + 1) {
        let char = dart.as(dart.dsend(this.source, 'codeUnitAt', i), core.int);
        if (char == 10 || char == 13) {
          lineEnd = i;
          break;
        }
      }
      let length = dart.notNull(lineEnd) - lineStart;
      let start = lineStart;
      let end = lineEnd;
      let prefix = "";
      let postfix = "";
      if (length > 78) {
        let index = dart.notNull(offset) - lineStart;
        if (index < 75) {
          end = start + 75;
          postfix = "...";
        } else if (dart.notNull(end) - dart.notNull(offset) < 75) {
          start = dart.notNull(end) - 75;
          prefix = "...";
        } else {
          start = dart.notNull(offset) - 36;
          end = dart.notNull(offset) + 36;
          prefix = postfix = "...";
        }
      }
      let slice = dart.as(dart.dsend(this.source, 'substring', start, end), core.String);
      let markOffset = dart.notNull(offset) - start + dart.notNull(prefix[dartx.length]);
      return `${report}${prefix}${slice}${postfix}\n${" "[dartx['*']](markOffset)}^\n`;
    }
  };
  core.FormatException[dart.implements] = () => [core.Exception];
  dart.setSignature(core.FormatException, {
    constructors: () => ({FormatException: [core.FormatException, [], [core.String, dart.dynamic, core.int]]})
  });
  core.IntegerDivisionByZeroException = class IntegerDivisionByZeroException extends core.Object {
    IntegerDivisionByZeroException() {
    }
    toString() {
      return "IntegerDivisionByZeroException";
    }
  };
  core.IntegerDivisionByZeroException[dart.implements] = () => [core.Exception];
  dart.setSignature(core.IntegerDivisionByZeroException, {
    constructors: () => ({IntegerDivisionByZeroException: [core.IntegerDivisionByZeroException, []]})
  });
  const _getKey = Symbol('_getKey');
  core.Expando$ = dart.generic(T => {
    class Expando extends core.Object {
      Expando(name) {
        if (name === void 0) name = null;
        this.name = name;
      }
      toString() {
        return `Expando:${this.name}`;
      }
      get(object) {
        let values = _js_helper.Primitives.getProperty(object, core.Expando._EXPANDO_PROPERTY_NAME);
        return dart.as(values == null ? null : _js_helper.Primitives.getProperty(values, this[_getKey]()), T);
      }
      set(object, value) {
        dart.as(value, T);
        let values = _js_helper.Primitives.getProperty(object, core.Expando._EXPANDO_PROPERTY_NAME);
        if (values == null) {
          values = new core.Object();
          _js_helper.Primitives.setProperty(object, core.Expando._EXPANDO_PROPERTY_NAME, values);
        }
        _js_helper.Primitives.setProperty(values, this[_getKey](), value);
        return value;
      }
      [_getKey]() {
        let key = dart.as(_js_helper.Primitives.getProperty(this, core.Expando._KEY_PROPERTY_NAME), core.String);
        if (key == null) {
          key = `expando\$key\$${(() => {
            let x = core.Expando._keyCount;
            core.Expando._keyCount = dart.notNull(x) + 1;
            return x;
          })()}`;
          _js_helper.Primitives.setProperty(this, core.Expando._KEY_PROPERTY_NAME, key);
        }
        return key;
      }
    }
    dart.setSignature(Expando, {
      constructors: () => ({Expando: [core.Expando$(T), [], [core.String]]}),
      methods: () => ({
        get: [T, [core.Object]],
        set: [dart.void, [core.Object, T]],
        [_getKey]: [core.String, []]
      })
    });
    return Expando;
  });
  core.Expando = core.Expando$();
  core.Expando._KEY_PROPERTY_NAME = 'expando$key';
  core.Expando._EXPANDO_PROPERTY_NAME = 'expando$values';
  core.Expando._keyCount = 0;
  core.Function = class Function extends core.Object {
    static apply(f, positionalArguments, namedArguments) {
      if (namedArguments === void 0) namedArguments = null;
      return dart.dcall.apply(null, [f].concat(positionalArguments));
    }
    static _toMangledNames(namedArguments) {
      let result = dart.map();
      namedArguments[dartx.forEach](dart.fn((symbol, value) => {
        result[dartx.set](core._symbolToString(symbol), value);
      }, dart.void, [core.Symbol, dart.dynamic]));
      return result;
    }
  };
  dart.setSignature(core.Function, {
    statics: () => ({
      apply: [dart.dynamic, [core.Function, core.List], [core.Map$(core.Symbol, dart.dynamic)]],
      _toMangledNames: [core.Map$(core.String, dart.dynamic), [core.Map$(core.Symbol, dart.dynamic)]]
    }),
    names: ['apply', '_toMangledNames']
  });
  core.identical = function(a, b) {
    return a == null ? b == null : a === b;
  };
  dart.fn(core.identical, core.bool, [core.Object, core.Object]);
  core.identityHashCode = function(object) {
    return _js_helper.objectHashCode(object);
  };
  dart.fn(core.identityHashCode, core.int, [core.Object]);
  core.Invocation = class Invocation extends core.Object {
    get isAccessor() {
      return dart.notNull(this.isGetter) || dart.notNull(this.isSetter);
    }
  };
  core._Generator$ = dart.generic(E => {
    const _Generator = dart.typedef('_Generator', () => dart.functionType(E, [core.int]));
    return _Generator;
  });
  core._Generator = core._Generator$();
  const _end$ = Symbol('_end');
  const _start$0 = Symbol('_start');
  const _generator$ = Symbol('_generator');
  core._GeneratorIterable$ = dart.generic(E => {
    class _GeneratorIterable extends core.Iterable$(E) {
      _GeneratorIterable(end, generator) {
        this[_end$] = end;
        this[_start$0] = 0;
        this[_generator$] = generator != null ? generator : dart.as(core._GeneratorIterable._id, core._Generator$(E));
        super.Iterable();
      }
      slice(start, end, generator) {
        this[_start$0] = start;
        this[_end$] = end;
        this[_generator$] = generator;
        super.Iterable();
      }
      get iterator() {
        return new (core._GeneratorIterator$(E))(this[_start$0], this[_end$], this[_generator$]);
      }
      get length() {
        return dart.notNull(this[_end$]) - dart.notNull(this[_start$0]);
      }
      skip(count) {
        core.RangeError.checkNotNegative(count, "count");
        if (count == 0) return this;
        let newStart = dart.notNull(this[_start$0]) + dart.notNull(count);
        if (newStart >= dart.notNull(this[_end$])) return new (_internal.EmptyIterable$(E))();
        return new (core._GeneratorIterable$(E)).slice(newStart, this[_end$], this[_generator$]);
      }
      take(count) {
        core.RangeError.checkNotNegative(count, "count");
        if (count == 0) return new (_internal.EmptyIterable$(E))();
        let newEnd = dart.notNull(this[_start$0]) + dart.notNull(count);
        if (newEnd >= dart.notNull(this[_end$])) return this;
        return new (core._GeneratorIterable$(E)).slice(this[_start$0], newEnd, this[_generator$]);
      }
      static _id(n) {
        return n;
      }
    }
    dart.defineNamedConstructor(_GeneratorIterable, 'slice');
    _GeneratorIterable[dart.implements] = () => [_internal.EfficientLength];
    dart.setSignature(_GeneratorIterable, {
      constructors: () => ({
        _GeneratorIterable: [core._GeneratorIterable$(E), [core.int, dart.functionType(E, [core.int])]],
        slice: [core._GeneratorIterable$(E), [core.int, core.int, core._Generator$(E)]]
      }),
      methods: () => ({
        skip: [core.Iterable$(E), [core.int]],
        take: [core.Iterable$(E), [core.int]]
      }),
      statics: () => ({_id: [core.int, [core.int]]}),
      names: ['_id']
    });
    dart.defineExtensionMembers(_GeneratorIterable, ['skip', 'take', 'iterator', 'length']);
    return _GeneratorIterable;
  });
  core._GeneratorIterable = core._GeneratorIterable$();
  const _index$1 = Symbol('_index');
  const _current$3 = Symbol('_current');
  core._GeneratorIterator$ = dart.generic(E => {
    class _GeneratorIterator extends core.Object {
      _GeneratorIterator(index, end, generator) {
        this[_index$1] = index;
        this[_end$] = end;
        this[_generator$] = generator;
        this[_current$3] = null;
      }
      moveNext() {
        if (dart.notNull(this[_index$1]) < dart.notNull(this[_end$])) {
          this[_current$3] = this[_generator$](this[_index$1]);
          this[_index$1] = dart.notNull(this[_index$1]) + 1;
          return true;
        } else {
          this[_current$3] = null;
          return false;
        }
      }
      get current() {
        return this[_current$3];
      }
    }
    _GeneratorIterator[dart.implements] = () => [core.Iterator$(E)];
    dart.setSignature(_GeneratorIterator, {
      constructors: () => ({_GeneratorIterator: [core._GeneratorIterator$(E), [core.int, core.int, core._Generator$(E)]]}),
      methods: () => ({moveNext: [core.bool, []]})
    });
    return _GeneratorIterator;
  });
  core._GeneratorIterator = core._GeneratorIterator$();
  core.BidirectionalIterator$ = dart.generic(E => {
    class BidirectionalIterator extends core.Object {}
    BidirectionalIterator[dart.implements] = () => [core.Iterator$(E)];
    return BidirectionalIterator;
  });
  core.BidirectionalIterator = core.BidirectionalIterator$();
  core.Map$ = dart.generic((K, V) => {
    class Map extends core.Object {
      static new() {
        return _js_helper.JsLinkedHashMap$(K, V).es6();
      }
      static from(other) {
        return collection.LinkedHashMap$(K, V).from(other);
      }
      static unmodifiable(other) {
        return new (collection.UnmodifiableMapView$(K, V))(core.Map$(K, V).from(other));
      }
      static identity() {
        return collection.LinkedHashMap$(K, V).identity();
      }
      static fromIterable(iterable, opts) {
        return collection.LinkedHashMap$(K, V).fromIterable(iterable, opts);
      }
      static fromIterables(keys, values) {
        return collection.LinkedHashMap$(K, V).fromIterables(keys, values);
      }
    }
    dart.setSignature(Map, {
      constructors: () => ({
        new: [core.Map$(K, V), []],
        from: [core.Map$(K, V), [core.Map]],
        unmodifiable: [core.Map$(K, V), [core.Map]],
        identity: [core.Map$(K, V), []],
        fromIterable: [core.Map$(K, V), [core.Iterable], {key: dart.functionType(K, [dart.dynamic]), value: dart.functionType(V, [dart.dynamic])}],
        fromIterables: [core.Map$(K, V), [core.Iterable$(K), core.Iterable$(V)]]
      })
    });
    return Map;
  });
  core.Map = core.Map$();
  core.Null = class Null extends core.Object {
    static _uninstantiable() {
      dart.throw(new core.UnsupportedError('class Null cannot be instantiated'));
    }
    toString() {
      return "null";
    }
  };
  dart.setSignature(core.Null, {
    constructors: () => ({_uninstantiable: [core.Null, []]})
  });
  core.Pattern = class Pattern extends core.Object {};
  core.print = function(object) {
    let line = `${object}`;
    if (_internal.printToZone == null) {
      _internal.printToConsole(line);
    } else {
      dart.dcall(_internal.printToZone, line);
    }
  };
  dart.fn(core.print, dart.void, [core.Object]);
  core.RegExp = class RegExp extends core.Object {
    static new(source, opts) {
      let multiLine = opts && 'multiLine' in opts ? opts.multiLine : false;
      let caseSensitive = opts && 'caseSensitive' in opts ? opts.caseSensitive : true;
      return new _js_helper.JSSyntaxRegExp(source, {multiLine: multiLine, caseSensitive: caseSensitive});
    }
  };
  core.RegExp[dart.implements] = () => [core.Pattern];
  dart.setSignature(core.RegExp, {
    constructors: () => ({new: [core.RegExp, [core.String], {multiLine: core.bool, caseSensitive: core.bool}]})
  });
  core.Set$ = dart.generic(E => {
    class Set extends core.Iterable$(E) {
      static new() {
        return collection.LinkedHashSet$(E).new();
      }
      static identity() {
        return collection.LinkedHashSet$(E).identity();
      }
      static from(elements) {
        return collection.LinkedHashSet$(E).from(elements);
      }
    }
    Set[dart.implements] = () => [_internal.EfficientLength];
    dart.setSignature(Set, {
      constructors: () => ({
        new: [core.Set$(E), []],
        identity: [core.Set$(E), []],
        from: [core.Set$(E), [core.Iterable$(E)]]
      })
    });
    return Set;
  });
  core.Set = core.Set$();
  core.Sink$ = dart.generic(T => {
    class Sink extends core.Object {}
    return Sink;
  });
  core.Sink = core.Sink$();
  core.StackTrace = class StackTrace extends core.Object {
    static get current() {
      if (Error.captureStackTrace != null) {
        let error = new Error();
        Error.captureStackTrace(error);
        return _js_helper.getTraceFromException(error);
      }
      try {
        dart.throw('');
      } catch (_) {
        let stackTrace = dart.stackTrace(_);
        return stackTrace;
      }

    }
  };
  const _stop = Symbol('_stop');
  core.Stopwatch = class Stopwatch extends core.Object {
    get frequency() {
      return core.Stopwatch._frequency;
    }
    Stopwatch() {
      this[_start$0] = null;
      this[_stop] = null;
      core.Stopwatch._initTicker();
    }
    start() {
      if (dart.notNull(this.isRunning)) return;
      if (this[_start$0] == null) {
        this[_start$0] = core.Stopwatch._now();
      } else {
        this[_start$0] = dart.notNull(core.Stopwatch._now()) - (dart.notNull(this[_stop]) - dart.notNull(this[_start$0]));
        this[_stop] = null;
      }
    }
    stop() {
      if (!dart.notNull(this.isRunning)) return;
      this[_stop] = core.Stopwatch._now();
    }
    reset() {
      if (this[_start$0] == null) return;
      this[_start$0] = core.Stopwatch._now();
      if (this[_stop] != null) {
        this[_stop] = this[_start$0];
      }
    }
    get elapsedTicks() {
      if (this[_start$0] == null) {
        return 0;
      }
      return this[_stop] == null ? dart.notNull(core.Stopwatch._now()) - dart.notNull(this[_start$0]) : dart.notNull(this[_stop]) - dart.notNull(this[_start$0]);
    }
    get elapsed() {
      return new core.Duration({microseconds: this.elapsedMicroseconds});
    }
    get elapsedMicroseconds() {
      return (dart.notNull(this.elapsedTicks) * 1000000 / dart.notNull(this.frequency))[dartx.truncate]();
    }
    get elapsedMilliseconds() {
      return (dart.notNull(this.elapsedTicks) * 1000 / dart.notNull(this.frequency))[dartx.truncate]();
    }
    get isRunning() {
      return this[_start$0] != null && this[_stop] == null;
    }
    static _initTicker() {
      _js_helper.Primitives.initTicker();
      core.Stopwatch._frequency = _js_helper.Primitives.timerFrequency;
    }
    static _now() {
      return dart.as(dart.dcall(_js_helper.Primitives.timerTicks), core.int);
    }
  };
  dart.setSignature(core.Stopwatch, {
    constructors: () => ({Stopwatch: [core.Stopwatch, []]}),
    methods: () => ({
      start: [dart.void, []],
      stop: [dart.void, []],
      reset: [dart.void, []]
    }),
    statics: () => ({
      _initTicker: [dart.void, []],
      _now: [core.int, []]
    }),
    names: ['_initTicker', '_now']
  });
  core.Stopwatch._frequency = null;
  core.Runes = class Runes extends core.Iterable$(core.int) {
    Runes(string) {
      this.string = string;
      super.Iterable();
    }
    get iterator() {
      return new core.RuneIterator(this.string);
    }
    get last() {
      if (this.string[dartx.length] == 0) {
        dart.throw(new core.StateError('No elements.'));
      }
      let length = this.string[dartx.length];
      let code = this.string[dartx.codeUnitAt](dart.notNull(length) - 1);
      if (dart.notNull(core._isTrailSurrogate(code)) && dart.notNull(this.string[dartx.length]) > 1) {
        let previousCode = this.string[dartx.codeUnitAt](dart.notNull(length) - 2);
        if (dart.notNull(core._isLeadSurrogate(previousCode))) {
          return core._combineSurrogatePair(previousCode, code);
        }
      }
      return code;
    }
  };
  dart.setSignature(core.Runes, {
    constructors: () => ({Runes: [core.Runes, [core.String]]})
  });
  dart.defineExtensionMembers(core.Runes, ['iterator', 'last']);
  core._isLeadSurrogate = function(code) {
    return (dart.notNull(code) & 64512) == 55296;
  };
  dart.fn(core._isLeadSurrogate, core.bool, [core.int]);
  core._isTrailSurrogate = function(code) {
    return (dart.notNull(code) & 64512) == 56320;
  };
  dart.fn(core._isTrailSurrogate, core.bool, [core.int]);
  core._combineSurrogatePair = function(start, end) {
    return 65536 + ((dart.notNull(start) & 1023) << 10) + (dart.notNull(end) & 1023);
  };
  dart.fn(core._combineSurrogatePair, core.int, [core.int, core.int]);
  const _position$ = Symbol('_position');
  const _nextPosition = Symbol('_nextPosition');
  const _currentCodePoint = Symbol('_currentCodePoint');
  const _checkSplitSurrogate = Symbol('_checkSplitSurrogate');
  core.RuneIterator = class RuneIterator extends core.Object {
    RuneIterator(string) {
      this.string = string;
      this[_position$] = 0;
      this[_nextPosition] = 0;
      this[_currentCodePoint] = null;
    }
    at(string, index) {
      this.string = string;
      this[_position$] = index;
      this[_nextPosition] = index;
      this[_currentCodePoint] = null;
      core.RangeError.checkValueInInterval(index, 0, string[dartx.length]);
      this[_checkSplitSurrogate](index);
    }
    [_checkSplitSurrogate](index) {
      if (dart.notNull(index) > 0 && dart.notNull(index) < dart.notNull(this.string[dartx.length]) && dart.notNull(core._isLeadSurrogate(this.string[dartx.codeUnitAt](dart.notNull(index) - 1))) && dart.notNull(core._isTrailSurrogate(this.string[dartx.codeUnitAt](index)))) {
        dart.throw(new core.ArgumentError(`Index inside surrogate pair: ${index}`));
      }
    }
    get rawIndex() {
      return this[_position$] != this[_nextPosition] ? this[_position$] : null;
    }
    set rawIndex(rawIndex) {
      core.RangeError.checkValidIndex(rawIndex, this.string, "rawIndex");
      this.reset(rawIndex);
      this.moveNext();
    }
    reset(rawIndex) {
      if (rawIndex === void 0) rawIndex = 0;
      core.RangeError.checkValueInInterval(rawIndex, 0, this.string[dartx.length], "rawIndex");
      this[_checkSplitSurrogate](rawIndex);
      this[_position$] = this[_nextPosition] = rawIndex;
      this[_currentCodePoint] = null;
    }
    get current() {
      return this[_currentCodePoint];
    }
    get currentSize() {
      return dart.notNull(this[_nextPosition]) - dart.notNull(this[_position$]);
    }
    get currentAsString() {
      if (this[_position$] == this[_nextPosition]) return null;
      if (dart.notNull(this[_position$]) + 1 == this[_nextPosition]) return this.string[dartx.get](this[_position$]);
      return this.string[dartx.substring](this[_position$], this[_nextPosition]);
    }
    moveNext() {
      this[_position$] = this[_nextPosition];
      if (this[_position$] == this.string[dartx.length]) {
        this[_currentCodePoint] = null;
        return false;
      }
      let codeUnit = this.string[dartx.codeUnitAt](this[_position$]);
      let nextPosition = dart.notNull(this[_position$]) + 1;
      if (dart.notNull(core._isLeadSurrogate(codeUnit)) && nextPosition < dart.notNull(this.string[dartx.length])) {
        let nextCodeUnit = this.string[dartx.codeUnitAt](nextPosition);
        if (dart.notNull(core._isTrailSurrogate(nextCodeUnit))) {
          this[_nextPosition] = nextPosition + 1;
          this[_currentCodePoint] = core._combineSurrogatePair(codeUnit, nextCodeUnit);
          return true;
        }
      }
      this[_nextPosition] = nextPosition;
      this[_currentCodePoint] = codeUnit;
      return true;
    }
    movePrevious() {
      this[_nextPosition] = this[_position$];
      if (this[_position$] == 0) {
        this[_currentCodePoint] = null;
        return false;
      }
      let position = dart.notNull(this[_position$]) - 1;
      let codeUnit = this.string[dartx.codeUnitAt](position);
      if (dart.notNull(core._isTrailSurrogate(codeUnit)) && position > 0) {
        let prevCodeUnit = this.string[dartx.codeUnitAt](position - 1);
        if (dart.notNull(core._isLeadSurrogate(prevCodeUnit))) {
          this[_position$] = position - 1;
          this[_currentCodePoint] = core._combineSurrogatePair(prevCodeUnit, codeUnit);
          return true;
        }
      }
      this[_position$] = position;
      this[_currentCodePoint] = codeUnit;
      return true;
    }
  };
  dart.defineNamedConstructor(core.RuneIterator, 'at');
  core.RuneIterator[dart.implements] = () => [core.BidirectionalIterator$(core.int)];
  dart.setSignature(core.RuneIterator, {
    constructors: () => ({
      RuneIterator: [core.RuneIterator, [core.String]],
      at: [core.RuneIterator, [core.String, core.int]]
    }),
    methods: () => ({
      [_checkSplitSurrogate]: [dart.void, [core.int]],
      reset: [dart.void, [], [core.int]],
      moveNext: [core.bool, []],
      movePrevious: [core.bool, []]
    })
  });
  const _contents = Symbol('_contents');
  const _writeString = Symbol('_writeString');
  core.StringBuffer = class StringBuffer extends core.Object {
    StringBuffer(content) {
      if (content === void 0) content = "";
      this[_contents] = `${content}`;
    }
    get length() {
      return this[_contents][dartx.length];
    }
    get isEmpty() {
      return this.length == 0;
    }
    get isNotEmpty() {
      return !dart.notNull(this.isEmpty);
    }
    write(obj) {
      this[_writeString](`${obj}`);
    }
    writeCharCode(charCode) {
      this[_writeString](core.String.fromCharCode(charCode));
    }
    writeAll(objects, separator) {
      if (separator === void 0) separator = "";
      this[_contents] = core.StringBuffer._writeAll(this[_contents], objects, separator);
    }
    writeln(obj) {
      if (obj === void 0) obj = "";
      this[_writeString](`${obj}\n`);
    }
    clear() {
      this[_contents] = "";
    }
    toString() {
      return _js_helper.Primitives.flattenString(this[_contents]);
    }
    [_writeString](str) {
      this[_contents] = _js_helper.Primitives.stringConcatUnchecked(this[_contents], dart.as(str, core.String));
    }
    static _writeAll(string, objects, separator) {
      let iterator = objects[dartx.iterator];
      if (!dart.notNull(iterator.moveNext())) return string;
      if (dart.notNull(separator[dartx.isEmpty])) {
        do {
          string = core.StringBuffer._writeOne(string, iterator.current);
        } while (dart.notNull(iterator.moveNext()));
      } else {
        string = core.StringBuffer._writeOne(string, iterator.current);
        while (dart.notNull(iterator.moveNext())) {
          string = core.StringBuffer._writeOne(string, separator);
          string = core.StringBuffer._writeOne(string, iterator.current);
        }
      }
      return string;
    }
    static _writeOne(string, obj) {
      return _js_helper.Primitives.stringConcatUnchecked(string, `${obj}`);
    }
  };
  core.StringBuffer[dart.implements] = () => [core.StringSink];
  dart.setSignature(core.StringBuffer, {
    constructors: () => ({StringBuffer: [core.StringBuffer, [], [core.Object]]}),
    methods: () => ({
      write: [dart.void, [core.Object]],
      writeCharCode: [dart.void, [core.int]],
      writeAll: [dart.void, [core.Iterable], [core.String]],
      writeln: [dart.void, [], [core.Object]],
      clear: [dart.void, []],
      [_writeString]: [dart.void, [dart.dynamic]]
    }),
    statics: () => ({
      _writeAll: [core.String, [core.String, core.Iterable, core.String]],
      _writeOne: [core.String, [core.String, core.Object]]
    }),
    names: ['_writeAll', '_writeOne']
  });
  core.Symbol = class Symbol extends core.Object {
    static new(name) {
      return new _internal.Symbol(name);
    }
  };
  dart.setSignature(core.Symbol, {
    constructors: () => ({new: [core.Symbol, [core.String]]})
  });
  core.Type = class Type extends core.Object {};
  const _userInfo = Symbol('_userInfo');
  const _host = Symbol('_host');
  const _port = Symbol('_port');
  const _path = Symbol('_path');
  const _query = Symbol('_query');
  const _fragment = Symbol('_fragment');
  const _pathSegments = Symbol('_pathSegments');
  const _queryParameters = Symbol('_queryParameters');
  const _queryParameterLists = Symbol('_queryParameterLists');
  const _writeAuthority = Symbol('_writeAuthority');
  const _mergePaths = Symbol('_mergePaths');
  const _toWindowsFilePath = Symbol('_toWindowsFilePath');
  const _toFilePath = Symbol('_toFilePath');
  const _isPathAbsolute = Symbol('_isPathAbsolute');
  core.Uri = class Uri extends core.Object {
    _internal(scheme, userInfo, host, port, path, query, fragment) {
      this.scheme = scheme;
      this[_userInfo] = userInfo;
      this[_host] = host;
      this[_port] = port;
      this[_path] = path;
      this[_query] = query;
      this[_fragment] = fragment;
      this[_pathSegments] = null;
      this[_queryParameters] = null;
      this[_queryParameterLists] = null;
    }
    static new(opts) {
      let scheme = opts && 'scheme' in opts ? opts.scheme : "";
      let userInfo = opts && 'userInfo' in opts ? opts.userInfo : "";
      let host = opts && 'host' in opts ? opts.host : null;
      let port = opts && 'port' in opts ? opts.port : null;
      let path = opts && 'path' in opts ? opts.path : null;
      let pathSegments = opts && 'pathSegments' in opts ? opts.pathSegments : null;
      let query = opts && 'query' in opts ? opts.query : null;
      let queryParameters = opts && 'queryParameters' in opts ? opts.queryParameters : null;
      let fragment = opts && 'fragment' in opts ? opts.fragment : null;
      scheme = core.Uri._makeScheme(scheme, 0, core.Uri._stringOrNullLength(scheme));
      userInfo = core.Uri._makeUserInfo(userInfo, 0, core.Uri._stringOrNullLength(userInfo));
      host = core.Uri._makeHost(host, 0, core.Uri._stringOrNullLength(host), false);
      if (query == "") query = null;
      query = core.Uri._makeQuery(query, 0, core.Uri._stringOrNullLength(query), queryParameters);
      fragment = core.Uri._makeFragment(fragment, 0, core.Uri._stringOrNullLength(fragment));
      port = core.Uri._makePort(port, scheme);
      let isFile = scheme == "file";
      if (host == null && (dart.notNull(userInfo[dartx.isNotEmpty]) || port != null || isFile)) {
        host = "";
      }
      let hasAuthority = host != null;
      path = core.Uri._makePath(path, 0, core.Uri._stringOrNullLength(path), pathSegments, scheme, hasAuthority);
      if (dart.notNull(scheme[dartx.isEmpty]) && host == null && !dart.notNull(path[dartx.startsWith]('/'))) {
        path = core.Uri._normalizeRelativePath(path);
      } else {
        path = core.Uri._removeDotSegments(path);
      }
      return new core.Uri._internal(scheme, userInfo, host, port, path, query, fragment);
    }
    static http(authority, unencodedPath, queryParameters) {
      if (queryParameters === void 0) queryParameters = null;
      return core.Uri._makeHttpUri("http", authority, unencodedPath, queryParameters);
    }
    static https(authority, unencodedPath, queryParameters) {
      if (queryParameters === void 0) queryParameters = null;
      return core.Uri._makeHttpUri("https", authority, unencodedPath, queryParameters);
    }
    get authority() {
      if (!dart.notNull(this.hasAuthority)) return "";
      let sb = new core.StringBuffer();
      this[_writeAuthority](sb);
      return sb.toString();
    }
    get userInfo() {
      return this[_userInfo];
    }
    get host() {
      if (this[_host] == null) return "";
      if (dart.notNull(this[_host][dartx.startsWith]('['))) {
        return this[_host][dartx.substring](1, dart.notNull(this[_host][dartx.length]) - 1);
      }
      return this[_host];
    }
    get port() {
      if (this[_port] == null) return core.Uri._defaultPort(this.scheme);
      return this[_port];
    }
    static _defaultPort(scheme) {
      if (scheme == "http") return 80;
      if (scheme == "https") return 443;
      return 0;
    }
    get path() {
      return this[_path];
    }
    get query() {
      return this[_query] == null ? "" : this[_query];
    }
    get fragment() {
      return this[_fragment] == null ? "" : this[_fragment];
    }
    static parse(uri, start, end) {
      if (start === void 0) start = 0;
      if (end === void 0) end = null;
      let EOI = -1;
      let scheme = "";
      let userinfo = "";
      let host = null;
      let port = null;
      let path = null;
      let query = null;
      let fragment = null;
      if (end == null) end = uri[dartx.length];
      let index = start;
      let pathStart = start;
      let char = EOI;
      function parseAuth() {
        if (index == end) {
          char = EOI;
          return;
        }
        let authStart = index;
        let lastColon = -1;
        let lastAt = -1;
        char = uri[dartx.codeUnitAt](index);
        while (dart.notNull(index) < dart.notNull(end)) {
          char = uri[dartx.codeUnitAt](index);
          if (char == core.Uri._SLASH || char == core.Uri._QUESTION || char == core.Uri._NUMBER_SIGN) {
            break;
          }
          if (char == core.Uri._AT_SIGN) {
            lastAt = index;
            lastColon = -1;
          } else if (char == core.Uri._COLON) {
            lastColon = index;
          } else if (char == core.Uri._LEFT_BRACKET) {
            lastColon = -1;
            let endBracket = uri[dartx.indexOf](']', dart.notNull(index) + 1);
            if (endBracket == -1) {
              index = end;
              char = EOI;
              break;
            } else {
              index = endBracket;
            }
          }
          index = dart.notNull(index) + 1;
          char = EOI;
        }
        let hostStart = authStart;
        let hostEnd = index;
        if (dart.notNull(lastAt) >= 0) {
          userinfo = core.Uri._makeUserInfo(uri, authStart, lastAt);
          hostStart = dart.notNull(lastAt) + 1;
        }
        if (dart.notNull(lastColon) >= 0) {
          let portNumber = null;
          if (dart.notNull(lastColon) + 1 < dart.notNull(index)) {
            portNumber = 0;
            for (let i = dart.notNull(lastColon) + 1; i < dart.notNull(index); i++) {
              let digit = uri[dartx.codeUnitAt](i);
              if (dart.notNull(core.Uri._ZERO) > dart.notNull(digit) || dart.notNull(core.Uri._NINE) < dart.notNull(digit)) {
                core.Uri._fail(uri, i, "Invalid port number");
              }
              portNumber = dart.notNull(portNumber) * 10 + (dart.notNull(digit) - dart.notNull(core.Uri._ZERO));
            }
          }
          port = core.Uri._makePort(portNumber, scheme);
          hostEnd = lastColon;
        }
        host = core.Uri._makeHost(uri, hostStart, hostEnd, true);
        if (dart.notNull(index) < dart.notNull(end)) {
          char = uri[dartx.codeUnitAt](index);
        }
      }
      dart.fn(parseAuth, dart.void, []);
      let NOT_IN_PATH = 0;
      let IN_PATH = 1;
      let ALLOW_AUTH = 2;
      let state = NOT_IN_PATH;
      let i = index;
      while (dart.notNull(i) < dart.notNull(end)) {
        char = uri[dartx.codeUnitAt](i);
        if (char == core.Uri._QUESTION || char == core.Uri._NUMBER_SIGN) {
          state = NOT_IN_PATH;
          break;
        }
        if (char == core.Uri._SLASH) {
          state = i == start ? ALLOW_AUTH : IN_PATH;
          break;
        }
        if (char == core.Uri._COLON) {
          if (i == start) core.Uri._fail(uri, start, "Invalid empty scheme");
          scheme = core.Uri._makeScheme(uri, start, i);
          i = dart.notNull(i) + 1;
          pathStart = i;
          if (i == end) {
            char = EOI;
            state = NOT_IN_PATH;
          } else {
            char = uri[dartx.codeUnitAt](i);
            if (char == core.Uri._QUESTION || char == core.Uri._NUMBER_SIGN) {
              state = NOT_IN_PATH;
            } else if (char == core.Uri._SLASH) {
              state = ALLOW_AUTH;
            } else {
              state = IN_PATH;
            }
          }
          break;
        }
        i = dart.notNull(i) + 1;
        char = EOI;
      }
      index = i;
      if (state == ALLOW_AUTH) {
        dart.assert(char == core.Uri._SLASH);
        index = dart.notNull(index) + 1;
        if (index == end) {
          char = EOI;
          state = NOT_IN_PATH;
        } else {
          char = uri[dartx.codeUnitAt](index);
          if (char == core.Uri._SLASH) {
            index = dart.notNull(index) + 1;
            parseAuth();
            pathStart = index;
          }
          if (char == core.Uri._QUESTION || char == core.Uri._NUMBER_SIGN || char == EOI) {
            state = NOT_IN_PATH;
          } else {
            state = IN_PATH;
          }
        }
      }
      dart.assert(state == IN_PATH || state == NOT_IN_PATH);
      if (state == IN_PATH) {
        while ((index = dart.notNull(index) + 1) < dart.notNull(end)) {
          char = uri[dartx.codeUnitAt](index);
          if (char == core.Uri._QUESTION || char == core.Uri._NUMBER_SIGN) {
            break;
          }
          char = EOI;
        }
        state = NOT_IN_PATH;
      }
      dart.assert(state == NOT_IN_PATH);
      let hasAuthority = host != null;
      path = core.Uri._makePath(uri, pathStart, index, null, scheme, hasAuthority);
      if (char == core.Uri._QUESTION) {
        let numberSignIndex = -1;
        for (let i = dart.notNull(index) + 1; i < dart.notNull(end); i++) {
          if (uri[dartx.codeUnitAt](i) == core.Uri._NUMBER_SIGN) {
            numberSignIndex = i;
            break;
          }
        }
        if (numberSignIndex < 0) {
          query = core.Uri._makeQuery(uri, dart.notNull(index) + 1, end, null);
        } else {
          query = core.Uri._makeQuery(uri, dart.notNull(index) + 1, numberSignIndex, null);
          fragment = core.Uri._makeFragment(uri, numberSignIndex + 1, end);
        }
      } else if (char == core.Uri._NUMBER_SIGN) {
        fragment = core.Uri._makeFragment(uri, dart.notNull(index) + 1, end);
      }
      return new core.Uri._internal(scheme, userinfo, host, port, path, query, fragment);
    }
    static _fail(uri, index, message) {
      dart.throw(new core.FormatException(message, uri, index));
    }
    static _makeHttpUri(scheme, authority, unencodedPath, queryParameters) {
      let userInfo = "";
      let host = null;
      let port = null;
      if (authority != null && dart.notNull(authority[dartx.isNotEmpty])) {
        let hostStart = 0;
        let hasUserInfo = false;
        for (let i = 0; i < dart.notNull(authority[dartx.length]); i++) {
          if (authority[dartx.codeUnitAt](i) == core.Uri._AT_SIGN) {
            hasUserInfo = true;
            userInfo = authority[dartx.substring](0, i);
            hostStart = i + 1;
            break;
          }
        }
        let hostEnd = hostStart;
        if (hostStart < dart.notNull(authority[dartx.length]) && authority[dartx.codeUnitAt](hostStart) == core.Uri._LEFT_BRACKET) {
          for (; hostEnd < dart.notNull(authority[dartx.length]); hostEnd++) {
            if (authority[dartx.codeUnitAt](hostEnd) == core.Uri._RIGHT_BRACKET) break;
          }
          if (hostEnd == authority[dartx.length]) {
            dart.throw(new core.FormatException("Invalid IPv6 host entry.", authority, hostStart));
          }
          core.Uri.parseIPv6Address(authority, hostStart + 1, hostEnd);
          hostEnd++;
          if (hostEnd != authority[dartx.length] && authority[dartx.codeUnitAt](hostEnd) != core.Uri._COLON) {
            dart.throw(new core.FormatException("Invalid end of authority", authority, hostEnd));
          }
        }
        let hasPort = false;
        for (; hostEnd < dart.notNull(authority[dartx.length]); hostEnd++) {
          if (authority[dartx.codeUnitAt](hostEnd) == core.Uri._COLON) {
            let portString = authority[dartx.substring](hostEnd + 1);
            if (dart.notNull(portString[dartx.isNotEmpty])) port = core.int.parse(portString);
            break;
          }
        }
        host = authority[dartx.substring](hostStart, hostEnd);
      }
      return core.Uri.new({scheme: scheme, userInfo: userInfo, host: dart.as(host, core.String), port: dart.as(port, core.int), pathSegments: unencodedPath[dartx.split]("/"), queryParameters: queryParameters});
    }
    static file(path, opts) {
      let windows = opts && 'windows' in opts ? opts.windows : null;
      windows = windows == null ? core.Uri._isWindows : windows;
      return dart.as(dart.notNull(windows) ? core.Uri._makeWindowsFileUrl(path, false) : core.Uri._makeFileUri(path, false), core.Uri);
    }
    static directory(path, opts) {
      let windows = opts && 'windows' in opts ? opts.windows : null;
      windows = windows == null ? core.Uri._isWindows : windows;
      return dart.as(dart.notNull(windows) ? core.Uri._makeWindowsFileUrl(path, true) : core.Uri._makeFileUri(path, true), core.Uri);
    }
    static dataFromString(content, opts) {
      let mimeType = opts && 'mimeType' in opts ? opts.mimeType : null;
      let encoding = opts && 'encoding' in opts ? opts.encoding : null;
      let parameters = opts && 'parameters' in opts ? opts.parameters : null;
      let base64 = opts && 'base64' in opts ? opts.base64 : false;
      let data = core.UriData.fromString(content, {mimeType: mimeType, encoding: encoding, parameters: parameters, base64: base64});
      return data.uri;
    }
    static dataFromBytes(bytes, opts) {
      let mimeType = opts && 'mimeType' in opts ? opts.mimeType : "application/octet-stream";
      let parameters = opts && 'parameters' in opts ? opts.parameters : null;
      let percentEncoded = opts && 'percentEncoded' in opts ? opts.percentEncoded : false;
      let data = core.UriData.fromBytes(bytes, {mimeType: mimeType, parameters: parameters, percentEncoded: percentEncoded});
      return data.uri;
    }
    static get base() {
      let uri = _js_helper.Primitives.currentUri();
      if (uri != null) return core.Uri.parse(uri);
      dart.throw(new core.UnsupportedError("'Uri.base' is not supported"));
    }
    static get _isWindows() {
      return false;
    }
    static _checkNonWindowsPathReservedCharacters(segments, argumentError) {
      segments[dartx.forEach](dart.fn(segment => {
        if (dart.notNull(segment[dartx.contains]("/"))) {
          if (dart.notNull(argumentError)) {
            dart.throw(new core.ArgumentError(`Illegal path character ${segment}`));
          } else {
            dart.throw(new core.UnsupportedError(`Illegal path character ${segment}`));
          }
        }
      }, dart.void, [core.String]));
    }
    static _checkWindowsPathReservedCharacters(segments, argumentError, firstSegment) {
      if (firstSegment === void 0) firstSegment = 0;
      for (let segment of segments[dartx.skip](firstSegment)) {
        if (dart.notNull(segment[dartx.contains](core.RegExp.new('["*/:<>?\\\\|]')))) {
          if (dart.notNull(argumentError)) {
            dart.throw(new core.ArgumentError("Illegal character in path"));
          } else {
            dart.throw(new core.UnsupportedError("Illegal character in path"));
          }
        }
      }
    }
    static _checkWindowsDriveLetter(charCode, argumentError) {
      if (dart.notNull(core.Uri._UPPER_CASE_A) <= dart.notNull(charCode) && dart.notNull(charCode) <= dart.notNull(core.Uri._UPPER_CASE_Z) || dart.notNull(core.Uri._LOWER_CASE_A) <= dart.notNull(charCode) && dart.notNull(charCode) <= dart.notNull(core.Uri._LOWER_CASE_Z)) {
        return;
      }
      if (dart.notNull(argumentError)) {
        dart.throw(new core.ArgumentError("Illegal drive letter " + core.String.fromCharCode(charCode)));
      } else {
        dart.throw(new core.UnsupportedError("Illegal drive letter " + core.String.fromCharCode(charCode)));
      }
    }
    static _makeFileUri(path, slashTerminated) {
      let sep = "/";
      let segments = path[dartx.split](sep);
      if (dart.notNull(slashTerminated) && dart.notNull(segments[dartx.isNotEmpty]) && dart.notNull(segments[dartx.last][dartx.isNotEmpty])) {
        segments[dartx.add]("");
      }
      if (dart.notNull(path[dartx.startsWith](sep))) {
        return core.Uri.new({scheme: "file", pathSegments: segments});
      } else {
        return core.Uri.new({pathSegments: segments});
      }
    }
    static _makeWindowsFileUrl(path, slashTerminated) {
      if (dart.notNull(path[dartx.startsWith]("\\\\?\\"))) {
        if (dart.notNull(path[dartx.startsWith]("UNC\\", 4))) {
          path = path[dartx.replaceRange](0, 7, '\\');
        } else {
          path = path[dartx.substring](4);
          if (dart.notNull(path[dartx.length]) < 3 || path[dartx.codeUnitAt](1) != core.Uri._COLON || path[dartx.codeUnitAt](2) != core.Uri._BACKSLASH) {
            dart.throw(new core.ArgumentError("Windows paths with \\\\?\\ prefix must be absolute"));
          }
        }
      } else {
        path = path[dartx.replaceAll]("/", '\\');
      }
      let sep = '\\';
      if (dart.notNull(path[dartx.length]) > 1 && path[dartx.codeUnitAt](1) == core.Uri._COLON) {
        core.Uri._checkWindowsDriveLetter(path[dartx.codeUnitAt](0), true);
        if (path[dartx.length] == 2 || path[dartx.codeUnitAt](2) != core.Uri._BACKSLASH) {
          dart.throw(new core.ArgumentError("Windows paths with drive letter must be absolute"));
        }
        let pathSegments = path[dartx.split](sep);
        if (dart.notNull(slashTerminated) && dart.notNull(pathSegments[dartx.last][dartx.isNotEmpty])) {
          pathSegments[dartx.add]("");
        }
        core.Uri._checkWindowsPathReservedCharacters(pathSegments, true, 1);
        return core.Uri.new({scheme: "file", pathSegments: pathSegments});
      }
      if (dart.notNull(path[dartx.startsWith](sep))) {
        if (dart.notNull(path[dartx.startsWith](sep, 1))) {
          let pathStart = path[dartx.indexOf]('\\', 2);
          let hostPart = dart.notNull(pathStart) < 0 ? path[dartx.substring](2) : path[dartx.substring](2, pathStart);
          let pathPart = dart.notNull(pathStart) < 0 ? "" : path[dartx.substring](dart.notNull(pathStart) + 1);
          let pathSegments = pathPart[dartx.split](sep);
          core.Uri._checkWindowsPathReservedCharacters(pathSegments, true);
          if (dart.notNull(slashTerminated) && dart.notNull(pathSegments[dartx.last][dartx.isNotEmpty])) {
            pathSegments[dartx.add]("");
          }
          return core.Uri.new({scheme: "file", host: hostPart, pathSegments: pathSegments});
        } else {
          let pathSegments = path[dartx.split](sep);
          if (dart.notNull(slashTerminated) && dart.notNull(pathSegments[dartx.last][dartx.isNotEmpty])) {
            pathSegments[dartx.add]("");
          }
          core.Uri._checkWindowsPathReservedCharacters(pathSegments, true);
          return core.Uri.new({scheme: "file", pathSegments: pathSegments});
        }
      } else {
        let pathSegments = path[dartx.split](sep);
        core.Uri._checkWindowsPathReservedCharacters(pathSegments, true);
        if (dart.notNull(slashTerminated) && dart.notNull(pathSegments[dartx.isNotEmpty]) && dart.notNull(pathSegments[dartx.last][dartx.isNotEmpty])) {
          pathSegments[dartx.add]("");
        }
        return core.Uri.new({pathSegments: pathSegments});
      }
    }
    replace(opts) {
      let scheme = opts && 'scheme' in opts ? opts.scheme : null;
      let userInfo = opts && 'userInfo' in opts ? opts.userInfo : null;
      let host = opts && 'host' in opts ? opts.host : null;
      let port = opts && 'port' in opts ? opts.port : null;
      let path = opts && 'path' in opts ? opts.path : null;
      let pathSegments = opts && 'pathSegments' in opts ? opts.pathSegments : null;
      let query = opts && 'query' in opts ? opts.query : null;
      let queryParameters = opts && 'queryParameters' in opts ? opts.queryParameters : null;
      let fragment = opts && 'fragment' in opts ? opts.fragment : null;
      let schemeChanged = false;
      if (scheme != null) {
        scheme = core.Uri._makeScheme(scheme, 0, scheme[dartx.length]);
        schemeChanged = true;
      } else {
        scheme = this.scheme;
      }
      let isFile = scheme == "file";
      if (userInfo != null) {
        userInfo = core.Uri._makeUserInfo(userInfo, 0, userInfo[dartx.length]);
      } else {
        userInfo = this[_userInfo];
      }
      if (port != null) {
        port = core.Uri._makePort(port, scheme);
      } else {
        port = this[_port];
        if (schemeChanged) {
          port = core.Uri._makePort(port, scheme);
        }
      }
      if (host != null) {
        host = core.Uri._makeHost(host, 0, host[dartx.length], false);
      } else if (dart.notNull(this.hasAuthority)) {
        host = this[_host];
      } else if (dart.notNull(userInfo[dartx.isNotEmpty]) || port != null || isFile) {
        host = "";
      }
      let hasAuthority = host != null;
      if (path != null || pathSegments != null) {
        path = core.Uri._makePath(path, 0, core.Uri._stringOrNullLength(path), pathSegments, scheme, hasAuthority);
      } else {
        path = this[_path];
        if ((isFile || hasAuthority && !dart.notNull(path[dartx.isEmpty])) && !dart.notNull(path[dartx.startsWith]('/'))) {
          path = "/" + dart.notNull(path);
        }
      }
      if (query != null || queryParameters != null) {
        query = core.Uri._makeQuery(query, 0, core.Uri._stringOrNullLength(query), queryParameters);
      } else {
        query = this[_query];
      }
      if (fragment != null) {
        fragment = core.Uri._makeFragment(fragment, 0, fragment[dartx.length]);
      } else {
        fragment = this[_fragment];
      }
      return new core.Uri._internal(scheme, userInfo, host, port, path, query, fragment);
    }
    removeFragment() {
      if (!dart.notNull(this.hasFragment)) return this;
      return new core.Uri._internal(this.scheme, this[_userInfo], this[_host], this[_port], this[_path], this[_query], null);
    }
    get pathSegments() {
      let result = this[_pathSegments];
      if (result != null) return result;
      let pathToSplit = this.path;
      if (dart.notNull(pathToSplit[dartx.isNotEmpty]) && pathToSplit[dartx.codeUnitAt](0) == core.Uri._SLASH) {
        pathToSplit = pathToSplit[dartx.substring](1);
      }
      result = pathToSplit == "" ? dart.const(dart.list([], core.String)) : core.List$(core.String).unmodifiable(pathToSplit[dartx.split]("/")[dartx.map](core.String)(core.Uri.decodeComponent));
      this[_pathSegments] = result;
      return result;
    }
    get queryParameters() {
      if (this[_queryParameters] == null) {
        this[_queryParameters] = new (collection.UnmodifiableMapView$(core.String, core.String))(core.Uri.splitQueryString(this.query));
      }
      return this[_queryParameters];
    }
    get queryParametersAll() {
      if (this[_queryParameterLists] == null) {
        let queryParameterLists = core.Uri._splitQueryStringAll(this.query);
        for (let key of queryParameterLists[dartx.keys]) {
          queryParameterLists[dartx.set](key, core.List$(core.String).unmodifiable(dart.as(queryParameterLists[dartx.get](key), core.Iterable)));
        }
        this[_queryParameterLists] = core.Map$(core.String, core.List$(core.String)).unmodifiable(queryParameterLists);
      }
      return this[_queryParameterLists];
    }
    normalizePath() {
      let path = core.Uri._normalizePath(this[_path], this.scheme, this.hasAuthority);
      if (core.identical(path, this[_path])) return this;
      return this.replace({path: path});
    }
    static _makePort(port, scheme) {
      if (port != null && port == core.Uri._defaultPort(scheme)) return null;
      return port;
    }
    static _makeHost(host, start, end, strictIPv6) {
      if (host == null) return null;
      if (start == end) return "";
      if (host[dartx.codeUnitAt](start) == core.Uri._LEFT_BRACKET) {
        if (host[dartx.codeUnitAt](dart.notNull(end) - 1) != core.Uri._RIGHT_BRACKET) {
          core.Uri._fail(host, start, 'Missing end `]` to match `[` in host');
        }
        core.Uri.parseIPv6Address(host, dart.notNull(start) + 1, dart.notNull(end) - 1);
        return host[dartx.substring](start, end)[dartx.toLowerCase]();
      }
      if (!dart.notNull(strictIPv6)) {
        for (let i = start; dart.notNull(i) < dart.notNull(end); i = dart.notNull(i) + 1) {
          if (host[dartx.codeUnitAt](i) == core.Uri._COLON) {
            core.Uri.parseIPv6Address(host, start, end);
            return `[${host}]`;
          }
        }
      }
      return core.Uri._normalizeRegName(host, start, end);
    }
    static _isRegNameChar(char) {
      return dart.notNull(char) < 127 && (dart.notNull(core.Uri._regNameTable[dartx.get](char[dartx['>>']](4))) & 1 << (dart.notNull(char) & 15)) != 0;
    }
    static _normalizeRegName(host, start, end) {
      let buffer = null;
      let sectionStart = start;
      let index = start;
      let isNormalized = true;
      while (dart.notNull(index) < dart.notNull(end)) {
        let char = host[dartx.codeUnitAt](index);
        if (char == core.Uri._PERCENT) {
          let replacement = core.Uri._normalizeEscape(host, index, true);
          if (replacement == null && isNormalized) {
            index = dart.notNull(index) + 3;
            continue;
          }
          if (buffer == null) buffer = new core.StringBuffer();
          let slice = host[dartx.substring](sectionStart, index);
          if (!isNormalized) slice = slice[dartx.toLowerCase]();
          buffer.write(slice);
          let sourceLength = 3;
          if (replacement == null) {
            replacement = host[dartx.substring](index, dart.notNull(index) + 3);
          } else if (replacement == "%") {
            replacement = "%25";
            sourceLength = 1;
          }
          buffer.write(replacement);
          index = dart.notNull(index) + sourceLength;
          sectionStart = index;
          isNormalized = true;
        } else if (dart.notNull(core.Uri._isRegNameChar(char))) {
          if (isNormalized && dart.notNull(core.Uri._UPPER_CASE_A) <= dart.notNull(char) && dart.notNull(core.Uri._UPPER_CASE_Z) >= dart.notNull(char)) {
            if (buffer == null) buffer = new core.StringBuffer();
            if (dart.notNull(sectionStart) < dart.notNull(index)) {
              buffer.write(host[dartx.substring](sectionStart, index));
              sectionStart = index;
            }
            isNormalized = false;
          }
          index = dart.notNull(index) + 1;
        } else if (dart.notNull(core.Uri._isGeneralDelimiter(char))) {
          core.Uri._fail(host, index, "Invalid character");
        } else {
          let sourceLength = 1;
          if ((dart.notNull(char) & 64512) == 55296 && dart.notNull(index) + 1 < dart.notNull(end)) {
            let tail = host[dartx.codeUnitAt](dart.notNull(index) + 1);
            if ((dart.notNull(tail) & 64512) == 56320) {
              char = 65536 | (dart.notNull(char) & 1023) << 10 | dart.notNull(tail) & 1023;
              sourceLength = 2;
            }
          }
          if (buffer == null) buffer = new core.StringBuffer();
          let slice = host[dartx.substring](sectionStart, index);
          if (!isNormalized) slice = slice[dartx.toLowerCase]();
          buffer.write(slice);
          buffer.write(core.Uri._escapeChar(char));
          index = dart.notNull(index) + sourceLength;
          sectionStart = index;
        }
      }
      if (buffer == null) return host[dartx.substring](start, end);
      if (dart.notNull(sectionStart) < dart.notNull(end)) {
        let slice = host[dartx.substring](sectionStart, end);
        if (!isNormalized) slice = slice[dartx.toLowerCase]();
        buffer.write(slice);
      }
      return dart.toString(buffer);
    }
    static _makeScheme(scheme, start, end) {
      if (start == end) return "";
      let firstCodeUnit = scheme[dartx.codeUnitAt](start);
      if (!dart.notNull(core.Uri._isAlphabeticCharacter(firstCodeUnit))) {
        core.Uri._fail(scheme, start, "Scheme not starting with alphabetic character");
      }
      let containsUpperCase = false;
      for (let i = start; dart.notNull(i) < dart.notNull(end); i = dart.notNull(i) + 1) {
        let codeUnit = scheme[dartx.codeUnitAt](i);
        if (!dart.notNull(core.Uri._isSchemeCharacter(codeUnit))) {
          core.Uri._fail(scheme, i, "Illegal scheme character");
        }
        if (dart.notNull(core.Uri._UPPER_CASE_A) <= dart.notNull(codeUnit) && dart.notNull(codeUnit) <= dart.notNull(core.Uri._UPPER_CASE_Z)) {
          containsUpperCase = true;
        }
      }
      scheme = scheme[dartx.substring](start, end);
      if (containsUpperCase) scheme = scheme[dartx.toLowerCase]();
      return scheme;
    }
    static _makeUserInfo(userInfo, start, end) {
      if (userInfo == null) return "";
      return core.Uri._normalize(userInfo, start, end, core.Uri._userinfoTable);
    }
    static _makePath(path, start, end, pathSegments, scheme, hasAuthority) {
      let isFile = scheme == "file";
      let ensureLeadingSlash = isFile || dart.notNull(hasAuthority);
      if (path == null && pathSegments == null) return isFile ? "/" : "";
      if (path != null && pathSegments != null) {
        dart.throw(new core.ArgumentError('Both path and pathSegments specified'));
      }
      let result = null;
      if (path != null) {
        result = core.Uri._normalize(path, start, end, core.Uri._pathCharOrSlashTable);
      } else {
        result = pathSegments[dartx.map](core.String)(dart.fn(s => core.Uri._uriEncode(core.Uri._pathCharTable, s, convert.UTF8, false), core.String, [core.String]))[dartx.join]("/");
      }
      if (dart.test(dart.dload(result, 'isEmpty'))) {
        if (isFile) return "/";
      } else if (ensureLeadingSlash && !dart.test(dart.dsend(result, 'startsWith', '/'))) {
        result = "/" + dart.notNull(dart.as(result, core.String));
      }
      result = core.Uri._normalizePath(dart.as(result, core.String), scheme, hasAuthority);
      return dart.as(result, core.String);
    }
    static _normalizePath(path, scheme, hasAuthority) {
      if (dart.notNull(scheme[dartx.isEmpty]) && !dart.notNull(hasAuthority) && !dart.notNull(path[dartx.startsWith]('/'))) {
        return core.Uri._normalizeRelativePath(path);
      }
      return core.Uri._removeDotSegments(path);
    }
    static _makeQuery(query, start, end, queryParameters) {
      if (query == null && queryParameters == null) return null;
      if (query != null && queryParameters != null) {
        dart.throw(new core.ArgumentError('Both query and queryParameters specified'));
      }
      if (query != null) return core.Uri._normalize(query, start, end, core.Uri._queryCharTable);
      let result = new core.StringBuffer();
      let separator = "";
      function writeParameter(key, value) {
        result.write(separator);
        separator = "&";
        result.write(core.Uri.encodeQueryComponent(key));
        if (value != null && dart.notNull(value[dartx.isNotEmpty])) {
          result.write("=");
          result.write(core.Uri.encodeQueryComponent(value));
        }
      }
      dart.fn(writeParameter, dart.void, [core.String, core.String]);
      queryParameters[dartx.forEach](dart.fn((key, value) => {
        if (value == null || typeof value == 'string') {
          writeParameter(key, dart.as(value, core.String));
        } else {
          let values = dart.as(value, core.Iterable);
          for (let value of values) {
            dart.as(value, core.String);
            writeParameter(key, value);
          }
        }
      }, dart.void, [core.String, dart.dynamic]));
      return result.toString();
    }
    static _makeFragment(fragment, start, end) {
      if (fragment == null) return null;
      return core.Uri._normalize(fragment, start, end, core.Uri._queryCharTable);
    }
    static _stringOrNullLength(s) {
      return s == null ? 0 : s[dartx.length];
    }
    static _normalizeEscape(source, index, lowerCase) {
      dart.assert(source[dartx.codeUnitAt](index) == core.Uri._PERCENT);
      if (dart.notNull(index) + 2 >= dart.notNull(source[dartx.length])) {
        return "%";
      }
      let firstDigit = source[dartx.codeUnitAt](dart.notNull(index) + 1);
      let secondDigit = source[dartx.codeUnitAt](dart.notNull(index) + 2);
      let firstDigitValue = core.Uri._parseHexDigit(firstDigit);
      let secondDigitValue = core.Uri._parseHexDigit(secondDigit);
      if (dart.notNull(firstDigitValue) < 0 || dart.notNull(secondDigitValue) < 0) {
        return "%";
      }
      let value = dart.notNull(firstDigitValue) * 16 + dart.notNull(secondDigitValue);
      if (dart.notNull(core.Uri._isUnreservedChar(value))) {
        if (dart.notNull(lowerCase) && dart.notNull(core.Uri._UPPER_CASE_A) <= value && dart.notNull(core.Uri._UPPER_CASE_Z) >= value) {
          value = (value | 32) >>> 0;
        }
        return core.String.fromCharCode(value);
      }
      if (dart.notNull(firstDigit) >= dart.notNull(core.Uri._LOWER_CASE_A) || dart.notNull(secondDigit) >= dart.notNull(core.Uri._LOWER_CASE_A)) {
        return source[dartx.substring](index, dart.notNull(index) + 3)[dartx.toUpperCase]();
      }
      return null;
    }
    static _parseHexDigit(char) {
      let digit = (dart.notNull(char) ^ dart.notNull(core.Uri._ZERO)) >>> 0;
      if (digit <= 9) return digit;
      let lowerCase = (dart.notNull(char) | 32) >>> 0;
      if (dart.notNull(core.Uri._LOWER_CASE_A) <= lowerCase && lowerCase <= dart.notNull(core.Uri._LOWER_CASE_F)) {
        return lowerCase - (dart.notNull(core.Uri._LOWER_CASE_A) - 10);
      }
      return -1;
    }
    static _escapeChar(char) {
      dart.assert(dart.notNull(char) <= 1114111);
      let codeUnits = null;
      if (dart.notNull(char) < 128) {
        codeUnits = core.List$(core.int).new(3);
        codeUnits[dartx.set](0, core.Uri._PERCENT);
        codeUnits[dartx.set](1, core.Uri._hexDigits[dartx.codeUnitAt](char[dartx['>>']](4)));
        codeUnits[dartx.set](2, core.Uri._hexDigits[dartx.codeUnitAt](dart.notNull(char) & 15));
      } else {
        let flag = 192;
        let encodedBytes = 2;
        if (dart.notNull(char) > 2047) {
          flag = 224;
          encodedBytes = 3;
          if (dart.notNull(char) > 65535) {
            encodedBytes = 4;
            flag = 240;
          }
        }
        codeUnits = core.List$(core.int).new(3 * encodedBytes);
        let index = 0;
        while (--encodedBytes >= 0) {
          let byte = (char[dartx['>>']](6 * encodedBytes) & 63 | flag) >>> 0;
          codeUnits[dartx.set](index, core.Uri._PERCENT);
          codeUnits[dartx.set](index + 1, core.Uri._hexDigits[dartx.codeUnitAt](byte[dartx['>>']](4)));
          codeUnits[dartx.set](index + 2, core.Uri._hexDigits[dartx.codeUnitAt](byte & 15));
          index = index + 3;
          flag = 128;
        }
      }
      return core.String.fromCharCodes(codeUnits);
    }
    static _normalize(component, start, end, charTable) {
      let buffer = null;
      let sectionStart = start;
      let index = start;
      while (dart.notNull(index) < dart.notNull(end)) {
        let char = component[dartx.codeUnitAt](index);
        if (dart.notNull(char) < 127 && (dart.notNull(charTable[dartx.get](char[dartx['>>']](4))) & 1 << (dart.notNull(char) & 15)) != 0) {
          index = dart.notNull(index) + 1;
        } else {
          let replacement = null;
          let sourceLength = null;
          if (char == core.Uri._PERCENT) {
            replacement = core.Uri._normalizeEscape(component, index, false);
            if (replacement == null) {
              index = dart.notNull(index) + 3;
              continue;
            }
            if ("%" == replacement) {
              replacement = "%25";
              sourceLength = 1;
            } else {
              sourceLength = 3;
            }
          } else if (dart.notNull(core.Uri._isGeneralDelimiter(char))) {
            core.Uri._fail(component, index, "Invalid character");
          } else {
            sourceLength = 1;
            if ((dart.notNull(char) & 64512) == 55296) {
              if (dart.notNull(index) + 1 < dart.notNull(end)) {
                let tail = component[dartx.codeUnitAt](dart.notNull(index) + 1);
                if ((dart.notNull(tail) & 64512) == 56320) {
                  sourceLength = 2;
                  char = 65536 | (dart.notNull(char) & 1023) << 10 | dart.notNull(tail) & 1023;
                }
              }
            }
            replacement = core.Uri._escapeChar(char);
          }
          if (buffer == null) buffer = new core.StringBuffer();
          buffer.write(component[dartx.substring](sectionStart, index));
          buffer.write(replacement);
          index = dart.notNull(index) + dart.notNull(sourceLength);
          sectionStart = index;
        }
      }
      if (buffer == null) {
        return component[dartx.substring](start, end);
      }
      if (dart.notNull(sectionStart) < dart.notNull(end)) {
        buffer.write(component[dartx.substring](sectionStart, end));
      }
      return dart.toString(buffer);
    }
    static _isSchemeCharacter(ch) {
      return dart.notNull(ch) < 128 && (dart.notNull(core.Uri._schemeTable[dartx.get](ch[dartx['>>']](4))) & 1 << (dart.notNull(ch) & 15)) != 0;
    }
    static _isGeneralDelimiter(ch) {
      return dart.notNull(ch) <= dart.notNull(core.Uri._RIGHT_BRACKET) && (dart.notNull(core.Uri._genDelimitersTable[dartx.get](ch[dartx['>>']](4))) & 1 << (dart.notNull(ch) & 15)) != 0;
    }
    get isAbsolute() {
      return this.scheme != "" && this.fragment == "";
    }
    [_mergePaths](base, reference) {
      let backCount = 0;
      let refStart = 0;
      while (dart.notNull(reference[dartx.startsWith]("../", refStart))) {
        refStart = refStart + 3;
        backCount++;
      }
      let baseEnd = base[dartx.lastIndexOf]('/');
      while (dart.notNull(baseEnd) > 0 && backCount > 0) {
        let newEnd = base[dartx.lastIndexOf]('/', dart.notNull(baseEnd) - 1);
        if (dart.notNull(newEnd) < 0) {
          break;
        }
        let delta = dart.notNull(baseEnd) - dart.notNull(newEnd);
        if ((delta == 2 || delta == 3) && base[dartx.codeUnitAt](dart.notNull(newEnd) + 1) == core.Uri._DOT && (delta == 2 || base[dartx.codeUnitAt](dart.notNull(newEnd) + 2) == core.Uri._DOT)) {
          break;
        }
        baseEnd = newEnd;
        backCount--;
      }
      return base[dartx.replaceRange](dart.notNull(baseEnd) + 1, null, reference[dartx.substring](refStart - 3 * backCount));
    }
    static _mayContainDotSegments(path) {
      if (dart.notNull(path[dartx.startsWith]('.'))) return true;
      let index = path[dartx.indexOf]("/.");
      return index != -1;
    }
    static _removeDotSegments(path) {
      if (!dart.notNull(core.Uri._mayContainDotSegments(path))) return path;
      dart.assert(path[dartx.isNotEmpty]);
      let output = dart.list([], core.String);
      let appendSlash = false;
      for (let segment of path[dartx.split]("/")) {
        appendSlash = false;
        if (segment == "..") {
          if (dart.notNull(output[dartx.isNotEmpty])) {
            output[dartx.removeLast]();
            if (dart.notNull(output[dartx.isEmpty])) {
              output[dartx.add]("");
            }
          }
          appendSlash = true;
        } else if ("." == segment) {
          appendSlash = true;
        } else {
          output[dartx.add](segment);
        }
      }
      if (appendSlash) output[dartx.add]("");
      return output[dartx.join]("/");
    }
    static _normalizeRelativePath(path) {
      dart.assert(!dart.notNull(path[dartx.startsWith]('/')));
      if (!dart.notNull(core.Uri._mayContainDotSegments(path))) return path;
      dart.assert(path[dartx.isNotEmpty]);
      let output = dart.list([], core.String);
      let appendSlash = false;
      for (let segment of path[dartx.split]("/")) {
        appendSlash = false;
        if (".." == segment) {
          if (!dart.notNull(output[dartx.isEmpty]) && output[dartx.last] != "..") {
            output[dartx.removeLast]();
            appendSlash = true;
          } else {
            output[dartx.add]("..");
          }
        } else if ("." == segment) {
          appendSlash = true;
        } else {
          output[dartx.add](segment);
        }
      }
      if (dart.notNull(output[dartx.isEmpty]) || output[dartx.length] == 1 && dart.notNull(output[dartx.get](0)[dartx.isEmpty])) {
        return "./";
      }
      if (appendSlash || output[dartx.last] == '..') output[dartx.add]("");
      return output[dartx.join]("/");
    }
    resolve(reference) {
      return this.resolveUri(core.Uri.parse(reference));
    }
    resolveUri(reference) {
      let targetScheme = null;
      let targetUserInfo = "";
      let targetHost = null;
      let targetPort = null;
      let targetPath = null;
      let targetQuery = null;
      if (dart.notNull(reference.scheme[dartx.isNotEmpty])) {
        targetScheme = reference.scheme;
        if (dart.notNull(reference.hasAuthority)) {
          targetUserInfo = reference.userInfo;
          targetHost = reference.host;
          targetPort = dart.notNull(reference.hasPort) ? reference.port : null;
        }
        targetPath = core.Uri._removeDotSegments(reference.path);
        if (dart.notNull(reference.hasQuery)) {
          targetQuery = reference.query;
        }
      } else {
        targetScheme = this.scheme;
        if (dart.notNull(reference.hasAuthority)) {
          targetUserInfo = reference.userInfo;
          targetHost = reference.host;
          targetPort = core.Uri._makePort(dart.notNull(reference.hasPort) ? reference.port : null, targetScheme);
          targetPath = core.Uri._removeDotSegments(reference.path);
          if (dart.notNull(reference.hasQuery)) targetQuery = reference.query;
        } else {
          targetUserInfo = this[_userInfo];
          targetHost = this[_host];
          targetPort = this[_port];
          if (reference.path == "") {
            targetPath = this[_path];
            if (dart.notNull(reference.hasQuery)) {
              targetQuery = reference.query;
            } else {
              targetQuery = this[_query];
            }
          } else {
            if (dart.notNull(reference.hasAbsolutePath)) {
              targetPath = core.Uri._removeDotSegments(reference.path);
            } else {
              if (dart.notNull(this.hasEmptyPath)) {
                if (!dart.notNull(this.hasScheme) && !dart.notNull(this.hasAuthority)) {
                  targetPath = reference.path;
                } else {
                  targetPath = core.Uri._removeDotSegments("/" + dart.notNull(reference.path));
                }
              } else {
                let mergedPath = this[_mergePaths](this[_path], reference.path);
                if (dart.notNull(this.hasScheme) || dart.notNull(this.hasAuthority) || dart.notNull(this.hasAbsolutePath)) {
                  targetPath = core.Uri._removeDotSegments(mergedPath);
                } else {
                  targetPath = core.Uri._normalizeRelativePath(mergedPath);
                }
              }
            }
            if (dart.notNull(reference.hasQuery)) targetQuery = reference.query;
          }
        }
      }
      let fragment = dart.notNull(reference.hasFragment) ? reference.fragment : null;
      return new core.Uri._internal(targetScheme, targetUserInfo, targetHost, targetPort, targetPath, targetQuery, fragment);
    }
    get hasScheme() {
      return this.scheme[dartx.isNotEmpty];
    }
    get hasAuthority() {
      return this[_host] != null;
    }
    get hasPort() {
      return this[_port] != null;
    }
    get hasQuery() {
      return this[_query] != null;
    }
    get hasFragment() {
      return this[_fragment] != null;
    }
    get hasEmptyPath() {
      return this[_path][dartx.isEmpty];
    }
    get hasAbsolutePath() {
      return this[_path][dartx.startsWith]('/');
    }
    get origin() {
      if (this.scheme == "" || this[_host] == null || this[_host] == "") {
        dart.throw(new core.StateError(`Cannot use origin without a scheme: ${this}`));
      }
      if (this.scheme != "http" && this.scheme != "https") {
        dart.throw(new core.StateError(`Origin is only applicable schemes http and https: ${this}`));
      }
      if (this[_port] == null) return `${this.scheme}://${this[_host]}`;
      return `${this.scheme}://${this[_host]}:${this[_port]}`;
    }
    toFilePath(opts) {
      let windows = opts && 'windows' in opts ? opts.windows : null;
      if (this.scheme != "" && this.scheme != "file") {
        dart.throw(new core.UnsupportedError(`Cannot extract a file path from a ${this.scheme} URI`));
      }
      if (this.query != "") {
        dart.throw(new core.UnsupportedError("Cannot extract a file path from a URI with a query component"));
      }
      if (this.fragment != "") {
        dart.throw(new core.UnsupportedError("Cannot extract a file path from a URI with a fragment component"));
      }
      if (windows == null) windows = core.Uri._isWindows;
      return dart.notNull(windows) ? this[_toWindowsFilePath]() : this[_toFilePath]();
    }
    [_toFilePath]() {
      if (this.host != "") {
        dart.throw(new core.UnsupportedError("Cannot extract a non-Windows file path from a file URI " + "with an authority"));
      }
      core.Uri._checkNonWindowsPathReservedCharacters(this.pathSegments, false);
      let result = new core.StringBuffer();
      if (dart.notNull(this[_isPathAbsolute])) result.write("/");
      result.writeAll(this.pathSegments, "/");
      return result.toString();
    }
    [_toWindowsFilePath]() {
      let hasDriveLetter = false;
      let segments = this.pathSegments;
      if (dart.notNull(segments[dartx.length]) > 0 && segments[dartx.get](0)[dartx.length] == 2 && segments[dartx.get](0)[dartx.codeUnitAt](1) == core.Uri._COLON) {
        core.Uri._checkWindowsDriveLetter(segments[dartx.get](0)[dartx.codeUnitAt](0), false);
        core.Uri._checkWindowsPathReservedCharacters(segments, false, 1);
        hasDriveLetter = true;
      } else {
        core.Uri._checkWindowsPathReservedCharacters(segments, false);
      }
      let result = new core.StringBuffer();
      if (dart.notNull(this[_isPathAbsolute]) && !hasDriveLetter) result.write("\\");
      if (this.host != "") {
        result.write("\\");
        result.write(this.host);
        result.write("\\");
      }
      result.writeAll(segments, "\\");
      if (hasDriveLetter && segments[dartx.length] == 1) result.write("\\");
      return result.toString();
    }
    get [_isPathAbsolute]() {
      if (this.path == null || dart.notNull(this.path[dartx.isEmpty])) return false;
      return this.path[dartx.startsWith]('/');
    }
    [_writeAuthority](ss) {
      if (dart.notNull(this[_userInfo][dartx.isNotEmpty])) {
        ss.write(this[_userInfo]);
        ss.write("@");
      }
      if (this[_host] != null) ss.write(this[_host]);
      if (this[_port] != null) {
        ss.write(":");
        ss.write(this[_port]);
      }
    }
    get data() {
      return this.scheme == "data" ? core.UriData.fromUri(this) : null;
    }
    toString() {
      let sb = new core.StringBuffer();
      core.Uri._addIfNonEmpty(sb, this.scheme, this.scheme, ':');
      if (dart.notNull(this.hasAuthority) || dart.notNull(this.path[dartx.startsWith]("//")) || this.scheme == "file") {
        sb.write("//");
        this[_writeAuthority](sb);
      }
      sb.write(this.path);
      if (this[_query] != null) {
        sb.write("?");
        sb.write(this[_query]);
      }
      if (this[_fragment] != null) {
        sb.write("#");
        sb.write(this[_fragment]);
      }
      return sb.toString();
    }
    ['=='](other) {
      if (!dart.is(other, core.Uri)) return false;
      let uri = dart.as(other, core.Uri);
      return this.scheme == uri.scheme && this.hasAuthority == uri.hasAuthority && this.userInfo == uri.userInfo && this.host == uri.host && this.port == uri.port && this.path == uri.path && this.hasQuery == uri.hasQuery && this.query == uri.query && this.hasFragment == uri.hasFragment && this.fragment == uri.fragment;
    }
    get hashCode() {
      function combine(part, current) {
        return dart.as(dart.dsend(dart.dsend(dart.dsend(current, '*', 31), '+', dart.hashCode(part)), '&', 1073741823), core.int);
      }
      dart.fn(combine, core.int, [dart.dynamic, dart.dynamic]);
      return combine(this.scheme, combine(this.userInfo, combine(this.host, combine(this.port, combine(this.path, combine(this.query, combine(this.fragment, 1)))))));
    }
    static _addIfNonEmpty(sb, test, first, second) {
      if ("" != test) {
        sb.write(first);
        sb.write(second);
      }
    }
    static encodeComponent(component) {
      return core.Uri._uriEncode(core.Uri._unreserved2396Table, component, convert.UTF8, false);
    }
    static encodeQueryComponent(component, opts) {
      let encoding = opts && 'encoding' in opts ? opts.encoding : convert.UTF8;
      return core.Uri._uriEncode(core.Uri._unreservedTable, component, encoding, true);
    }
    static decodeComponent(encodedComponent) {
      return core.Uri._uriDecode(encodedComponent, 0, encodedComponent[dartx.length], convert.UTF8, false);
    }
    static decodeQueryComponent(encodedComponent, opts) {
      let encoding = opts && 'encoding' in opts ? opts.encoding : convert.UTF8;
      return core.Uri._uriDecode(encodedComponent, 0, encodedComponent[dartx.length], encoding, true);
    }
    static encodeFull(uri) {
      return core.Uri._uriEncode(core.Uri._encodeFullTable, uri, convert.UTF8, false);
    }
    static decodeFull(uri) {
      return core.Uri._uriDecode(uri, 0, uri[dartx.length], convert.UTF8, false);
    }
    static splitQueryString(query, opts) {
      let encoding = opts && 'encoding' in opts ? opts.encoding : convert.UTF8;
      return query[dartx.split]("&")[dartx.fold](core.Map$(core.String, core.String))(dart.map(), dart.fn((map, element) => {
        let index = element[dartx.indexOf]("=");
        if (index == -1) {
          if (element != "") {
            map[dartx.set](core.Uri.decodeQueryComponent(element, {encoding: encoding}), "");
          }
        } else if (index != 0) {
          let key = element[dartx.substring](0, index);
          let value = element[dartx.substring](dart.notNull(index) + 1);
          map[dartx.set](core.Uri.decodeQueryComponent(key, {encoding: encoding}), core.Uri.decodeQueryComponent(value, {encoding: encoding}));
        }
        return map;
      }, core.Map$(core.String, core.String), [core.Map$(core.String, core.String), core.String]));
    }
    static _createList() {
      return [];
    }
    static _splitQueryStringAll(query, opts) {
      let encoding = opts && 'encoding' in opts ? opts.encoding : convert.UTF8;
      let result = dart.map();
      let i = 0;
      let start = 0;
      let equalsIndex = -1;
      function parsePair(start, equalsIndex, end) {
        let key = null;
        let value = null;
        if (start == end) return;
        if (dart.notNull(equalsIndex) < 0) {
          key = core.Uri._uriDecode(query, start, end, encoding, true);
          value = "";
        } else {
          key = core.Uri._uriDecode(query, start, equalsIndex, encoding, true);
          value = core.Uri._uriDecode(query, dart.notNull(equalsIndex) + 1, end, encoding, true);
        }
        dart.dsend(result[dartx.putIfAbsent](key, core.Uri._createList), 'add', value);
      }
      dart.fn(parsePair, dart.void, [core.int, core.int, core.int]);
      let _equals = 61;
      let _ampersand = 38;
      while (i < dart.notNull(query[dartx.length])) {
        let char = query[dartx.codeUnitAt](i);
        if (char == _equals) {
          if (equalsIndex < 0) equalsIndex = i;
        } else if (char == _ampersand) {
          parsePair(start, equalsIndex, i);
          start = i + 1;
          equalsIndex = -1;
        }
        i++;
      }
      parsePair(start, equalsIndex, i);
      return result;
    }
    static parseIPv4Address(host) {
      function error(msg) {
        dart.throw(new core.FormatException(`Illegal IPv4 address, ${msg}`));
      }
      dart.fn(error, dart.void, [core.String]);
      let bytes = host[dartx.split]('.');
      if (bytes[dartx.length] != 4) {
        error('IPv4 address should contain exactly 4 parts');
      }
      return bytes[dartx.map](core.int)(dart.fn(byteString => {
        let byte = core.int.parse(byteString);
        if (dart.notNull(byte) < 0 || dart.notNull(byte) > 255) {
          error('each part must be in the range of `0..255`');
        }
        return byte;
      }, core.int, [core.String]))[dartx.toList]();
    }
    static parseIPv6Address(host, start, end) {
      if (start === void 0) start = 0;
      if (end === void 0) end = null;
      if (end == null) end = host[dartx.length];
      function error(msg, position) {
        if (position === void 0) position = null;
        dart.throw(new core.FormatException(`Illegal IPv6 address, ${msg}`, host, dart.as(position, core.int)));
      }
      dart.fn(error, dart.void, [core.String], [dart.dynamic]);
      function parseHex(start, end) {
        if (dart.notNull(end) - dart.notNull(start) > 4) {
          error('an IPv6 part can only contain a maximum of 4 hex digits', start);
        }
        let value = core.int.parse(host[dartx.substring](start, end), {radix: 16});
        if (dart.notNull(value) < 0 || dart.notNull(value) > (1 << 16) - 1) {
          error('each part must be in the range of `0x0..0xFFFF`', start);
        }
        return value;
      }
      dart.fn(parseHex, core.int, [core.int, core.int]);
      if (dart.notNull(host[dartx.length]) < 2) error('address is too short');
      let parts = dart.list([], core.int);
      let wildcardSeen = false;
      let partStart = start;
      for (let i = start; dart.notNull(i) < dart.notNull(end); i = dart.notNull(i) + 1) {
        if (host[dartx.codeUnitAt](i) == core.Uri._COLON) {
          if (i == start) {
            i = dart.notNull(i) + 1;
            if (host[dartx.codeUnitAt](i) != core.Uri._COLON) {
              error('invalid start colon.', i);
            }
            partStart = i;
          }
          if (i == partStart) {
            if (wildcardSeen) {
              error('only one wildcard `::` is allowed', i);
            }
            wildcardSeen = true;
            parts[dartx.add](-1);
          } else {
            parts[dartx.add](parseHex(partStart, i));
          }
          partStart = dart.notNull(i) + 1;
        }
      }
      if (parts[dartx.length] == 0) error('too few parts');
      let atEnd = partStart == end;
      let isLastWildcard = parts[dartx.last] == -1;
      if (atEnd && !isLastWildcard) {
        error('expected a part after last `:`', end);
      }
      if (!atEnd) {
        try {
          parts[dartx.add](parseHex(partStart, end));
        } catch (e) {
          try {
            let last = core.Uri.parseIPv4Address(host[dartx.substring](partStart, end));
            parts[dartx.add]((dart.notNull(last[dartx.get](0)) << 8 | dart.notNull(last[dartx.get](1))) >>> 0);
            parts[dartx.add]((dart.notNull(last[dartx.get](2)) << 8 | dart.notNull(last[dartx.get](3))) >>> 0);
          } catch (e) {
            error('invalid end of IPv6 address.', partStart);
          }

        }

      }
      if (wildcardSeen) {
        if (dart.notNull(parts[dartx.length]) > 7) {
          error('an address with a wildcard must have less than 7 parts');
        }
      } else if (parts[dartx.length] != 8) {
        error('an address without a wildcard must contain exactly 8 parts');
      }
      let bytes = typed_data.Uint8List.new(16);
      for (let i = 0, index = 0; i < dart.notNull(parts[dartx.length]); i++) {
        let value = parts[dartx.get](i);
        if (value == -1) {
          let wildCardLength = 9 - dart.notNull(parts[dartx.length]);
          for (let j = 0; j < wildCardLength; j++) {
            bytes[dartx.set](index, 0);
            bytes[dartx.set](index + 1, 0);
            index = index + 2;
          }
        } else {
          bytes[dartx.set](index, value[dartx['>>']](8));
          bytes[dartx.set](index + 1, dart.notNull(value) & 255);
          index = index + 2;
        }
      }
      return bytes;
    }
    static _uriEncode(canonicalTable, text, encoding, spaceToPlus) {
      if (core.identical(encoding, convert.UTF8) && dart.notNull(core.Uri._needsNoEncoding.hasMatch(text))) {
        return text;
      }
      let result = new core.StringBuffer();
      let bytes = encoding.encode(text);
      for (let i = 0; i < dart.notNull(bytes[dartx.length]); i++) {
        let byte = bytes[dartx.get](i);
        if (dart.notNull(byte) < 128 && (dart.notNull(canonicalTable[dartx.get](byte[dartx['>>']](4))) & 1 << (dart.notNull(byte) & 15)) != 0) {
          result.writeCharCode(byte);
        } else if (dart.notNull(spaceToPlus) && byte == core.Uri._SPACE) {
          result.write('+');
        } else {
          let hexDigits = '0123456789ABCDEF';
          result.write('%');
          result.write(hexDigits[dartx.get](byte[dartx['>>']](4) & 15));
          result.write(hexDigits[dartx.get](dart.notNull(byte) & 15));
        }
      }
      return result.toString();
    }
    static _hexCharPairToByte(s, pos) {
      let byte = 0;
      for (let i = 0; i < 2; i++) {
        let charCode = s[dartx.codeUnitAt](dart.notNull(pos) + i);
        if (48 <= dart.notNull(charCode) && dart.notNull(charCode) <= 57) {
          byte = byte * 16 + dart.notNull(charCode) - 48;
        } else {
          charCode = (dart.notNull(charCode) | 32) >>> 0;
          if (97 <= dart.notNull(charCode) && dart.notNull(charCode) <= 102) {
            byte = byte * 16 + dart.notNull(charCode) - 87;
          } else {
            dart.throw(new core.ArgumentError("Invalid URL encoding"));
          }
        }
      }
      return byte;
    }
    static _uriDecode(text, start, end, encoding, plusToSpace) {
      dart.assert(0 <= dart.notNull(start));
      dart.assert(dart.notNull(start) <= dart.notNull(end));
      dart.assert(dart.notNull(end) <= dart.notNull(text[dartx.length]));
      dart.assert(encoding != null);
      let simple = true;
      for (let i = start; dart.notNull(i) < dart.notNull(end); i = dart.notNull(i) + 1) {
        let codeUnit = text[dartx.codeUnitAt](i);
        if (dart.notNull(codeUnit) > 127 || codeUnit == core.Uri._PERCENT || dart.notNull(plusToSpace) && codeUnit == core.Uri._PLUS) {
          simple = false;
          break;
        }
      }
      let bytes = null;
      if (simple) {
        if (dart.equals(convert.UTF8, encoding) || dart.equals(convert.LATIN1, encoding) || dart.equals(convert.ASCII, encoding)) {
          return text[dartx.substring](start, end);
        } else {
          bytes = text[dartx.substring](start, end)[dartx.codeUnits];
        }
      } else {
        bytes = core.List$(core.int).new();
        for (let i = start; dart.notNull(i) < dart.notNull(end); i = dart.notNull(i) + 1) {
          let codeUnit = text[dartx.codeUnitAt](i);
          if (dart.notNull(codeUnit) > 127) {
            dart.throw(new core.ArgumentError("Illegal percent encoding in URI"));
          }
          if (codeUnit == core.Uri._PERCENT) {
            if (dart.notNull(i) + 3 > dart.notNull(text[dartx.length])) {
              dart.throw(new core.ArgumentError('Truncated URI'));
            }
            bytes[dartx.add](core.Uri._hexCharPairToByte(text, dart.notNull(i) + 1));
            i = dart.notNull(i) + 2;
          } else if (dart.notNull(plusToSpace) && codeUnit == core.Uri._PLUS) {
            bytes[dartx.add](core.Uri._SPACE);
          } else {
            bytes[dartx.add](codeUnit);
          }
        }
      }
      return encoding.decode(bytes);
    }
    static _isAlphabeticCharacter(codeUnit) {
      let lowerCase = (dart.notNull(codeUnit) | 32) >>> 0;
      return dart.notNull(core.Uri._LOWER_CASE_A) <= lowerCase && lowerCase <= dart.notNull(core.Uri._LOWER_CASE_Z);
    }
    static _isUnreservedChar(char) {
      return dart.notNull(char) < 127 && (dart.notNull(core.Uri._unreservedTable[dartx.get](char[dartx['>>']](4))) & 1 << (dart.notNull(char) & 15)) != 0;
    }
  };
  dart.defineNamedConstructor(core.Uri, '_internal');
  dart.setSignature(core.Uri, {
    constructors: () => ({
      _internal: [core.Uri, [core.String, core.String, core.String, core.int, core.String, core.String, core.String]],
      new: [core.Uri, [], {scheme: core.String, userInfo: core.String, host: core.String, port: core.int, path: core.String, pathSegments: core.Iterable$(core.String), query: core.String, queryParameters: core.Map$(core.String, dart.dynamic), fragment: core.String}],
      http: [core.Uri, [core.String, core.String], [core.Map$(core.String, core.String)]],
      https: [core.Uri, [core.String, core.String], [core.Map$(core.String, core.String)]],
      file: [core.Uri, [core.String], {windows: core.bool}],
      directory: [core.Uri, [core.String], {windows: core.bool}],
      dataFromString: [core.Uri, [core.String], {mimeType: core.String, encoding: convert.Encoding, parameters: core.Map$(core.String, core.String), base64: core.bool}],
      dataFromBytes: [core.Uri, [core.List$(core.int)], {mimeType: dart.dynamic, parameters: core.Map$(core.String, core.String), percentEncoded: dart.dynamic}]
    }),
    methods: () => ({
      replace: [core.Uri, [], {scheme: core.String, userInfo: core.String, host: core.String, port: core.int, path: core.String, pathSegments: core.Iterable$(core.String), query: core.String, queryParameters: core.Map$(core.String, dart.dynamic), fragment: core.String}],
      removeFragment: [core.Uri, []],
      normalizePath: [core.Uri, []],
      [_mergePaths]: [core.String, [core.String, core.String]],
      resolve: [core.Uri, [core.String]],
      resolveUri: [core.Uri, [core.Uri]],
      toFilePath: [core.String, [], {windows: core.bool}],
      [_toFilePath]: [core.String, []],
      [_toWindowsFilePath]: [core.String, []],
      [_writeAuthority]: [dart.void, [core.StringSink]]
    }),
    statics: () => ({
      _defaultPort: [core.int, [core.String]],
      parse: [core.Uri, [core.String], [core.int, core.int]],
      _fail: [dart.void, [core.String, core.int, core.String]],
      _makeHttpUri: [core.Uri, [core.String, core.String, core.String, core.Map$(core.String, core.String)]],
      _checkNonWindowsPathReservedCharacters: [dart.dynamic, [core.List$(core.String), core.bool]],
      _checkWindowsPathReservedCharacters: [dart.dynamic, [core.List$(core.String), core.bool], [core.int]],
      _checkWindowsDriveLetter: [dart.dynamic, [core.int, core.bool]],
      _makeFileUri: [dart.dynamic, [core.String, core.bool]],
      _makeWindowsFileUrl: [dart.dynamic, [core.String, core.bool]],
      _makePort: [core.int, [core.int, core.String]],
      _makeHost: [core.String, [core.String, core.int, core.int, core.bool]],
      _isRegNameChar: [core.bool, [core.int]],
      _normalizeRegName: [core.String, [core.String, core.int, core.int]],
      _makeScheme: [core.String, [core.String, core.int, core.int]],
      _makeUserInfo: [core.String, [core.String, core.int, core.int]],
      _makePath: [core.String, [core.String, core.int, core.int, core.Iterable$(core.String), core.String, core.bool]],
      _normalizePath: [core.String, [core.String, core.String, core.bool]],
      _makeQuery: [core.String, [core.String, core.int, core.int, core.Map$(core.String, dart.dynamic)]],
      _makeFragment: [core.String, [core.String, core.int, core.int]],
      _stringOrNullLength: [core.int, [core.String]],
      _normalizeEscape: [core.String, [core.String, core.int, core.bool]],
      _parseHexDigit: [core.int, [core.int]],
      _escapeChar: [core.String, [core.int]],
      _normalize: [core.String, [core.String, core.int, core.int, core.List$(core.int)]],
      _isSchemeCharacter: [core.bool, [core.int]],
      _isGeneralDelimiter: [core.bool, [core.int]],
      _mayContainDotSegments: [core.bool, [core.String]],
      _removeDotSegments: [core.String, [core.String]],
      _normalizeRelativePath: [core.String, [core.String]],
      _addIfNonEmpty: [dart.void, [core.StringBuffer, core.String, core.String, core.String]],
      encodeComponent: [core.String, [core.String]],
      encodeQueryComponent: [core.String, [core.String], {encoding: convert.Encoding}],
      decodeComponent: [core.String, [core.String]],
      decodeQueryComponent: [core.String, [core.String], {encoding: convert.Encoding}],
      encodeFull: [core.String, [core.String]],
      decodeFull: [core.String, [core.String]],
      splitQueryString: [core.Map$(core.String, core.String), [core.String], {encoding: convert.Encoding}],
      _createList: [core.List, []],
      _splitQueryStringAll: [core.Map, [core.String], {encoding: convert.Encoding}],
      parseIPv4Address: [core.List$(core.int), [core.String]],
      parseIPv6Address: [core.List$(core.int), [core.String], [core.int, core.int]],
      _uriEncode: [core.String, [core.List$(core.int), core.String, convert.Encoding, core.bool]],
      _hexCharPairToByte: [core.int, [core.String, core.int]],
      _uriDecode: [core.String, [core.String, core.int, core.int, convert.Encoding, core.bool]],
      _isAlphabeticCharacter: [core.bool, [core.int]],
      _isUnreservedChar: [core.bool, [core.int]]
    }),
    names: ['_defaultPort', 'parse', '_fail', '_makeHttpUri', '_checkNonWindowsPathReservedCharacters', '_checkWindowsPathReservedCharacters', '_checkWindowsDriveLetter', '_makeFileUri', '_makeWindowsFileUrl', '_makePort', '_makeHost', '_isRegNameChar', '_normalizeRegName', '_makeScheme', '_makeUserInfo', '_makePath', '_normalizePath', '_makeQuery', '_makeFragment', '_stringOrNullLength', '_normalizeEscape', '_parseHexDigit', '_escapeChar', '_normalize', '_isSchemeCharacter', '_isGeneralDelimiter', '_mayContainDotSegments', '_removeDotSegments', '_normalizeRelativePath', '_addIfNonEmpty', 'encodeComponent', 'encodeQueryComponent', 'decodeComponent', 'decodeQueryComponent', 'encodeFull', 'decodeFull', 'splitQueryString', '_createList', '_splitQueryStringAll', 'parseIPv4Address', 'parseIPv6Address', '_uriEncode', '_hexCharPairToByte', '_uriDecode', '_isAlphabeticCharacter', '_isUnreservedChar']
  });
  core.Uri._SPACE = 32;
  core.Uri._DOUBLE_QUOTE = 34;
  core.Uri._NUMBER_SIGN = 35;
  core.Uri._PERCENT = 37;
  core.Uri._ASTERISK = 42;
  core.Uri._PLUS = 43;
  core.Uri._DOT = 46;
  core.Uri._SLASH = 47;
  core.Uri._ZERO = 48;
  core.Uri._NINE = 57;
  core.Uri._COLON = 58;
  core.Uri._LESS = 60;
  core.Uri._GREATER = 62;
  core.Uri._QUESTION = 63;
  core.Uri._AT_SIGN = 64;
  core.Uri._UPPER_CASE_A = 65;
  core.Uri._UPPER_CASE_F = 70;
  core.Uri._UPPER_CASE_Z = 90;
  core.Uri._LEFT_BRACKET = 91;
  core.Uri._BACKSLASH = 92;
  core.Uri._RIGHT_BRACKET = 93;
  core.Uri._LOWER_CASE_A = 97;
  core.Uri._LOWER_CASE_F = 102;
  core.Uri._LOWER_CASE_Z = 122;
  core.Uri._BAR = 124;
  core.Uri._hexDigits = "0123456789ABCDEF";
  core.Uri._unreservedTable = dart.const(dart.list([0, 0, 24576, 1023, 65534, 34815, 65534, 18431], core.int));
  core.Uri._unreserved2396Table = dart.const(dart.list([0, 0, 26498, 1023, 65534, 34815, 65534, 18431], core.int));
  core.Uri._encodeFullTable = dart.const(dart.list([0, 0, 65498, 45055, 65535, 34815, 65534, 18431], core.int));
  core.Uri._schemeTable = dart.const(dart.list([0, 0, 26624, 1023, 65534, 2047, 65534, 2047], core.int));
  core.Uri._schemeLowerTable = dart.const(dart.list([0, 0, 26624, 1023, 0, 0, 65534, 2047], core.int));
  core.Uri._subDelimitersTable = dart.const(dart.list([0, 0, 32722, 11263, 65534, 34815, 65534, 18431], core.int));
  core.Uri._genDelimitersTable = dart.const(dart.list([0, 0, 32776, 33792, 1, 10240, 0, 0], core.int));
  core.Uri._userinfoTable = dart.const(dart.list([0, 0, 32722, 12287, 65534, 34815, 65534, 18431], core.int));
  core.Uri._regNameTable = dart.const(dart.list([0, 0, 32754, 11263, 65534, 34815, 65534, 18431], core.int));
  core.Uri._pathCharTable = dart.const(dart.list([0, 0, 32722, 12287, 65535, 34815, 65534, 18431], core.int));
  core.Uri._pathCharOrSlashTable = dart.const(dart.list([0, 0, 65490, 12287, 65535, 34815, 65534, 18431], core.int));
  core.Uri._queryCharTable = dart.const(dart.list([0, 0, 65490, 45055, 65535, 34815, 65534, 18431], core.int));
  dart.defineLazy(core.Uri, {
    get _needsNoEncoding() {
      return core.RegExp.new('^[\\-\\.0-9A-Z_a-z~]*$');
    }
  });
  const _text = Symbol('_text');
  const _separatorIndices = Symbol('_separatorIndices');
  const _uriCache = Symbol('_uriCache');
  core.UriData = class UriData extends core.Object {
    _(text, separatorIndices, uriCache) {
      this[_text] = text;
      this[_separatorIndices] = separatorIndices;
      this[_uriCache] = uriCache;
    }
    static fromString(content, opts) {
      let mimeType = opts && 'mimeType' in opts ? opts.mimeType : null;
      let encoding = opts && 'encoding' in opts ? opts.encoding : null;
      let parameters = opts && 'parameters' in opts ? opts.parameters : null;
      let base64 = opts && 'base64' in opts ? opts.base64 : false;
      let buffer = new core.StringBuffer();
      let indices = dart.list([core.UriData._noScheme], core.int);
      let charsetName = null;
      let encodingName = null;
      if (parameters != null) charsetName = parameters[dartx.get]("charset");
      if (encoding == null) {
        if (charsetName != null) {
          encoding = convert.Encoding.getByName(charsetName);
        }
      } else if (charsetName == null) {
        encodingName = encoding.name;
      }
      let t = encoding;
      t == null ? encoding = convert.ASCII : t;
      core.UriData._writeUri(mimeType, encodingName, parameters, buffer, indices);
      indices[dartx.add](buffer.length);
      if (dart.notNull(base64)) {
        buffer.write(';base64,');
        indices[dartx.add](dart.notNull(buffer.length) - 1);
        buffer.write(encoding.fuse(convert.BASE64).encode(content));
      } else {
        buffer.write(',');
        core.UriData._uriEncodeBytes(core.UriData._uricTable, encoding.encode(content), buffer);
      }
      return new core.UriData._(buffer.toString(), indices, null);
    }
    static fromBytes(bytes, opts) {
      let mimeType = opts && 'mimeType' in opts ? opts.mimeType : "application/octet-stream";
      let parameters = opts && 'parameters' in opts ? opts.parameters : null;
      let percentEncoded = opts && 'percentEncoded' in opts ? opts.percentEncoded : false;
      let buffer = new core.StringBuffer();
      let indices = dart.list([core.UriData._noScheme], core.int);
      core.UriData._writeUri(dart.as(mimeType, core.String), null, parameters, buffer, indices);
      indices[dartx.add](buffer.length);
      if (dart.test(percentEncoded)) {
        buffer.write(',');
        core.UriData._uriEncodeBytes(core.UriData._uricTable, bytes, buffer);
      } else {
        buffer.write(';base64,');
        indices[dartx.add](dart.notNull(buffer.length) - 1);
        convert.BASE64.encoder.startChunkedConversion(convert.StringConversionSink.fromStringSink(buffer)).addSlice(bytes, 0, bytes[dartx.length], true);
      }
      return new core.UriData._(buffer.toString(), indices, null);
    }
    static fromUri(uri) {
      if (uri.scheme != "data") {
        dart.throw(new core.ArgumentError.value(uri, "uri", "Scheme must be 'data'"));
      }
      if (dart.notNull(uri.hasAuthority)) {
        dart.throw(new core.ArgumentError.value(uri, "uri", "Data uri must not have authority"));
      }
      if (dart.notNull(uri.hasFragment)) {
        dart.throw(new core.ArgumentError.value(uri, "uri", "Data uri must not have a fragment part"));
      }
      if (!dart.notNull(uri.hasQuery)) {
        return core.UriData._parse(uri.path, 0, uri);
      }
      return core.UriData._parse(`${uri}`, 5, uri);
    }
    static _writeUri(mimeType, charsetName, parameters, buffer, indices) {
      if (mimeType == null || mimeType == "text/plain") {
        mimeType = "";
      }
      if (dart.notNull(mimeType[dartx.isEmpty]) || core.identical(mimeType, "application/octet-stream")) {
        buffer.write(mimeType);
      } else {
        let slashIndex = core.UriData._validateMimeType(mimeType);
        if (dart.notNull(slashIndex) < 0) {
          dart.throw(new core.ArgumentError.value(mimeType, "mimeType", "Invalid MIME type"));
        }
        buffer.write(core.Uri._uriEncode(core.UriData._tokenCharTable, mimeType[dartx.substring](0, slashIndex), convert.UTF8, false));
        buffer.write("/");
        buffer.write(core.Uri._uriEncode(core.UriData._tokenCharTable, mimeType[dartx.substring](dart.notNull(slashIndex) + 1), convert.UTF8, false));
      }
      if (charsetName != null) {
        if (indices != null) {
          indices[dartx.add](buffer.length);
          indices[dartx.add](dart.notNull(buffer.length) + 8);
        }
        buffer.write(";charset=");
        buffer.write(core.Uri._uriEncode(core.UriData._tokenCharTable, charsetName, convert.UTF8, false));
      }
      dart.nullSafe(parameters, _ => _[dartx.forEach](dart.fn((key, value) => {
        if (dart.notNull(key[dartx.isEmpty])) {
          dart.throw(new core.ArgumentError.value("", "Parameter names must not be empty"));
        }
        if (dart.notNull(value[dartx.isEmpty])) {
          dart.throw(new core.ArgumentError.value("", "Parameter values must not be empty", `parameters["${key}"]`));
        }
        if (indices != null) indices[dartx.add](buffer.length);
        buffer.write(';');
        buffer.write(core.Uri._uriEncode(core.UriData._tokenCharTable, key, convert.UTF8, false));
        if (indices != null) indices[dartx.add](buffer.length);
        buffer.write('=');
        buffer.write(core.Uri._uriEncode(core.UriData._tokenCharTable, value, convert.UTF8, false));
      }, dart.void, [core.String, core.String])));
    }
    static _validateMimeType(mimeType) {
      let slashIndex = -1;
      for (let i = 0; i < dart.notNull(mimeType[dartx.length]); i++) {
        let char = mimeType[dartx.codeUnitAt](i);
        if (char != core.Uri._SLASH) continue;
        if (slashIndex < 0) {
          slashIndex = i;
          continue;
        }
        return -1;
      }
      return slashIndex;
    }
    static parse(uri) {
      if (!dart.notNull(uri[dartx.startsWith]("data:"))) {
        dart.throw(new core.FormatException("Does not start with 'data:'", uri, 0));
      }
      return core.UriData._parse(uri, 5, null);
    }
    get uri() {
      if (this[_uriCache] != null) return this[_uriCache];
      let path = this[_text];
      let query = null;
      let colonIndex = this[_separatorIndices][dartx.get](0);
      let queryIndex = this[_text][dartx.indexOf]('?', dart.notNull(colonIndex) + 1);
      let end = null;
      if (dart.notNull(queryIndex) >= 0) {
        query = this[_text][dartx.substring](dart.notNull(queryIndex) + 1);
        end = queryIndex;
      }
      path = this[_text][dartx.substring](dart.notNull(colonIndex) + 1, end);
      this[_uriCache] = new core.Uri._internal("data", "", null, null, path, query, null);
      return this[_uriCache];
    }
    get mimeType() {
      let start = dart.notNull(this[_separatorIndices][dartx.get](0)) + 1;
      let end = this[_separatorIndices][dartx.get](1);
      if (start == end) return "text/plain";
      return core.Uri._uriDecode(this[_text], start, end, convert.UTF8, false);
    }
    get charset() {
      let parameterStart = 1;
      let parameterEnd = dart.notNull(this[_separatorIndices][dartx.length]) - 1;
      if (dart.notNull(this.isBase64)) {
        parameterEnd = parameterEnd - 1;
      }
      for (let i = parameterStart; i < parameterEnd; i = i + 2) {
        let keyStart = dart.notNull(this[_separatorIndices][dartx.get](i)) + 1;
        let keyEnd = this[_separatorIndices][dartx.get](i + 1);
        if (keyEnd == keyStart + 7 && dart.notNull(this[_text][dartx.startsWith]("charset", keyStart))) {
          return core.Uri._uriDecode(this[_text], dart.notNull(keyEnd) + 1, this[_separatorIndices][dartx.get](i + 2), convert.UTF8, false);
        }
      }
      return "US-ASCII";
    }
    get isBase64() {
      return this[_separatorIndices][dartx.length][dartx.isOdd];
    }
    get contentText() {
      return this[_text][dartx.substring](dart.notNull(this[_separatorIndices][dartx.last]) + 1);
    }
    contentAsBytes() {
      let text = this[_text];
      let start = dart.notNull(this[_separatorIndices][dartx.last]) + 1;
      if (dart.notNull(this.isBase64)) {
        return convert.BASE64.decoder.convert(text, start);
      }
      let percent = 37;
      let length = dart.notNull(text[dartx.length]) - start;
      for (let i = start; i < dart.notNull(text[dartx.length]); i++) {
        let codeUnit = text[dartx.codeUnitAt](i);
        if (codeUnit == percent) {
          i = i + 2;
          length = length - 2;
        }
      }
      let result = typed_data.Uint8List.new(length);
      if (length == text[dartx.length]) {
        result[dartx.setRange](0, length, text[dartx.codeUnits], start);
        return result;
      }
      let index = 0;
      for (let i = start; i < dart.notNull(text[dartx.length]); i++) {
        let codeUnit = text[dartx.codeUnitAt](i);
        if (codeUnit != percent) {
          result[dartx.set](index++, codeUnit);
        } else {
          if (i + 2 < dart.notNull(text[dartx.length])) {
            let digit1 = core.Uri._parseHexDigit(text[dartx.codeUnitAt](i + 1));
            let digit2 = core.Uri._parseHexDigit(text[dartx.codeUnitAt](i + 2));
            if (dart.notNull(digit1) >= 0 && dart.notNull(digit2) >= 0) {
              let byte = dart.notNull(digit1) * 16 + dart.notNull(digit2);
              result[dartx.set](index++, byte);
              i = i + 2;
              continue;
            }
          }
          dart.throw(new core.FormatException("Invalid percent escape", text, i));
        }
      }
      dart.assert(index == result[dartx.length]);
      return result;
    }
    contentAsString(opts) {
      let encoding = opts && 'encoding' in opts ? opts.encoding : null;
      if (encoding == null) {
        let charset = this.charset;
        encoding = convert.Encoding.getByName(charset);
        if (encoding == null) {
          dart.throw(new core.UnsupportedError(`Unknown charset: ${charset}`));
        }
      }
      let text = this[_text];
      let start = dart.notNull(this[_separatorIndices][dartx.last]) + 1;
      if (dart.notNull(this.isBase64)) {
        let converter = convert.BASE64.decoder.fuse(encoding.decoder);
        return dart.as(converter.convert(text[dartx.substring](start)), core.String);
      }
      return core.Uri._uriDecode(text, start, text[dartx.length], encoding, false);
    }
    get parameters() {
      let result = dart.map({}, core.String, core.String);
      for (let i = 3; i < dart.notNull(this[_separatorIndices][dartx.length]); i = i + 2) {
        let start = dart.notNull(this[_separatorIndices][dartx.get](i - 2)) + 1;
        let equals = this[_separatorIndices][dartx.get](i - 1);
        let end = this[_separatorIndices][dartx.get](i);
        let key = core.Uri._uriDecode(this[_text], start, equals, convert.UTF8, false);
        let value = core.Uri._uriDecode(this[_text], dart.notNull(equals) + 1, end, convert.UTF8, false);
        result[dartx.set](key, value);
      }
      return result;
    }
    static _parse(text, start, sourceUri) {
      dart.assert(start == 0 || start == 5);
      dart.assert(start == 5 == text[dartx.startsWith]("data:"));
      let comma = 44;
      let slash = 47;
      let semicolon = 59;
      let equals = 61;
      let indices = dart.list([dart.notNull(start) - 1], core.int);
      let slashIndex = -1;
      let char = null;
      let i = start;
      for (; dart.notNull(i) < dart.notNull(text[dartx.length]); i = dart.notNull(i) + 1) {
        char = text[dartx.codeUnitAt](i);
        if (dart.equals(char, comma) || dart.equals(char, semicolon)) break;
        if (dart.equals(char, slash)) {
          if (dart.notNull(slashIndex) < 0) {
            slashIndex = i;
            continue;
          }
          dart.throw(new core.FormatException("Invalid MIME type", text, i));
        }
      }
      if (dart.notNull(slashIndex) < 0 && dart.notNull(i) > dart.notNull(start)) {
        dart.throw(new core.FormatException("Invalid MIME type", text, i));
      }
      while (!dart.equals(char, comma)) {
        indices[dartx.add](i);
        i = dart.notNull(i) + 1;
        let equalsIndex = -1;
        for (; dart.notNull(i) < dart.notNull(text[dartx.length]); i = dart.notNull(i) + 1) {
          char = text[dartx.codeUnitAt](i);
          if (dart.equals(char, equals)) {
            if (dart.notNull(equalsIndex) < 0) equalsIndex = i;
          } else if (dart.equals(char, semicolon) || dart.equals(char, comma)) {
            break;
          }
        }
        if (dart.notNull(equalsIndex) >= 0) {
          indices[dartx.add](equalsIndex);
        } else {
          let lastSeparator = indices[dartx.last];
          if (!dart.equals(char, comma) || i != dart.notNull(lastSeparator) + 7 || !dart.notNull(text[dartx.startsWith]("base64", dart.notNull(lastSeparator) + 1))) {
            dart.throw(new core.FormatException("Expecting '='", text, i));
          }
          break;
        }
      }
      indices[dartx.add](i);
      return new core.UriData._(text, indices, sourceUri);
    }
    static _uriEncodeBytes(canonicalTable, bytes, buffer) {
      let byteOr = 0;
      for (let i = 0; i < dart.notNull(bytes[dartx.length]); i++) {
        let byte = bytes[dartx.get](i);
        byteOr = (dart.notNull(byteOr) | dart.notNull(byte)) >>> 0;
        if (dart.notNull(byte) < 128 && (dart.notNull(canonicalTable[dartx.get](byte[dartx['>>']](4))) & 1 << (dart.notNull(byte) & 15)) != 0) {
          buffer.writeCharCode(byte);
        } else {
          buffer.writeCharCode(core.Uri._PERCENT);
          buffer.writeCharCode(core.Uri._hexDigits[dartx.codeUnitAt](byte[dartx['>>']](4)));
          buffer.writeCharCode(core.Uri._hexDigits[dartx.codeUnitAt](dart.notNull(byte) & 15));
        }
      }
      if ((dart.notNull(byteOr) & ~255) >>> 0 != 0) {
        for (let i = 0; i < dart.notNull(bytes[dartx.length]); i++) {
          let byte = bytes[dartx.get](i);
          if (dart.notNull(byte) < 0 || dart.notNull(byte) > 255) {
            dart.throw(new core.ArgumentError.value(byte, "non-byte value"));
          }
        }
      }
    }
    toString() {
      return this[_separatorIndices][dartx.get](0) == core.UriData._noScheme ? `data:${this[_text]}` : this[_text];
    }
  };
  dart.defineNamedConstructor(core.UriData, '_');
  dart.setSignature(core.UriData, {
    constructors: () => ({
      _: [core.UriData, [core.String, core.List$(core.int), core.Uri]],
      fromString: [core.UriData, [core.String], {mimeType: core.String, encoding: convert.Encoding, parameters: core.Map$(core.String, core.String), base64: core.bool}],
      fromBytes: [core.UriData, [core.List$(core.int)], {mimeType: dart.dynamic, parameters: core.Map$(core.String, core.String), percentEncoded: dart.dynamic}],
      fromUri: [core.UriData, [core.Uri]]
    }),
    methods: () => ({
      contentAsBytes: [core.List$(core.int), []],
      contentAsString: [core.String, [], {encoding: convert.Encoding}]
    }),
    statics: () => ({
      _writeUri: [dart.void, [core.String, core.String, core.Map$(core.String, core.String), core.StringBuffer, core.List]],
      _validateMimeType: [core.int, [core.String]],
      parse: [core.UriData, [core.String]],
      _parse: [core.UriData, [core.String, core.int, core.Uri]],
      _uriEncodeBytes: [dart.void, [core.List$(core.int), core.List$(core.int), core.StringSink]]
    }),
    names: ['_writeUri', '_validateMimeType', 'parse', '_parse', '_uriEncodeBytes']
  });
  core.UriData._noScheme = -1;
  core.UriData._tokenCharTable = dart.const(dart.list([0, 0, 27858, 1023, 65534, 51199, 65535, 32767], core.int));
  core.UriData._uricTable = core.Uri._queryCharTable;
  isolate.IsolateSpawnException = class IsolateSpawnException extends core.Object {
    IsolateSpawnException(message) {
      this.message = message;
    }
    toString() {
      return `IsolateSpawnException: ${this.message}`;
    }
  };
  isolate.IsolateSpawnException[dart.implements] = () => [core.Exception];
  dart.setSignature(isolate.IsolateSpawnException, {
    constructors: () => ({IsolateSpawnException: [isolate.IsolateSpawnException, [core.String]]})
  });
  const _pause = Symbol('_pause');
  isolate.Isolate = class Isolate extends core.Object {
    Isolate(controlPort, opts) {
      let pauseCapability = opts && 'pauseCapability' in opts ? opts.pauseCapability : null;
      let terminateCapability = opts && 'terminateCapability' in opts ? opts.terminateCapability : null;
      this.controlPort = controlPort;
      this.pauseCapability = pauseCapability;
      this.terminateCapability = terminateCapability;
    }
    static get current() {
      return isolate.Isolate._currentIsolateCache;
    }
    static spawn(entryPoint, message, opts) {
      let paused = opts && 'paused' in opts ? opts.paused : false;
      try {
        return _isolate_helper.IsolateNatives.spawnFunction(entryPoint, message, paused).then(isolate.Isolate)(dart.fn(msg => new isolate.Isolate(dart.as(msg[dartx.get](1), isolate.SendPort), {pauseCapability: dart.as(msg[dartx.get](2), isolate.Capability), terminateCapability: dart.as(msg[dartx.get](3), isolate.Capability)}), isolate.Isolate, [core.List]));
      } catch (e) {
        let st = dart.stackTrace(e);
        return async.Future$(isolate.Isolate).error(e, st);
      }

    }
    static spawnUri(uri, args, message, opts) {
      let paused = opts && 'paused' in opts ? opts.paused : false;
      let packageRoot = opts && 'packageRoot' in opts ? opts.packageRoot : null;
      if (packageRoot != null) dart.throw(new core.UnimplementedError("packageRoot"));
      try {
        if (dart.is(args, core.List)) {
          for (let i = 0; i < dart.notNull(args[dartx.length]); i++) {
            if (!(typeof args[dartx.get](i) == 'string')) {
              dart.throw(new core.ArgumentError(`Args must be a list of Strings ${args}`));
            }
          }
        } else if (args != null) {
          dart.throw(new core.ArgumentError(`Args must be a list of Strings ${args}`));
        }
        return _isolate_helper.IsolateNatives.spawnUri(uri, args, message, paused).then(isolate.Isolate)(dart.fn(msg => new isolate.Isolate(dart.as(msg[dartx.get](1), isolate.SendPort), {pauseCapability: dart.as(msg[dartx.get](2), isolate.Capability), terminateCapability: dart.as(msg[dartx.get](3), isolate.Capability)}), isolate.Isolate, [core.List]));
      } catch (e) {
        let st = dart.stackTrace(e);
        return async.Future$(isolate.Isolate).error(e, st);
      }

    }
    pause(resumeCapability) {
      if (resumeCapability === void 0) resumeCapability = null;
      if (resumeCapability == null) resumeCapability = isolate.Capability.new();
      this[_pause](resumeCapability);
      return resumeCapability;
    }
    [_pause](resumeCapability) {
      let message = core.List.new(3);
      message[dartx.set](0, "pause");
      message[dartx.set](1, this.pauseCapability);
      message[dartx.set](2, resumeCapability);
      this.controlPort.send(message);
    }
    resume(resumeCapability) {
      let message = core.List.new(2);
      message[dartx.set](0, "resume");
      message[dartx.set](1, resumeCapability);
      this.controlPort.send(message);
    }
    addOnExitListener(responsePort) {
      let message = core.List.new(2);
      message[dartx.set](0, "add-ondone");
      message[dartx.set](1, responsePort);
      this.controlPort.send(message);
    }
    removeOnExitListener(responsePort) {
      let message = core.List.new(2);
      message[dartx.set](0, "remove-ondone");
      message[dartx.set](1, responsePort);
      this.controlPort.send(message);
    }
    setErrorsFatal(errorsAreFatal) {
      let message = core.List.new(3);
      message[dartx.set](0, "set-errors-fatal");
      message[dartx.set](1, this.terminateCapability);
      message[dartx.set](2, errorsAreFatal);
      this.controlPort.send(message);
    }
    kill(priority) {
      if (priority === void 0) priority = isolate.Isolate.BEFORE_NEXT_EVENT;
      this.controlPort.send(dart.list(["kill", this.terminateCapability, priority], core.Object));
    }
    ping(responsePort, pingType) {
      if (pingType === void 0) pingType = isolate.Isolate.IMMEDIATE;
      let message = core.List.new(3);
      message[dartx.set](0, "ping");
      message[dartx.set](1, responsePort);
      message[dartx.set](2, pingType);
      this.controlPort.send(message);
    }
    addErrorListener(port) {
      let message = core.List.new(2);
      message[dartx.set](0, "getErrors");
      message[dartx.set](1, port);
      this.controlPort.send(message);
    }
    removeErrorListener(port) {
      let message = core.List.new(2);
      message[dartx.set](0, "stopErrors");
      message[dartx.set](1, port);
      this.controlPort.send(message);
    }
    get errors() {
      let controller = null;
      let port = null;
      function handleError(message) {
        let errorDescription = dart.as(dart.dindex(message, 0), core.String);
        let stackDescription = dart.as(dart.dindex(message, 1), core.String);
        let error = new isolate.RemoteError(errorDescription, stackDescription);
        controller.addError(error, error.stackTrace);
      }
      dart.fn(handleError, dart.void, [dart.dynamic]);
      controller = async.StreamController.broadcast({sync: true, onListen: dart.fn(() => {
          port = isolate.RawReceivePort.new(handleError);
          this.addErrorListener(port.sendPort);
        }, dart.void, []), onCancel: dart.fn(() => {
          this.removeErrorListener(port.sendPort);
          port.close();
          port = null;
        }, dart.void, [])});
      return controller.stream;
    }
  };
  dart.setSignature(isolate.Isolate, {
    constructors: () => ({Isolate: [isolate.Isolate, [isolate.SendPort], {pauseCapability: isolate.Capability, terminateCapability: isolate.Capability}]}),
    methods: () => ({
      pause: [isolate.Capability, [], [isolate.Capability]],
      [_pause]: [dart.void, [isolate.Capability]],
      resume: [dart.void, [isolate.Capability]],
      addOnExitListener: [dart.void, [isolate.SendPort]],
      removeOnExitListener: [dart.void, [isolate.SendPort]],
      setErrorsFatal: [dart.void, [core.bool]],
      kill: [dart.void, [], [core.int]],
      ping: [dart.void, [isolate.SendPort], [core.int]],
      addErrorListener: [dart.void, [isolate.SendPort]],
      removeErrorListener: [dart.void, [isolate.SendPort]]
    }),
    statics: () => ({
      spawn: [async.Future$(isolate.Isolate), [dart.functionType(dart.void, [dart.dynamic]), dart.dynamic], {paused: core.bool}],
      spawnUri: [async.Future$(isolate.Isolate), [core.Uri, core.List$(core.String), dart.dynamic], {paused: core.bool, packageRoot: core.Uri}]
    }),
    names: ['spawn', 'spawnUri']
  });
  isolate.Isolate.IMMEDIATE = 0;
  isolate.Isolate.BEFORE_NEXT_EVENT = 1;
  isolate.Isolate.AS_EVENT = 2;
  dart.defineLazy(isolate.Isolate, {
    get _currentIsolateCache() {
      return _isolate_helper.IsolateNatives.currentIsolate;
    }
  });
  isolate.SendPort = class SendPort extends core.Object {};
  isolate.SendPort[dart.implements] = () => [isolate.Capability];
  isolate.ReceivePort = class ReceivePort extends core.Object {
    static new() {
      return new _isolate_helper.ReceivePortImpl();
    }
    static fromRawReceivePort(rawPort) {
      return new _isolate_helper.ReceivePortImpl.fromRawReceivePort(rawPort);
    }
  };
  isolate.ReceivePort[dart.implements] = () => [async.Stream];
  dart.setSignature(isolate.ReceivePort, {
    constructors: () => ({
      new: [isolate.ReceivePort, []],
      fromRawReceivePort: [isolate.ReceivePort, [isolate.RawReceivePort]]
    })
  });
  isolate.RawReceivePort = class RawReceivePort extends core.Object {
    static new(handler) {
      if (handler === void 0) handler = null;
      return new _isolate_helper.RawReceivePortImpl(handler);
    }
  };
  dart.setSignature(isolate.RawReceivePort, {
    constructors: () => ({new: [isolate.RawReceivePort, [], [dart.functionType(dart.void, [dart.dynamic])]]})
  });
  isolate._IsolateUnhandledException = class _IsolateUnhandledException extends core.Object {
    _IsolateUnhandledException(message, source, stackTrace) {
      this.message = message;
      this.source = source;
      this.stackTrace = stackTrace;
    }
    toString() {
      return 'IsolateUnhandledException: exception while handling message: ' + `${this.message} \n  ` + `${dart.toString(this.source)[dartx.replaceAll]("\n", "\n  ")}\n` + 'original stack trace:\n  ' + `${dart.toString(this.stackTrace)[dartx.replaceAll]("\n", "\n  ")}`;
    }
  };
  isolate._IsolateUnhandledException[dart.implements] = () => [core.Exception];
  dart.setSignature(isolate._IsolateUnhandledException, {
    constructors: () => ({_IsolateUnhandledException: [isolate._IsolateUnhandledException, [dart.dynamic, dart.dynamic, core.StackTrace]]})
  });
  const _description = Symbol('_description');
  isolate.RemoteError = class RemoteError extends core.Object {
    RemoteError(description, stackDescription) {
      this[_description] = description;
      this.stackTrace = new isolate._RemoteStackTrace(stackDescription);
    }
    toString() {
      return this[_description];
    }
  };
  isolate.RemoteError[dart.implements] = () => [core.Error];
  dart.setSignature(isolate.RemoteError, {
    constructors: () => ({RemoteError: [isolate.RemoteError, [core.String, core.String]]})
  });
  const _trace$ = Symbol('_trace');
  isolate._RemoteStackTrace = class _RemoteStackTrace extends core.Object {
    _RemoteStackTrace(trace) {
      this[_trace$] = trace;
    }
    toString() {
      return this[_trace$];
    }
  };
  isolate._RemoteStackTrace[dart.implements] = () => [core.StackTrace];
  dart.setSignature(isolate._RemoteStackTrace, {
    constructors: () => ({_RemoteStackTrace: [isolate._RemoteStackTrace, [core.String]]})
  });
  isolate.Capability = class Capability extends core.Object {
    static new() {
      return new _isolate_helper.CapabilityImpl();
    }
  };
  dart.setSignature(isolate.Capability, {
    constructors: () => ({new: [isolate.Capability, []]})
  });
  dart.defineLazy(js, {
    get _global() {
      return dart.global;
    }
  });
  dart.defineLazy(js, {
    get context() {
      return js._wrapToDart(js._global);
    }
  });
  const _jsObject = Symbol('_jsObject');
  js.JsObject = class JsObject extends core.Object {
    _fromJs(jsObject) {
      this[_jsObject] = jsObject;
      dart.assert(this[_jsObject] != null);
    }
    static new(constructor, arguments$) {
      if (arguments$ === void 0) arguments$ = null;
      let ctor = constructor[_jsObject];
      if (arguments$ == null) {
        return js._wrapToDart(new ctor());
      }
      let unwrapped = core.List.from(arguments$[dartx.map](dart.dynamic)(js._convertToJS));
      return js._wrapToDart(new ctor(...unwrapped));
    }
    static fromBrowserObject(object) {
      if (typeof object == 'number' || typeof object == 'string' || typeof object == 'boolean' || object == null) {
        dart.throw(new core.ArgumentError("object cannot be a num, string, bool, or null"));
      }
      return js._wrapToDart(js._convertToJS(object));
    }
    static jsify(object) {
      if (!dart.is(object, core.Map) && !dart.is(object, core.Iterable)) {
        dart.throw(new core.ArgumentError("object must be a Map or Iterable"));
      }
      return js._wrapToDart(js.JsObject._convertDataTree(object));
    }
    static _convertDataTree(data) {
      let _convertedObjects = collection.HashMap.identity();
      function _convert(o) {
        if (dart.notNull(_convertedObjects.containsKey(o))) {
          return _convertedObjects.get(o);
        }
        if (dart.is(o, core.Map)) {
          let convertedMap = {};
          _convertedObjects.set(o, convertedMap);
          for (let key of o[dartx.keys]) {
            convertedMap[key] = _convert(o[dartx.get](key));
          }
          return convertedMap;
        } else if (dart.is(o, core.Iterable)) {
          let convertedList = [];
          _convertedObjects.set(o, convertedList);
          convertedList[dartx.addAll](o[dartx.map](dart.dynamic)(_convert));
          return convertedList;
        } else {
          return js._convertToJS(o);
        }
      }
      dart.fn(_convert);
      return _convert(data);
    }
    get(property) {
      if (!(typeof property == 'string') && !(typeof property == 'number')) {
        dart.throw(new core.ArgumentError("property is not a String or num"));
      }
      return js._convertToDart(this[_jsObject][property]);
    }
    set(property, value) {
      if (!(typeof property == 'string') && !(typeof property == 'number')) {
        dart.throw(new core.ArgumentError("property is not a String or num"));
      }
      this[_jsObject][property] = js._convertToJS(value);
      return value;
    }
    get hashCode() {
      return 0;
    }
    ['=='](other) {
      return dart.is(other, js.JsObject) && this[_jsObject] === other[_jsObject];
    }
    hasProperty(property) {
      if (!(typeof property == 'string') && !(typeof property == 'number')) {
        dart.throw(new core.ArgumentError("property is not a String or num"));
      }
      return property in this[_jsObject];
    }
    deleteProperty(property) {
      if (!(typeof property == 'string') && !(typeof property == 'number')) {
        dart.throw(new core.ArgumentError("property is not a String or num"));
      }
      delete this[_jsObject][property];
    }
    instanceof(type) {
      return this[_jsObject] instanceof js._convertToJS(type);
    }
    toString() {
      try {
        return String(this[_jsObject]);
      } catch (e) {
        return super.toString();
      }

    }
    callMethod(method, args) {
      if (args === void 0) args = null;
      if (!(typeof method == 'string') && !(typeof method == 'number')) {
        dart.throw(new core.ArgumentError("method is not a String or num"));
      }
      if (args != null) args = core.List.from(args[dartx.map](dart.dynamic)(js._convertToJS));
      let fn = this[_jsObject][method];
      if (!(fn instanceof Function)) {
        dart.throw(new core.NoSuchMethodError(this[_jsObject], core.Symbol.new(dart.as(method, core.String)), args, dart.map()));
      }
      return js._convertToDart(fn.apply(this[_jsObject], args));
    }
  };
  dart.defineNamedConstructor(js.JsObject, '_fromJs');
  dart.setSignature(js.JsObject, {
    constructors: () => ({
      _fromJs: [js.JsObject, [dart.dynamic]],
      new: [js.JsObject, [js.JsFunction], [core.List]],
      fromBrowserObject: [js.JsObject, [dart.dynamic]],
      jsify: [js.JsObject, [dart.dynamic]]
    }),
    methods: () => ({
      get: [dart.dynamic, [core.Object]],
      set: [dart.dynamic, [core.Object, dart.dynamic]],
      hasProperty: [core.bool, [dart.dynamic]],
      deleteProperty: [dart.void, [dart.dynamic]],
      instanceof: [core.bool, [js.JsFunction]],
      callMethod: [dart.dynamic, [dart.dynamic], [core.List]]
    }),
    statics: () => ({_convertDataTree: [dart.dynamic, [dart.dynamic]]}),
    names: ['_convertDataTree']
  });
  js.JsFunction = class JsFunction extends js.JsObject {
    static withThis(f) {
      return new js.JsFunction._fromJs(function() {
        let args = [js._convertToDart(this)];
        for (let arg of arguments) {
          args.push(js._convertToDart(arg));
        }
        return js._convertToJS(f(...args));
      });
    }
    _fromJs(jsObject) {
      super._fromJs(jsObject);
    }
    apply(args, opts) {
      let thisArg = opts && 'thisArg' in opts ? opts.thisArg : null;
      return js._convertToDart(this[_jsObject].apply(js._convertToJS(thisArg), args == null ? null : core.List.from(args[dartx.map](dart.dynamic)(js._convertToJS))));
    }
  };
  dart.defineNamedConstructor(js.JsFunction, '_fromJs');
  dart.setSignature(js.JsFunction, {
    constructors: () => ({
      withThis: [js.JsFunction, [core.Function]],
      _fromJs: [js.JsFunction, [dart.dynamic]]
    }),
    methods: () => ({apply: [dart.dynamic, [core.List], {thisArg: dart.dynamic}]})
  });
  const _checkIndex = Symbol('_checkIndex');
  const _checkInsertIndex = Symbol('_checkInsertIndex');
  js.JsArray$ = dart.generic(E => {
    class JsArray extends dart.mixin(js.JsObject, collection.ListMixin$(E)) {
      JsArray() {
        super._fromJs([]);
      }
      from(other) {
        super._fromJs((() => {
          let _ = [];
          _[dartx.addAll](other[dartx.map](dart.dynamic)(js._convertToJS));
          return _;
        })());
      }
      _fromJs(jsObject) {
        super._fromJs(jsObject);
      }
      [_checkIndex](index) {
        if (typeof index == 'number' && (dart.notNull(index) < 0 || dart.notNull(index) >= dart.notNull(this.length))) {
          dart.throw(new core.RangeError.range(index, 0, this.length));
        }
      }
      [_checkInsertIndex](index) {
        if (typeof index == 'number' && (dart.notNull(index) < 0 || dart.notNull(index) >= dart.notNull(this.length) + 1)) {
          dart.throw(new core.RangeError.range(index, 0, this.length));
        }
      }
      static _checkRange(start, end, length) {
        if (dart.notNull(start) < 0 || dart.notNull(start) > dart.notNull(length)) {
          dart.throw(new core.RangeError.range(start, 0, length));
        }
        if (dart.notNull(end) < dart.notNull(start) || dart.notNull(end) > dart.notNull(length)) {
          dart.throw(new core.RangeError.range(end, start, length));
        }
      }
      get(index) {
        if (typeof index == 'number' && index == index[dartx.toInt]()) {
          this[_checkIndex](dart.asInt(index));
        }
        return dart.as(super.get(index), E);
      }
      set(index, value) {
        dart.as(value, E);
        if (typeof index == 'number' && index == index[dartx.toInt]()) {
          this[_checkIndex](dart.asInt(index));
        }
        super.set(index, value);
        return value;
      }
      get length() {
        let len = this[_jsObject].length;
        if (typeof len === "number" && len >>> 0 === len) {
          return len;
        }
        dart.throw(new core.StateError('Bad JsArray length'));
      }
      set length(length) {
        super.set('length', length);
      }
      add(value) {
        dart.as(value, E);
        this.callMethod('push', dart.list([value], E));
      }
      addAll(iterable) {
        dart.as(iterable, core.Iterable$(E));
        let list = iterable instanceof Array ? iterable : core.List.from(iterable);
        this.callMethod('push', dart.as(list, core.List));
      }
      insert(index, element) {
        dart.as(element, E);
        this[_checkInsertIndex](index);
        this.callMethod('splice', dart.list([index, 0, element], core.Object));
      }
      removeAt(index) {
        this[_checkIndex](index);
        return dart.as(dart.dindex(this.callMethod('splice', dart.list([index, 1], core.int)), 0), E);
      }
      removeLast() {
        if (this.length == 0) dart.throw(new core.RangeError(-1));
        return dart.as(this.callMethod('pop'), E);
      }
      removeRange(start, end) {
        js.JsArray._checkRange(start, end, this.length);
        this.callMethod('splice', dart.list([start, dart.notNull(end) - dart.notNull(start)], core.int));
      }
      setRange(start, end, iterable, skipCount) {
        dart.as(iterable, core.Iterable$(E));
        if (skipCount === void 0) skipCount = 0;
        js.JsArray._checkRange(start, end, this.length);
        let length = dart.notNull(end) - dart.notNull(start);
        if (length == 0) return;
        if (dart.notNull(skipCount) < 0) dart.throw(new core.ArgumentError(skipCount));
        let args = dart.list([start, length], core.Object);
        args[dartx.addAll](iterable[dartx.skip](skipCount)[dartx.take](length));
        this.callMethod('splice', args);
      }
      sort(compare) {
        if (compare === void 0) compare = null;
        dart.as(compare, dart.functionType(core.int, [E, E]));
        this.callMethod('sort', compare == null ? [] : dart.list([compare], dart.functionType(core.int, [E, E])));
      }
    }
    dart.defineNamedConstructor(JsArray, 'from');
    dart.defineNamedConstructor(JsArray, '_fromJs');
    dart.setSignature(JsArray, {
      constructors: () => ({
        JsArray: [js.JsArray$(E), []],
        from: [js.JsArray$(E), [core.Iterable$(E)]],
        _fromJs: [js.JsArray$(E), [dart.dynamic]]
      }),
      methods: () => ({
        [_checkIndex]: [dart.dynamic, [core.int]],
        [_checkInsertIndex]: [dart.dynamic, [core.int]],
        get: [E, [core.Object]],
        set: [dart.void, [core.Object, E]],
        add: [dart.void, [E]],
        addAll: [dart.void, [core.Iterable$(E)]],
        insert: [dart.void, [core.int, E]],
        removeAt: [E, [core.int]],
        removeLast: [E, []],
        setRange: [dart.void, [core.int, core.int, core.Iterable$(E)], [core.int]],
        sort: [dart.void, [], [dart.functionType(core.int, [E, E])]]
      }),
      statics: () => ({_checkRange: [dart.dynamic, [core.int, core.int, core.int]]}),
      names: ['_checkRange']
    });
    dart.defineExtensionMembers(JsArray, [
      'get',
      'set',
      'add',
      'addAll',
      'insert',
      'removeAt',
      'removeLast',
      'removeRange',
      'setRange',
      'sort',
      'length',
      'length'
    ]);
    return JsArray;
  });
  js.JsArray = js.JsArray$();
  js._isBrowserType = function(o) {
    return o instanceof Blob || o instanceof Event || window.KeyRange && o instanceof KeyRange || o instanceof ImageData || o instanceof Node || window.TypedData && o instanceof TypedData || o instanceof Window;
  };
  dart.fn(js._isBrowserType, core.bool, [dart.dynamic]);
  const _dartObj = Symbol('_dartObj');
  js._DartObject = class _DartObject extends core.Object {
    _DartObject(dartObj) {
      this[_dartObj] = dartObj;
    }
  };
  dart.setSignature(js._DartObject, {
    constructors: () => ({_DartObject: [js._DartObject, [dart.dynamic]]})
  });
  js._convertToJS = function(o) {
    if (o == null || typeof o == 'string' || typeof o == 'number' || typeof o == 'boolean' || dart.notNull(js._isBrowserType(o))) {
      return o;
    } else if (dart.is(o, core.DateTime)) {
      return _js_helper.Primitives.lazyAsJsDate(o);
    } else if (dart.is(o, js.JsObject)) {
      return o[_jsObject];
    } else if (dart.is(o, core.Function)) {
      return js._putIfAbsent(js._jsProxies, o, js._wrapDartFunction);
    } else {
      return js._putIfAbsent(js._jsProxies, o, dart.fn(o => new js._DartObject(o), js._DartObject, [dart.dynamic]));
    }
  };
  dart.fn(js._convertToJS);
  js._wrapDartFunction = function(f) {
    let wrapper = function() {
      let args = Array.prototype.map.call(arguments, js._convertToDart);
      return js._convertToJS(f(...args));
    };
    dart.dsetindex(js._dartProxies, wrapper, f);
    return wrapper;
  };
  dart.fn(js._wrapDartFunction);
  js._convertToDart = function(o) {
    if (o == null || typeof o == "string" || typeof o == "number" || typeof o == "boolean" || dart.notNull(js._isBrowserType(o))) {
      return o;
    } else if (o instanceof Date) {
      let ms = o.getTime();
      return new core.DateTime.fromMillisecondsSinceEpoch(dart.asInt(ms));
    } else if (dart.is(o, js._DartObject) && dart.jsobject != dart.getReifiedType(o)) {
      return o[_dartObj];
    } else {
      return js._putIfAbsent(js._dartProxies, o, js._wrapToDart);
    }
  };
  dart.fn(js._convertToDart, core.Object, [dart.dynamic]);
  js._wrapToDart = function(o) {
    if (typeof o == "function") {
      return new js.JsFunction._fromJs(o);
    }
    if (o instanceof Array) {
      return new js.JsArray._fromJs(o);
    }
    return new js.JsObject._fromJs(o);
  };
  dart.fn(js._wrapToDart, js.JsObject, [dart.dynamic]);
  dart.defineLazy(js, {
    get _dartProxies() {
      return new WeakMap();
    }
  });
  dart.defineLazy(js, {
    get _jsProxies() {
      return new WeakMap();
    }
  });
  js._putIfAbsent = function(weakMap, o, getValue) {
    let value = weakMap.get(o);
    if (value == null) {
      value = dart.dcall(getValue, o);
      weakMap.set(o, value);
    }
    return value;
  };
  dart.fn(js._putIfAbsent, core.Object, [dart.dynamic, dart.dynamic, dart.functionType(dart.dynamic, [dart.dynamic])]);
  js.allowInterop = function(f) {
    return f;
  };
  dart.fn(js.allowInterop, core.Function, [core.Function]);
  dart.defineLazy(js, {
    get _interopCaptureThisExpando() {
      return new (core.Expando$(core.Function))();
    },
    set _interopCaptureThisExpando(_) {}
  });
  js.allowInteropCaptureThis = function(f) {
    let ret = js._interopCaptureThisExpando.get(f);
    if (ret == null) {
      ret = function() {
        let args = [this];
        for (let arg of arguments) {
          args.push(arg);
        }
        return f(...args);
      };
      js._interopCaptureThisExpando.set(f, ret);
    }
    return ret;
  };
  dart.fn(js.allowInteropCaptureThis, core.Function, [core.Function]);
  math.E = 2.718281828459045;
  math.LN10 = 2.302585092994046;
  math.LN2 = 0.6931471805599453;
  math.LOG2E = 1.4426950408889634;
  math.LOG10E = 0.4342944819032518;
  math.PI = 3.141592653589793;
  math.SQRT1_2 = 0.7071067811865476;
  math.SQRT2 = 1.4142135623730951;
  math.min = function(T) {
    return (a, b) => {
      if (!(typeof a == 'number')) dart.throw(new core.ArgumentError(a));
      if (!(typeof b == 'number')) dart.throw(new core.ArgumentError(b));
      if (dart.notNull(a) > dart.notNull(b)) return b;
      if (dart.notNull(a) < dart.notNull(b)) return a;
      if (typeof b == 'number') {
        if (typeof a == 'number') {
          if (a == 0.0) {
            return (dart.notNull(a) + dart.notNull(b)) * dart.notNull(a) * dart.notNull(b);
          }
        }
        if (a == 0 && dart.notNull(b[dartx.isNegative]) || dart.notNull(b[dartx.isNaN])) return b;
        return a;
      }
      return a;
    };
  };
  dart.fn(math.min, T => [T, [T, T]]);
  math.max = function(T) {
    return (a, b) => {
      if (!(typeof a == 'number')) dart.throw(new core.ArgumentError(a));
      if (!(typeof b == 'number')) dart.throw(new core.ArgumentError(b));
      if (dart.notNull(a) > dart.notNull(b)) return a;
      if (dart.notNull(a) < dart.notNull(b)) return b;
      if (typeof b == 'number') {
        if (typeof a == 'number') {
          if (a == 0.0) {
            return dart.notNull(a) + dart.notNull(b);
          }
        }
        if (dart.notNull(b[dartx.isNaN])) return b;
        return a;
      }
      if (b == 0 && dart.notNull(a[dartx.isNegative])) return b;
      return a;
    };
  };
  dart.fn(math.max, T => [T, [T, T]]);
  math.atan2 = function(a, b) {
    return Math.atan2(_js_helper.checkNum(a), _js_helper.checkNum(b));
  };
  dart.fn(math.atan2, core.double, [core.num, core.num]);
  math.pow = function(x, exponent) {
    _js_helper.checkNum(x);
    _js_helper.checkNum(exponent);
    return Math.pow(x, exponent);
  };
  dart.fn(math.pow, core.num, [core.num, core.num]);
  math.sin = function(x) {
    return Math.sin(_js_helper.checkNum(x));
  };
  dart.fn(math.sin, core.double, [core.num]);
  math.cos = function(x) {
    return Math.cos(_js_helper.checkNum(x));
  };
  dart.fn(math.cos, core.double, [core.num]);
  math.tan = function(x) {
    return Math.tan(_js_helper.checkNum(x));
  };
  dart.fn(math.tan, core.double, [core.num]);
  math.acos = function(x) {
    return Math.acos(_js_helper.checkNum(x));
  };
  dart.fn(math.acos, core.double, [core.num]);
  math.asin = function(x) {
    return Math.asin(_js_helper.checkNum(x));
  };
  dart.fn(math.asin, core.double, [core.num]);
  math.atan = function(x) {
    return Math.atan(_js_helper.checkNum(x));
  };
  dart.fn(math.atan, core.double, [core.num]);
  math.sqrt = function(x) {
    return Math.sqrt(_js_helper.checkNum(x));
  };
  dart.fn(math.sqrt, core.double, [core.num]);
  math.exp = function(x) {
    return Math.exp(_js_helper.checkNum(x));
  };
  dart.fn(math.exp, core.double, [core.num]);
  math.log = function(x) {
    return Math.log(_js_helper.checkNum(x));
  };
  dart.fn(math.log, core.double, [core.num]);
  math._POW2_32 = 4294967296;
  math._JSRandom = class _JSRandom extends core.Object {
    _JSRandom() {
    }
    nextInt(max) {
      if (dart.notNull(max) <= 0 || dart.notNull(max) > dart.notNull(math._POW2_32)) {
        dart.throw(new core.RangeError(`max must be in range 0 < max ≤ 2^32, was ${max}`));
      }
      return Math.random() * max >>> 0;
    }
    nextDouble() {
      return Math.random();
    }
    nextBool() {
      return Math.random() < 0.5;
    }
  };
  math._JSRandom[dart.implements] = () => [math.Random];
  dart.setSignature(math._JSRandom, {
    constructors: () => ({_JSRandom: [math._JSRandom, []]}),
    methods: () => ({
      nextInt: [core.int, [core.int]],
      nextDouble: [core.double, []],
      nextBool: [core.bool, []]
    })
  });
  const _lo = Symbol('_lo');
  const _hi = Symbol('_hi');
  const _nextState = Symbol('_nextState');
  math._Random = class _Random extends core.Object {
    _Random(seed) {
      this[_lo] = 0;
      this[_hi] = 0;
      let empty_seed = 0;
      if (dart.notNull(seed) < 0) {
        empty_seed = -1;
      }
      do {
        let low = (dart.notNull(seed) & dart.notNull(math._Random._MASK32)) >>> 0;
        seed = ((dart.notNull(seed) - low) / dart.notNull(math._POW2_32))[dartx.truncate]();
        let high = (dart.notNull(seed) & dart.notNull(math._Random._MASK32)) >>> 0;
        seed = ((dart.notNull(seed) - high) / dart.notNull(math._POW2_32))[dartx.truncate]();
        let tmplow = low << 21 >>> 0;
        let tmphigh = (high << 21 | low[dartx['>>']](11)) >>> 0;
        tmplow = ((~low & dart.notNull(math._Random._MASK32)) >>> 0) + tmplow;
        low = (tmplow & dart.notNull(math._Random._MASK32)) >>> 0;
        high = ((~high >>> 0) + tmphigh + ((tmplow - low) / 4294967296)[dartx.truncate]() & dart.notNull(math._Random._MASK32)) >>> 0;
        tmphigh = high[dartx['>>']](24);
        tmplow = (low[dartx['>>']](24) | high << 8) >>> 0;
        low = (low ^ tmplow) >>> 0;
        high = (high ^ tmphigh) >>> 0;
        tmplow = low * 265;
        low = (tmplow & dart.notNull(math._Random._MASK32)) >>> 0;
        high = (high * 265 + ((tmplow - low) / 4294967296)[dartx.truncate]() & dart.notNull(math._Random._MASK32)) >>> 0;
        tmphigh = high[dartx['>>']](14);
        tmplow = (low[dartx['>>']](14) | high << 18) >>> 0;
        low = (low ^ tmplow) >>> 0;
        high = (high ^ tmphigh) >>> 0;
        tmplow = low * 21;
        low = (tmplow & dart.notNull(math._Random._MASK32)) >>> 0;
        high = (high * 21 + ((tmplow - low) / 4294967296)[dartx.truncate]() & dart.notNull(math._Random._MASK32)) >>> 0;
        tmphigh = high[dartx['>>']](28);
        tmplow = (low[dartx['>>']](28) | high << 4) >>> 0;
        low = (low ^ tmplow) >>> 0;
        high = (high ^ tmphigh) >>> 0;
        tmplow = low << 31 >>> 0;
        tmphigh = (high << 31 | low[dartx['>>']](1)) >>> 0;
        tmplow = tmplow + low;
        low = (tmplow & dart.notNull(math._Random._MASK32)) >>> 0;
        high = (high + tmphigh + ((tmplow - low) / 4294967296)[dartx.truncate]() & dart.notNull(math._Random._MASK32)) >>> 0;
        tmplow = dart.notNull(this[_lo]) * 1037;
        this[_lo] = (tmplow & dart.notNull(math._Random._MASK32)) >>> 0;
        this[_hi] = (dart.notNull(this[_hi]) * 1037 + ((tmplow - dart.notNull(this[_lo])) / 4294967296)[dartx.truncate]() & dart.notNull(math._Random._MASK32)) >>> 0;
        this[_lo] = (dart.notNull(this[_lo]) ^ low) >>> 0;
        this[_hi] = (dart.notNull(this[_hi]) ^ high) >>> 0;
      } while (seed != empty_seed);
      if (this[_hi] == 0 && this[_lo] == 0) {
        this[_lo] = 23063;
      }
      this[_nextState]();
      this[_nextState]();
      this[_nextState]();
      this[_nextState]();
    }
    [_nextState]() {
      let tmpHi = 4294901760 * dart.notNull(this[_lo]);
      let tmpHiLo = (tmpHi & dart.notNull(math._Random._MASK32)) >>> 0;
      let tmpHiHi = tmpHi - tmpHiLo;
      let tmpLo = 55905 * dart.notNull(this[_lo]);
      let tmpLoLo = (tmpLo & dart.notNull(math._Random._MASK32)) >>> 0;
      let tmpLoHi = tmpLo - tmpLoLo;
      let newLo = tmpLoLo + tmpHiLo + dart.notNull(this[_hi]);
      this[_lo] = (newLo & dart.notNull(math._Random._MASK32)) >>> 0;
      let newLoHi = newLo - dart.notNull(this[_lo]);
      this[_hi] = (((tmpLoHi + tmpHiHi + newLoHi) / dart.notNull(math._POW2_32))[dartx.truncate]() & dart.notNull(math._Random._MASK32)) >>> 0;
      dart.assert(dart.notNull(this[_lo]) < dart.notNull(math._POW2_32));
      dart.assert(dart.notNull(this[_hi]) < dart.notNull(math._POW2_32));
    }
    nextInt(max) {
      if (dart.notNull(max) <= 0 || dart.notNull(max) > dart.notNull(math._POW2_32)) {
        dart.throw(new core.RangeError(`max must be in range 0 < max ≤ 2^32, was ${max}`));
      }
      if ((dart.notNull(max) & dart.notNull(max) - 1) >>> 0 == 0) {
        this[_nextState]();
        return (dart.notNull(this[_lo]) & dart.notNull(max) - 1) >>> 0;
      }
      let rnd32 = null;
      let result = null;
      do {
        this[_nextState]();
        rnd32 = this[_lo];
        result = dart.asInt(rnd32[dartx.remainder](max));
      } while (dart.notNull(rnd32) - dart.notNull(result) + dart.notNull(max) >= dart.notNull(math._POW2_32));
      return result;
    }
    nextDouble() {
      this[_nextState]();
      let bits26 = (dart.notNull(this[_lo]) & (1 << 26) - 1) >>> 0;
      this[_nextState]();
      let bits27 = (dart.notNull(this[_lo]) & (1 << 27) - 1) >>> 0;
      return (bits26 * dart.notNull(math._Random._POW2_27_D) + bits27) / dart.notNull(math._Random._POW2_53_D);
    }
    nextBool() {
      this[_nextState]();
      return (dart.notNull(this[_lo]) & 1) == 0;
    }
  };
  math._Random[dart.implements] = () => [math.Random];
  dart.setSignature(math._Random, {
    constructors: () => ({_Random: [math._Random, [core.int]]}),
    methods: () => ({
      [_nextState]: [dart.void, []],
      nextInt: [core.int, [core.int]],
      nextDouble: [core.double, []],
      nextBool: [core.bool, []]
    })
  });
  math._Random._POW2_53_D = 1.0 * 9007199254740992;
  math._Random._POW2_27_D = 1.0 * (1 << 27);
  math._Random._MASK32 = 4294967295;
  math._JenkinsSmiHash = class _JenkinsSmiHash extends core.Object {
    static combine(hash, value) {
      hash = 536870911 & dart.notNull(hash) + dart.notNull(value);
      hash = 536870911 & dart.notNull(hash) + ((524287 & dart.notNull(hash)) << 10);
      return (dart.notNull(hash) ^ hash[dartx['>>']](6)) >>> 0;
    }
    static finish(hash) {
      hash = 536870911 & dart.notNull(hash) + ((67108863 & dart.notNull(hash)) << 3);
      hash = (dart.notNull(hash) ^ hash[dartx['>>']](11)) >>> 0;
      return 536870911 & dart.notNull(hash) + ((16383 & dart.notNull(hash)) << 15);
    }
    static hash2(a, b) {
      return math._JenkinsSmiHash.finish(math._JenkinsSmiHash.combine(math._JenkinsSmiHash.combine(0, dart.as(a, core.int)), dart.as(b, core.int)));
    }
    static hash4(a, b, c, d) {
      return math._JenkinsSmiHash.finish(math._JenkinsSmiHash.combine(math._JenkinsSmiHash.combine(math._JenkinsSmiHash.combine(math._JenkinsSmiHash.combine(0, dart.as(a, core.int)), dart.as(b, core.int)), dart.as(c, core.int)), dart.as(d, core.int)));
    }
  };
  dart.setSignature(math._JenkinsSmiHash, {
    statics: () => ({
      combine: [core.int, [core.int, core.int]],
      finish: [core.int, [core.int]],
      hash2: [core.int, [dart.dynamic, dart.dynamic]],
      hash4: [core.int, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]]
    }),
    names: ['combine', 'finish', 'hash2', 'hash4']
  });
  math.Point$ = dart.generic(T => {
    class Point extends core.Object {
      Point(x, y) {
        this.x = x;
        this.y = y;
      }
      toString() {
        return `Point(${this.x}, ${this.y})`;
      }
      ['=='](other) {
        if (!dart.is(other, math.Point$(core.num))) return false;
        return dart.equals(this.x, dart.dload(other, 'x')) && dart.equals(this.y, dart.dload(other, 'y'));
      }
      get hashCode() {
        return math._JenkinsSmiHash.hash2(dart.hashCode(this.x), dart.hashCode(this.y));
      }
      ['+'](other) {
        dart.as(other, math.Point$(T));
        return new (math.Point$(T))(dart.notNull(this.x) + dart.notNull(other.x), dart.notNull(this.y) + dart.notNull(other.y));
      }
      ['-'](other) {
        dart.as(other, math.Point$(T));
        return new (math.Point$(T))(dart.notNull(this.x) - dart.notNull(other.x), dart.notNull(this.y) - dart.notNull(other.y));
      }
      ['*'](factor) {
        return new (math.Point$(T))(dart.notNull(this.x) * dart.notNull(factor), dart.notNull(this.y) * dart.notNull(factor));
      }
      get magnitude() {
        return math.sqrt(dart.notNull(this.x) * dart.notNull(this.x) + dart.notNull(this.y) * dart.notNull(this.y));
      }
      distanceTo(other) {
        dart.as(other, math.Point$(T));
        let dx = dart.notNull(this.x) - dart.notNull(other.x);
        let dy = dart.notNull(this.y) - dart.notNull(other.y);
        return math.sqrt(dx * dx + dy * dy);
      }
      squaredDistanceTo(other) {
        dart.as(other, math.Point$(T));
        let dx = dart.notNull(this.x) - dart.notNull(other.x);
        let dy = dart.notNull(this.y) - dart.notNull(other.y);
        return dx * dx + dy * dy;
      }
    }
    dart.setSignature(Point, {
      constructors: () => ({Point: [math.Point$(T), [T, T]]}),
      methods: () => ({
        '+': [math.Point$(T), [math.Point$(T)]],
        '-': [math.Point$(T), [math.Point$(T)]],
        '*': [math.Point$(T), [core.num]],
        distanceTo: [core.double, [math.Point$(T)]],
        squaredDistanceTo: [T, [math.Point$(T)]]
      })
    });
    return Point;
  });
  math.Point = math.Point$();
  math.Random = class Random extends core.Object {
    static new(seed) {
      if (seed === void 0) seed = null;
      return seed == null ? dart.const(new math._JSRandom()) : new math._Random(seed);
    }
  };
  dart.setSignature(math.Random, {
    constructors: () => ({new: [math.Random, [], [core.int]]})
  });
  math._RectangleBase$ = dart.generic(T => {
    dart.defineExtensionNames([
      'right',
      'bottom',
      'toString',
      '==',
      'hashCode',
      'intersection',
      'intersects',
      'boundingBox',
      'containsRectangle',
      'containsPoint',
      'topLeft',
      'topRight',
      'bottomRight',
      'bottomLeft'
    ]);
    class _RectangleBase extends core.Object {
      _RectangleBase() {
      }
      get right() {
        return dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]);
      }
      get bottom() {
        return dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]);
      }
      toString() {
        return `Rectangle (${this[dartx.left]}, ${this[dartx.top]}) ${this[dartx.width]} x ${this[dartx.height]}`;
      }
      ['=='](other) {
        if (!dart.is(other, math.Rectangle$(core.num))) return false;
        return dart.equals(this[dartx.left], dart.dload(other, 'left')) && dart.equals(this[dartx.top], dart.dload(other, 'top')) && dart.equals(this[dartx.right], dart.dload(other, 'right')) && dart.equals(this[dartx.bottom], dart.dload(other, 'bottom'));
      }
      get hashCode() {
        return math._JenkinsSmiHash.hash4(dart.hashCode(this[dartx.left]), dart.hashCode(this[dartx.top]), dart.hashCode(this[dartx.right]), dart.hashCode(this[dartx.bottom]));
      }
      intersection(other) {
        dart.as(other, math.Rectangle$(T));
        let x0 = math.max(T)(this[dartx.left], other[dartx.left]);
        let x1 = math.min(T)(dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]), dart.notNull(other[dartx.left]) + dart.notNull(other[dartx.width]));
        if (dart.notNull(x0) <= dart.notNull(x1)) {
          let y0 = math.max(T)(this[dartx.top], other[dartx.top]);
          let y1 = math.min(T)(dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]), dart.notNull(other[dartx.top]) + dart.notNull(other[dartx.height]));
          if (dart.notNull(y0) <= dart.notNull(y1)) {
            return new (math.Rectangle$(T))(x0, y0, dart.notNull(x1) - dart.notNull(x0), dart.notNull(y1) - dart.notNull(y0));
          }
        }
        return null;
      }
      intersects(other) {
        return dart.notNull(this[dartx.left]) <= dart.notNull(other[dartx.left]) + dart.notNull(other[dartx.width]) && dart.notNull(other[dartx.left]) <= dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]) && dart.notNull(this[dartx.top]) <= dart.notNull(other[dartx.top]) + dart.notNull(other[dartx.height]) && dart.notNull(other[dartx.top]) <= dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]);
      }
      boundingBox(other) {
        dart.as(other, math.Rectangle$(T));
        let right = math.max(T)(dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]), dart.notNull(other[dartx.left]) + dart.notNull(other[dartx.width]));
        let bottom = math.max(T)(dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]), dart.notNull(other[dartx.top]) + dart.notNull(other[dartx.height]));
        let left = math.min(T)(this[dartx.left], other[dartx.left]);
        let top = math.min(T)(this[dartx.top], other[dartx.top]);
        return new (math.Rectangle$(T))(left, top, dart.notNull(right) - dart.notNull(left), dart.notNull(bottom) - dart.notNull(top));
      }
      containsRectangle(another) {
        return dart.notNull(this[dartx.left]) <= dart.notNull(another[dartx.left]) && dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]) >= dart.notNull(another[dartx.left]) + dart.notNull(another[dartx.width]) && dart.notNull(this[dartx.top]) <= dart.notNull(another[dartx.top]) && dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]) >= dart.notNull(another[dartx.top]) + dart.notNull(another[dartx.height]);
      }
      containsPoint(another) {
        return dart.notNull(another.x) >= dart.notNull(this[dartx.left]) && dart.notNull(another.x) <= dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]) && dart.notNull(another.y) >= dart.notNull(this[dartx.top]) && dart.notNull(another.y) <= dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]);
      }
      get topLeft() {
        return new (math.Point$(T))(this[dartx.left], this[dartx.top]);
      }
      get topRight() {
        return new (math.Point$(T))(dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]), this[dartx.top]);
      }
      get bottomRight() {
        return new (math.Point$(T))(dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]), dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]));
      }
      get bottomLeft() {
        return new (math.Point$(T))(this[dartx.left], dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]));
      }
    }
    dart.setSignature(_RectangleBase, {
      constructors: () => ({_RectangleBase: [math._RectangleBase$(T), []]}),
      methods: () => ({
        intersection: [math.Rectangle$(T), [math.Rectangle$(T)]],
        intersects: [core.bool, [math.Rectangle$(core.num)]],
        boundingBox: [math.Rectangle$(T), [math.Rectangle$(T)]],
        containsRectangle: [core.bool, [math.Rectangle$(core.num)]],
        containsPoint: [core.bool, [math.Point$(core.num)]]
      })
    });
    dart.defineExtensionMembers(_RectangleBase, [
      'toString',
      '==',
      'intersection',
      'intersects',
      'boundingBox',
      'containsRectangle',
      'containsPoint',
      'right',
      'bottom',
      'hashCode',
      'topLeft',
      'topRight',
      'bottomRight',
      'bottomLeft'
    ]);
    return _RectangleBase;
  });
  math._RectangleBase = math._RectangleBase$();
  math.Rectangle$ = dart.generic(T => {
    dart.defineExtensionNames([
      'left',
      'top',
      'width',
      'height'
    ]);
    class Rectangle extends math._RectangleBase$(T) {
      Rectangle(left, top, width, height) {
        this[dartx.left] = left;
        this[dartx.top] = top;
        this[dartx.width] = dart.notNull(width) < 0 ? -dart.notNull(width) * 0 : width;
        this[dartx.height] = dart.notNull(height) < 0 ? -dart.notNull(height) * 0 : height;
        super._RectangleBase();
      }
      static fromPoints(a, b) {
        let left = math.min(T)(a.x, b.x);
        let width = dart.notNull(math.max(T)(a.x, b.x)) - dart.notNull(left);
        let top = math.min(T)(a.y, b.y);
        let height = dart.notNull(math.max(T)(a.y, b.y)) - dart.notNull(top);
        return new (math.Rectangle$(T))(left, top, width, height);
      }
    }
    dart.setSignature(Rectangle, {
      constructors: () => ({
        Rectangle: [math.Rectangle$(T), [T, T, T, T]],
        fromPoints: [math.Rectangle$(T), [math.Point$(T), math.Point$(T)]]
      })
    });
    dart.defineExtensionMembers(Rectangle, ['left', 'top', 'width', 'height']);
    return Rectangle;
  });
  math.Rectangle = math.Rectangle$();
  const _width = Symbol('_width');
  const _height = Symbol('_height');
  math.MutableRectangle$ = dart.generic(T => {
    class MutableRectangle extends math._RectangleBase$(T) {
      MutableRectangle(left, top, width, height) {
        this.left = left;
        this.top = top;
        this[_width] = dart.notNull(width) < 0 ? math._clampToZero(width) : width;
        this[_height] = dart.notNull(height) < 0 ? math._clampToZero(height) : height;
        super._RectangleBase();
      }
      static fromPoints(a, b) {
        let left = math.min(T)(a.x, b.x);
        let width = dart.notNull(math.max(T)(a.x, b.x)) - dart.notNull(left);
        let top = math.min(T)(a.y, b.y);
        let height = dart.notNull(math.max(T)(a.y, b.y)) - dart.notNull(top);
        return new (math.MutableRectangle$(T))(left, top, width, height);
      }
      get width() {
        return this[_width];
      }
      set width(width) {
        dart.as(width, T);
        if (dart.notNull(width) < 0) width = math._clampToZero(width);
        this[_width] = width;
      }
      get height() {
        return this[_height];
      }
      set height(height) {
        dart.as(height, T);
        if (dart.notNull(height) < 0) height = math._clampToZero(height);
        this[_height] = height;
      }
    }
    MutableRectangle[dart.implements] = () => [math.Rectangle$(T)];
    dart.setSignature(MutableRectangle, {
      constructors: () => ({
        MutableRectangle: [math.MutableRectangle$(T), [T, T, T, T]],
        fromPoints: [math.MutableRectangle$(T), [math.Point$(T), math.Point$(T)]]
      })
    });
    dart.defineExtensionMembers(MutableRectangle, ['left', 'top', 'width', 'height']);
    return MutableRectangle;
  });
  math.MutableRectangle = math.MutableRectangle$();
  math._clampToZero = function(value) {
    dart.assert(dart.notNull(value) < 0);
    return -dart.notNull(value) * 0;
  };
  dart.fn(math._clampToZero, core.num, [core.num]);
  mirrors.MirrorSystem = class MirrorSystem extends core.Object {
    findLibrary(libraryName) {
      return this.libraries[dartx.values][dartx.singleWhere](dart.fn(library => dart.equals(library.simpleName, libraryName), core.bool, [mirrors.LibraryMirror]));
    }
    static getName(symbol) {
      return _js_mirrors.getName(symbol);
    }
    static getSymbol(name, library) {
      if (library === void 0) library = null;
      return _js_mirrors.getSymbol(name, library);
    }
  };
  dart.setSignature(mirrors.MirrorSystem, {
    methods: () => ({findLibrary: [mirrors.LibraryMirror, [core.Symbol]]}),
    statics: () => ({
      getName: [core.String, [core.Symbol]],
      getSymbol: [core.Symbol, [core.String], [mirrors.LibraryMirror]]
    }),
    names: ['getName', 'getSymbol']
  });
  mirrors.currentMirrorSystem = function() {
    return dart.as(_js_mirrors.currentJsMirrorSystem, mirrors.MirrorSystem);
  };
  dart.fn(mirrors.currentMirrorSystem, mirrors.MirrorSystem, []);
  mirrors.reflect = function(reflectee) {
    return _js_mirrors.reflect(reflectee);
  };
  dart.lazyFn(mirrors.reflect, () => [mirrors.InstanceMirror, [core.Object]]);
  mirrors.reflectClass = function(key) {
    if (!dart.is(key, core.Type) || dart.equals(key, dart.wrapType(dart.dynamic))) {
      dart.throw(new core.ArgumentError(`${key} does not denote a class`));
    }
    let tm = mirrors.reflectType(key);
    if (!dart.is(tm, mirrors.ClassMirror)) {
      dart.throw(new core.ArgumentError(`${key} does not denote a class`));
    }
    return dart.as(dart.as(tm, mirrors.ClassMirror).originalDeclaration, mirrors.ClassMirror);
  };
  dart.lazyFn(mirrors.reflectClass, () => [mirrors.ClassMirror, [core.Type]]);
  mirrors.reflectType = function(key) {
    if (dart.equals(key, dart.wrapType(dart.dynamic))) {
      return mirrors.currentMirrorSystem().dynamicType;
    }
    return _js_mirrors.reflectType(key);
  };
  dart.lazyFn(mirrors.reflectType, () => [mirrors.TypeMirror, [core.Type]]);
  mirrors.Mirror = class Mirror extends core.Object {};
  mirrors.IsolateMirror = class IsolateMirror extends core.Object {};
  mirrors.IsolateMirror[dart.implements] = () => [mirrors.Mirror];
  mirrors.DeclarationMirror = class DeclarationMirror extends core.Object {};
  mirrors.DeclarationMirror[dart.implements] = () => [mirrors.Mirror];
  mirrors.ObjectMirror = class ObjectMirror extends core.Object {};
  mirrors.ObjectMirror[dart.implements] = () => [mirrors.Mirror];
  mirrors.InstanceMirror = class InstanceMirror extends core.Object {};
  mirrors.InstanceMirror[dart.implements] = () => [mirrors.ObjectMirror];
  mirrors.ClosureMirror = class ClosureMirror extends core.Object {};
  mirrors.ClosureMirror[dart.implements] = () => [mirrors.InstanceMirror];
  mirrors.LibraryMirror = class LibraryMirror extends core.Object {};
  mirrors.LibraryMirror[dart.implements] = () => [mirrors.DeclarationMirror, mirrors.ObjectMirror];
  mirrors.LibraryDependencyMirror = class LibraryDependencyMirror extends core.Object {};
  mirrors.LibraryDependencyMirror[dart.implements] = () => [mirrors.Mirror];
  mirrors.CombinatorMirror = class CombinatorMirror extends core.Object {};
  mirrors.CombinatorMirror[dart.implements] = () => [mirrors.Mirror];
  mirrors.TypeMirror = class TypeMirror extends core.Object {};
  mirrors.TypeMirror[dart.implements] = () => [mirrors.DeclarationMirror];
  mirrors.ClassMirror = class ClassMirror extends core.Object {};
  mirrors.ClassMirror[dart.implements] = () => [mirrors.TypeMirror, mirrors.ObjectMirror];
  mirrors.FunctionTypeMirror = class FunctionTypeMirror extends core.Object {};
  mirrors.FunctionTypeMirror[dart.implements] = () => [mirrors.ClassMirror];
  mirrors.TypeVariableMirror = class TypeVariableMirror extends mirrors.TypeMirror {};
  mirrors.TypedefMirror = class TypedefMirror extends core.Object {};
  mirrors.TypedefMirror[dart.implements] = () => [mirrors.TypeMirror];
  mirrors.MethodMirror = class MethodMirror extends core.Object {};
  mirrors.MethodMirror[dart.implements] = () => [mirrors.DeclarationMirror];
  mirrors.VariableMirror = class VariableMirror extends core.Object {};
  mirrors.VariableMirror[dart.implements] = () => [mirrors.DeclarationMirror];
  mirrors.ParameterMirror = class ParameterMirror extends core.Object {};
  mirrors.ParameterMirror[dart.implements] = () => [mirrors.VariableMirror];
  mirrors.SourceLocation = class SourceLocation extends core.Object {};
  mirrors.Comment = class Comment extends core.Object {
    Comment(text, trimmedText, isDocComment) {
      this.text = text;
      this.trimmedText = trimmedText;
      this.isDocComment = isDocComment;
    }
  };
  dart.setSignature(mirrors.Comment, {
    constructors: () => ({Comment: [mirrors.Comment, [core.String, core.String, core.bool]]})
  });
  mirrors.MirrorsUsed = class MirrorsUsed extends core.Object {
    MirrorsUsed(opts) {
      let symbols = opts && 'symbols' in opts ? opts.symbols : null;
      let targets = opts && 'targets' in opts ? opts.targets : null;
      let metaTargets = opts && 'metaTargets' in opts ? opts.metaTargets : null;
      let override = opts && 'override' in opts ? opts.override : null;
      this.symbols = symbols;
      this.targets = targets;
      this.metaTargets = metaTargets;
      this.override = override;
    }
  };
  dart.setSignature(mirrors.MirrorsUsed, {
    constructors: () => ({MirrorsUsed: [mirrors.MirrorsUsed, [], {symbols: dart.dynamic, targets: dart.dynamic, metaTargets: dart.dynamic, override: dart.dynamic}]})
  });
  typed_data.ByteBuffer = class ByteBuffer extends core.Object {};
  typed_data.TypedData = class TypedData extends core.Object {};
  const _littleEndian = Symbol('_littleEndian');
  typed_data.Endianness = class Endianness extends core.Object {
    _(littleEndian) {
      this[_littleEndian] = littleEndian;
    }
  };
  dart.defineNamedConstructor(typed_data.Endianness, '_');
  dart.setSignature(typed_data.Endianness, {
    constructors: () => ({_: [typed_data.Endianness, [core.bool]]})
  });
  dart.defineLazy(typed_data.Endianness, {
    get BIG_ENDIAN() {
      return dart.const(new typed_data.Endianness._(false));
    },
    get LITTLE_ENDIAN() {
      return dart.const(new typed_data.Endianness._(true));
    },
    get HOST_ENDIAN() {
      return typed_data.ByteData.view(typed_data.Uint16List.fromList(dart.list([1], core.int))[dartx.buffer])[dartx.getInt8](0) == 1 ? typed_data.Endianness.LITTLE_ENDIAN : typed_data.Endianness.BIG_ENDIAN;
    }
  });
  typed_data.ByteData = class ByteData extends core.Object {
    static new(length) {
      return _native_typed_data.NativeByteData.new(length);
    }
    static view(buffer, offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      return buffer[dartx.asByteData](offsetInBytes, length);
    }
  };
  typed_data.ByteData[dart.implements] = () => [typed_data.TypedData];
  dart.setSignature(typed_data.ByteData, {
    constructors: () => ({
      new: [typed_data.ByteData, [core.int]],
      view: [typed_data.ByteData, [typed_data.ByteBuffer], [core.int, core.int]]
    })
  });
  typed_data.Int8List = class Int8List extends core.Object {
    static new(length) {
      return _native_typed_data.NativeInt8List.new(length);
    }
    static fromList(elements) {
      return _native_typed_data.NativeInt8List.fromList(elements);
    }
    static view(buffer, offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      return buffer[dartx.asInt8List](offsetInBytes, length);
    }
  };
  typed_data.Int8List[dart.implements] = () => [core.List$(core.int), typed_data.TypedData];
  dart.setSignature(typed_data.Int8List, {
    constructors: () => ({
      new: [typed_data.Int8List, [core.int]],
      fromList: [typed_data.Int8List, [core.List$(core.int)]],
      view: [typed_data.Int8List, [typed_data.ByteBuffer], [core.int, core.int]]
    })
  });
  typed_data.Int8List.BYTES_PER_ELEMENT = 1;
  typed_data.Uint8List = class Uint8List extends core.Object {
    static new(length) {
      return _native_typed_data.NativeUint8List.new(length);
    }
    static fromList(elements) {
      return _native_typed_data.NativeUint8List.fromList(elements);
    }
    static view(buffer, offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      return buffer[dartx.asUint8List](offsetInBytes, length);
    }
  };
  typed_data.Uint8List[dart.implements] = () => [core.List$(core.int), typed_data.TypedData];
  dart.setSignature(typed_data.Uint8List, {
    constructors: () => ({
      new: [typed_data.Uint8List, [core.int]],
      fromList: [typed_data.Uint8List, [core.List$(core.int)]],
      view: [typed_data.Uint8List, [typed_data.ByteBuffer], [core.int, core.int]]
    })
  });
  typed_data.Uint8List.BYTES_PER_ELEMENT = 1;
  typed_data.Uint8ClampedList = class Uint8ClampedList extends core.Object {
    static new(length) {
      return _native_typed_data.NativeUint8ClampedList.new(length);
    }
    static fromList(elements) {
      return _native_typed_data.NativeUint8ClampedList.fromList(elements);
    }
    static view(buffer, offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      return buffer[dartx.asUint8ClampedList](offsetInBytes, length);
    }
  };
  typed_data.Uint8ClampedList[dart.implements] = () => [core.List$(core.int), typed_data.TypedData];
  dart.setSignature(typed_data.Uint8ClampedList, {
    constructors: () => ({
      new: [typed_data.Uint8ClampedList, [core.int]],
      fromList: [typed_data.Uint8ClampedList, [core.List$(core.int)]],
      view: [typed_data.Uint8ClampedList, [typed_data.ByteBuffer], [core.int, core.int]]
    })
  });
  typed_data.Uint8ClampedList.BYTES_PER_ELEMENT = 1;
  typed_data.Int16List = class Int16List extends core.Object {
    static new(length) {
      return _native_typed_data.NativeInt16List.new(length);
    }
    static fromList(elements) {
      return _native_typed_data.NativeInt16List.fromList(elements);
    }
    static view(buffer, offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      return buffer[dartx.asInt16List](offsetInBytes, length);
    }
  };
  typed_data.Int16List[dart.implements] = () => [core.List$(core.int), typed_data.TypedData];
  dart.setSignature(typed_data.Int16List, {
    constructors: () => ({
      new: [typed_data.Int16List, [core.int]],
      fromList: [typed_data.Int16List, [core.List$(core.int)]],
      view: [typed_data.Int16List, [typed_data.ByteBuffer], [core.int, core.int]]
    })
  });
  typed_data.Int16List.BYTES_PER_ELEMENT = 2;
  typed_data.Uint16List = class Uint16List extends core.Object {
    static new(length) {
      return _native_typed_data.NativeUint16List.new(length);
    }
    static fromList(elements) {
      return _native_typed_data.NativeUint16List.fromList(elements);
    }
    static view(buffer, offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      return buffer[dartx.asUint16List](offsetInBytes, length);
    }
  };
  typed_data.Uint16List[dart.implements] = () => [core.List$(core.int), typed_data.TypedData];
  dart.setSignature(typed_data.Uint16List, {
    constructors: () => ({
      new: [typed_data.Uint16List, [core.int]],
      fromList: [typed_data.Uint16List, [core.List$(core.int)]],
      view: [typed_data.Uint16List, [typed_data.ByteBuffer], [core.int, core.int]]
    })
  });
  typed_data.Uint16List.BYTES_PER_ELEMENT = 2;
  typed_data.Int32List = class Int32List extends core.Object {
    static new(length) {
      return _native_typed_data.NativeInt32List.new(length);
    }
    static fromList(elements) {
      return _native_typed_data.NativeInt32List.fromList(elements);
    }
    static view(buffer, offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      return buffer[dartx.asInt32List](offsetInBytes, length);
    }
  };
  typed_data.Int32List[dart.implements] = () => [core.List$(core.int), typed_data.TypedData];
  dart.setSignature(typed_data.Int32List, {
    constructors: () => ({
      new: [typed_data.Int32List, [core.int]],
      fromList: [typed_data.Int32List, [core.List$(core.int)]],
      view: [typed_data.Int32List, [typed_data.ByteBuffer], [core.int, core.int]]
    })
  });
  typed_data.Int32List.BYTES_PER_ELEMENT = 4;
  typed_data.Uint32List = class Uint32List extends core.Object {
    static new(length) {
      return _native_typed_data.NativeUint32List.new(length);
    }
    static fromList(elements) {
      return _native_typed_data.NativeUint32List.fromList(elements);
    }
    static view(buffer, offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      return buffer[dartx.asUint32List](offsetInBytes, length);
    }
  };
  typed_data.Uint32List[dart.implements] = () => [core.List$(core.int), typed_data.TypedData];
  dart.setSignature(typed_data.Uint32List, {
    constructors: () => ({
      new: [typed_data.Uint32List, [core.int]],
      fromList: [typed_data.Uint32List, [core.List$(core.int)]],
      view: [typed_data.Uint32List, [typed_data.ByteBuffer], [core.int, core.int]]
    })
  });
  typed_data.Uint32List.BYTES_PER_ELEMENT = 4;
  typed_data.Int64List = class Int64List extends core.Object {
    static new(length) {
      dart.throw(new core.UnsupportedError("Int64List not supported by dart2js."));
    }
    static fromList(elements) {
      dart.throw(new core.UnsupportedError("Int64List not supported by dart2js."));
    }
    static view(buffer, offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      return buffer[dartx.asInt64List](offsetInBytes, length);
    }
  };
  typed_data.Int64List[dart.implements] = () => [core.List$(core.int), typed_data.TypedData];
  dart.setSignature(typed_data.Int64List, {
    constructors: () => ({
      new: [typed_data.Int64List, [core.int]],
      fromList: [typed_data.Int64List, [core.List$(core.int)]],
      view: [typed_data.Int64List, [typed_data.ByteBuffer], [core.int, core.int]]
    })
  });
  typed_data.Int64List.BYTES_PER_ELEMENT = 8;
  typed_data.Uint64List = class Uint64List extends core.Object {
    static new(length) {
      dart.throw(new core.UnsupportedError("Uint64List not supported by dart2js."));
    }
    static fromList(elements) {
      dart.throw(new core.UnsupportedError("Uint64List not supported by dart2js."));
    }
    static view(buffer, offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      return buffer[dartx.asUint64List](offsetInBytes, length);
    }
  };
  typed_data.Uint64List[dart.implements] = () => [core.List$(core.int), typed_data.TypedData];
  dart.setSignature(typed_data.Uint64List, {
    constructors: () => ({
      new: [typed_data.Uint64List, [core.int]],
      fromList: [typed_data.Uint64List, [core.List$(core.int)]],
      view: [typed_data.Uint64List, [typed_data.ByteBuffer], [core.int, core.int]]
    })
  });
  typed_data.Uint64List.BYTES_PER_ELEMENT = 8;
  typed_data.Float32List = class Float32List extends core.Object {
    static new(length) {
      return _native_typed_data.NativeFloat32List.new(length);
    }
    static fromList(elements) {
      return _native_typed_data.NativeFloat32List.fromList(elements);
    }
    static view(buffer, offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      return buffer[dartx.asFloat32List](offsetInBytes, length);
    }
  };
  typed_data.Float32List[dart.implements] = () => [core.List$(core.double), typed_data.TypedData];
  dart.setSignature(typed_data.Float32List, {
    constructors: () => ({
      new: [typed_data.Float32List, [core.int]],
      fromList: [typed_data.Float32List, [core.List$(core.double)]],
      view: [typed_data.Float32List, [typed_data.ByteBuffer], [core.int, core.int]]
    })
  });
  typed_data.Float32List.BYTES_PER_ELEMENT = 4;
  typed_data.Float64List = class Float64List extends core.Object {
    static new(length) {
      return _native_typed_data.NativeFloat64List.new(length);
    }
    static fromList(elements) {
      return _native_typed_data.NativeFloat64List.fromList(elements);
    }
    static view(buffer, offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      return buffer[dartx.asFloat64List](offsetInBytes, length);
    }
  };
  typed_data.Float64List[dart.implements] = () => [core.List$(core.double), typed_data.TypedData];
  dart.setSignature(typed_data.Float64List, {
    constructors: () => ({
      new: [typed_data.Float64List, [core.int]],
      fromList: [typed_data.Float64List, [core.List$(core.double)]],
      view: [typed_data.Float64List, [typed_data.ByteBuffer], [core.int, core.int]]
    })
  });
  typed_data.Float64List.BYTES_PER_ELEMENT = 8;
  typed_data.Float32x4List = class Float32x4List extends core.Object {
    static new(length) {
      return new _native_typed_data.NativeFloat32x4List(length);
    }
    static fromList(elements) {
      return _native_typed_data.NativeFloat32x4List.fromList(elements);
    }
    static view(buffer, offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      return buffer[dartx.asFloat32x4List](offsetInBytes, length);
    }
  };
  typed_data.Float32x4List[dart.implements] = () => [core.List$(typed_data.Float32x4), typed_data.TypedData];
  dart.setSignature(typed_data.Float32x4List, {
    constructors: () => ({
      new: [typed_data.Float32x4List, [core.int]],
      fromList: [typed_data.Float32x4List, [core.List$(typed_data.Float32x4)]],
      view: [typed_data.Float32x4List, [typed_data.ByteBuffer], [core.int, core.int]]
    })
  });
  typed_data.Float32x4List.BYTES_PER_ELEMENT = 16;
  typed_data.Int32x4List = class Int32x4List extends core.Object {
    static new(length) {
      return new _native_typed_data.NativeInt32x4List(length);
    }
    static fromList(elements) {
      return _native_typed_data.NativeInt32x4List.fromList(elements);
    }
    static view(buffer, offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      return buffer[dartx.asInt32x4List](offsetInBytes, length);
    }
  };
  typed_data.Int32x4List[dart.implements] = () => [core.List$(typed_data.Int32x4), typed_data.TypedData];
  dart.setSignature(typed_data.Int32x4List, {
    constructors: () => ({
      new: [typed_data.Int32x4List, [core.int]],
      fromList: [typed_data.Int32x4List, [core.List$(typed_data.Int32x4)]],
      view: [typed_data.Int32x4List, [typed_data.ByteBuffer], [core.int, core.int]]
    })
  });
  typed_data.Int32x4List.BYTES_PER_ELEMENT = 16;
  typed_data.Float64x2List = class Float64x2List extends core.Object {
    static new(length) {
      return new _native_typed_data.NativeFloat64x2List(length);
    }
    static fromList(elements) {
      return _native_typed_data.NativeFloat64x2List.fromList(elements);
    }
    static view(buffer, offsetInBytes, length) {
      if (offsetInBytes === void 0) offsetInBytes = 0;
      if (length === void 0) length = null;
      return buffer[dartx.asFloat64x2List](offsetInBytes, length);
    }
  };
  typed_data.Float64x2List[dart.implements] = () => [core.List$(typed_data.Float64x2), typed_data.TypedData];
  dart.setSignature(typed_data.Float64x2List, {
    constructors: () => ({
      new: [typed_data.Float64x2List, [core.int]],
      fromList: [typed_data.Float64x2List, [core.List$(typed_data.Float64x2)]],
      view: [typed_data.Float64x2List, [typed_data.ByteBuffer], [core.int, core.int]]
    })
  });
  typed_data.Float64x2List.BYTES_PER_ELEMENT = 16;
  indexed_db._KeyRangeFactoryProvider = class _KeyRangeFactoryProvider extends core.Object {
    static createKeyRange_only(value) {
      return indexed_db._KeyRangeFactoryProvider._only(indexed_db._KeyRangeFactoryProvider._class(), indexed_db._KeyRangeFactoryProvider._translateKey(value));
    }
    static createKeyRange_lowerBound(bound, open) {
      if (open === void 0) open = false;
      return indexed_db._KeyRangeFactoryProvider._lowerBound(indexed_db._KeyRangeFactoryProvider._class(), indexed_db._KeyRangeFactoryProvider._translateKey(bound), open);
    }
    static createKeyRange_upperBound(bound, open) {
      if (open === void 0) open = false;
      return indexed_db._KeyRangeFactoryProvider._upperBound(indexed_db._KeyRangeFactoryProvider._class(), indexed_db._KeyRangeFactoryProvider._translateKey(bound), open);
    }
    static createKeyRange_bound(lower, upper, lowerOpen, upperOpen) {
      if (lowerOpen === void 0) lowerOpen = false;
      if (upperOpen === void 0) upperOpen = false;
      return indexed_db._KeyRangeFactoryProvider._bound(indexed_db._KeyRangeFactoryProvider._class(), indexed_db._KeyRangeFactoryProvider._translateKey(lower), indexed_db._KeyRangeFactoryProvider._translateKey(upper), lowerOpen, upperOpen);
    }
    static _class() {
      if (indexed_db._KeyRangeFactoryProvider._cachedClass != null) return indexed_db._KeyRangeFactoryProvider._cachedClass;
      return indexed_db._KeyRangeFactoryProvider._cachedClass = indexed_db._KeyRangeFactoryProvider._uncachedClass();
    }
    static _uncachedClass() {
      return window.webkitIDBKeyRange || window.mozIDBKeyRange || window.msIDBKeyRange || window.IDBKeyRange;
    }
    static _translateKey(idbkey) {
      return idbkey;
    }
    static _only(cls, value) {
      return cls.only(value);
    }
    static _lowerBound(cls, bound, open) {
      return cls.lowerBound(bound, open);
    }
    static _upperBound(cls, bound, open) {
      return cls.upperBound(bound, open);
    }
    static _bound(cls, lower, upper, lowerOpen, upperOpen) {
      return cls.bound(lower, upper, lowerOpen, upperOpen);
    }
  };
  dart.setSignature(indexed_db._KeyRangeFactoryProvider, {
    statics: () => ({
      createKeyRange_only: [indexed_db.KeyRange, [dart.dynamic]],
      createKeyRange_lowerBound: [indexed_db.KeyRange, [dart.dynamic], [core.bool]],
      createKeyRange_upperBound: [indexed_db.KeyRange, [dart.dynamic], [core.bool]],
      createKeyRange_bound: [indexed_db.KeyRange, [dart.dynamic, dart.dynamic], [core.bool, core.bool]],
      _class: [dart.dynamic, []],
      _uncachedClass: [dart.dynamic, []],
      _translateKey: [dart.dynamic, [dart.dynamic]],
      _only: [indexed_db.KeyRange, [dart.dynamic, dart.dynamic]],
      _lowerBound: [indexed_db.KeyRange, [dart.dynamic, dart.dynamic, dart.dynamic]],
      _upperBound: [indexed_db.KeyRange, [dart.dynamic, dart.dynamic, dart.dynamic]],
      _bound: [indexed_db.KeyRange, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]]
    }),
    names: ['createKeyRange_only', 'createKeyRange_lowerBound', 'createKeyRange_upperBound', 'createKeyRange_bound', '_class', '_uncachedClass', '_translateKey', '_only', '_lowerBound', '_upperBound', '_bound']
  });
  indexed_db._KeyRangeFactoryProvider._cachedClass = null;
  indexed_db._convertNativeToDart_IDBKey = function(nativeKey) {
    function containsDate(object) {
      if (dart.notNull(html_common.isJavaScriptDate(object))) return true;
      if (dart.is(object, core.List)) {
        for (let i = 0; i < dart.notNull(object[dartx.length]); i++) {
          if (dart.test(containsDate(object[dartx.get](i)))) return true;
        }
      }
      return false;
    }
    dart.fn(containsDate);
    if (dart.test(containsDate(nativeKey))) {
      dart.throw(new core.UnimplementedError('Key containing DateTime'));
    }
    return nativeKey;
  };
  dart.fn(indexed_db._convertNativeToDart_IDBKey);
  indexed_db._convertDartToNative_IDBKey = function(dartKey) {
    return dartKey;
  };
  dart.fn(indexed_db._convertDartToNative_IDBKey);
  indexed_db._convertNativeToDart_IDBAny = function(object) {
    return html_common.convertNativeToDart_AcceptStructuredClone(object, {mustCopy: false});
  };
  dart.fn(indexed_db._convertNativeToDart_IDBAny);
  indexed_db._idbKey = 'JSExtendableArray|=Object|num|String';
  indexed_db._annotation_Creates_IDBKey = dart.const(new _js_helper.Creates(indexed_db._idbKey));
  indexed_db._annotation_Returns_IDBKey = dart.const(new _js_helper.Returns(indexed_db._idbKey));
  const _delete = Symbol('_delete');
  const _update = Symbol('_update');
  const _update_1 = Symbol('_update_1');
  dart.defineExtensionNames([
    'delete',
    'update',
    'next',
    'advance',
    'continuePrimaryKey',
    'direction',
    'key',
    'primaryKey',
    'source'
  ]);
  indexed_db.Cursor = class Cursor extends _interceptors.Interceptor {
    [dartx.delete]() {
      try {
        return indexed_db._completeRequest(dart.dynamic)(this[_delete]());
      } catch (e) {
        let stacktrace = dart.stackTrace(e);
        return async.Future.error(e, stacktrace);
      }

    }
    [dartx.update](value) {
      try {
        return indexed_db._completeRequest(dart.dynamic)(this[_update](value));
      } catch (e) {
        let stacktrace = dart.stackTrace(e);
        return async.Future.error(e, stacktrace);
      }

    }
    [dartx.next](key) {
      if (key === void 0) key = null;
      if (key == null) {
        this.continue();
      } else {
        this.continue(key);
      }
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.direction]() {
      return this.direction;
    }
    get [dartx.key]() {
      return this.key;
    }
    get [dartx.primaryKey]() {
      return this.primaryKey;
    }
    get [dartx.source]() {
      return this.source;
    }
    [dartx.advance](count) {
      return this.advance(count);
    }
    [dartx.continuePrimaryKey](key, primaryKey) {
      return this.continuePrimaryKey(key, primaryKey);
    }
    [_delete]() {
      return this.delete();
    }
    [_update](value) {
      let value_1 = html_common.convertDartToNative_SerializedScriptValue(value);
      return this[_update_1](value_1);
    }
    [_update_1](value) {
      return this.update(value);
    }
  };
  dart.setSignature(indexed_db.Cursor, {
    constructors: () => ({_: [indexed_db.Cursor, []]}),
    methods: () => ({
      [dartx.delete]: [async.Future, []],
      [dartx.update]: [async.Future, [dart.dynamic]],
      [dartx.next]: [dart.void, [], [core.Object]],
      [dartx.advance]: [dart.void, [core.int]],
      [dartx.continuePrimaryKey]: [dart.void, [core.Object, core.Object]],
      [_delete]: [indexed_db.Request, []],
      [_update]: [indexed_db.Request, [dart.dynamic]],
      [_update_1]: [indexed_db.Request, [dart.dynamic]]
    })
  });
  indexed_db.Cursor[dart.metadata] = () => [dart.const(new _metadata.DomName('IDBCursor')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("IDBCursor"))];
  dart.registerExtension(dart.global.IDBCursor, indexed_db.Cursor);
  const _get_value = Symbol('_get_value');
  dart.defineExtensionNames([
    'value'
  ]);
  indexed_db.CursorWithValue = class CursorWithValue extends indexed_db.Cursor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.value]() {
      return indexed_db._convertNativeToDart_IDBAny(this[_get_value]);
    }
    get [_get_value]() {
      return this.value;
    }
  };
  dart.setSignature(indexed_db.CursorWithValue, {
    constructors: () => ({_: [indexed_db.CursorWithValue, []]})
  });
  indexed_db.CursorWithValue[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('IDBCursorWithValue')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("IDBCursorWithValue"))];
  dart.registerExtension(dart.global.IDBCursorWithValue, indexed_db.CursorWithValue);
  const _createObjectStore = Symbol('_createObjectStore');
  const _transaction = Symbol('_transaction');
  const _createObjectStore_1 = Symbol('_createObjectStore_1');
  const _createObjectStore_2 = Symbol('_createObjectStore_2');
  const _addEventListener = Symbol('_addEventListener');
  const _removeEventListener = Symbol('_removeEventListener');
  dart.defineExtensionNames([
    'on',
    'addEventListener',
    'removeEventListener',
    'dispatchEvent'
  ]);
  html$.EventTarget = class EventTarget extends _interceptors.Interceptor {
    _created() {
      super.Interceptor();
    }
    get [dartx.on]() {
      return new html$.Events(this);
    }
    [dartx.addEventListener](type, listener, useCapture) {
      if (useCapture === void 0) useCapture = null;
      if (listener != null) {
        this[_addEventListener](type, listener, useCapture);
      }
    }
    [dartx.removeEventListener](type, listener, useCapture) {
      if (useCapture === void 0) useCapture = null;
      if (listener != null) {
        this[_removeEventListener](type, listener, useCapture);
      }
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [_addEventListener](type, listener, capture) {
      return this.addEventListener(type, listener, capture);
    }
    [dartx.dispatchEvent](event) {
      return this.dispatchEvent(event);
    }
    [_removeEventListener](type, listener, capture) {
      return this.removeEventListener(type, listener, capture);
    }
  };
  dart.defineNamedConstructor(html$.EventTarget, '_created');
  dart.setSignature(html$.EventTarget, {
    constructors: () => ({
      _created: [html$.EventTarget, []],
      _: [html$.EventTarget, []]
    }),
    methods: () => ({
      [dartx.addEventListener]: [dart.void, [core.String, html$.EventListener], [core.bool]],
      [dartx.removeEventListener]: [dart.void, [core.String, html$.EventListener], [core.bool]],
      [_addEventListener]: [dart.void, [core.String, html$.EventListener], [core.bool]],
      [dartx.dispatchEvent]: [core.bool, [html$.Event]],
      [_removeEventListener]: [dart.void, [core.String, html$.EventListener], [core.bool]]
    })
  });
  html$.EventTarget[dart.metadata] = () => [dart.const(new _metadata.DomName('EventTarget')), dart.const(new _js_helper.Native("EventTarget"))];
  dart.registerExtension(dart.global.EventTarget, html$.EventTarget);
  dart.defineExtensionNames([
    'createObjectStore',
    'transaction',
    'transactionStore',
    'transactionList',
    'transactionStores',
    'close',
    'deleteObjectStore',
    'onAbort',
    'onClose',
    'onError',
    'onVersionChange',
    'name',
    'objectStoreNames',
    'version'
  ]);
  indexed_db.Database = class Database extends html$.EventTarget {
    [dartx.createObjectStore](name, opts) {
      let keyPath = opts && 'keyPath' in opts ? opts.keyPath : null;
      let autoIncrement = opts && 'autoIncrement' in opts ? opts.autoIncrement : null;
      let options = dart.map();
      if (keyPath != null) {
        options[dartx.set]('keyPath', keyPath);
      }
      if (autoIncrement != null) {
        options[dartx.set]('autoIncrement', autoIncrement);
      }
      return this[_createObjectStore](name, options);
    }
    [dartx.transaction](storeName_OR_storeNames, mode) {
      if (mode != 'readonly' && mode != 'readwrite') {
        dart.throw(new core.ArgumentError(mode));
      }
      return this[_transaction](storeName_OR_storeNames, mode);
    }
    [dartx.transactionStore](storeName, mode) {
      if (mode != 'readonly' && mode != 'readwrite') {
        dart.throw(new core.ArgumentError(mode));
      }
      return this[_transaction](storeName, mode);
    }
    [dartx.transactionList](storeNames, mode) {
      if (mode != 'readonly' && mode != 'readwrite') {
        dart.throw(new core.ArgumentError(mode));
      }
      let storeNames_1 = html_common.convertDartToNative_StringArray(storeNames);
      return this[_transaction](storeNames_1, mode);
    }
    [dartx.transactionStores](storeNames, mode) {
      if (mode != 'readonly' && mode != 'readwrite') {
        dart.throw(new core.ArgumentError(mode));
      }
      return this[_transaction](storeNames, mode);
    }
    [_transaction](stores, mode) {
      return this.transaction(stores, mode);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.name]() {
      return this.name;
    }
    get [dartx.objectStoreNames]() {
      return this.objectStoreNames;
    }
    get [dartx.version]() {
      return this.version;
    }
    [dartx.close]() {
      return this.close();
    }
    [_createObjectStore](name, options) {
      if (options === void 0) options = null;
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        return this[_createObjectStore_1](name, options_1);
      }
      return this[_createObjectStore_2](name);
    }
    [_createObjectStore_1](name, options) {
      return this.createObjectStore(name, options);
    }
    [_createObjectStore_2](name) {
      return this.createObjectStore(name);
    }
    [dartx.deleteObjectStore](name) {
      return this.deleteObjectStore(name);
    }
    get [dartx.onAbort]() {
      return indexed_db.Database.abortEvent.forTarget(this);
    }
    get [dartx.onClose]() {
      return indexed_db.Database.closeEvent.forTarget(this);
    }
    get [dartx.onError]() {
      return indexed_db.Database.errorEvent.forTarget(this);
    }
    get [dartx.onVersionChange]() {
      return indexed_db.Database.versionChangeEvent.forTarget(this);
    }
  };
  dart.setSignature(indexed_db.Database, {
    constructors: () => ({_: [indexed_db.Database, []]}),
    methods: () => ({
      [dartx.createObjectStore]: [indexed_db.ObjectStore, [core.String], {keyPath: core.String, autoIncrement: core.bool}],
      [dartx.transaction]: [indexed_db.Transaction, [dart.dynamic, core.String]],
      [dartx.transactionStore]: [indexed_db.Transaction, [core.String, core.String]],
      [dartx.transactionList]: [indexed_db.Transaction, [core.List$(core.String), core.String]],
      [dartx.transactionStores]: [indexed_db.Transaction, [html$.DomStringList, core.String]],
      [_transaction]: [indexed_db.Transaction, [dart.dynamic, dart.dynamic]],
      [dartx.close]: [dart.void, []],
      [_createObjectStore]: [indexed_db.ObjectStore, [core.String], [core.Map]],
      [_createObjectStore_1]: [indexed_db.ObjectStore, [dart.dynamic, dart.dynamic]],
      [_createObjectStore_2]: [indexed_db.ObjectStore, [dart.dynamic]],
      [dartx.deleteObjectStore]: [dart.void, [core.String]]
    })
  });
  indexed_db.Database[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('IDBDatabase')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX, '15')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.Experimental()), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("IDBDatabase"))];
  dart.defineLazy(indexed_db.Database, {
    get abortEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('abort'));
    },
    get closeEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('close'));
    },
    get errorEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('error'));
    },
    get versionChangeEvent() {
      return dart.const(new (html$.EventStreamProvider$(indexed_db.VersionChangeEvent))('versionchange'));
    }
  });
  dart.registerExtension(dart.global.IDBDatabase, indexed_db.Database);
  const _open = Symbol('_open');
  const _deleteDatabase = Symbol('_deleteDatabase');
  const _webkitGetDatabaseNames = Symbol('_webkitGetDatabaseNames');
  dart.defineExtensionNames([
    'open',
    'deleteDatabase',
    'getDatabaseNames',
    'supportsDatabaseNames',
    'cmp'
  ]);
  indexed_db.IdbFactory = class IdbFactory extends _interceptors.Interceptor {
    static get supported() {
      return !!(window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB);
    }
    [dartx.open](name, opts) {
      let version = opts && 'version' in opts ? opts.version : null;
      let onUpgradeNeeded = opts && 'onUpgradeNeeded' in opts ? opts.onUpgradeNeeded : null;
      let onBlocked = opts && 'onBlocked' in opts ? opts.onBlocked : null;
      if (version == null != (onUpgradeNeeded == null)) {
        return async.Future$(indexed_db.Database).error(new core.ArgumentError('version and onUpgradeNeeded must be specified together'));
      }
      try {
        let request = null;
        if (version != null) {
          request = this[_open](name, version);
        } else {
          request = this[_open](name);
        }
        if (onUpgradeNeeded != null) {
          dart.dsend(dart.dload(request, 'onUpgradeNeeded'), 'listen', onUpgradeNeeded);
        }
        if (onBlocked != null) {
          dart.dsend(dart.dload(request, 'onBlocked'), 'listen', onBlocked);
        }
        return indexed_db._completeRequest(indexed_db.Database)(dart.as(request, indexed_db.Request));
      } catch (e) {
        let stacktrace = dart.stackTrace(e);
        return async.Future$(indexed_db.Database).error(e, stacktrace);
      }

    }
    [dartx.deleteDatabase](name, opts) {
      let onBlocked = opts && 'onBlocked' in opts ? opts.onBlocked : null;
      try {
        let request = this[_deleteDatabase](name);
        if (onBlocked != null) {
          request[dartx.onBlocked].listen(onBlocked);
        }
        let completer = async.Completer$(indexed_db.IdbFactory).sync();
        request[dartx.onSuccess].listen(dart.fn(e => {
          completer.complete(this);
        }, dart.void, [html$.Event]));
        request[dartx.onError].listen(dart.bind(completer, 'completeError'));
        return completer.future;
      } catch (e) {
        let stacktrace = dart.stackTrace(e);
        return async.Future$(indexed_db.IdbFactory).error(e, stacktrace);
      }

    }
    [dartx.getDatabaseNames]() {
      try {
        let request = this[_webkitGetDatabaseNames]();
        return indexed_db._completeRequest(core.List$(core.String))(request);
      } catch (e) {
        let stacktrace = dart.stackTrace(e);
        return async.Future$(core.List$(core.String)).error(e, stacktrace);
      }

    }
    get [dartx.supportsDatabaseNames]() {
      return dart.notNull(indexed_db.IdbFactory.supported) && !!(this.getDatabaseNames || this.webkitGetDatabaseNames);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.cmp](first, second) {
      return this.cmp(first, second);
    }
    [_deleteDatabase](name) {
      return this.deleteDatabase(name);
    }
    [_open](name, version) {
      return this.open(name, version);
    }
    [_webkitGetDatabaseNames]() {
      return this.webkitGetDatabaseNames();
    }
  };
  dart.setSignature(indexed_db.IdbFactory, {
    constructors: () => ({_: [indexed_db.IdbFactory, []]}),
    methods: () => ({
      [dartx.open]: [async.Future$(indexed_db.Database), [core.String], {version: core.int, onUpgradeNeeded: dart.functionType(dart.void, [dart.dynamic]), onBlocked: dart.functionType(dart.void, [dart.dynamic])}],
      [dartx.deleteDatabase]: [async.Future$(indexed_db.IdbFactory), [core.String], {onBlocked: dart.functionType(dart.void, [html$.Event])}],
      [dartx.getDatabaseNames]: [async.Future$(core.List$(core.String)), []],
      [dartx.cmp]: [core.int, [core.Object, core.Object]],
      [_deleteDatabase]: [indexed_db.OpenDBRequest, [core.String]],
      [_open]: [indexed_db.OpenDBRequest, [core.String], [core.int]],
      [_webkitGetDatabaseNames]: [indexed_db.Request, []]
    })
  });
  indexed_db.IdbFactory[dart.metadata] = () => [dart.const(new _metadata.DomName('IDBFactory')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX, '15')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.Experimental()), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("IDBFactory"))];
  dart.registerExtension(dart.global.IDBFactory, indexed_db.IdbFactory);
  indexed_db._completeRequest = function(T) {
    return request => {
      let completer = async.Completer$(T).sync();
      request[dartx.onSuccess].listen(dart.fn(e => {
        let result = indexed_db._cast(T)(request[dartx.result]);
        completer.complete(result);
      }, dart.void, [html$.Event]));
      request[dartx.onError].listen(dart.bind(completer, 'completeError'));
      return completer.future;
    };
  };
  dart.lazyFn(indexed_db._completeRequest, () => [T => [async.Future$(T), [indexed_db.Request]]]);
  const _count$0 = Symbol('_count');
  const _get$ = Symbol('_get');
  const _getKey$ = Symbol('_getKey');
  const _openCursor = Symbol('_openCursor');
  const _openKeyCursor = Symbol('_openKeyCursor');
  dart.defineExtensionNames([
    'count',
    'get',
    'getKey',
    'openCursor',
    'openKeyCursor',
    'getAll',
    'getAllKeys',
    'keyPath',
    'multiEntry',
    'name',
    'objectStore',
    'unique'
  ]);
  indexed_db.Index = class Index extends _interceptors.Interceptor {
    [dartx.count](key_OR_range) {
      if (key_OR_range === void 0) key_OR_range = null;
      try {
        let request = this[_count$0](key_OR_range);
        return indexed_db._completeRequest(core.int)(request);
      } catch (e) {
        let stacktrace = dart.stackTrace(e);
        return async.Future$(core.int).error(e, stacktrace);
      }

    }
    [dartx.get](key) {
      try {
        let request = this[_get$](key);
        return indexed_db._completeRequest(dart.dynamic)(request);
      } catch (e) {
        let stacktrace = dart.stackTrace(e);
        return async.Future.error(e, stacktrace);
      }

    }
    [dartx.getKey](key) {
      try {
        let request = this[_getKey$](key);
        return indexed_db._completeRequest(dart.dynamic)(request);
      } catch (e) {
        let stacktrace = dart.stackTrace(e);
        return async.Future.error(e, stacktrace);
      }

    }
    [dartx.openCursor](opts) {
      let key = opts && 'key' in opts ? opts.key : null;
      let range = opts && 'range' in opts ? opts.range : null;
      let direction = opts && 'direction' in opts ? opts.direction : null;
      let autoAdvance = opts && 'autoAdvance' in opts ? opts.autoAdvance : null;
      let key_OR_range = null;
      if (key != null) {
        if (range != null) {
          dart.throw(new core.ArgumentError('Cannot specify both key and range.'));
        }
        key_OR_range = key;
      } else {
        key_OR_range = range;
      }
      let request = null;
      if (direction == null) {
        request = this[_openCursor](key_OR_range, "next");
      } else {
        request = this[_openCursor](key_OR_range, direction);
      }
      return indexed_db.ObjectStore._cursorStreamFromResult(indexed_db.CursorWithValue)(dart.as(request, indexed_db.Request), autoAdvance);
    }
    [dartx.openKeyCursor](opts) {
      let key = opts && 'key' in opts ? opts.key : null;
      let range = opts && 'range' in opts ? opts.range : null;
      let direction = opts && 'direction' in opts ? opts.direction : null;
      let autoAdvance = opts && 'autoAdvance' in opts ? opts.autoAdvance : null;
      let key_OR_range = null;
      if (key != null) {
        if (range != null) {
          dart.throw(new core.ArgumentError('Cannot specify both key and range.'));
        }
        key_OR_range = key;
      } else {
        key_OR_range = range;
      }
      let request = null;
      if (direction == null) {
        request = this[_openKeyCursor](key_OR_range, "next");
      } else {
        request = this[_openKeyCursor](key_OR_range, direction);
      }
      return indexed_db.ObjectStore._cursorStreamFromResult(indexed_db.Cursor)(dart.as(request, indexed_db.Request), autoAdvance);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.keyPath]() {
      return this.keyPath;
    }
    get [dartx.multiEntry]() {
      return this.multiEntry;
    }
    get [dartx.name]() {
      return this.name;
    }
    get [dartx.objectStore]() {
      return this.objectStore;
    }
    get [dartx.unique]() {
      return this.unique;
    }
    [_count$0](key) {
      return this.count(key);
    }
    [_get$](key) {
      return this.get(key);
    }
    [dartx.getAll](range, maxCount) {
      return this.getAll(range, maxCount);
    }
    [dartx.getAllKeys](range, maxCount) {
      return this.getAllKeys(range, maxCount);
    }
    [_getKey$](key) {
      return this.getKey(key);
    }
    [_openCursor](range, direction) {
      return this.openCursor(range, direction);
    }
    [_openKeyCursor](range, direction) {
      return this.openKeyCursor(range, direction);
    }
  };
  dart.setSignature(indexed_db.Index, {
    constructors: () => ({_: [indexed_db.Index, []]}),
    methods: () => ({
      [dartx.count]: [async.Future$(core.int), [], [dart.dynamic]],
      [dartx.get]: [async.Future, [dart.dynamic]],
      [dartx.getKey]: [async.Future, [dart.dynamic]],
      [dartx.openCursor]: [async.Stream$(indexed_db.CursorWithValue), [], {key: dart.dynamic, range: indexed_db.KeyRange, direction: core.String, autoAdvance: core.bool}],
      [dartx.openKeyCursor]: [async.Stream$(indexed_db.Cursor), [], {key: dart.dynamic, range: indexed_db.KeyRange, direction: core.String, autoAdvance: core.bool}],
      [_count$0]: [indexed_db.Request, [core.Object]],
      [_get$]: [indexed_db.Request, [core.Object]],
      [dartx.getAll]: [indexed_db.Request, [core.Object], [core.int]],
      [dartx.getAllKeys]: [indexed_db.Request, [core.Object], [core.int]],
      [_getKey$]: [indexed_db.Request, [core.Object]],
      [_openCursor]: [indexed_db.Request, [core.Object], [core.String]],
      [_openKeyCursor]: [indexed_db.Request, [core.Object], [core.String]]
    })
  });
  indexed_db.Index[dart.metadata] = () => [dart.const(new _metadata.DomName('IDBIndex')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("IDBIndex"))];
  dart.registerExtension(dart.global.IDBIndex, indexed_db.Index);
  dart.defineExtensionNames([
    'lower',
    'lowerOpen',
    'upper',
    'upperOpen'
  ]);
  indexed_db.KeyRange = class KeyRange extends _interceptors.Interceptor {
    static only(value) {
      return indexed_db._KeyRangeFactoryProvider.createKeyRange_only(value);
    }
    static lowerBound(bound, open) {
      if (open === void 0) open = false;
      return indexed_db._KeyRangeFactoryProvider.createKeyRange_lowerBound(bound, open);
    }
    static upperBound(bound, open) {
      if (open === void 0) open = false;
      return indexed_db._KeyRangeFactoryProvider.createKeyRange_upperBound(bound, open);
    }
    static bound(lower, upper, lowerOpen, upperOpen) {
      if (lowerOpen === void 0) lowerOpen = false;
      if (upperOpen === void 0) upperOpen = false;
      return indexed_db._KeyRangeFactoryProvider.createKeyRange_bound(lower, upper, lowerOpen, upperOpen);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.lower]() {
      return this.lower;
    }
    get [dartx.lowerOpen]() {
      return this.lowerOpen;
    }
    get [dartx.upper]() {
      return this.upper;
    }
    get [dartx.upperOpen]() {
      return this.upperOpen;
    }
  };
  dart.setSignature(indexed_db.KeyRange, {
    constructors: () => ({
      only: [indexed_db.KeyRange, [dart.dynamic]],
      lowerBound: [indexed_db.KeyRange, [dart.dynamic], [core.bool]],
      upperBound: [indexed_db.KeyRange, [dart.dynamic], [core.bool]],
      bound: [indexed_db.KeyRange, [dart.dynamic, dart.dynamic], [core.bool, core.bool]],
      _: [indexed_db.KeyRange, []]
    }),
    statics: () => ({
      bound_: [indexed_db.KeyRange, [core.Object, core.Object], [core.bool, core.bool]],
      lowerBound_: [indexed_db.KeyRange, [core.Object], [core.bool]],
      only_: [indexed_db.KeyRange, [core.Object]],
      upperBound_: [indexed_db.KeyRange, [core.Object], [core.bool]]
    }),
    names: ['bound_', 'lowerBound_', 'only_', 'upperBound_']
  });
  indexed_db.KeyRange[dart.metadata] = () => [dart.const(new _metadata.DomName('IDBKeyRange')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("IDBKeyRange"))];
  dart.registerExtension(dart.global.IDBKeyRange, indexed_db.KeyRange);
  const _add$2 = Symbol('_add');
  const _clear$0 = Symbol('_clear');
  const _put = Symbol('_put');
  const _createIndex = Symbol('_createIndex');
  const _add_1 = Symbol('_add_1');
  const _add_2 = Symbol('_add_2');
  const _createIndex_1 = Symbol('_createIndex_1');
  const _createIndex_2 = Symbol('_createIndex_2');
  const _put_1 = Symbol('_put_1');
  const _put_2 = Symbol('_put_2');
  dart.defineExtensionNames([
    'add',
    'clear',
    'delete',
    'count',
    'put',
    'getObject',
    'openCursor',
    'createIndex',
    'deleteIndex',
    'getAll',
    'getAllKeys',
    'index',
    'openKeyCursor',
    'autoIncrement',
    'indexNames',
    'keyPath',
    'name',
    'transaction'
  ]);
  indexed_db.ObjectStore = class ObjectStore extends _interceptors.Interceptor {
    [dartx.add](value, key) {
      if (key === void 0) key = null;
      try {
        let request = null;
        if (key != null) {
          request = this[_add$2](value, key);
        } else {
          request = this[_add$2](value);
        }
        return indexed_db._completeRequest(dart.dynamic)(dart.as(request, indexed_db.Request));
      } catch (e) {
        let stacktrace = dart.stackTrace(e);
        return async.Future.error(e, stacktrace);
      }

    }
    [dartx.clear]() {
      try {
        return indexed_db._completeRequest(dart.dynamic)(this[_clear$0]());
      } catch (e) {
        let stacktrace = dart.stackTrace(e);
        return async.Future.error(e, stacktrace);
      }

    }
    [dartx.delete](key_OR_keyRange) {
      try {
        return indexed_db._completeRequest(dart.dynamic)(this[_delete](key_OR_keyRange));
      } catch (e) {
        let stacktrace = dart.stackTrace(e);
        return async.Future.error(e, stacktrace);
      }

    }
    [dartx.count](key_OR_range) {
      if (key_OR_range === void 0) key_OR_range = null;
      try {
        let request = this[_count$0](key_OR_range);
        return indexed_db._completeRequest(core.int)(request);
      } catch (e) {
        let stacktrace = dart.stackTrace(e);
        return async.Future$(core.int).error(e, stacktrace);
      }

    }
    [dartx.put](value, key) {
      if (key === void 0) key = null;
      try {
        let request = null;
        if (key != null) {
          request = this[_put](value, key);
        } else {
          request = this[_put](value);
        }
        return indexed_db._completeRequest(dart.dynamic)(dart.as(request, indexed_db.Request));
      } catch (e) {
        let stacktrace = dart.stackTrace(e);
        return async.Future.error(e, stacktrace);
      }

    }
    [dartx.getObject](key) {
      try {
        let request = this[_get$](key);
        return indexed_db._completeRequest(dart.dynamic)(request);
      } catch (e) {
        let stacktrace = dart.stackTrace(e);
        return async.Future.error(e, stacktrace);
      }

    }
    [dartx.openCursor](opts) {
      let key = opts && 'key' in opts ? opts.key : null;
      let range = opts && 'range' in opts ? opts.range : null;
      let direction = opts && 'direction' in opts ? opts.direction : null;
      let autoAdvance = opts && 'autoAdvance' in opts ? opts.autoAdvance : null;
      let key_OR_range = null;
      if (key != null) {
        if (range != null) {
          dart.throw(new core.ArgumentError('Cannot specify both key and range.'));
        }
        key_OR_range = key;
      } else {
        key_OR_range = range;
      }
      let request = null;
      if (direction == null) {
        request = this[_openCursor](key_OR_range);
      } else {
        request = this[_openCursor](key_OR_range, direction);
      }
      return indexed_db.ObjectStore._cursorStreamFromResult(indexed_db.CursorWithValue)(dart.as(request, indexed_db.Request), autoAdvance);
    }
    [dartx.createIndex](name, keyPath, opts) {
      let unique = opts && 'unique' in opts ? opts.unique : null;
      let multiEntry = opts && 'multiEntry' in opts ? opts.multiEntry : null;
      let options = dart.map();
      if (unique != null) {
        options[dartx.set]('unique', unique);
      }
      if (multiEntry != null) {
        options[dartx.set]('multiEntry', multiEntry);
      }
      return this[_createIndex](name, keyPath, options);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.autoIncrement]() {
      return this.autoIncrement;
    }
    get [dartx.indexNames]() {
      return this.indexNames;
    }
    get [dartx.keyPath]() {
      return this.keyPath;
    }
    get [dartx.name]() {
      return this.name;
    }
    get [dartx.transaction]() {
      return this.transaction;
    }
    [_add$2](value, key) {
      if (key === void 0) key = null;
      if (key != null) {
        let value_1 = html_common.convertDartToNative_SerializedScriptValue(value);
        let key_2 = html_common.convertDartToNative_SerializedScriptValue(key);
        return this[_add_1](value_1, key_2);
      }
      let value_1 = html_common.convertDartToNative_SerializedScriptValue(value);
      return this[_add_2](value_1);
    }
    [_add_1](value, key) {
      return this.add(value, key);
    }
    [_add_2](value) {
      return this.add(value);
    }
    [_clear$0]() {
      return this.clear();
    }
    [_count$0](key) {
      return this.count(key);
    }
    [_createIndex](name, keyPath, options) {
      if (options === void 0) options = null;
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        return this[_createIndex_1](name, keyPath, options_1);
      }
      return this[_createIndex_2](name, keyPath);
    }
    [_createIndex_1](name, keyPath, options) {
      return this.createIndex(name, keyPath, options);
    }
    [_createIndex_2](name, keyPath) {
      return this.createIndex(name, keyPath);
    }
    [_delete](key) {
      return this.delete(key);
    }
    [dartx.deleteIndex](name) {
      return this.deleteIndex(name);
    }
    [_get$](key) {
      return this.get(key);
    }
    [dartx.getAll](range, maxCount) {
      return this.getAll(range, maxCount);
    }
    [dartx.getAllKeys](range, maxCount) {
      return this.getAllKeys(range, maxCount);
    }
    [dartx.index](name) {
      return this.index(name);
    }
    [_openCursor](range, direction) {
      return this.openCursor(range, direction);
    }
    [dartx.openKeyCursor](range, direction) {
      return this.openKeyCursor(range, direction);
    }
    [_put](value, key) {
      if (key === void 0) key = null;
      if (key != null) {
        let value_1 = html_common.convertDartToNative_SerializedScriptValue(value);
        let key_2 = html_common.convertDartToNative_SerializedScriptValue(key);
        return this[_put_1](value_1, key_2);
      }
      let value_1 = html_common.convertDartToNative_SerializedScriptValue(value);
      return this[_put_2](value_1);
    }
    [_put_1](value, key) {
      return this.put(value, key);
    }
    [_put_2](value) {
      return this.put(value);
    }
    static _cursorStreamFromResult(T) {
      return (request, autoAdvance) => {
        let controller = async.StreamController$(T).new({sync: true});
        request[dartx.onError].listen(dart.bind(controller, 'addError'));
        request[dartx.onSuccess].listen(dart.fn(e => {
          let cursor = indexed_db._cast(T)(request[dartx.result]);
          if (cursor == null) {
            controller.close();
          } else {
            controller.add(cursor);
            if (autoAdvance == true && dart.notNull(controller.hasListener)) {
              cursor[dartx.next]();
            }
          }
        }, dart.void, [html$.Event]));
        return controller.stream;
      };
    }
  };
  dart.setSignature(indexed_db.ObjectStore, {
    constructors: () => ({_: [indexed_db.ObjectStore, []]}),
    methods: () => ({
      [dartx.add]: [async.Future, [dart.dynamic], [dart.dynamic]],
      [dartx.clear]: [async.Future, []],
      [dartx.delete]: [async.Future, [dart.dynamic]],
      [dartx.count]: [async.Future$(core.int), [], [dart.dynamic]],
      [dartx.put]: [async.Future, [dart.dynamic], [dart.dynamic]],
      [dartx.getObject]: [async.Future, [dart.dynamic]],
      [dartx.openCursor]: [async.Stream$(indexed_db.CursorWithValue), [], {key: dart.dynamic, range: indexed_db.KeyRange, direction: core.String, autoAdvance: core.bool}],
      [dartx.createIndex]: [indexed_db.Index, [core.String, dart.dynamic], {unique: core.bool, multiEntry: core.bool}],
      [_add$2]: [indexed_db.Request, [dart.dynamic], [dart.dynamic]],
      [_add_1]: [indexed_db.Request, [dart.dynamic, dart.dynamic]],
      [_add_2]: [indexed_db.Request, [dart.dynamic]],
      [_clear$0]: [indexed_db.Request, []],
      [_count$0]: [indexed_db.Request, [core.Object]],
      [_createIndex]: [indexed_db.Index, [core.String, core.Object], [core.Map]],
      [_createIndex_1]: [indexed_db.Index, [dart.dynamic, dart.dynamic, dart.dynamic]],
      [_createIndex_2]: [indexed_db.Index, [dart.dynamic, dart.dynamic]],
      [_delete]: [indexed_db.Request, [core.Object]],
      [dartx.deleteIndex]: [dart.void, [core.String]],
      [_get$]: [indexed_db.Request, [core.Object]],
      [dartx.getAll]: [indexed_db.Request, [core.Object], [core.int]],
      [dartx.getAllKeys]: [indexed_db.Request, [core.Object], [core.int]],
      [dartx.index]: [indexed_db.Index, [core.String]],
      [_openCursor]: [indexed_db.Request, [core.Object], [core.String]],
      [dartx.openKeyCursor]: [indexed_db.Request, [core.Object], [core.String]],
      [_put]: [indexed_db.Request, [dart.dynamic], [dart.dynamic]],
      [_put_1]: [indexed_db.Request, [dart.dynamic, dart.dynamic]],
      [_put_2]: [indexed_db.Request, [dart.dynamic]]
    }),
    statics: () => ({_cursorStreamFromResult: [T => [async.Stream$(T), [indexed_db.Request, core.bool]]]}),
    names: ['_cursorStreamFromResult']
  });
  indexed_db.ObjectStore[dart.metadata] = () => [dart.const(new _metadata.DomName('IDBObjectStore')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("IDBObjectStore"))];
  dart.registerExtension(dart.global.IDBObjectStore, indexed_db.ObjectStore);
  indexed_db._cast = function(To) {
    return x => {
      return dart.as(x, To);
    };
  };
  dart.fn(indexed_db._cast, To => [To, [dart.dynamic]]);
  const _get_result = Symbol('_get_result');
  dart.defineExtensionNames([
    'result',
    'onError',
    'onSuccess',
    'error',
    'readyState',
    'source',
    'transaction'
  ]);
  indexed_db.Request = class Request extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.error]() {
      return this.error;
    }
    get [dartx.readyState]() {
      return this.readyState;
    }
    get [dartx.result]() {
      return indexed_db._convertNativeToDart_IDBAny(this[_get_result]);
    }
    get [_get_result]() {
      return this.result;
    }
    get [dartx.source]() {
      return this.source;
    }
    get [dartx.transaction]() {
      return this.transaction;
    }
    get [dartx.onError]() {
      return indexed_db.Request.errorEvent.forTarget(this);
    }
    get [dartx.onSuccess]() {
      return indexed_db.Request.successEvent.forTarget(this);
    }
  };
  dart.setSignature(indexed_db.Request, {
    constructors: () => ({_: [indexed_db.Request, []]})
  });
  indexed_db.Request[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('IDBRequest')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("IDBRequest"))];
  dart.defineLazy(indexed_db.Request, {
    get errorEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('error'));
    },
    get successEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('success'));
    }
  });
  dart.registerExtension(dart.global.IDBRequest, indexed_db.Request);
  dart.defineExtensionNames([
    'onBlocked',
    'onUpgradeNeeded'
  ]);
  indexed_db.OpenDBRequest = class OpenDBRequest extends indexed_db.Request {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.onBlocked]() {
      return indexed_db.OpenDBRequest.blockedEvent.forTarget(this);
    }
    get [dartx.onUpgradeNeeded]() {
      return indexed_db.OpenDBRequest.upgradeNeededEvent.forTarget(this);
    }
  };
  dart.setSignature(indexed_db.OpenDBRequest, {
    constructors: () => ({_: [indexed_db.OpenDBRequest, []]})
  });
  indexed_db.OpenDBRequest[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('IDBOpenDBRequest')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("IDBOpenDBRequest,IDBVersionChangeRequest"))];
  dart.defineLazy(indexed_db.OpenDBRequest, {
    get blockedEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('blocked'));
    },
    get upgradeNeededEvent() {
      return dart.const(new (html$.EventStreamProvider$(indexed_db.VersionChangeEvent))('upgradeneeded'));
    }
  });
  dart.registerExtension(dart.global.IDBOpenDBRequest, indexed_db.OpenDBRequest);
  dart.defineExtensionNames([
    'completed',
    'abort',
    'objectStore',
    'onAbort',
    'onComplete',
    'onError',
    'db',
    'error',
    'mode',
    'objectStoreNames'
  ]);
  indexed_db.Transaction = class Transaction extends html$.EventTarget {
    get [dartx.completed]() {
      let completer = async.Completer$(indexed_db.Database).new();
      this[dartx.onComplete].first.then(dart.dynamic)(dart.fn(_ => {
        completer.complete(this[dartx.db]);
      }, dart.dynamic, [html$.Event]));
      this[dartx.onError].first.then(dart.dynamic)(dart.fn(e => {
        completer.completeError(e);
      }, dart.dynamic, [html$.Event]));
      this[dartx.onAbort].first.then(dart.dynamic)(dart.fn(e => {
        if (!dart.notNull(completer.isCompleted)) {
          completer.completeError(e);
        }
      }, dart.dynamic, [html$.Event]));
      return completer.future;
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.db]() {
      return this.db;
    }
    get [dartx.error]() {
      return this.error;
    }
    get [dartx.mode]() {
      return this.mode;
    }
    get [dartx.objectStoreNames]() {
      return this.objectStoreNames;
    }
    [dartx.abort]() {
      return this.abort();
    }
    [dartx.objectStore](name) {
      return this.objectStore(name);
    }
    get [dartx.onAbort]() {
      return indexed_db.Transaction.abortEvent.forTarget(this);
    }
    get [dartx.onComplete]() {
      return indexed_db.Transaction.completeEvent.forTarget(this);
    }
    get [dartx.onError]() {
      return indexed_db.Transaction.errorEvent.forTarget(this);
    }
  };
  dart.setSignature(indexed_db.Transaction, {
    constructors: () => ({_: [indexed_db.Transaction, []]}),
    methods: () => ({
      [dartx.abort]: [dart.void, []],
      [dartx.objectStore]: [indexed_db.ObjectStore, [core.String]]
    })
  });
  indexed_db.Transaction[dart.metadata] = () => [dart.const(new _metadata.DomName('IDBTransaction')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("IDBTransaction"))];
  dart.defineLazy(indexed_db.Transaction, {
    get abortEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('abort'));
    },
    get completeEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('complete'));
    },
    get errorEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('error'));
    }
  });
  dart.registerExtension(dart.global.IDBTransaction, indexed_db.Transaction);
  const _createEvent = Symbol('_createEvent');
  const _initEvent = Symbol('_initEvent');
  const _selector = Symbol('_selector');
  const _get_currentTarget = Symbol('_get_currentTarget');
  const _get_target = Symbol('_get_target');
  dart.defineExtensionNames([
    'matchingTarget',
    'currentTarget',
    'target',
    'preventDefault',
    'stopImmediatePropagation',
    'stopPropagation',
    'bubbles',
    'cancelable',
    'defaultPrevented',
    'eventPhase',
    'path',
    'timeStamp',
    'type'
  ]);
  html$.Event = class Event extends _interceptors.Interceptor {
    static new(type, opts) {
      let canBubble = opts && 'canBubble' in opts ? opts.canBubble : true;
      let cancelable = opts && 'cancelable' in opts ? opts.cancelable : true;
      return html$.Event.eventType('Event', type, {canBubble: canBubble, cancelable: cancelable});
    }
    static eventType(type, name, opts) {
      let canBubble = opts && 'canBubble' in opts ? opts.canBubble : true;
      let cancelable = opts && 'cancelable' in opts ? opts.cancelable : true;
      let e = html$.document[_createEvent](type);
      e[_initEvent](name, canBubble, cancelable);
      return e;
    }
    get [_selector]() {
      return this._selector;
    }
    set [_selector](value) {
      this._selector = value;
    }
    get [dartx.matchingTarget]() {
      if (this[_selector] == null) {
        dart.throw(new core.UnsupportedError('Cannot call matchingTarget if this Event did' + ' not arise as a result of event delegation.'));
      }
      let currentTarget = dart.as(this[dartx.currentTarget], html$.Element);
      let target = dart.as(this[dartx.target], html$.Element);
      let matchedTarget = null;
      do {
        if (dart.notNull(target[dartx.matches](this[_selector]))) return target;
        target = target[dartx.parent];
      } while (target != null && !dart.equals(target, currentTarget[dartx.parent]));
      dart.throw(new core.StateError('No selector matched for populating matchedTarget.'));
    }
    static _(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.Event._create_1(type, eventInitDict_1);
      }
      return html$.Event._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new Event(type, eventInitDict);
    }
    static _create_2(type) {
      return new Event(type);
    }
    get [dartx.bubbles]() {
      return this.bubbles;
    }
    get [dartx.cancelable]() {
      return this.cancelable;
    }
    get [dartx.currentTarget]() {
      return html$._convertNativeToDart_EventTarget(this[_get_currentTarget]);
    }
    get [_get_currentTarget]() {
      return this.currentTarget;
    }
    get [dartx.defaultPrevented]() {
      return this.defaultPrevented;
    }
    get [dartx.eventPhase]() {
      return this.eventPhase;
    }
    get [dartx.path]() {
      return this.path;
    }
    get [dartx.target]() {
      return html$._convertNativeToDart_EventTarget(this[_get_target]);
    }
    get [_get_target]() {
      return this.target;
    }
    get [dartx.timeStamp]() {
      return this.timeStamp;
    }
    get [dartx.type]() {
      return this.type;
    }
    [_initEvent](type, bubbles, cancelable) {
      return this.initEvent(type, bubbles, cancelable);
    }
    [dartx.preventDefault]() {
      return this.preventDefault();
    }
    [dartx.stopImmediatePropagation]() {
      return this.stopImmediatePropagation();
    }
    [dartx.stopPropagation]() {
      return this.stopPropagation();
    }
  };
  dart.setSignature(html$.Event, {
    constructors: () => ({
      new: [html$.Event, [core.String], {canBubble: core.bool, cancelable: core.bool}],
      eventType: [html$.Event, [core.String, core.String], {canBubble: core.bool, cancelable: core.bool}],
      _: [html$.Event, [core.String], [core.Map]]
    }),
    methods: () => ({
      [_initEvent]: [dart.void, [core.String, core.bool, core.bool]],
      [dartx.preventDefault]: [dart.void, []],
      [dartx.stopImmediatePropagation]: [dart.void, []],
      [dartx.stopPropagation]: [dart.void, []]
    }),
    statics: () => ({
      _create_1: [html$.Event, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.Event, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.Event[dart.metadata] = () => [dart.const(new _metadata.DomName('Event')), dart.const(new _js_helper.Native("Event,InputEvent"))];
  html$.Event.AT_TARGET = 2;
  html$.Event.BUBBLING_PHASE = 3;
  html$.Event.CAPTURING_PHASE = 1;
  dart.registerExtension(dart.global.Event, html$.Event);
  dart.defineExtensionNames([
    'dataLoss',
    'dataLossMessage',
    'newVersion',
    'oldVersion'
  ]);
  indexed_db.VersionChangeEvent = class VersionChangeEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return indexed_db.VersionChangeEvent._create_1(type, eventInitDict_1);
      }
      return indexed_db.VersionChangeEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new IDBVersionChangeEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new IDBVersionChangeEvent(type);
    }
    get [dartx.dataLoss]() {
      return this.dataLoss;
    }
    get [dartx.dataLossMessage]() {
      return this.dataLossMessage;
    }
    get [dartx.newVersion]() {
      return this.newVersion;
    }
    get [dartx.oldVersion]() {
      return this.oldVersion;
    }
  };
  dart.setSignature(indexed_db.VersionChangeEvent, {
    constructors: () => ({
      _: [indexed_db.VersionChangeEvent, []],
      new: [indexed_db.VersionChangeEvent, [core.String], [core.Map]]
    }),
    statics: () => ({
      _create_1: [indexed_db.VersionChangeEvent, [dart.dynamic, dart.dynamic]],
      _create_2: [indexed_db.VersionChangeEvent, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  indexed_db.VersionChangeEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('IDBVersionChangeEvent')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("IDBVersionChangeEvent"))];
  dart.registerExtension(dart.global.IDBVersionChangeEvent, indexed_db.VersionChangeEvent);
  dart.copyProperties(html$, {
    get window() {
      return window;
    }
  });
  dart.copyProperties(html$, {
    get document() {
      return document;
    }
  });
  const _xtag = Symbol('_xtag');
  const _attributes$ = Symbol('_attributes');
  const _innerHtml = Symbol('_innerHtml');
  const _scrollHeight = Symbol('_scrollHeight');
  const _scrollLeft = Symbol('_scrollLeft');
  const _scrollTop = Symbol('_scrollTop');
  const _scrollWidth = Symbol('_scrollWidth');
  const _childElementCount = Symbol('_childElementCount');
  const _children = Symbol('_children');
  const _firstElementChild = Symbol('_firstElementChild');
  const _lastElementChild = Symbol('_lastElementChild');
  const _querySelectorAll = Symbol('_querySelectorAll');
  const _getComputedStyle = Symbol('_getComputedStyle');
  const _animate = Symbol('_animate');
  const _localName = Symbol('_localName');
  const _namespaceUri = Symbol('_namespaceUri');
  const _scrollIntoView = Symbol('_scrollIntoView');
  const _scrollIntoViewIfNeeded = Symbol('_scrollIntoViewIfNeeded');
  const _insertAdjacentText = Symbol('_insertAdjacentText');
  const _insertAdjacentNode = Symbol('_insertAdjacentNode');
  const _insertAdjacentHtml = Symbol('_insertAdjacentHtml');
  const _insertAdjacentElement = Symbol('_insertAdjacentElement');
  const _canBeUsedToCreateContextualFragment = Symbol('_canBeUsedToCreateContextualFragment');
  const _cannotBeUsedToCreateContextualFragment = Symbol('_cannotBeUsedToCreateContextualFragment');
  const _getElementsByTagName = Symbol('_getElementsByTagName');
  const _hasAttribute = Symbol('_hasAttribute');
  const _hasAttributeNS = Symbol('_hasAttributeNS');
  const _removeAttribute = Symbol('_removeAttribute');
  const _removeAttributeNS = Symbol('_removeAttributeNS');
  const _scroll_1 = Symbol('_scroll_1');
  const _scroll_2 = Symbol('_scroll_2');
  const _scroll_3 = Symbol('_scroll_3');
  const _scrollBy_1 = Symbol('_scrollBy_1');
  const _scrollBy_2 = Symbol('_scrollBy_2');
  const _scrollBy_3 = Symbol('_scrollBy_3');
  const _scrollTo_1 = Symbol('_scrollTo_1');
  const _scrollTo_2 = Symbol('_scrollTo_2');
  const _scrollTo_3 = Symbol('_scrollTo_3');
  const _removeChild = Symbol('_removeChild');
  const _replaceChild = Symbol('_replaceChild');
  const _this = Symbol('_this');
  const _clearChildren = Symbol('_clearChildren');
  dart.defineExtensionNames([
    'nodes',
    'nodes',
    'remove',
    'replaceWith',
    'insertAllBefore',
    'toString',
    'append',
    'clone',
    'contains',
    'hasChildNodes',
    'insertBefore',
    'childNodes',
    'baseUri',
    'firstChild',
    'lastChild',
    'nextNode',
    'nodeName',
    'nodeType',
    'nodeValue',
    'ownerDocument',
    'parent',
    'parentNode',
    'previousNode',
    'text'
  ]);
  html$.Node = class Node extends html$.EventTarget {
    _created() {
      this[dartx.childNodes] = null;
      this[dartx.baseUri] = null;
      this[dartx.firstChild] = null;
      this[dartx.lastChild] = null;
      this[_localName] = null;
      this[_namespaceUri] = null;
      this[dartx.nextNode] = null;
      this[dartx.nodeName] = null;
      this[dartx.nodeType] = null;
      this[dartx.nodeValue] = null;
      this[dartx.ownerDocument] = null;
      this[dartx.parent] = null;
      this[dartx.parentNode] = null;
      this[dartx.previousNode] = null;
      this[dartx.text] = null;
      super._created();
    }
    get [dartx.nodes]() {
      return new html$._ChildNodeListLazy(this);
    }
    set [dartx.nodes](value) {
      let copy = value[dartx.toList]();
      this[dartx.text] = '';
      for (let node of copy) {
        this[dartx.append](node);
      }
    }
    [dartx.remove]() {
      if (this[dartx.parentNode] != null) {
        let parent = this[dartx.parentNode];
        this[dartx.parentNode][_removeChild](this);
      }
    }
    [dartx.replaceWith](otherNode) {
      try {
        let parent = this[dartx.parentNode];
        parent[_replaceChild](otherNode, this);
      } catch (e) {
      }

      ;
      return this;
    }
    [dartx.insertAllBefore](newNodes, refChild) {
      if (dart.is(newNodes, html$._ChildNodeListLazy)) {
        let otherList = newNodes;
        if (core.identical(otherList[_this], this)) {
          dart.throw(new core.ArgumentError(newNodes));
        }
        for (let i = 0, len = otherList.length; i < dart.notNull(len); ++i) {
          this[dartx.insertBefore](otherList[_this][dartx.firstChild], refChild);
        }
      } else {
        for (let node of newNodes) {
          this[dartx.insertBefore](node, refChild);
        }
      }
    }
    [_clearChildren]() {
      while (this[dartx.firstChild] != null) {
        this[_removeChild](this[dartx.firstChild]);
      }
    }
    [dartx.toString]() {
      let value = this[dartx.nodeValue];
      return value == null ? super.toString() : value;
    }
    get [dartx.childNodes]() {
      return this.childNodes;
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.baseUri]() {
      return this.baseURI;
    }
    get [dartx.firstChild]() {
      return this.firstChild;
    }
    get [dartx.lastChild]() {
      return this.lastChild;
    }
    get [_localName]() {
      return this.localName;
    }
    get [_namespaceUri]() {
      return this.namespaceURI;
    }
    get [dartx.nextNode]() {
      return this.nextSibling;
    }
    get [dartx.nodeName]() {
      return this.nodeName;
    }
    get [dartx.nodeType]() {
      return this.nodeType;
    }
    get [dartx.nodeValue]() {
      return this.nodeValue;
    }
    get [dartx.ownerDocument]() {
      return this.ownerDocument;
    }
    get [dartx.parent]() {
      return this.parentElement;
    }
    get [dartx.parentNode]() {
      return this.parentNode;
    }
    get [dartx.previousNode]() {
      return this.previousSibling;
    }
    get [dartx.text]() {
      return this.textContent;
    }
    set [dartx.text](value) {
      this.textContent = value;
    }
    [dartx.append](node) {
      return this.appendChild(node);
    }
    [dartx.clone](deep) {
      return this.cloneNode(deep);
    }
    [dartx.contains](other) {
      return this.contains(other);
    }
    [dartx.hasChildNodes]() {
      return this.hasChildNodes();
    }
    [dartx.insertBefore](node, child) {
      return this.insertBefore(node, child);
    }
    [_removeChild](child) {
      return this.removeChild(child);
    }
    [_replaceChild](node, child) {
      return this.replaceChild(node, child);
    }
  };
  dart.defineNamedConstructor(html$.Node, '_created');
  dart.setSignature(html$.Node, {
    constructors: () => ({
      _created: [html$.Node, []],
      _: [html$.Node, []]
    }),
    methods: () => ({
      [dartx.remove]: [dart.void, []],
      [dartx.replaceWith]: [html$.Node, [html$.Node]],
      [dartx.insertAllBefore]: [html$.Node, [core.Iterable$(html$.Node), html$.Node]],
      [_clearChildren]: [dart.void, []],
      [dartx.append]: [html$.Node, [html$.Node]],
      [dartx.clone]: [html$.Node, [core.bool]],
      [dartx.contains]: [core.bool, [html$.Node]],
      [dartx.hasChildNodes]: [core.bool, []],
      [dartx.insertBefore]: [html$.Node, [html$.Node, html$.Node]],
      [_removeChild]: [html$.Node, [html$.Node]],
      [_replaceChild]: [html$.Node, [html$.Node, html$.Node]]
    })
  });
  html$.Node[dart.metadata] = () => [dart.const(new _metadata.DomName('Node')), dart.const(new _js_helper.Native("Node"))];
  html$.Node.ATTRIBUTE_NODE = 2;
  html$.Node.CDATA_SECTION_NODE = 4;
  html$.Node.COMMENT_NODE = 8;
  html$.Node.DOCUMENT_FRAGMENT_NODE = 11;
  html$.Node.DOCUMENT_NODE = 9;
  html$.Node.DOCUMENT_TYPE_NODE = 10;
  html$.Node.ELEMENT_NODE = 1;
  html$.Node.ENTITY_NODE = 6;
  html$.Node.ENTITY_REFERENCE_NODE = 5;
  html$.Node.NOTATION_NODE = 12;
  html$.Node.PROCESSING_INSTRUCTION_NODE = 7;
  html$.Node.TEXT_NODE = 3;
  dart.registerExtension(dart.global.Node, html$.Node);
  dart.defineExtensionNames([
    'attributes',
    'attributes',
    'children',
    'children',
    'querySelectorAll',
    'query',
    'queryAll',
    'classes',
    'classes',
    'dataset',
    'dataset',
    'getNamespacedAttributes',
    'getComputedStyle',
    'client',
    'offset',
    'appendText',
    'appendHtml',
    'attached',
    'detached',
    'enteredView',
    'leftView',
    'animate',
    'attributeChanged',
    'xtag',
    'xtag',
    'localName',
    'namespaceUri',
    'toString',
    'scrollIntoView',
    'insertAdjacentText',
    'insertAdjacentHtml',
    'insertAdjacentElement',
    'matches',
    'matchesWithAncestors',
    'createShadowRoot',
    'shadowRoot',
    'contentEdge',
    'paddingEdge',
    'borderEdge',
    'marginEdge',
    'documentOffset',
    'offsetTo',
    'createFragment',
    'innerHtml',
    'setInnerHtml',
    'innerHtml',
    'on',
    'offsetHeight',
    'offsetLeft',
    'offsetTop',
    'offsetWidth',
    'scrollHeight',
    'scrollLeft',
    'scrollLeft',
    'scrollTop',
    'scrollTop',
    'scrollWidth',
    'isContentEditable',
    'blur',
    'click',
    'focus',
    'outerHtml',
    'closest',
    'getAnimations',
    'getAttribute',
    'getAttributeNS',
    'getBoundingClientRect',
    'getClientRects',
    'getDestinationInsertionPoints',
    'getElementsByClassName',
    'requestFullscreen',
    'requestPointerLock',
    'scroll',
    'scrollBy',
    'scrollTo',
    'setAttribute',
    'setAttributeNS',
    'after',
    'before',
    'querySelector',
    'onAbort',
    'onBeforeCopy',
    'onBeforeCut',
    'onBeforePaste',
    'onBlur',
    'onCanPlay',
    'onCanPlayThrough',
    'onChange',
    'onClick',
    'onContextMenu',
    'onCopy',
    'onCut',
    'onDoubleClick',
    'onDrag',
    'onDragEnd',
    'onDragEnter',
    'onDragLeave',
    'onDragOver',
    'onDragStart',
    'onDrop',
    'onDurationChange',
    'onEmptied',
    'onEnded',
    'onError',
    'onFocus',
    'onInput',
    'onInvalid',
    'onKeyDown',
    'onKeyPress',
    'onKeyUp',
    'onLoad',
    'onLoadedData',
    'onLoadedMetadata',
    'onMouseDown',
    'onMouseEnter',
    'onMouseLeave',
    'onMouseMove',
    'onMouseOut',
    'onMouseOver',
    'onMouseUp',
    'onMouseWheel',
    'onPaste',
    'onPause',
    'onPlay',
    'onPlaying',
    'onRateChange',
    'onReset',
    'onResize',
    'onScroll',
    'onSearch',
    'onSeeked',
    'onSeeking',
    'onSelect',
    'onSelectStart',
    'onStalled',
    'onSubmit',
    'onSuspend',
    'onTimeUpdate',
    'onTouchCancel',
    'onTouchEnd',
    'onTouchEnter',
    'onTouchLeave',
    'onTouchMove',
    'onTouchStart',
    'onTransitionEnd',
    'onVolumeChange',
    'onWaiting',
    'onFullscreenChange',
    'onFullscreenError',
    'offsetParent',
    'contentEditable',
    'contextMenu',
    'dir',
    'draggable',
    'hidden',
    'lang',
    'spellcheck',
    'style',
    'tabIndex',
    'title',
    'translate',
    'dropzone',
    'className',
    'clientHeight',
    'clientLeft',
    'clientTop',
    'clientWidth',
    'computedName',
    'computedRole',
    'id',
    'tagName',
    'nextElementSibling',
    'previousElementSibling'
  ]);
  html$.Element = class Element extends html$.Node {
    static html(html, opts) {
      let validator = opts && 'validator' in opts ? opts.validator : null;
      let treeSanitizer = opts && 'treeSanitizer' in opts ? opts.treeSanitizer : null;
      let fragment = html$.document[dartx.body][dartx.createFragment](html, {validator: validator, treeSanitizer: treeSanitizer});
      return dart.as(fragment[dartx.nodes][dartx.where](dart.fn(e => dart.is(e, html$.Element), core.bool, [html$.Node]))[dartx.single], html$.Element);
    }
    created() {
      this[_xtag] = null;
      this[dartx.offsetParent] = null;
      this[dartx.contentEditable] = null;
      this[dartx.contextMenu] = null;
      this[dartx.dir] = null;
      this[dartx.draggable] = null;
      this[dartx.hidden] = null;
      this[dartx.lang] = null;
      this[dartx.spellcheck] = null;
      this[dartx.style] = null;
      this[dartx.tabIndex] = null;
      this[dartx.title] = null;
      this[dartx.translate] = null;
      this[dartx.dropzone] = null;
      this[_attributes$] = null;
      this[dartx.className] = null;
      this[dartx.clientHeight] = null;
      this[dartx.clientLeft] = null;
      this[dartx.clientTop] = null;
      this[dartx.clientWidth] = null;
      this[dartx.computedName] = null;
      this[dartx.computedRole] = null;
      this[dartx.id] = null;
      this[_innerHtml] = null;
      this[_scrollHeight] = null;
      this[_scrollLeft] = null;
      this[_scrollTop] = null;
      this[_scrollWidth] = null;
      this[dartx.tagName] = null;
      this[dartx.nextElementSibling] = null;
      this[dartx.previousElementSibling] = null;
      this[_childElementCount] = null;
      this[_children] = null;
      this[_firstElementChild] = null;
      this[_lastElementChild] = null;
      super._created();
    }
    static tag(tag, typeExtention) {
      if (typeExtention === void 0) typeExtention = null;
      return dart.as(html$._ElementFactoryProvider.createElement_tag(tag, typeExtention), html$.Element);
    }
    static a() {
      return html$.Element.tag('a');
    }
    static article() {
      return html$.Element.tag('article');
    }
    static aside() {
      return html$.Element.tag('aside');
    }
    static audio() {
      return html$.Element.tag('audio');
    }
    static br() {
      return html$.Element.tag('br');
    }
    static canvas() {
      return html$.Element.tag('canvas');
    }
    static div() {
      return html$.Element.tag('div');
    }
    static footer() {
      return html$.Element.tag('footer');
    }
    static header() {
      return html$.Element.tag('header');
    }
    static hr() {
      return html$.Element.tag('hr');
    }
    static iframe() {
      return html$.Element.tag('iframe');
    }
    static img() {
      return html$.Element.tag('img');
    }
    static li() {
      return html$.Element.tag('li');
    }
    static nav() {
      return html$.Element.tag('nav');
    }
    static ol() {
      return html$.Element.tag('ol');
    }
    static option() {
      return html$.Element.tag('option');
    }
    static p() {
      return html$.Element.tag('p');
    }
    static pre() {
      return html$.Element.tag('pre');
    }
    static section() {
      return html$.Element.tag('section');
    }
    static select() {
      return html$.Element.tag('select');
    }
    static span() {
      return html$.Element.tag('span');
    }
    static svg() {
      return html$.Element.tag('svg');
    }
    static table() {
      return html$.Element.tag('table');
    }
    static td() {
      return html$.Element.tag('td');
    }
    static textarea() {
      return html$.Element.tag('textarea');
    }
    static th() {
      return html$.Element.tag('th');
    }
    static tr() {
      return html$.Element.tag('tr');
    }
    static ul() {
      return html$.Element.tag('ul');
    }
    static video() {
      return html$.Element.tag('video');
    }
    get [dartx.attributes]() {
      return new html$._ElementAttributeMap(this);
    }
    set [dartx.attributes](value) {
      let attributes = this[dartx.attributes];
      attributes[dartx.clear]();
      for (let key of value[dartx.keys]) {
        attributes[dartx.set](key, value[dartx.get](key));
      }
    }
    get [dartx.children]() {
      return new html$._ChildrenElementList._wrap(this);
    }
    set [dartx.children](value) {
      let copy = value[dartx.toList]();
      let children = this[dartx.children];
      children[dartx.clear]();
      children[dartx.addAll](copy);
    }
    [dartx.querySelectorAll](T) {
      return selectors => {
        return new (html$._FrozenElementList$(T))._wrap(this[_querySelectorAll](selectors));
      };
    }
    [dartx.query](relativeSelectors) {
      return this[dartx.querySelector](relativeSelectors);
    }
    [dartx.queryAll](T) {
      return relativeSelectors => {
        return this[dartx.querySelectorAll](T)(relativeSelectors);
      };
    }
    get [dartx.classes]() {
      return new html$._ElementCssClassSet(this);
    }
    set [dartx.classes](value) {
      let classSet = this[dartx.classes];
      classSet.clear();
      classSet.addAll(value);
    }
    get [dartx.dataset]() {
      return new html$._DataAttributeMap(this[dartx.attributes]);
    }
    set [dartx.dataset](value) {
      let data = this[dartx.dataset];
      data[dartx.clear]();
      for (let key of value[dartx.keys]) {
        data[dartx.set](key, value[dartx.get](key));
      }
    }
    [dartx.getNamespacedAttributes](namespace) {
      return new html$._NamespacedAttributeMap(this, namespace);
    }
    [dartx.getComputedStyle](pseudoElement) {
      if (pseudoElement === void 0) pseudoElement = null;
      if (pseudoElement == null) {
        pseudoElement = '';
      }
      return html$.window[_getComputedStyle](this, pseudoElement);
    }
    get [dartx.client]() {
      return new (math.Rectangle$(core.num))(this[dartx.clientLeft], this[dartx.clientTop], this[dartx.clientWidth], this[dartx.clientHeight]);
    }
    get [dartx.offset]() {
      return new (math.Rectangle$(core.num))(this[dartx.offsetLeft], this[dartx.offsetTop], this[dartx.offsetWidth], this[dartx.offsetHeight]);
    }
    [dartx.appendText](text) {
      this[dartx.append](html$.Text.new(text));
    }
    [dartx.appendHtml](text, opts) {
      let validator = opts && 'validator' in opts ? opts.validator : null;
      let treeSanitizer = opts && 'treeSanitizer' in opts ? opts.treeSanitizer : null;
      this[dartx.insertAdjacentHtml]('beforeend', text, {validator: validator, treeSanitizer: treeSanitizer});
    }
    static isTagSupported(tag) {
      let e = html$._ElementFactoryProvider.createElement_tag(tag, null);
      return dart.is(e, html$.Element) && !dart.is(e, html$.UnknownElement);
    }
    [dartx.attached]() {
      this[dartx.enteredView]();
    }
    [dartx.detached]() {
      this[dartx.leftView]();
    }
    [dartx.enteredView]() {}
    [dartx.leftView]() {}
    [dartx.animate](frames, timing) {
      if (timing === void 0) timing = null;
      if (!dart.is(frames, core.Iterable) || !dart.notNull(frames[dartx.every](dart.fn(x => dart.is(x, core.Map), core.bool, [core.Map$(core.String, dart.dynamic)])))) {
        dart.throw(new core.ArgumentError("The frames parameter should be a List of Maps " + "with frame information"));
      }
      let convertedFrames = null;
      if (dart.is(frames, core.Iterable)) {
        convertedFrames = frames[dartx.map](dart.dynamic)(html_common.convertDartToNative_Dictionary)[dartx.toList]();
      } else {
        convertedFrames = frames;
      }
      let convertedTiming = dart.is(timing, core.Map) ? html_common.convertDartToNative_Dictionary(timing) : timing;
      return convertedTiming == null ? this[_animate](convertedFrames) : this[_animate](convertedFrames, convertedTiming);
    }
    [_animate](effect, timing) {
      return this.animate(effect, timing);
    }
    [dartx.attributeChanged](name, oldValue, newValue) {}
    get [_xtag]() {
      return this._xtag;
    }
    set [_xtag](value) {
      this._xtag = value;
    }
    get [dartx.xtag]() {
      return this[_xtag] != null ? this[_xtag] : this;
    }
    set [dartx.xtag](value) {
      this[_xtag] = value;
    }
    get [dartx.localName]() {
      return this[_localName];
    }
    get [dartx.namespaceUri]() {
      return this[_namespaceUri];
    }
    [dartx.toString]() {
      return this[dartx.localName];
    }
    [dartx.scrollIntoView](alignment) {
      if (alignment === void 0) alignment = null;
      let hasScrollIntoViewIfNeeded = true;
      hasScrollIntoViewIfNeeded = !!this.scrollIntoViewIfNeeded;
      if (dart.equals(alignment, html$.ScrollAlignment.TOP)) {
        this[_scrollIntoView](true);
      } else if (dart.equals(alignment, html$.ScrollAlignment.BOTTOM)) {
        this[_scrollIntoView](false);
      } else if (hasScrollIntoViewIfNeeded) {
        if (dart.equals(alignment, html$.ScrollAlignment.CENTER)) {
          this[_scrollIntoViewIfNeeded](true);
        } else {
          this[_scrollIntoViewIfNeeded]();
        }
      } else {
        this[_scrollIntoView]();
      }
    }
    static _determineMouseWheelEventType(e) {
      return 'wheel';
    }
    static _determineTransitionEventType(e) {
      if (dart.notNull(html_common.Device.isWebKit)) {
        return 'webkitTransitionEnd';
      } else if (dart.notNull(html_common.Device.isOpera)) {
        return 'oTransitionEnd';
      }
      return 'transitionend';
    }
    [dartx.insertAdjacentText](where, text) {
      if (!!this.insertAdjacentText) {
        this[_insertAdjacentText](where, text);
      } else {
        this[_insertAdjacentNode](where, html$.Text.new(text));
      }
    }
    [_insertAdjacentText](where, text) {
      return this.insertAdjacentText(where, text);
    }
    [dartx.insertAdjacentHtml](where, html, opts) {
      let validator = opts && 'validator' in opts ? opts.validator : null;
      let treeSanitizer = opts && 'treeSanitizer' in opts ? opts.treeSanitizer : null;
      if (dart.is(treeSanitizer, html$._TrustedHtmlTreeSanitizer)) {
        this[_insertAdjacentHtml](where, html);
      } else {
        this[_insertAdjacentNode](where, this[dartx.createFragment](html, {validator: validator, treeSanitizer: treeSanitizer}));
      }
    }
    [_insertAdjacentHtml](where, text) {
      return this.insertAdjacentHTML(where, text);
    }
    [dartx.insertAdjacentElement](where, element) {
      if (!!this.insertAdjacentElement) {
        this[_insertAdjacentElement](where, element);
      } else {
        this[_insertAdjacentNode](where, element);
      }
      return element;
    }
    [_insertAdjacentElement](where, element) {
      return this.insertAdjacentElement(where, element);
    }
    [_insertAdjacentNode](where, node) {
      switch (where[dartx.toLowerCase]()) {
        case 'beforebegin':
        {
          this[dartx.parentNode][dartx.insertBefore](node, this);
          break;
        }
        case 'afterbegin':
        {
          let first = dart.notNull(this[dartx.nodes][dartx.length]) > 0 ? this[dartx.nodes][dartx.get](0) : null;
          this[dartx.insertBefore](node, first);
          break;
        }
        case 'beforeend':
        {
          this[dartx.append](node);
          break;
        }
        case 'afterend':
        {
          this[dartx.parentNode][dartx.insertBefore](node, this[dartx.nextNode]);
          break;
        }
        default:
        {
          dart.throw(new core.ArgumentError(`Invalid position ${where}`));
        }
      }
    }
    [dartx.matches](selectors) {
      if (!!this.matches) {
        return this.matches(selectors);
      } else if (!!this.webkitMatchesSelector) {
        return this.webkitMatchesSelector(selectors);
      } else if (!!this.mozMatchesSelector) {
        return this.mozMatchesSelector(selectors);
      } else if (!!this.msMatchesSelector) {
        return this.msMatchesSelector(selectors);
      } else if (!!this.oMatchesSelector) {
        return this.oMatchesSelector(selectors);
      } else {
        dart.throw(new core.UnsupportedError("Not supported on this platform"));
      }
    }
    [dartx.matchesWithAncestors](selectors) {
      let elem = this;
      do {
        if (dart.notNull(elem[dartx.matches](selectors))) return true;
        elem = elem[dartx.parent];
      } while (elem != null);
      return false;
    }
    [dartx.createShadowRoot]() {
      return (this.createShadowRoot || this.webkitCreateShadowRoot).call(this);
    }
    get [dartx.shadowRoot]() {
      return this.shadowRoot || this.webkitShadowRoot;
    }
    get [dartx.contentEdge]() {
      return new html$._ContentCssRect(this);
    }
    get [dartx.paddingEdge]() {
      return new html$._PaddingCssRect(this);
    }
    get [dartx.borderEdge]() {
      return new html$._BorderCssRect(this);
    }
    get [dartx.marginEdge]() {
      return new html$._MarginCssRect(this);
    }
    get [dartx.documentOffset]() {
      return this[dartx.offsetTo](html$.document[dartx.documentElement]);
    }
    [dartx.offsetTo](parent) {
      return html$.Element._offsetToHelper(this, parent);
    }
    static _offsetToHelper(current, parent) {
      let sameAsParent = core.identical(current, parent);
      let foundAsParent = sameAsParent || parent[dartx.tagName] == 'HTML';
      if (current == null || sameAsParent) {
        if (foundAsParent) return new (math.Point$(core.num))(0, 0);
        dart.throw(new core.ArgumentError("Specified element is not a transitive offset " + "parent of this element."));
      }
      let parentOffset = current[dartx.offsetParent];
      let p = html$.Element._offsetToHelper(parentOffset, parent);
      return new (math.Point$(core.num))(dart.notNull(p.x) + dart.notNull(current[dartx.offsetLeft]), dart.notNull(p.y) + dart.notNull(current[dartx.offsetTop]));
    }
    [dartx.createFragment](html, opts) {
      let validator = opts && 'validator' in opts ? opts.validator : null;
      let treeSanitizer = opts && 'treeSanitizer' in opts ? opts.treeSanitizer : null;
      if (treeSanitizer == null) {
        if (validator == null) {
          if (html$.Element._defaultValidator == null) {
            html$.Element._defaultValidator = new html$.NodeValidatorBuilder.common();
          }
          validator = html$.Element._defaultValidator;
        }
        if (html$.Element._defaultSanitizer == null) {
          html$.Element._defaultSanitizer = new html$._ValidatingTreeSanitizer(validator);
        } else {
          html$.Element._defaultSanitizer.validator = validator;
        }
        treeSanitizer = html$.Element._defaultSanitizer;
      } else if (validator != null) {
        dart.throw(new core.ArgumentError('validator can only be passed if treeSanitizer is null'));
      }
      if (html$.Element._parseDocument == null) {
        html$.Element._parseDocument = html$.document[dartx.implementation][dartx.createHtmlDocument]('');
        html$.Element._parseRange = html$.Element._parseDocument[dartx.createRange]();
        let base = dart.as(html$.Element._parseDocument[dartx.createElement]('base'), html$.BaseElement);
        base[dartx.href] = html$.document[dartx.baseUri];
        html$.Element._parseDocument[dartx.head][dartx.append](base);
      }
      let contextElement = null;
      if (dart.is(this, html$.BodyElement)) {
        contextElement = html$.Element._parseDocument[dartx.body];
      } else {
        contextElement = html$.Element._parseDocument[dartx.createElement](this[dartx.tagName]);
        html$.Element._parseDocument[dartx.body][dartx.append](dart.as(contextElement, html$.Node));
      }
      let fragment = null;
      if (dart.notNull(html$.Range.supportsCreateContextualFragment) && dart.notNull(this[_canBeUsedToCreateContextualFragment])) {
        html$.Element._parseRange[dartx.selectNodeContents](dart.as(contextElement, html$.Node));
        fragment = html$.Element._parseRange[dartx.createContextualFragment](html);
      } else {
        dart.dput(contextElement, _innerHtml, html);
        fragment = html$.Element._parseDocument[dartx.createDocumentFragment]();
        while (dart.dload(contextElement, 'firstChild') != null) {
          dart.dsend(fragment, 'append', dart.dload(contextElement, 'firstChild'));
        }
      }
      if (!dart.equals(contextElement, html$.Element._parseDocument[dartx.body])) {
        dart.dsend(contextElement, 'remove');
      }
      treeSanitizer.sanitizeTree(dart.as(fragment, html$.Node));
      html$.document[dartx.adoptNode](dart.as(fragment, html$.Node));
      return dart.as(fragment, html$.DocumentFragment);
    }
    get [_canBeUsedToCreateContextualFragment]() {
      return !dart.notNull(this[_cannotBeUsedToCreateContextualFragment]);
    }
    get [_cannotBeUsedToCreateContextualFragment]() {
      return html$.Element._tagsForWhichCreateContextualFragmentIsNotSupported[dartx.contains](this[dartx.tagName]);
    }
    set [dartx.innerHtml](html) {
      this[dartx.setInnerHtml](html);
    }
    [dartx.setInnerHtml](html, opts) {
      let validator = opts && 'validator' in opts ? opts.validator : null;
      let treeSanitizer = opts && 'treeSanitizer' in opts ? opts.treeSanitizer : null;
      this[dartx.text] = null;
      if (dart.is(treeSanitizer, html$._TrustedHtmlTreeSanitizer)) {
        this[_innerHtml] = html;
      } else {
        this[dartx.append](this[dartx.createFragment](html, {validator: validator, treeSanitizer: treeSanitizer}));
      }
    }
    get [dartx.innerHtml]() {
      return this[_innerHtml];
    }
    get [dartx.on]() {
      return new html$.ElementEvents(this);
    }
    static _hasCorruptedAttributes(element) {
      return (function(element) {
        if (!(element.attributes instanceof NamedNodeMap)) {
          return true;
        }
        var childNodes = element.childNodes;
        if (element.lastChild && element.lastChild !== childNodes[childNodes.length - 1]) {
          return true;
        }
        if (element.children) {
          if (!(element.children instanceof HTMLCollection || element.children instanceof NodeList)) {
            return true;
          }
        }
        var length = 0;
        if (element.children) {
          length = element.children.length;
        }
        for (var i = 0; i < length; i++) {
          var child = element.children[i];
          if (child.id == 'attributes' || child.name == 'attributes' || child.id == 'lastChild' || child.name == 'lastChild' || child.id == 'children' || child.name == 'children') {
            return true;
          }
        }
        return false;
      })(element);
    }
    static _hasCorruptedAttributesAdditionalCheck(element) {
      return !(element.attributes instanceof NamedNodeMap);
    }
    static _safeTagName(element) {
      let result = 'element tag unavailable';
      try {
        if (typeof dart.dload(element, 'tagName') == 'string') {
          result = dart.as(dart.dload(element, 'tagName'), core.String);
        }
      } catch (e) {
      }

      return result;
    }
    get [dartx.offsetParent]() {
      return this.offsetParent;
    }
    get [dartx.offsetHeight]() {
      return this.offsetHeight[dartx.round]();
    }
    get [dartx.offsetLeft]() {
      return this.offsetLeft[dartx.round]();
    }
    get [dartx.offsetTop]() {
      return this.offsetTop[dartx.round]();
    }
    get [dartx.offsetWidth]() {
      return this.offsetWidth[dartx.round]();
    }
    get [dartx.scrollHeight]() {
      return this.scrollHeight[dartx.round]();
    }
    get [dartx.scrollLeft]() {
      return this.scrollLeft[dartx.round]();
    }
    set [dartx.scrollLeft](value) {
      this.scrollLeft = value[dartx.round]();
    }
    get [dartx.scrollTop]() {
      return this.scrollTop[dartx.round]();
    }
    set [dartx.scrollTop](value) {
      this.scrollTop = value[dartx.round]();
    }
    get [dartx.scrollWidth]() {
      return this.scrollWidth[dartx.round]();
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.contentEditable]() {
      return this.contentEditable;
    }
    set [dartx.contentEditable](value) {
      this.contentEditable = value;
    }
    get [dartx.contextMenu]() {
      return this.contextMenu;
    }
    set [dartx.contextMenu](value) {
      this.contextMenu = value;
    }
    get [dartx.dir]() {
      return this.dir;
    }
    set [dartx.dir](value) {
      this.dir = value;
    }
    get [dartx.draggable]() {
      return this.draggable;
    }
    set [dartx.draggable](value) {
      this.draggable = value;
    }
    get [dartx.hidden]() {
      return this.hidden;
    }
    set [dartx.hidden](value) {
      this.hidden = value;
    }
    get [dartx.isContentEditable]() {
      return this.isContentEditable;
    }
    get [dartx.lang]() {
      return this.lang;
    }
    set [dartx.lang](value) {
      this.lang = value;
    }
    get [dartx.spellcheck]() {
      return this.spellcheck;
    }
    set [dartx.spellcheck](value) {
      this.spellcheck = value;
    }
    get [dartx.style]() {
      return this.style;
    }
    get [dartx.tabIndex]() {
      return this.tabIndex;
    }
    set [dartx.tabIndex](value) {
      this.tabIndex = value;
    }
    get [dartx.title]() {
      return this.title;
    }
    set [dartx.title](value) {
      this.title = value;
    }
    get [dartx.translate]() {
      return this.translate;
    }
    set [dartx.translate](value) {
      this.translate = value;
    }
    get [dartx.dropzone]() {
      return this.webkitdropzone;
    }
    set [dartx.dropzone](value) {
      this.webkitdropzone = value;
    }
    [dartx.blur]() {
      return this.blur();
    }
    [dartx.click]() {
      return this.click();
    }
    [dartx.focus]() {
      return this.focus();
    }
    get [_attributes$]() {
      return this.attributes;
    }
    get [dartx.className]() {
      return this.className;
    }
    set [dartx.className](value) {
      this.className = value;
    }
    get [dartx.clientHeight]() {
      return this.clientHeight;
    }
    get [dartx.clientLeft]() {
      return this.clientLeft;
    }
    get [dartx.clientTop]() {
      return this.clientTop;
    }
    get [dartx.clientWidth]() {
      return this.clientWidth;
    }
    get [dartx.computedName]() {
      return this.computedName;
    }
    get [dartx.computedRole]() {
      return this.computedRole;
    }
    get [dartx.id]() {
      return this.id;
    }
    set [dartx.id](value) {
      this.id = value;
    }
    get [_innerHtml]() {
      return this.innerHTML;
    }
    set [_innerHtml](value) {
      this.innerHTML = value;
    }
    get [dartx.outerHtml]() {
      return this.outerHTML;
    }
    get [_scrollHeight]() {
      return this.scrollHeight;
    }
    get [_scrollLeft]() {
      return this.scrollLeft;
    }
    set [_scrollLeft](value) {
      this.scrollLeft = value;
    }
    get [_scrollTop]() {
      return this.scrollTop;
    }
    set [_scrollTop](value) {
      this.scrollTop = value;
    }
    get [_scrollWidth]() {
      return this.scrollWidth;
    }
    get [dartx.tagName]() {
      return this.tagName;
    }
    [dartx.closest](selectors) {
      return this.closest(selectors);
    }
    [dartx.getAnimations]() {
      return this.getAnimations();
    }
    [dartx.getAttribute](name) {
      return this.getAttribute(name);
    }
    [dartx.getAttributeNS](namespaceURI, localName) {
      return this.getAttributeNS(namespaceURI, localName);
    }
    [dartx.getBoundingClientRect]() {
      return this.getBoundingClientRect();
    }
    [dartx.getClientRects]() {
      return this.getClientRects();
    }
    [dartx.getDestinationInsertionPoints]() {
      return this.getDestinationInsertionPoints();
    }
    [dartx.getElementsByClassName](classNames) {
      return this.getElementsByClassName(classNames);
    }
    [_getElementsByTagName](localName) {
      return this.getElementsByTagName(localName);
    }
    [_hasAttribute](name) {
      return this.hasAttribute(name);
    }
    [_hasAttributeNS](namespaceURI, localName) {
      return this.hasAttributeNS(namespaceURI, localName);
    }
    [_removeAttribute](name) {
      return this.removeAttribute(name);
    }
    [_removeAttributeNS](namespaceURI, localName) {
      return this.removeAttributeNS(namespaceURI, localName);
    }
    [dartx.requestFullscreen]() {
      return this.requestFullscreen();
    }
    [dartx.requestPointerLock]() {
      return this.requestPointerLock();
    }
    [dartx.scroll](options_OR_x, y) {
      if (options_OR_x === void 0) options_OR_x = null;
      if (y === void 0) y = null;
      if (options_OR_x == null && y == null) {
        this[_scroll_1]();
        return;
      }
      if (dart.is(options_OR_x, core.Map) && y == null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options_OR_x);
        this[_scroll_2](options_1);
        return;
      }
      if (y != null && typeof options_OR_x == 'number') {
        this[_scroll_3](options_OR_x, y);
        return;
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    [_scroll_1]() {
      return this.scroll();
    }
    [_scroll_2](options) {
      return this.scroll(options);
    }
    [_scroll_3](x, y) {
      return this.scroll(x, y);
    }
    [dartx.scrollBy](options_OR_x, y) {
      if (options_OR_x === void 0) options_OR_x = null;
      if (y === void 0) y = null;
      if (options_OR_x == null && y == null) {
        this[_scrollBy_1]();
        return;
      }
      if (dart.is(options_OR_x, core.Map) && y == null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options_OR_x);
        this[_scrollBy_2](options_1);
        return;
      }
      if (y != null && typeof options_OR_x == 'number') {
        this[_scrollBy_3](options_OR_x, y);
        return;
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    [_scrollBy_1]() {
      return this.scrollBy();
    }
    [_scrollBy_2](options) {
      return this.scrollBy(options);
    }
    [_scrollBy_3](x, y) {
      return this.scrollBy(x, y);
    }
    [_scrollIntoView](alignWithTop) {
      return this.scrollIntoView(alignWithTop);
    }
    [_scrollIntoViewIfNeeded](centerIfNeeded) {
      return this.scrollIntoViewIfNeeded(centerIfNeeded);
    }
    [dartx.scrollTo](options_OR_x, y) {
      if (options_OR_x === void 0) options_OR_x = null;
      if (y === void 0) y = null;
      if (options_OR_x == null && y == null) {
        this[_scrollTo_1]();
        return;
      }
      if (dart.is(options_OR_x, core.Map) && y == null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options_OR_x);
        this[_scrollTo_2](options_1);
        return;
      }
      if (y != null && typeof options_OR_x == 'number') {
        this[_scrollTo_3](options_OR_x, y);
        return;
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    [_scrollTo_1]() {
      return this.scrollTo();
    }
    [_scrollTo_2](options) {
      return this.scrollTo(options);
    }
    [_scrollTo_3](x, y) {
      return this.scrollTo(x, y);
    }
    [dartx.setAttribute](name, value) {
      return this.setAttribute(name, value);
    }
    [dartx.setAttributeNS](namespaceURI, name, value) {
      return this.setAttributeNS(namespaceURI, name, value);
    }
    [dartx.after](nodes) {
      return this.after(nodes);
    }
    [dartx.before](nodes) {
      return this.before(nodes);
    }
    get [dartx.nextElementSibling]() {
      return this.nextElementSibling;
    }
    get [dartx.previousElementSibling]() {
      return this.previousElementSibling;
    }
    get [_childElementCount]() {
      return this.childElementCount;
    }
    get [_children]() {
      return this.children;
    }
    get [_firstElementChild]() {
      return this.firstElementChild;
    }
    get [_lastElementChild]() {
      return this.lastElementChild;
    }
    [dartx.querySelector](selectors) {
      return this.querySelector(selectors);
    }
    [_querySelectorAll](selectors) {
      return this.querySelectorAll(selectors);
    }
    get [dartx.onAbort]() {
      return html$.Element.abortEvent.forElement(this);
    }
    get [dartx.onBeforeCopy]() {
      return html$.Element.beforeCopyEvent.forElement(this);
    }
    get [dartx.onBeforeCut]() {
      return html$.Element.beforeCutEvent.forElement(this);
    }
    get [dartx.onBeforePaste]() {
      return html$.Element.beforePasteEvent.forElement(this);
    }
    get [dartx.onBlur]() {
      return html$.Element.blurEvent.forElement(this);
    }
    get [dartx.onCanPlay]() {
      return html$.Element.canPlayEvent.forElement(this);
    }
    get [dartx.onCanPlayThrough]() {
      return html$.Element.canPlayThroughEvent.forElement(this);
    }
    get [dartx.onChange]() {
      return html$.Element.changeEvent.forElement(this);
    }
    get [dartx.onClick]() {
      return html$.Element.clickEvent.forElement(this);
    }
    get [dartx.onContextMenu]() {
      return html$.Element.contextMenuEvent.forElement(this);
    }
    get [dartx.onCopy]() {
      return html$.Element.copyEvent.forElement(this);
    }
    get [dartx.onCut]() {
      return html$.Element.cutEvent.forElement(this);
    }
    get [dartx.onDoubleClick]() {
      return html$.Element.doubleClickEvent.forElement(this);
    }
    get [dartx.onDrag]() {
      return html$.Element.dragEvent.forElement(this);
    }
    get [dartx.onDragEnd]() {
      return html$.Element.dragEndEvent.forElement(this);
    }
    get [dartx.onDragEnter]() {
      return html$.Element.dragEnterEvent.forElement(this);
    }
    get [dartx.onDragLeave]() {
      return html$.Element.dragLeaveEvent.forElement(this);
    }
    get [dartx.onDragOver]() {
      return html$.Element.dragOverEvent.forElement(this);
    }
    get [dartx.onDragStart]() {
      return html$.Element.dragStartEvent.forElement(this);
    }
    get [dartx.onDrop]() {
      return html$.Element.dropEvent.forElement(this);
    }
    get [dartx.onDurationChange]() {
      return html$.Element.durationChangeEvent.forElement(this);
    }
    get [dartx.onEmptied]() {
      return html$.Element.emptiedEvent.forElement(this);
    }
    get [dartx.onEnded]() {
      return html$.Element.endedEvent.forElement(this);
    }
    get [dartx.onError]() {
      return html$.Element.errorEvent.forElement(this);
    }
    get [dartx.onFocus]() {
      return html$.Element.focusEvent.forElement(this);
    }
    get [dartx.onInput]() {
      return html$.Element.inputEvent.forElement(this);
    }
    get [dartx.onInvalid]() {
      return html$.Element.invalidEvent.forElement(this);
    }
    get [dartx.onKeyDown]() {
      return html$.Element.keyDownEvent.forElement(this);
    }
    get [dartx.onKeyPress]() {
      return html$.Element.keyPressEvent.forElement(this);
    }
    get [dartx.onKeyUp]() {
      return html$.Element.keyUpEvent.forElement(this);
    }
    get [dartx.onLoad]() {
      return html$.Element.loadEvent.forElement(this);
    }
    get [dartx.onLoadedData]() {
      return html$.Element.loadedDataEvent.forElement(this);
    }
    get [dartx.onLoadedMetadata]() {
      return html$.Element.loadedMetadataEvent.forElement(this);
    }
    get [dartx.onMouseDown]() {
      return html$.Element.mouseDownEvent.forElement(this);
    }
    get [dartx.onMouseEnter]() {
      return html$.Element.mouseEnterEvent.forElement(this);
    }
    get [dartx.onMouseLeave]() {
      return html$.Element.mouseLeaveEvent.forElement(this);
    }
    get [dartx.onMouseMove]() {
      return html$.Element.mouseMoveEvent.forElement(this);
    }
    get [dartx.onMouseOut]() {
      return html$.Element.mouseOutEvent.forElement(this);
    }
    get [dartx.onMouseOver]() {
      return html$.Element.mouseOverEvent.forElement(this);
    }
    get [dartx.onMouseUp]() {
      return html$.Element.mouseUpEvent.forElement(this);
    }
    get [dartx.onMouseWheel]() {
      return html$.Element.mouseWheelEvent.forElement(this);
    }
    get [dartx.onPaste]() {
      return html$.Element.pasteEvent.forElement(this);
    }
    get [dartx.onPause]() {
      return html$.Element.pauseEvent.forElement(this);
    }
    get [dartx.onPlay]() {
      return html$.Element.playEvent.forElement(this);
    }
    get [dartx.onPlaying]() {
      return html$.Element.playingEvent.forElement(this);
    }
    get [dartx.onRateChange]() {
      return html$.Element.rateChangeEvent.forElement(this);
    }
    get [dartx.onReset]() {
      return html$.Element.resetEvent.forElement(this);
    }
    get [dartx.onResize]() {
      return html$.Element.resizeEvent.forElement(this);
    }
    get [dartx.onScroll]() {
      return html$.Element.scrollEvent.forElement(this);
    }
    get [dartx.onSearch]() {
      return html$.Element.searchEvent.forElement(this);
    }
    get [dartx.onSeeked]() {
      return html$.Element.seekedEvent.forElement(this);
    }
    get [dartx.onSeeking]() {
      return html$.Element.seekingEvent.forElement(this);
    }
    get [dartx.onSelect]() {
      return html$.Element.selectEvent.forElement(this);
    }
    get [dartx.onSelectStart]() {
      return html$.Element.selectStartEvent.forElement(this);
    }
    get [dartx.onStalled]() {
      return html$.Element.stalledEvent.forElement(this);
    }
    get [dartx.onSubmit]() {
      return html$.Element.submitEvent.forElement(this);
    }
    get [dartx.onSuspend]() {
      return html$.Element.suspendEvent.forElement(this);
    }
    get [dartx.onTimeUpdate]() {
      return html$.Element.timeUpdateEvent.forElement(this);
    }
    get [dartx.onTouchCancel]() {
      return html$.Element.touchCancelEvent.forElement(this);
    }
    get [dartx.onTouchEnd]() {
      return html$.Element.touchEndEvent.forElement(this);
    }
    get [dartx.onTouchEnter]() {
      return html$.Element.touchEnterEvent.forElement(this);
    }
    get [dartx.onTouchLeave]() {
      return html$.Element.touchLeaveEvent.forElement(this);
    }
    get [dartx.onTouchMove]() {
      return html$.Element.touchMoveEvent.forElement(this);
    }
    get [dartx.onTouchStart]() {
      return html$.Element.touchStartEvent.forElement(this);
    }
    get [dartx.onTransitionEnd]() {
      return html$.Element.transitionEndEvent.forElement(this);
    }
    get [dartx.onVolumeChange]() {
      return html$.Element.volumeChangeEvent.forElement(this);
    }
    get [dartx.onWaiting]() {
      return html$.Element.waitingEvent.forElement(this);
    }
    get [dartx.onFullscreenChange]() {
      return html$.Element.fullscreenChangeEvent.forElement(this);
    }
    get [dartx.onFullscreenError]() {
      return html$.Element.fullscreenErrorEvent.forElement(this);
    }
  };
  dart.defineNamedConstructor(html$.Element, 'created');
  html$.Element[dart.implements] = () => [html$.NonDocumentTypeChildNode, html$.GlobalEventHandlers, html$.ParentNode, html$.ChildNode];
  dart.setSignature(html$.Element, {
    constructors: () => ({
      html: [html$.Element, [core.String], {validator: html$.NodeValidator, treeSanitizer: html$.NodeTreeSanitizer}],
      created: [html$.Element, []],
      tag: [html$.Element, [core.String], [core.String]],
      a: [html$.Element, []],
      article: [html$.Element, []],
      aside: [html$.Element, []],
      audio: [html$.Element, []],
      br: [html$.Element, []],
      canvas: [html$.Element, []],
      div: [html$.Element, []],
      footer: [html$.Element, []],
      header: [html$.Element, []],
      hr: [html$.Element, []],
      iframe: [html$.Element, []],
      img: [html$.Element, []],
      li: [html$.Element, []],
      nav: [html$.Element, []],
      ol: [html$.Element, []],
      option: [html$.Element, []],
      p: [html$.Element, []],
      pre: [html$.Element, []],
      section: [html$.Element, []],
      select: [html$.Element, []],
      span: [html$.Element, []],
      svg: [html$.Element, []],
      table: [html$.Element, []],
      td: [html$.Element, []],
      textarea: [html$.Element, []],
      th: [html$.Element, []],
      tr: [html$.Element, []],
      ul: [html$.Element, []],
      video: [html$.Element, []],
      _: [html$.Element, []]
    }),
    methods: () => ({
      [dartx.querySelectorAll]: [T => [html$.ElementList$(T), [core.String]]],
      [dartx.query]: [html$.Element, [core.String]],
      [dartx.queryAll]: [T => [html$.ElementList$(T), [core.String]]],
      [dartx.getNamespacedAttributes]: [core.Map$(core.String, core.String), [core.String]],
      [dartx.getComputedStyle]: [html$.CssStyleDeclaration, [], [core.String]],
      [dartx.appendText]: [dart.void, [core.String]],
      [dartx.appendHtml]: [dart.void, [core.String], {validator: html$.NodeValidator, treeSanitizer: html$.NodeTreeSanitizer}],
      [dartx.attached]: [dart.void, []],
      [dartx.detached]: [dart.void, []],
      [dartx.enteredView]: [dart.void, []],
      [dartx.leftView]: [dart.void, []],
      [dartx.animate]: [html$.Animation, [core.Iterable$(core.Map$(core.String, dart.dynamic))], [dart.dynamic]],
      [_animate]: [html$.Animation, [core.Object], [dart.dynamic]],
      [dartx.attributeChanged]: [dart.void, [core.String, core.String, core.String]],
      [dartx.scrollIntoView]: [dart.void, [], [html$.ScrollAlignment]],
      [dartx.insertAdjacentText]: [dart.void, [core.String, core.String]],
      [_insertAdjacentText]: [dart.void, [core.String, core.String]],
      [dartx.insertAdjacentHtml]: [dart.void, [core.String, core.String], {validator: html$.NodeValidator, treeSanitizer: html$.NodeTreeSanitizer}],
      [_insertAdjacentHtml]: [dart.void, [core.String, core.String]],
      [dartx.insertAdjacentElement]: [html$.Element, [core.String, html$.Element]],
      [_insertAdjacentElement]: [dart.void, [core.String, html$.Element]],
      [_insertAdjacentNode]: [dart.void, [core.String, html$.Node]],
      [dartx.matches]: [core.bool, [core.String]],
      [dartx.matchesWithAncestors]: [core.bool, [core.String]],
      [dartx.createShadowRoot]: [html$.ShadowRoot, []],
      [dartx.offsetTo]: [math.Point$(core.num), [html$.Element]],
      [dartx.createFragment]: [html$.DocumentFragment, [core.String], {validator: html$.NodeValidator, treeSanitizer: html$.NodeTreeSanitizer}],
      [dartx.setInnerHtml]: [dart.void, [core.String], {validator: html$.NodeValidator, treeSanitizer: html$.NodeTreeSanitizer}],
      [dartx.blur]: [dart.void, []],
      [dartx.click]: [dart.void, []],
      [dartx.focus]: [dart.void, []],
      [dartx.closest]: [html$.Element, [core.String]],
      [dartx.getAnimations]: [core.List$(html$.Animation), []],
      [dartx.getAttribute]: [core.String, [core.String]],
      [dartx.getAttributeNS]: [core.String, [core.String, core.String]],
      [dartx.getBoundingClientRect]: [math.Rectangle$(core.num), []],
      [dartx.getClientRects]: [core.List$(math.Rectangle$(core.num)), []],
      [dartx.getDestinationInsertionPoints]: [core.List$(html$.Node), []],
      [dartx.getElementsByClassName]: [core.List$(html$.Node), [core.String]],
      [_getElementsByTagName]: [core.List$(html$.Node), [core.String]],
      [_hasAttribute]: [core.bool, [core.String]],
      [_hasAttributeNS]: [core.bool, [core.String, core.String]],
      [_removeAttribute]: [dart.void, [core.String]],
      [_removeAttributeNS]: [dart.void, [core.String, core.String]],
      [dartx.requestFullscreen]: [dart.void, []],
      [dartx.requestPointerLock]: [dart.void, []],
      [dartx.scroll]: [dart.void, [], [dart.dynamic, core.num]],
      [_scroll_1]: [dart.void, []],
      [_scroll_2]: [dart.void, [dart.dynamic]],
      [_scroll_3]: [dart.void, [core.num, dart.dynamic]],
      [dartx.scrollBy]: [dart.void, [], [dart.dynamic, core.num]],
      [_scrollBy_1]: [dart.void, []],
      [_scrollBy_2]: [dart.void, [dart.dynamic]],
      [_scrollBy_3]: [dart.void, [core.num, dart.dynamic]],
      [_scrollIntoView]: [dart.void, [], [core.bool]],
      [_scrollIntoViewIfNeeded]: [dart.void, [], [core.bool]],
      [dartx.scrollTo]: [dart.void, [], [dart.dynamic, core.num]],
      [_scrollTo_1]: [dart.void, []],
      [_scrollTo_2]: [dart.void, [dart.dynamic]],
      [_scrollTo_3]: [dart.void, [core.num, dart.dynamic]],
      [dartx.setAttribute]: [dart.void, [core.String, core.String]],
      [dartx.setAttributeNS]: [dart.void, [core.String, core.String, core.String]],
      [dartx.after]: [dart.void, [core.Object]],
      [dartx.before]: [dart.void, [core.Object]],
      [dartx.querySelector]: [html$.Element, [core.String]],
      [_querySelectorAll]: [core.List$(html$.Node), [core.String]]
    }),
    statics: () => ({
      isTagSupported: [core.bool, [core.String]],
      _determineMouseWheelEventType: [core.String, [html$.EventTarget]],
      _determineTransitionEventType: [core.String, [html$.EventTarget]],
      _offsetToHelper: [math.Point$(core.num), [html$.Element, html$.Element]],
      _hasCorruptedAttributes: [core.bool, [html$.Element]],
      _hasCorruptedAttributesAdditionalCheck: [core.bool, [html$.Element]],
      _safeTagName: [core.String, [dart.dynamic]]
    }),
    names: ['isTagSupported', '_determineMouseWheelEventType', '_determineTransitionEventType', '_offsetToHelper', '_hasCorruptedAttributes', '_hasCorruptedAttributesAdditionalCheck', '_safeTagName']
  });
  html$.Element[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Element')), dart.const(new _js_helper.Native("Element"))];
  html$.Element._parseDocument = null;
  html$.Element._parseRange = null;
  html$.Element._defaultValidator = null;
  html$.Element._defaultSanitizer = null;
  html$.Element._tagsForWhichCreateContextualFragmentIsNotSupported = dart.const(dart.list(['HEAD', 'AREA', 'BASE', 'BASEFONT', 'BR', 'COL', 'COLGROUP', 'EMBED', 'FRAME', 'FRAMESET', 'HR', 'IMAGE', 'IMG', 'INPUT', 'ISINDEX', 'LINK', 'META', 'PARAM', 'SOURCE', 'STYLE', 'TITLE', 'WBR'], core.String));
  dart.defineLazy(html$.Element, {
    get mouseWheelEvent() {
      return dart.const(new (html$._CustomEventStreamProvider$(html$.WheelEvent))(html$.Element._determineMouseWheelEventType));
    },
    get transitionEndEvent() {
      return dart.const(new (html$._CustomEventStreamProvider$(html$.TransitionEvent))(html$.Element._determineTransitionEventType));
    },
    get abortEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('abort'));
    },
    get beforeCopyEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('beforecopy'));
    },
    get beforeCutEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('beforecut'));
    },
    get beforePasteEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('beforepaste'));
    },
    get blurEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('blur'));
    },
    get canPlayEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('canplay'));
    },
    get canPlayThroughEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('canplaythrough'));
    },
    get changeEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('change'));
    },
    get clickEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MouseEvent))('click'));
    },
    get contextMenuEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MouseEvent))('contextmenu'));
    },
    get copyEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.ClipboardEvent))('copy'));
    },
    get cutEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.ClipboardEvent))('cut'));
    },
    get doubleClickEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('dblclick'));
    },
    get dragEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MouseEvent))('drag'));
    },
    get dragEndEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MouseEvent))('dragend'));
    },
    get dragEnterEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MouseEvent))('dragenter'));
    },
    get dragLeaveEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MouseEvent))('dragleave'));
    },
    get dragOverEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MouseEvent))('dragover'));
    },
    get dragStartEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MouseEvent))('dragstart'));
    },
    get dropEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MouseEvent))('drop'));
    },
    get durationChangeEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('durationchange'));
    },
    get emptiedEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('emptied'));
    },
    get endedEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('ended'));
    },
    get errorEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('error'));
    },
    get focusEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('focus'));
    },
    get inputEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('input'));
    },
    get invalidEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('invalid'));
    },
    get keyDownEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.KeyboardEvent))('keydown'));
    },
    get keyPressEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.KeyboardEvent))('keypress'));
    },
    get keyUpEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.KeyboardEvent))('keyup'));
    },
    get loadEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('load'));
    },
    get loadedDataEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('loadeddata'));
    },
    get loadedMetadataEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('loadedmetadata'));
    },
    get mouseDownEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MouseEvent))('mousedown'));
    },
    get mouseEnterEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MouseEvent))('mouseenter'));
    },
    get mouseLeaveEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MouseEvent))('mouseleave'));
    },
    get mouseMoveEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MouseEvent))('mousemove'));
    },
    get mouseOutEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MouseEvent))('mouseout'));
    },
    get mouseOverEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MouseEvent))('mouseover'));
    },
    get mouseUpEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MouseEvent))('mouseup'));
    },
    get pasteEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.ClipboardEvent))('paste'));
    },
    get pauseEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('pause'));
    },
    get playEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('play'));
    },
    get playingEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('playing'));
    },
    get rateChangeEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('ratechange'));
    },
    get resetEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('reset'));
    },
    get resizeEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('resize'));
    },
    get scrollEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('scroll'));
    },
    get searchEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('search'));
    },
    get seekedEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('seeked'));
    },
    get seekingEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('seeking'));
    },
    get selectEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('select'));
    },
    get selectStartEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('selectstart'));
    },
    get stalledEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('stalled'));
    },
    get submitEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('submit'));
    },
    get suspendEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('suspend'));
    },
    get timeUpdateEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('timeupdate'));
    },
    get touchCancelEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.TouchEvent))('touchcancel'));
    },
    get touchEndEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.TouchEvent))('touchend'));
    },
    get touchEnterEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.TouchEvent))('touchenter'));
    },
    get touchLeaveEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.TouchEvent))('touchleave'));
    },
    get touchMoveEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.TouchEvent))('touchmove'));
    },
    get touchStartEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.TouchEvent))('touchstart'));
    },
    get volumeChangeEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('volumechange'));
    },
    get waitingEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('waiting'));
    },
    get fullscreenChangeEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('webkitfullscreenchange'));
    },
    get fullscreenErrorEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('webkitfullscreenerror'));
    }
  });
  dart.registerExtension(dart.global.Element, html$.Element);
  html$.HtmlElement = class HtmlElement extends html$.Element {
    static new() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(html$.HtmlElement, 'created');
  dart.setSignature(html$.HtmlElement, {
    constructors: () => ({
      new: [html$.HtmlElement, []],
      created: [html$.HtmlElement, []]
    })
  });
  html$.HtmlElement[dart.metadata] = () => [dart.const(new _js_helper.Native("HTMLElement"))];
  dart.registerExtension(dart.global.HTMLElement, html$.HtmlElement);
  html$._EntryArray = class _EntryArray extends core.Object {};
  html$._EntryArray[dart.implements] = () => [core.List$(html$.Entry)];
  html$._EntryArray[dart.metadata] = () => [dart.const(new _js_helper.Native("EntryArray"))];
  dart.registerExtension(dart.global.EntryArray, html$._EntryArray);
  html$.spawnDomUri = function(uri, args, message) {
    dart.throw(new core.UnimplementedError());
  };
  dart.fn(html$.spawnDomUri, async.Future$(isolate.Isolate), [core.Uri, core.List$(core.String), dart.dynamic]);
  html$.createCustomUpgrader = function(customElementClass, $this) {
    return $this;
  };
  dart.fn(html$.createCustomUpgrader, dart.dynamic, [core.Type, dart.dynamic]);
  dart.defineExtensionNames([
    'onError'
  ]);
  html$.AbstractWorker = class AbstractWorker extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get onError() {
      return html$.AbstractWorker.errorEvent.forTarget(this);
    }
  };
  html$.AbstractWorker[dart.implements] = () => [html$.EventTarget];
  dart.setSignature(html$.AbstractWorker, {
    constructors: () => ({_: [html$.AbstractWorker, []]})
  });
  dart.defineExtensionMembers(html$.AbstractWorker, ['onError']);
  html$.AbstractWorker[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('AbstractWorker'))];
  dart.defineLazy(html$.AbstractWorker, {
    get errorEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('error'));
    }
  });
  dart.defineExtensionNames([
    'toString',
    'download',
    'hreflang',
    'rel',
    'target',
    'type',
    'hash',
    'host',
    'hostname',
    'href',
    'origin',
    'password',
    'pathname',
    'port',
    'protocol',
    'search',
    'username'
  ]);
  html$.AnchorElement = class AnchorElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(opts) {
      let href = opts && 'href' in opts ? opts.href : null;
      let e = dart.as(html$.document[dartx.createElement]("a"), html$.AnchorElement);
      if (href != null) e[dartx.href] = href;
      return e;
    }
    created() {
      this[dartx.download] = null;
      this[dartx.hreflang] = null;
      this[dartx.rel] = null;
      this[dartx.target] = null;
      this[dartx.type] = null;
      this[dartx.hash] = null;
      this[dartx.host] = null;
      this[dartx.hostname] = null;
      this[dartx.href] = null;
      this[dartx.origin] = null;
      this[dartx.password] = null;
      this[dartx.pathname] = null;
      this[dartx.port] = null;
      this[dartx.protocol] = null;
      this[dartx.search] = null;
      this[dartx.username] = null;
      super.created();
    }
    get [dartx.download]() {
      return this.download;
    }
    set [dartx.download](value) {
      this.download = value;
    }
    get [dartx.hreflang]() {
      return this.hreflang;
    }
    set [dartx.hreflang](value) {
      this.hreflang = value;
    }
    get [dartx.rel]() {
      return this.rel;
    }
    set [dartx.rel](value) {
      this.rel = value;
    }
    get [dartx.target]() {
      return this.target;
    }
    set [dartx.target](value) {
      this.target = value;
    }
    get [dartx.type]() {
      return this.type;
    }
    set [dartx.type](value) {
      this.type = value;
    }
    get [dartx.hash]() {
      return this.hash;
    }
    set [dartx.hash](value) {
      this.hash = value;
    }
    get [dartx.host]() {
      return this.host;
    }
    set [dartx.host](value) {
      this.host = value;
    }
    get [dartx.hostname]() {
      return this.hostname;
    }
    set [dartx.hostname](value) {
      this.hostname = value;
    }
    get [dartx.href]() {
      return this.href;
    }
    set [dartx.href](value) {
      this.href = value;
    }
    get [dartx.origin]() {
      return this.origin;
    }
    get [dartx.password]() {
      return this.password;
    }
    set [dartx.password](value) {
      this.password = value;
    }
    get [dartx.pathname]() {
      return this.pathname;
    }
    set [dartx.pathname](value) {
      this.pathname = value;
    }
    get [dartx.port]() {
      return this.port;
    }
    set [dartx.port](value) {
      this.port = value;
    }
    get [dartx.protocol]() {
      return this.protocol;
    }
    set [dartx.protocol](value) {
      this.protocol = value;
    }
    get [dartx.search]() {
      return this.search;
    }
    set [dartx.search](value) {
      this.search = value;
    }
    get [dartx.username]() {
      return this.username;
    }
    set [dartx.username](value) {
      this.username = value;
    }
    [dartx.toString]() {
      return String(this);
    }
  };
  dart.defineNamedConstructor(html$.AnchorElement, 'created');
  html$.AnchorElement[dart.implements] = () => [html$.UrlUtils];
  dart.setSignature(html$.AnchorElement, {
    constructors: () => ({
      _: [html$.AnchorElement, []],
      new: [html$.AnchorElement, [], {href: core.String}],
      created: [html$.AnchorElement, []]
    })
  });
  html$.AnchorElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLAnchorElement')), dart.const(new _js_helper.Native("HTMLAnchorElement"))];
  dart.registerExtension(dart.global.HTMLAnchorElement, html$.AnchorElement);
  dart.defineExtensionNames([
    'cancel',
    'finish',
    'pause',
    'play',
    'reverse',
    'currentTime',
    'effect',
    'endClip',
    'finished',
    'playState',
    'playbackRate',
    'ready',
    'startClip',
    'startTime'
  ]);
  html$.Animation = class Animation extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static get supported() {
      return !!document.body.animate;
    }
    get [dartx.currentTime]() {
      return this.currentTime;
    }
    set [dartx.currentTime](value) {
      this.currentTime = value;
    }
    get [dartx.effect]() {
      return this.effect;
    }
    set [dartx.effect](value) {
      this.effect = value;
    }
    get [dartx.endClip]() {
      return this.endClip;
    }
    set [dartx.endClip](value) {
      this.endClip = value;
    }
    get [dartx.finished]() {
      return this.finished;
    }
    get [dartx.playState]() {
      return this.playState;
    }
    get [dartx.playbackRate]() {
      return this.playbackRate;
    }
    set [dartx.playbackRate](value) {
      this.playbackRate = value;
    }
    get [dartx.ready]() {
      return this.ready;
    }
    get [dartx.startClip]() {
      return this.startClip;
    }
    set [dartx.startClip](value) {
      this.startClip = value;
    }
    get [dartx.startTime]() {
      return this.startTime;
    }
    set [dartx.startTime](value) {
      this.startTime = value;
    }
    [dartx.cancel]() {
      return this.cancel();
    }
    [dartx.finish]() {
      return this.finish();
    }
    [dartx.pause]() {
      return this.pause();
    }
    [dartx.play]() {
      return this.play();
    }
    [dartx.reverse]() {
      return this.reverse();
    }
  };
  dart.setSignature(html$.Animation, {
    constructors: () => ({_: [html$.Animation, []]}),
    methods: () => ({
      [dartx.cancel]: [dart.void, []],
      [dartx.finish]: [dart.void, []],
      [dartx.pause]: [dart.void, []],
      [dartx.play]: [dart.void, []],
      [dartx.reverse]: [dart.void, []]
    })
  });
  html$.Animation[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Animation')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("Animation"))];
  dart.registerExtension(dart.global.Animation, html$.Animation);
  const _get_computedTiming = Symbol('_get_computedTiming');
  dart.defineExtensionNames([
    'computedTiming',
    'timing'
  ]);
  html$.AnimationEffectReadOnly = class AnimationEffectReadOnly extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.computedTiming]() {
      return html_common.convertNativeToDart_Dictionary(this[_get_computedTiming]);
    }
    get [_get_computedTiming]() {
      return this.computedTiming;
    }
    get [dartx.timing]() {
      return this.timing;
    }
  };
  dart.setSignature(html$.AnimationEffectReadOnly, {
    constructors: () => ({_: [html$.AnimationEffectReadOnly, []]})
  });
  html$.AnimationEffectReadOnly[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('AnimationEffectReadOnly')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("AnimationEffectReadOnly"))];
  dart.registerExtension(dart.global.AnimationEffectReadOnly, html$.AnimationEffectReadOnly);
  dart.defineExtensionNames([
    'delay',
    'direction',
    'duration',
    'easing',
    'endDelay',
    'fill',
    'iterationStart',
    'iterations',
    'playbackRate'
  ]);
  html$.AnimationEffectTiming = class AnimationEffectTiming extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.delay]() {
      return this.delay;
    }
    set [dartx.delay](value) {
      this.delay = value;
    }
    get [dartx.direction]() {
      return this.direction;
    }
    set [dartx.direction](value) {
      this.direction = value;
    }
    get [dartx.duration]() {
      return this.duration;
    }
    set [dartx.duration](value) {
      this.duration = value;
    }
    get [dartx.easing]() {
      return this.easing;
    }
    set [dartx.easing](value) {
      this.easing = value;
    }
    get [dartx.endDelay]() {
      return this.endDelay;
    }
    set [dartx.endDelay](value) {
      this.endDelay = value;
    }
    get [dartx.fill]() {
      return this.fill;
    }
    set [dartx.fill](value) {
      this.fill = value;
    }
    get [dartx.iterationStart]() {
      return this.iterationStart;
    }
    set [dartx.iterationStart](value) {
      this.iterationStart = value;
    }
    get [dartx.iterations]() {
      return this.iterations;
    }
    set [dartx.iterations](value) {
      this.iterations = value;
    }
    get [dartx.playbackRate]() {
      return this.playbackRate;
    }
    set [dartx.playbackRate](value) {
      this.playbackRate = value;
    }
  };
  dart.setSignature(html$.AnimationEffectTiming, {
    constructors: () => ({_: [html$.AnimationEffectTiming, []]})
  });
  html$.AnimationEffectTiming[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('AnimationEffectTiming')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("AnimationEffectTiming"))];
  dart.registerExtension(dart.global.AnimationEffectTiming, html$.AnimationEffectTiming);
  dart.defineExtensionNames([
    'animationName',
    'elapsedTime'
  ]);
  html$.AnimationEvent = class AnimationEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.AnimationEvent._create_1(type, eventInitDict_1);
      }
      return html$.AnimationEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new AnimationEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new AnimationEvent(type);
    }
    get [dartx.animationName]() {
      return this.animationName;
    }
    get [dartx.elapsedTime]() {
      return this.elapsedTime;
    }
  };
  dart.setSignature(html$.AnimationEvent, {
    constructors: () => ({
      _: [html$.AnimationEvent, []],
      new: [html$.AnimationEvent, [core.String], [core.Map]]
    }),
    statics: () => ({
      _create_1: [html$.AnimationEvent, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.AnimationEvent, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.AnimationEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('AnimationEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("AnimationEvent"))];
  dart.registerExtension(dart.global.AnimationEvent, html$.AnimationEvent);
  dart.defineExtensionNames([
    'currentTime',
    'timelineTime'
  ]);
  html$.AnimationPlayerEvent = class AnimationPlayerEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.AnimationPlayerEvent._create_1(type, eventInitDict_1);
      }
      return html$.AnimationPlayerEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new AnimationPlayerEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new AnimationPlayerEvent(type);
    }
    get [dartx.currentTime]() {
      return this.currentTime;
    }
    get [dartx.timelineTime]() {
      return this.timelineTime;
    }
  };
  dart.setSignature(html$.AnimationPlayerEvent, {
    constructors: () => ({
      _: [html$.AnimationPlayerEvent, []],
      new: [html$.AnimationPlayerEvent, [core.String], [core.Map]]
    }),
    statics: () => ({
      _create_1: [html$.AnimationPlayerEvent, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.AnimationPlayerEvent, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.AnimationPlayerEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('AnimationPlayerEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("AnimationPlayerEvent"))];
  dart.registerExtension(dart.global.AnimationPlayerEvent, html$.AnimationPlayerEvent);
  dart.defineExtensionNames([
    'getAnimations',
    'play',
    'currentTime',
    'playbackRate'
  ]);
  html$.AnimationTimeline = class AnimationTimeline extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.currentTime]() {
      return this.currentTime;
    }
    set [dartx.currentTime](value) {
      this.currentTime = value;
    }
    get [dartx.playbackRate]() {
      return this.playbackRate;
    }
    set [dartx.playbackRate](value) {
      this.playbackRate = value;
    }
    [dartx.getAnimations]() {
      return this.getAnimations();
    }
    [dartx.play](source) {
      return this.play(source);
    }
  };
  dart.setSignature(html$.AnimationTimeline, {
    constructors: () => ({_: [html$.AnimationTimeline, []]}),
    methods: () => ({
      [dartx.getAnimations]: [core.List$(html$.Animation), []],
      [dartx.play]: [html$.Animation, [html$.AnimationEffectReadOnly]]
    })
  });
  html$.AnimationTimeline[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('AnimationTimeline')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("AnimationTimeline"))];
  dart.registerExtension(dart.global.AnimationTimeline, html$.AnimationTimeline);
  dart.defineExtensionNames([
    'outcome',
    'platform'
  ]);
  html$.AppBannerPromptResult = class AppBannerPromptResult extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.outcome]() {
      return this.outcome;
    }
    get [dartx.platform]() {
      return this.platform;
    }
  };
  dart.setSignature(html$.AppBannerPromptResult, {
    constructors: () => ({_: [html$.AppBannerPromptResult, []]})
  });
  html$.AppBannerPromptResult[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('AppBannerPromptResult')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("AppBannerPromptResult"))];
  dart.registerExtension(dart.global.AppBannerPromptResult, html$.AppBannerPromptResult);
  dart.defineExtensionNames([
    'abort',
    'swapCache',
    'update',
    'onCached',
    'onChecking',
    'onDownloading',
    'onError',
    'onNoUpdate',
    'onObsolete',
    'onProgress',
    'onUpdateReady',
    'status'
  ]);
  html$.ApplicationCache = class ApplicationCache extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static get supported() {
      return !!window.applicationCache;
    }
    get [dartx.status]() {
      return this.status;
    }
    [dartx.abort]() {
      return this.abort();
    }
    [dartx.swapCache]() {
      return this.swapCache();
    }
    [dartx.update]() {
      return this.update();
    }
    get [dartx.onCached]() {
      return html$.ApplicationCache.cachedEvent.forTarget(this);
    }
    get [dartx.onChecking]() {
      return html$.ApplicationCache.checkingEvent.forTarget(this);
    }
    get [dartx.onDownloading]() {
      return html$.ApplicationCache.downloadingEvent.forTarget(this);
    }
    get [dartx.onError]() {
      return html$.ApplicationCache.errorEvent.forTarget(this);
    }
    get [dartx.onNoUpdate]() {
      return html$.ApplicationCache.noUpdateEvent.forTarget(this);
    }
    get [dartx.onObsolete]() {
      return html$.ApplicationCache.obsoleteEvent.forTarget(this);
    }
    get [dartx.onProgress]() {
      return html$.ApplicationCache.progressEvent.forTarget(this);
    }
    get [dartx.onUpdateReady]() {
      return html$.ApplicationCache.updateReadyEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.ApplicationCache, {
    constructors: () => ({_: [html$.ApplicationCache, []]}),
    methods: () => ({
      [dartx.abort]: [dart.void, []],
      [dartx.swapCache]: [dart.void, []],
      [dartx.update]: [dart.void, []]
    })
  });
  html$.ApplicationCache[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ApplicationCache')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.OPERA)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("ApplicationCache,DOMApplicationCache,OfflineResourceList"))];
  html$.ApplicationCache.CHECKING = 2;
  html$.ApplicationCache.DOWNLOADING = 3;
  html$.ApplicationCache.IDLE = 1;
  html$.ApplicationCache.OBSOLETE = 5;
  html$.ApplicationCache.UNCACHED = 0;
  html$.ApplicationCache.UPDATEREADY = 4;
  dart.defineLazy(html$.ApplicationCache, {
    get cachedEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('cached'));
    },
    get checkingEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('checking'));
    },
    get downloadingEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('downloading'));
    },
    get errorEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('error'));
    },
    get noUpdateEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('noupdate'));
    },
    get obsoleteEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('obsolete'));
    },
    get progressEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.ProgressEvent))('progress'));
    },
    get updateReadyEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('updateready'));
    }
  });
  dart.registerExtension(dart.global.ApplicationCache, html$.ApplicationCache);
  dart.defineExtensionNames([
    'message',
    'reason',
    'status',
    'url'
  ]);
  html$.ApplicationCacheErrorEvent = class ApplicationCacheErrorEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.ApplicationCacheErrorEvent._create_1(type, eventInitDict_1);
      }
      return html$.ApplicationCacheErrorEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new ApplicationCacheErrorEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new ApplicationCacheErrorEvent(type);
    }
    get [dartx.message]() {
      return this.message;
    }
    get [dartx.reason]() {
      return this.reason;
    }
    get [dartx.status]() {
      return this.status;
    }
    get [dartx.url]() {
      return this.url;
    }
  };
  dart.setSignature(html$.ApplicationCacheErrorEvent, {
    constructors: () => ({
      _: [html$.ApplicationCacheErrorEvent, []],
      new: [html$.ApplicationCacheErrorEvent, [core.String], [core.Map]]
    }),
    statics: () => ({
      _create_1: [html$.ApplicationCacheErrorEvent, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.ApplicationCacheErrorEvent, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.ApplicationCacheErrorEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ApplicationCacheErrorEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("ApplicationCacheErrorEvent"))];
  dart.registerExtension(dart.global.ApplicationCacheErrorEvent, html$.ApplicationCacheErrorEvent);
  dart.defineExtensionNames([
    'toString',
    'alt',
    'coords',
    'shape',
    'target',
    'hash',
    'host',
    'hostname',
    'href',
    'origin',
    'password',
    'pathname',
    'port',
    'protocol',
    'search',
    'username'
  ]);
  html$.AreaElement = class AreaElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("area"), html$.AreaElement);
    }
    created() {
      this[dartx.alt] = null;
      this[dartx.coords] = null;
      this[dartx.shape] = null;
      this[dartx.target] = null;
      this[dartx.hash] = null;
      this[dartx.host] = null;
      this[dartx.hostname] = null;
      this[dartx.href] = null;
      this[dartx.origin] = null;
      this[dartx.password] = null;
      this[dartx.pathname] = null;
      this[dartx.port] = null;
      this[dartx.protocol] = null;
      this[dartx.search] = null;
      this[dartx.username] = null;
      super.created();
    }
    get [dartx.alt]() {
      return this.alt;
    }
    set [dartx.alt](value) {
      this.alt = value;
    }
    get [dartx.coords]() {
      return this.coords;
    }
    set [dartx.coords](value) {
      this.coords = value;
    }
    get [dartx.shape]() {
      return this.shape;
    }
    set [dartx.shape](value) {
      this.shape = value;
    }
    get [dartx.target]() {
      return this.target;
    }
    set [dartx.target](value) {
      this.target = value;
    }
    get [dartx.hash]() {
      return this.hash;
    }
    set [dartx.hash](value) {
      this.hash = value;
    }
    get [dartx.host]() {
      return this.host;
    }
    set [dartx.host](value) {
      this.host = value;
    }
    get [dartx.hostname]() {
      return this.hostname;
    }
    set [dartx.hostname](value) {
      this.hostname = value;
    }
    get [dartx.href]() {
      return this.href;
    }
    set [dartx.href](value) {
      this.href = value;
    }
    get [dartx.origin]() {
      return this.origin;
    }
    get [dartx.password]() {
      return this.password;
    }
    set [dartx.password](value) {
      this.password = value;
    }
    get [dartx.pathname]() {
      return this.pathname;
    }
    set [dartx.pathname](value) {
      this.pathname = value;
    }
    get [dartx.port]() {
      return this.port;
    }
    set [dartx.port](value) {
      this.port = value;
    }
    get [dartx.protocol]() {
      return this.protocol;
    }
    set [dartx.protocol](value) {
      this.protocol = value;
    }
    get [dartx.search]() {
      return this.search;
    }
    set [dartx.search](value) {
      this.search = value;
    }
    get [dartx.username]() {
      return this.username;
    }
    set [dartx.username](value) {
      this.username = value;
    }
    [dartx.toString]() {
      return String(this);
    }
  };
  dart.defineNamedConstructor(html$.AreaElement, 'created');
  html$.AreaElement[dart.implements] = () => [html$.UrlUtils];
  dart.setSignature(html$.AreaElement, {
    constructors: () => ({
      _: [html$.AreaElement, []],
      new: [html$.AreaElement, []],
      created: [html$.AreaElement, []]
    })
  });
  html$.AreaElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLAreaElement')), dart.const(new _js_helper.Native("HTMLAreaElement"))];
  dart.registerExtension(dart.global.HTMLAreaElement, html$.AreaElement);
  dart.defineExtensionNames([
    'addTextTrack',
    'canPlayType',
    'load',
    'pause',
    'play',
    'setMediaKeys',
    'setSinkId',
    'addKey',
    'cancelKeyRequest',
    'generateKeyRequest',
    'onKeyAdded',
    'onKeyError',
    'onKeyMessage',
    'onNeedKey',
    'audioTracks',
    'autoplay',
    'buffered',
    'controller',
    'controls',
    'crossOrigin',
    'currentSrc',
    'currentTime',
    'defaultMuted',
    'defaultPlaybackRate',
    'duration',
    'ended',
    'error',
    'loop',
    'mediaGroup',
    'mediaKeys',
    'muted',
    'networkState',
    'paused',
    'playbackRate',
    'played',
    'preload',
    'readyState',
    'seekable',
    'seeking',
    'session',
    'sinkId',
    'src',
    'textTracks',
    'videoTracks',
    'volume',
    'audioDecodedByteCount',
    'videoDecodedByteCount'
  ]);
  html$.MediaElement = class MediaElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      this[dartx.audioTracks] = null;
      this[dartx.autoplay] = null;
      this[dartx.buffered] = null;
      this[dartx.controller] = null;
      this[dartx.controls] = null;
      this[dartx.crossOrigin] = null;
      this[dartx.currentSrc] = null;
      this[dartx.currentTime] = null;
      this[dartx.defaultMuted] = null;
      this[dartx.defaultPlaybackRate] = null;
      this[dartx.duration] = null;
      this[dartx.ended] = null;
      this[dartx.error] = null;
      this[dartx.loop] = null;
      this[dartx.mediaGroup] = null;
      this[dartx.mediaKeys] = null;
      this[dartx.muted] = null;
      this[dartx.networkState] = null;
      this[dartx.paused] = null;
      this[dartx.playbackRate] = null;
      this[dartx.played] = null;
      this[dartx.preload] = null;
      this[dartx.readyState] = null;
      this[dartx.seekable] = null;
      this[dartx.seeking] = null;
      this[dartx.session] = null;
      this[dartx.sinkId] = null;
      this[dartx.src] = null;
      this[dartx.textTracks] = null;
      this[dartx.videoTracks] = null;
      this[dartx.volume] = null;
      this[dartx.audioDecodedByteCount] = null;
      this[dartx.videoDecodedByteCount] = null;
      super.created();
    }
    get [dartx.audioTracks]() {
      return this.audioTracks;
    }
    get [dartx.autoplay]() {
      return this.autoplay;
    }
    set [dartx.autoplay](value) {
      this.autoplay = value;
    }
    get [dartx.buffered]() {
      return this.buffered;
    }
    get [dartx.controller]() {
      return this.controller;
    }
    set [dartx.controller](value) {
      this.controller = value;
    }
    get [dartx.controls]() {
      return this.controls;
    }
    set [dartx.controls](value) {
      this.controls = value;
    }
    get [dartx.crossOrigin]() {
      return this.crossOrigin;
    }
    set [dartx.crossOrigin](value) {
      this.crossOrigin = value;
    }
    get [dartx.currentSrc]() {
      return this.currentSrc;
    }
    get [dartx.currentTime]() {
      return this.currentTime;
    }
    set [dartx.currentTime](value) {
      this.currentTime = value;
    }
    get [dartx.defaultMuted]() {
      return this.defaultMuted;
    }
    set [dartx.defaultMuted](value) {
      this.defaultMuted = value;
    }
    get [dartx.defaultPlaybackRate]() {
      return this.defaultPlaybackRate;
    }
    set [dartx.defaultPlaybackRate](value) {
      this.defaultPlaybackRate = value;
    }
    get [dartx.duration]() {
      return this.duration;
    }
    get [dartx.ended]() {
      return this.ended;
    }
    get [dartx.error]() {
      return this.error;
    }
    get [dartx.loop]() {
      return this.loop;
    }
    set [dartx.loop](value) {
      this.loop = value;
    }
    get [dartx.mediaGroup]() {
      return this.mediaGroup;
    }
    set [dartx.mediaGroup](value) {
      this.mediaGroup = value;
    }
    get [dartx.mediaKeys]() {
      return this.mediaKeys;
    }
    get [dartx.muted]() {
      return this.muted;
    }
    set [dartx.muted](value) {
      this.muted = value;
    }
    get [dartx.networkState]() {
      return this.networkState;
    }
    get [dartx.paused]() {
      return this.paused;
    }
    get [dartx.playbackRate]() {
      return this.playbackRate;
    }
    set [dartx.playbackRate](value) {
      this.playbackRate = value;
    }
    get [dartx.played]() {
      return this.played;
    }
    get [dartx.preload]() {
      return this.preload;
    }
    set [dartx.preload](value) {
      this.preload = value;
    }
    get [dartx.readyState]() {
      return this.readyState;
    }
    get [dartx.seekable]() {
      return this.seekable;
    }
    get [dartx.seeking]() {
      return this.seeking;
    }
    get [dartx.session]() {
      return this.session;
    }
    set [dartx.session](value) {
      this.session = value;
    }
    get [dartx.sinkId]() {
      return this.sinkId;
    }
    get [dartx.src]() {
      return this.src;
    }
    set [dartx.src](value) {
      this.src = value;
    }
    get [dartx.textTracks]() {
      return this.textTracks;
    }
    get [dartx.videoTracks]() {
      return this.videoTracks;
    }
    get [dartx.volume]() {
      return this.volume;
    }
    set [dartx.volume](value) {
      this.volume = value;
    }
    get [dartx.audioDecodedByteCount]() {
      return this.webkitAudioDecodedByteCount;
    }
    get [dartx.videoDecodedByteCount]() {
      return this.webkitVideoDecodedByteCount;
    }
    [dartx.addTextTrack](kind, label, language) {
      return this.addTextTrack(kind, label, language);
    }
    [dartx.canPlayType](type, keySystem) {
      return this.canPlayType(type, keySystem);
    }
    [dartx.load]() {
      return this.load();
    }
    [dartx.pause]() {
      return this.pause();
    }
    [dartx.play]() {
      return this.play();
    }
    [dartx.setMediaKeys](mediaKeys) {
      return this.setMediaKeys(mediaKeys);
    }
    [dartx.setSinkId](sinkId) {
      return this.setSinkId(sinkId);
    }
    [dartx.addKey](keySystem, key, initData, sessionId) {
      return this.webkitAddKey(keySystem, key, initData, sessionId);
    }
    [dartx.cancelKeyRequest](keySystem, sessionId) {
      return this.webkitCancelKeyRequest(keySystem, sessionId);
    }
    [dartx.generateKeyRequest](keySystem, initData) {
      return this.webkitGenerateKeyRequest(keySystem, initData);
    }
    get [dartx.onKeyAdded]() {
      return html$.MediaElement.keyAddedEvent.forElement(this);
    }
    get [dartx.onKeyError]() {
      return html$.MediaElement.keyErrorEvent.forElement(this);
    }
    get [dartx.onKeyMessage]() {
      return html$.MediaElement.keyMessageEvent.forElement(this);
    }
    get [dartx.onNeedKey]() {
      return html$.MediaElement.needKeyEvent.forElement(this);
    }
  };
  dart.defineNamedConstructor(html$.MediaElement, 'created');
  dart.setSignature(html$.MediaElement, {
    constructors: () => ({
      _: [html$.MediaElement, []],
      created: [html$.MediaElement, []]
    }),
    methods: () => ({
      [dartx.addTextTrack]: [html$.TextTrack, [core.String], [core.String, core.String]],
      [dartx.canPlayType]: [core.String, [core.String], [core.String]],
      [dartx.load]: [dart.void, []],
      [dartx.pause]: [dart.void, []],
      [dartx.play]: [dart.void, []],
      [dartx.setMediaKeys]: [async.Future, [html$.MediaKeys]],
      [dartx.setSinkId]: [async.Future, [core.String]],
      [dartx.addKey]: [dart.void, [core.String, typed_data.Uint8List], [typed_data.Uint8List, core.String]],
      [dartx.cancelKeyRequest]: [dart.void, [core.String, core.String]],
      [dartx.generateKeyRequest]: [dart.void, [core.String], [typed_data.Uint8List]]
    })
  });
  html$.MediaElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLMediaElement')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("HTMLMediaElement"))];
  html$.MediaElement.HAVE_CURRENT_DATA = 2;
  html$.MediaElement.HAVE_ENOUGH_DATA = 4;
  html$.MediaElement.HAVE_FUTURE_DATA = 3;
  html$.MediaElement.HAVE_METADATA = 1;
  html$.MediaElement.HAVE_NOTHING = 0;
  html$.MediaElement.NETWORK_EMPTY = 0;
  html$.MediaElement.NETWORK_IDLE = 1;
  html$.MediaElement.NETWORK_LOADING = 2;
  html$.MediaElement.NETWORK_NO_SOURCE = 3;
  dart.defineLazy(html$.MediaElement, {
    get keyAddedEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MediaKeyEvent))('webkitkeyadded'));
    },
    get keyErrorEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MediaKeyEvent))('webkitkeyerror'));
    },
    get keyMessageEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MediaKeyEvent))('webkitkeymessage'));
    },
    get needKeyEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MediaKeyEvent))('webkitneedkey'));
    }
  });
  dart.registerExtension(dart.global.HTMLMediaElement, html$.MediaElement);
  html$.AudioElement = class AudioElement extends html$.MediaElement {
    static _(src) {
      if (src === void 0) src = null;
      if (src != null) {
        return html$.AudioElement._create_1(src);
      }
      return html$.AudioElement._create_2();
    }
    static _create_1(src) {
      return new Audio(src);
    }
    static _create_2() {
      return new Audio();
    }
    created() {
      super.created();
    }
    static new(src) {
      if (src === void 0) src = null;
      return html$.AudioElement._(src);
    }
  };
  dart.defineNamedConstructor(html$.AudioElement, 'created');
  dart.setSignature(html$.AudioElement, {
    constructors: () => ({
      _: [html$.AudioElement, [], [core.String]],
      created: [html$.AudioElement, []],
      new: [html$.AudioElement, [], [core.String]]
    }),
    statics: () => ({
      _create_1: [html$.AudioElement, [dart.dynamic]],
      _create_2: [html$.AudioElement, []]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.AudioElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLAudioElement')), dart.const(new _js_helper.Native("HTMLAudioElement"))];
  dart.registerExtension(dart.global.HTMLAudioElement, html$.AudioElement);
  dart.defineExtensionNames([
    'enabled',
    'id',
    'kind',
    'label',
    'language'
  ]);
  html$.AudioTrack = class AudioTrack extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.enabled]() {
      return this.enabled;
    }
    set [dartx.enabled](value) {
      this.enabled = value;
    }
    get [dartx.id]() {
      return this.id;
    }
    get [dartx.kind]() {
      return this.kind;
    }
    get [dartx.label]() {
      return this.label;
    }
    get [dartx.language]() {
      return this.language;
    }
  };
  dart.setSignature(html$.AudioTrack, {
    constructors: () => ({_: [html$.AudioTrack, []]})
  });
  html$.AudioTrack[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('AudioTrack')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("AudioTrack"))];
  dart.registerExtension(dart.global.AudioTrack, html$.AudioTrack);
  const __getter__ = Symbol('__getter__');
  dart.defineExtensionNames([
    'getTrackById',
    'onChange',
    'length'
  ]);
  html$.AudioTrackList = class AudioTrackList extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [__getter__](index) {
      return this.__getter__(index);
    }
    [dartx.getTrackById](id) {
      return this.getTrackById(id);
    }
    get [dartx.onChange]() {
      return html$.AudioTrackList.changeEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.AudioTrackList, {
    constructors: () => ({_: [html$.AudioTrackList, []]}),
    methods: () => ({
      [__getter__]: [html$.AudioTrack, [core.int]],
      [dartx.getTrackById]: [html$.AudioTrack, [core.String]]
    })
  });
  html$.AudioTrackList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('AudioTrackList')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("AudioTrackList"))];
  dart.defineLazy(html$.AudioTrackList, {
    get changeEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('change'));
    }
  });
  dart.registerExtension(dart.global.AudioTrackList, html$.AudioTrackList);
  dart.defineExtensionNames([
    'reason'
  ]);
  html$.AutocompleteErrorEvent = class AutocompleteErrorEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.AutocompleteErrorEvent._create_1(type, eventInitDict_1);
      }
      return html$.AutocompleteErrorEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new AutocompleteErrorEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new AutocompleteErrorEvent(type);
    }
    get [dartx.reason]() {
      return this.reason;
    }
  };
  dart.setSignature(html$.AutocompleteErrorEvent, {
    constructors: () => ({
      _: [html$.AutocompleteErrorEvent, []],
      new: [html$.AutocompleteErrorEvent, [core.String], [core.Map]]
    }),
    statics: () => ({
      _create_1: [html$.AutocompleteErrorEvent, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.AutocompleteErrorEvent, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.AutocompleteErrorEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('AutocompleteErrorEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("AutocompleteErrorEvent"))];
  dart.registerExtension(dart.global.AutocompleteErrorEvent, html$.AutocompleteErrorEvent);
  html$.BRElement = class BRElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("br"), html$.BRElement);
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(html$.BRElement, 'created');
  dart.setSignature(html$.BRElement, {
    constructors: () => ({
      _: [html$.BRElement, []],
      new: [html$.BRElement, []],
      created: [html$.BRElement, []]
    })
  });
  html$.BRElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLBRElement')), dart.const(new _js_helper.Native("HTMLBRElement"))];
  dart.registerExtension(dart.global.HTMLBRElement, html$.BRElement);
  dart.defineExtensionNames([
    'visible'
  ]);
  html$.BarProp = class BarProp extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.visible]() {
      return this.visible;
    }
  };
  dart.setSignature(html$.BarProp, {
    constructors: () => ({_: [html$.BarProp, []]})
  });
  html$.BarProp[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('BarProp')), core.deprecated, dart.const(new _js_helper.Native("BarProp"))];
  dart.registerExtension(dart.global.BarProp, html$.BarProp);
  dart.defineExtensionNames([
    'href',
    'target'
  ]);
  html$.BaseElement = class BaseElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("base"), html$.BaseElement);
    }
    created() {
      this[dartx.href] = null;
      this[dartx.target] = null;
      super.created();
    }
    get [dartx.href]() {
      return this.href;
    }
    set [dartx.href](value) {
      this.href = value;
    }
    get [dartx.target]() {
      return this.target;
    }
    set [dartx.target](value) {
      this.target = value;
    }
  };
  dart.defineNamedConstructor(html$.BaseElement, 'created');
  dart.setSignature(html$.BaseElement, {
    constructors: () => ({
      _: [html$.BaseElement, []],
      new: [html$.BaseElement, []],
      created: [html$.BaseElement, []]
    })
  });
  html$.BaseElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLBaseElement')), dart.const(new _js_helper.Native("HTMLBaseElement"))];
  dart.registerExtension(dart.global.HTMLBaseElement, html$.BaseElement);
  dart.defineExtensionNames([
    'charging',
    'chargingTime',
    'dischargingTime',
    'level'
  ]);
  html$.BatteryManager = class BatteryManager extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.charging]() {
      return this.charging;
    }
    get [dartx.chargingTime]() {
      return this.chargingTime;
    }
    get [dartx.dischargingTime]() {
      return this.dischargingTime;
    }
    get [dartx.level]() {
      return this.level;
    }
  };
  dart.setSignature(html$.BatteryManager, {
    constructors: () => ({_: [html$.BatteryManager, []]})
  });
  html$.BatteryManager[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('BatteryManager')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("BatteryManager"))];
  dart.registerExtension(dart.global.BatteryManager, html$.BatteryManager);
  dart.defineExtensionNames([
    'platforms',
    'prompt',
    'userChoice'
  ]);
  html$.BeforeInstallPromptEvent = class BeforeInstallPromptEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.BeforeInstallPromptEvent._create_1(type, eventInitDict_1);
      }
      return html$.BeforeInstallPromptEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new BeforeInstallPromptEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new BeforeInstallPromptEvent(type);
    }
    get [dartx.platforms]() {
      return this.platforms;
    }
    get [dartx.userChoice]() {
      return this.userChoice;
    }
    [dartx.prompt]() {
      return this.prompt();
    }
  };
  dart.setSignature(html$.BeforeInstallPromptEvent, {
    constructors: () => ({
      _: [html$.BeforeInstallPromptEvent, []],
      new: [html$.BeforeInstallPromptEvent, [core.String], [core.Map]]
    }),
    methods: () => ({[dartx.prompt]: [async.Future, []]}),
    statics: () => ({
      _create_1: [html$.BeforeInstallPromptEvent, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.BeforeInstallPromptEvent, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.BeforeInstallPromptEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('BeforeInstallPromptEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("BeforeInstallPromptEvent"))];
  dart.registerExtension(dart.global.BeforeInstallPromptEvent, html$.BeforeInstallPromptEvent);
  dart.defineExtensionNames([
    'returnValue',
    'returnValue'
  ]);
  html$.BeforeUnloadEvent = class BeforeUnloadEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.returnValue]() {
      return this.returnValue;
    }
    set [dartx.returnValue](value) {
      this.returnValue = value;
    }
  };
  dart.setSignature(html$.BeforeUnloadEvent, {
    constructors: () => ({_: [html$.BeforeUnloadEvent, []]})
  });
  html$.BeforeUnloadEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('BeforeUnloadEvent')), dart.const(new _js_helper.Native("BeforeUnloadEvent"))];
  dart.registerExtension(dart.global.BeforeUnloadEvent, html$.BeforeUnloadEvent);
  dart.defineExtensionNames([
    'close',
    'slice',
    'size',
    'type'
  ]);
  html$.Blob = class Blob extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.size]() {
      return this.size;
    }
    get [dartx.type]() {
      return this.type;
    }
    [dartx.close]() {
      return this.close();
    }
    [dartx.slice](start, end, contentType) {
      return this.slice(start, end, contentType);
    }
    static new(blobParts, type, endings) {
      if (type === void 0) type = null;
      if (endings === void 0) endings = null;
      if (type == null && endings == null) {
        return dart.as(html$.Blob._create_1(blobParts), html$.Blob);
      }
      let bag = html$.Blob._create_bag();
      if (type != null) html$.Blob._bag_set(bag, 'type', type);
      if (endings != null) html$.Blob._bag_set(bag, 'endings', endings);
      return dart.as(html$.Blob._create_2(blobParts, bag), html$.Blob);
    }
    static _create_1(parts) {
      return new Blob(parts);
    }
    static _create_2(parts, bag) {
      return new Blob(parts, bag);
    }
    static _create_bag() {
      return {};
    }
    static _bag_set(bag, key, value) {
      bag[key] = value;
    }
  };
  dart.setSignature(html$.Blob, {
    constructors: () => ({
      _: [html$.Blob, []],
      new: [html$.Blob, [core.List], [core.String, core.String]]
    }),
    methods: () => ({
      [dartx.close]: [dart.void, []],
      [dartx.slice]: [html$.Blob, [], [core.int, core.int, core.String]]
    }),
    statics: () => ({
      _create_1: [dart.dynamic, [dart.dynamic]],
      _create_2: [dart.dynamic, [dart.dynamic, dart.dynamic]],
      _create_bag: [dart.dynamic, []],
      _bag_set: [dart.dynamic, [dart.dynamic, dart.dynamic, dart.dynamic]]
    }),
    names: ['_create_1', '_create_2', '_create_bag', '_bag_set']
  });
  html$.Blob[dart.metadata] = () => [dart.const(new _metadata.DomName('Blob')), dart.const(new _js_helper.Native("Blob"))];
  dart.registerExtension(dart.global.Blob, html$.Blob);
  const _requestDevice_1 = Symbol('_requestDevice_1');
  dart.defineExtensionNames([
    'requestDevice'
  ]);
  html$.Bluetooth = class Bluetooth extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.requestDevice](options) {
      let options_1 = html_common.convertDartToNative_Dictionary(options);
      return this[_requestDevice_1](options_1);
    }
    [_requestDevice_1](options) {
      return this.requestDevice(options);
    }
  };
  dart.setSignature(html$.Bluetooth, {
    constructors: () => ({_: [html$.Bluetooth, []]}),
    methods: () => ({
      [dartx.requestDevice]: [async.Future, [core.Map]],
      [_requestDevice_1]: [async.Future, [dart.dynamic]]
    })
  });
  html$.Bluetooth[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Bluetooth')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("Bluetooth"))];
  dart.registerExtension(dart.global.Bluetooth, html$.Bluetooth);
  dart.defineExtensionNames([
    'connectGatt',
    'deviceClass',
    'instanceID',
    'name',
    'paired',
    'productID',
    'productVersion',
    'vendorID',
    'vendorIDSource'
  ]);
  html$.BluetoothDevice = class BluetoothDevice extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.deviceClass]() {
      return this.deviceClass;
    }
    get [dartx.instanceID]() {
      return this.instanceID;
    }
    get [dartx.name]() {
      return this.name;
    }
    get [dartx.paired]() {
      return this.paired;
    }
    get [dartx.productID]() {
      return this.productID;
    }
    get [dartx.productVersion]() {
      return this.productVersion;
    }
    get [dartx.vendorID]() {
      return this.vendorID;
    }
    get [dartx.vendorIDSource]() {
      return this.vendorIDSource;
    }
    [dartx.connectGatt]() {
      return this.connectGATT();
    }
  };
  dart.setSignature(html$.BluetoothDevice, {
    constructors: () => ({_: [html$.BluetoothDevice, []]}),
    methods: () => ({[dartx.connectGatt]: [async.Future, []]})
  });
  html$.BluetoothDevice[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('BluetoothDevice')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("BluetoothDevice"))];
  dart.registerExtension(dart.global.BluetoothDevice, html$.BluetoothDevice);
  dart.defineExtensionNames([
    'readValue',
    'writeValue',
    'uuid'
  ]);
  html$.BluetoothGattCharacteristic = class BluetoothGattCharacteristic extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.uuid]() {
      return this.uuid;
    }
    [dartx.readValue]() {
      return this.readValue();
    }
    [dartx.writeValue](value) {
      return this.writeValue(value);
    }
  };
  dart.setSignature(html$.BluetoothGattCharacteristic, {
    constructors: () => ({_: [html$.BluetoothGattCharacteristic, []]}),
    methods: () => ({
      [dartx.readValue]: [async.Future, []],
      [dartx.writeValue]: [async.Future, [dart.dynamic]]
    })
  });
  html$.BluetoothGattCharacteristic[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('BluetoothGATTCharacteristic')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("BluetoothGATTCharacteristic"))];
  dart.registerExtension(dart.global.BluetoothGATTCharacteristic, html$.BluetoothGattCharacteristic);
  dart.defineExtensionNames([
    'getPrimaryService',
    'connected'
  ]);
  html$.BluetoothGattRemoteServer = class BluetoothGattRemoteServer extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.connected]() {
      return this.connected;
    }
    [dartx.getPrimaryService](service) {
      return this.getPrimaryService(service);
    }
  };
  dart.setSignature(html$.BluetoothGattRemoteServer, {
    constructors: () => ({_: [html$.BluetoothGattRemoteServer, []]}),
    methods: () => ({[dartx.getPrimaryService]: [async.Future, [dart.dynamic]]})
  });
  html$.BluetoothGattRemoteServer[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('BluetoothGATTRemoteServer')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("BluetoothGATTRemoteServer"))];
  dart.registerExtension(dart.global.BluetoothGATTRemoteServer, html$.BluetoothGattRemoteServer);
  dart.defineExtensionNames([
    'getCharacteristic',
    'isPrimary',
    'uuid'
  ]);
  html$.BluetoothGattService = class BluetoothGattService extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.isPrimary]() {
      return this.isPrimary;
    }
    get [dartx.uuid]() {
      return this.uuid;
    }
    [dartx.getCharacteristic](characteristic) {
      return this.getCharacteristic(characteristic);
    }
  };
  dart.setSignature(html$.BluetoothGattService, {
    constructors: () => ({_: [html$.BluetoothGattService, []]}),
    methods: () => ({[dartx.getCharacteristic]: [async.Future, [dart.dynamic]]})
  });
  html$.BluetoothGattService[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('BluetoothGATTService')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("BluetoothGATTService"))];
  dart.registerExtension(dart.global.BluetoothGATTService, html$.BluetoothGattService);
  html$.BluetoothUuid = class BluetoothUuid extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$.BluetoothUuid, {
    constructors: () => ({_: [html$.BluetoothUuid, []]}),
    statics: () => ({
      canonicalUuid: [core.String, [core.int]],
      getCharacteristic: [core.String, [core.Object]],
      getDescriptor: [core.String, [core.Object]],
      getService: [core.String, [core.Object]]
    }),
    names: ['canonicalUuid', 'getCharacteristic', 'getDescriptor', 'getService']
  });
  html$.BluetoothUuid[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('BluetoothUUID')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("BluetoothUUID"))];
  dart.registerExtension(dart.global.BluetoothUUID, html$.BluetoothUuid);
  dart.defineExtensionNames([
    'arrayBuffer',
    'blob',
    'json',
    'text',
    'bodyUsed'
  ]);
  html$.Body = class Body extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.bodyUsed]() {
      return this.bodyUsed;
    }
    [dartx.arrayBuffer]() {
      return this.arrayBuffer();
    }
    [dartx.blob]() {
      return this.blob();
    }
    [dartx.json]() {
      return this.json();
    }
    [dartx.text]() {
      return this.text();
    }
  };
  dart.setSignature(html$.Body, {
    constructors: () => ({_: [html$.Body, []]}),
    methods: () => ({
      [dartx.arrayBuffer]: [async.Future, []],
      [dartx.blob]: [async.Future, []],
      [dartx.json]: [async.Future, []],
      [dartx.text]: [async.Future, []]
    })
  });
  html$.Body[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Body')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("Body"))];
  dart.registerExtension(dart.global.Body, html$.Body);
  dart.defineExtensionNames([
    'onBlur',
    'onError',
    'onFocus',
    'onHashChange',
    'onLoad',
    'onMessage',
    'onOffline',
    'onOnline',
    'onPopState',
    'onResize',
    'onScroll',
    'onStorage',
    'onUnload'
  ]);
  html$.BodyElement = class BodyElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("body"), html$.BodyElement);
    }
    created() {
      super.created();
    }
    get [dartx.onBlur]() {
      return html$.BodyElement.blurEvent.forElement(this);
    }
    get [dartx.onError]() {
      return html$.BodyElement.errorEvent.forElement(this);
    }
    get [dartx.onFocus]() {
      return html$.BodyElement.focusEvent.forElement(this);
    }
    get [dartx.onHashChange]() {
      return html$.BodyElement.hashChangeEvent.forElement(this);
    }
    get [dartx.onLoad]() {
      return html$.BodyElement.loadEvent.forElement(this);
    }
    get [dartx.onMessage]() {
      return html$.BodyElement.messageEvent.forElement(this);
    }
    get [dartx.onOffline]() {
      return html$.BodyElement.offlineEvent.forElement(this);
    }
    get [dartx.onOnline]() {
      return html$.BodyElement.onlineEvent.forElement(this);
    }
    get [dartx.onPopState]() {
      return html$.BodyElement.popStateEvent.forElement(this);
    }
    get [dartx.onResize]() {
      return html$.BodyElement.resizeEvent.forElement(this);
    }
    get [dartx.onScroll]() {
      return html$.BodyElement.scrollEvent.forElement(this);
    }
    get [dartx.onStorage]() {
      return html$.BodyElement.storageEvent.forElement(this);
    }
    get [dartx.onUnload]() {
      return html$.BodyElement.unloadEvent.forElement(this);
    }
  };
  dart.defineNamedConstructor(html$.BodyElement, 'created');
  html$.BodyElement[dart.implements] = () => [html$.WindowEventHandlers];
  dart.setSignature(html$.BodyElement, {
    constructors: () => ({
      _: [html$.BodyElement, []],
      new: [html$.BodyElement, []],
      created: [html$.BodyElement, []]
    })
  });
  html$.BodyElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLBodyElement')), dart.const(new _js_helper.Native("HTMLBodyElement"))];
  dart.defineLazy(html$.BodyElement, {
    get blurEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('blur'));
    },
    get errorEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('error'));
    },
    get focusEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('focus'));
    },
    get hashChangeEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('hashchange'));
    },
    get loadEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('load'));
    },
    get messageEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MessageEvent))('message'));
    },
    get offlineEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('offline'));
    },
    get onlineEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('online'));
    },
    get popStateEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.PopStateEvent))('popstate'));
    },
    get resizeEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('resize'));
    },
    get scrollEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('scroll'));
    },
    get storageEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.StorageEvent))('storage'));
    },
    get unloadEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('unload'));
    }
  });
  dart.registerExtension(dart.global.HTMLBodyElement, html$.BodyElement);
  dart.defineExtensionNames([
    'checkValidity',
    'reportValidity',
    'setCustomValidity',
    'autofocus',
    'disabled',
    'form',
    'formAction',
    'formEnctype',
    'formMethod',
    'formNoValidate',
    'formTarget',
    'labels',
    'name',
    'type',
    'validationMessage',
    'validity',
    'value',
    'willValidate'
  ]);
  html$.ButtonElement = class ButtonElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("button"), html$.ButtonElement);
    }
    created() {
      this[dartx.autofocus] = null;
      this[dartx.disabled] = null;
      this[dartx.form] = null;
      this[dartx.formAction] = null;
      this[dartx.formEnctype] = null;
      this[dartx.formMethod] = null;
      this[dartx.formNoValidate] = null;
      this[dartx.formTarget] = null;
      this[dartx.labels] = null;
      this[dartx.name] = null;
      this[dartx.type] = null;
      this[dartx.validationMessage] = null;
      this[dartx.validity] = null;
      this[dartx.value] = null;
      this[dartx.willValidate] = null;
      super.created();
    }
    get [dartx.autofocus]() {
      return this.autofocus;
    }
    set [dartx.autofocus](value) {
      this.autofocus = value;
    }
    get [dartx.disabled]() {
      return this.disabled;
    }
    set [dartx.disabled](value) {
      this.disabled = value;
    }
    get [dartx.form]() {
      return this.form;
    }
    get [dartx.formAction]() {
      return this.formAction;
    }
    set [dartx.formAction](value) {
      this.formAction = value;
    }
    get [dartx.formEnctype]() {
      return this.formEnctype;
    }
    set [dartx.formEnctype](value) {
      this.formEnctype = value;
    }
    get [dartx.formMethod]() {
      return this.formMethod;
    }
    set [dartx.formMethod](value) {
      this.formMethod = value;
    }
    get [dartx.formNoValidate]() {
      return this.formNoValidate;
    }
    set [dartx.formNoValidate](value) {
      this.formNoValidate = value;
    }
    get [dartx.formTarget]() {
      return this.formTarget;
    }
    set [dartx.formTarget](value) {
      this.formTarget = value;
    }
    get [dartx.labels]() {
      return this.labels;
    }
    get [dartx.name]() {
      return this.name;
    }
    set [dartx.name](value) {
      this.name = value;
    }
    get [dartx.type]() {
      return this.type;
    }
    set [dartx.type](value) {
      this.type = value;
    }
    get [dartx.validationMessage]() {
      return this.validationMessage;
    }
    get [dartx.validity]() {
      return this.validity;
    }
    get [dartx.value]() {
      return this.value;
    }
    set [dartx.value](value) {
      this.value = value;
    }
    get [dartx.willValidate]() {
      return this.willValidate;
    }
    [dartx.checkValidity]() {
      return this.checkValidity();
    }
    [dartx.reportValidity]() {
      return this.reportValidity();
    }
    [dartx.setCustomValidity](error) {
      return this.setCustomValidity(error);
    }
  };
  dart.defineNamedConstructor(html$.ButtonElement, 'created');
  dart.setSignature(html$.ButtonElement, {
    constructors: () => ({
      _: [html$.ButtonElement, []],
      new: [html$.ButtonElement, []],
      created: [html$.ButtonElement, []]
    }),
    methods: () => ({
      [dartx.checkValidity]: [core.bool, []],
      [dartx.reportValidity]: [core.bool, []],
      [dartx.setCustomValidity]: [dart.void, [core.String]]
    })
  });
  html$.ButtonElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLButtonElement')), dart.const(new _js_helper.Native("HTMLButtonElement"))];
  dart.registerExtension(dart.global.HTMLButtonElement, html$.ButtonElement);
  const _createTextNode = Symbol('_createTextNode');
  dart.defineExtensionNames([
    'appendData',
    'deleteData',
    'insertData',
    'replaceData',
    'substringData',
    'after',
    'before',
    'data',
    'length',
    'nextElementSibling',
    'previousElementSibling'
  ]);
  html$.CharacterData = class CharacterData extends html$.Node {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.data]() {
      return this.data;
    }
    set [dartx.data](value) {
      this.data = value;
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.appendData](data) {
      return this.appendData(data);
    }
    [dartx.deleteData](offset, count) {
      return this.deleteData(offset, count);
    }
    [dartx.insertData](offset, data) {
      return this.insertData(offset, data);
    }
    [dartx.replaceData](offset, count, data) {
      return this.replaceData(offset, count, data);
    }
    [dartx.substringData](offset, count) {
      return this.substringData(offset, count);
    }
    [dartx.after](nodes) {
      return this.after(nodes);
    }
    [dartx.before](nodes) {
      return this.before(nodes);
    }
    get [dartx.nextElementSibling]() {
      return this.nextElementSibling;
    }
    get [dartx.previousElementSibling]() {
      return this.previousElementSibling;
    }
  };
  html$.CharacterData[dart.implements] = () => [html$.NonDocumentTypeChildNode, html$.ChildNode];
  dart.setSignature(html$.CharacterData, {
    constructors: () => ({_: [html$.CharacterData, []]}),
    methods: () => ({
      [dartx.appendData]: [dart.void, [core.String]],
      [dartx.deleteData]: [dart.void, [core.int, core.int]],
      [dartx.insertData]: [dart.void, [core.int, core.String]],
      [dartx.replaceData]: [dart.void, [core.int, core.int, core.String]],
      [dartx.substringData]: [core.String, [core.int, core.int]],
      [dartx.after]: [dart.void, [core.Object]],
      [dartx.before]: [dart.void, [core.Object]]
    })
  });
  html$.CharacterData[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CharacterData')), dart.const(new _js_helper.Native("CharacterData"))];
  dart.registerExtension(dart.global.CharacterData, html$.CharacterData);
  dart.defineExtensionNames([
    'getDestinationInsertionPoints',
    'splitText',
    'wholeText'
  ]);
  html$.Text = class Text extends html$.CharacterData {
    static new(data) {
      return html$.document[_createTextNode](data);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.wholeText]() {
      return this.wholeText;
    }
    [dartx.getDestinationInsertionPoints]() {
      return this.getDestinationInsertionPoints();
    }
    [dartx.splitText](offset) {
      return this.splitText(offset);
    }
  };
  dart.setSignature(html$.Text, {
    constructors: () => ({
      new: [html$.Text, [core.String]],
      _: [html$.Text, []]
    }),
    methods: () => ({
      [dartx.getDestinationInsertionPoints]: [core.List$(html$.Node), []],
      [dartx.splitText]: [html$.Text, [core.int]]
    })
  });
  html$.Text[dart.metadata] = () => [dart.const(new _metadata.DomName('Text')), dart.const(new _js_helper.Native("Text"))];
  dart.registerExtension(dart.global.Text, html$.Text);
  html$.CDataSection = class CDataSection extends html$.Text {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$.CDataSection, {
    constructors: () => ({_: [html$.CDataSection, []]})
  });
  html$.CDataSection[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CDATASection')), core.deprecated, dart.const(new _js_helper.Native("CDATASection"))];
  dart.registerExtension(dart.global.CDATASection, html$.CDataSection);
  const _match_1 = Symbol('_match_1');
  const _match_2 = Symbol('_match_2');
  dart.defineExtensionNames([
    'delete',
    'has',
    'keys',
    'match',
    'open'
  ]);
  html$.CacheStorage = class CacheStorage extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.delete](cacheName) {
      return this.delete(cacheName);
    }
    [dartx.has](cacheName) {
      return this.has(cacheName);
    }
    [dartx.keys]() {
      return this.keys();
    }
    [dartx.match](request, options) {
      if (options === void 0) options = null;
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        return this[_match_1](request, options_1);
      }
      return this[_match_2](request);
    }
    [_match_1](request, options) {
      return this.match(request, options);
    }
    [_match_2](request) {
      return this.match(request);
    }
    [dartx.open](cacheName) {
      return this.open(cacheName);
    }
  };
  dart.setSignature(html$.CacheStorage, {
    constructors: () => ({_: [html$.CacheStorage, []]}),
    methods: () => ({
      [dartx.delete]: [async.Future, [core.String]],
      [dartx.has]: [async.Future, [core.String]],
      [dartx.keys]: [async.Future, []],
      [dartx.match]: [async.Future, [dart.dynamic], [core.Map]],
      [_match_1]: [async.Future, [dart.dynamic, dart.dynamic]],
      [_match_2]: [async.Future, [dart.dynamic]],
      [dartx.open]: [async.Future, [core.String]]
    })
  });
  html$.CacheStorage[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CacheStorage')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("CacheStorage"))];
  dart.registerExtension(dart.global.CacheStorage, html$.CacheStorage);
  const _getContext_1 = Symbol('_getContext_1');
  const _getContext_2 = Symbol('_getContext_2');
  const _toDataUrl = Symbol('_toDataUrl');
  dart.defineExtensionNames([
    'getContext',
    'onWebGlContextLost',
    'onWebGlContextRestored',
    'context2D',
    'getContext3d',
    'toDataUrl',
    'height',
    'width'
  ]);
  html$.CanvasElement = class CanvasElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(opts) {
      let width = opts && 'width' in opts ? opts.width : null;
      let height = opts && 'height' in opts ? opts.height : null;
      let e = dart.as(html$.document[dartx.createElement]("canvas"), html$.CanvasElement);
      if (width != null) e[dartx.width] = width;
      if (height != null) e[dartx.height] = height;
      return e;
    }
    created() {
      this[dartx.height] = null;
      this[dartx.width] = null;
      super.created();
    }
    get [dartx.height]() {
      return this.height;
    }
    set [dartx.height](value) {
      this.height = value;
    }
    get [dartx.width]() {
      return this.width;
    }
    set [dartx.width](value) {
      this.width = value;
    }
    [dartx.getContext](contextId, attributes) {
      if (attributes === void 0) attributes = null;
      if (attributes != null) {
        let attributes_1 = html_common.convertDartToNative_Dictionary(attributes);
        return this[_getContext_1](contextId, attributes_1);
      }
      return this[_getContext_2](contextId);
    }
    [_getContext_1](contextId, attributes) {
      return this.getContext(contextId, attributes);
    }
    [_getContext_2](contextId) {
      return this.getContext(contextId);
    }
    [_toDataUrl](type, arguments_OR_quality) {
      return this.toDataURL(type, arguments_OR_quality);
    }
    get [dartx.onWebGlContextLost]() {
      return html$.CanvasElement.webGlContextLostEvent.forElement(this);
    }
    get [dartx.onWebGlContextRestored]() {
      return html$.CanvasElement.webGlContextRestoredEvent.forElement(this);
    }
    get [dartx.context2D]() {
      return this.getContext('2d');
    }
    [dartx.getContext3d](opts) {
      let alpha = opts && 'alpha' in opts ? opts.alpha : true;
      let depth = opts && 'depth' in opts ? opts.depth : true;
      let stencil = opts && 'stencil' in opts ? opts.stencil : false;
      let antialias = opts && 'antialias' in opts ? opts.antialias : true;
      let premultipliedAlpha = opts && 'premultipliedAlpha' in opts ? opts.premultipliedAlpha : true;
      let preserveDrawingBuffer = opts && 'preserveDrawingBuffer' in opts ? opts.preserveDrawingBuffer : false;
      let options = dart.map({alpha: alpha, depth: depth, stencil: stencil, antialias: antialias, premultipliedAlpha: premultipliedAlpha, preserveDrawingBuffer: preserveDrawingBuffer});
      let context = this[dartx.getContext]('webgl', options);
      if (context == null) {
        context = this[dartx.getContext]('experimental-webgl', options);
      }
      return dart.as(context, web_gl.RenderingContext);
    }
    [dartx.toDataUrl](type, quality) {
      if (type === void 0) type = 'image/png';
      if (quality === void 0) quality = null;
      return this[_toDataUrl](type, quality);
    }
  };
  dart.defineNamedConstructor(html$.CanvasElement, 'created');
  html$.CanvasElement[dart.implements] = () => [html$.CanvasImageSource];
  dart.setSignature(html$.CanvasElement, {
    constructors: () => ({
      _: [html$.CanvasElement, []],
      new: [html$.CanvasElement, [], {width: core.int, height: core.int}],
      created: [html$.CanvasElement, []]
    }),
    methods: () => ({
      [dartx.getContext]: [core.Object, [core.String], [core.Map]],
      [_getContext_1]: [core.Object, [dart.dynamic, dart.dynamic]],
      [_getContext_2]: [core.Object, [dart.dynamic]],
      [_toDataUrl]: [core.String, [core.String], [dart.dynamic]],
      [dartx.getContext3d]: [web_gl.RenderingContext, [], {alpha: dart.dynamic, depth: dart.dynamic, stencil: dart.dynamic, antialias: dart.dynamic, premultipliedAlpha: dart.dynamic, preserveDrawingBuffer: dart.dynamic}],
      [dartx.toDataUrl]: [core.String, [], [core.String, core.num]]
    })
  });
  html$.CanvasElement[dart.metadata] = () => [dart.const(new _metadata.DomName('HTMLCanvasElement')), dart.const(new _js_helper.Native("HTMLCanvasElement"))];
  dart.defineLazy(html$.CanvasElement, {
    get webGlContextLostEvent() {
      return dart.const(new (html$.EventStreamProvider$(web_gl.ContextEvent))('webglcontextlost'));
    },
    get webGlContextRestoredEvent() {
      return dart.const(new (html$.EventStreamProvider$(web_gl.ContextEvent))('webglcontextrestored'));
    }
  });
  dart.registerExtension(dart.global.HTMLCanvasElement, html$.CanvasElement);
  dart.defineExtensionNames([
    'addColorStop'
  ]);
  html$.CanvasGradient = class CanvasGradient extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.addColorStop](offset, color) {
      return this.addColorStop(offset, color);
    }
  };
  dart.setSignature(html$.CanvasGradient, {
    constructors: () => ({_: [html$.CanvasGradient, []]}),
    methods: () => ({[dartx.addColorStop]: [dart.void, [core.num, core.String]]})
  });
  html$.CanvasGradient[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CanvasGradient')), dart.const(new _js_helper.Native("CanvasGradient"))];
  dart.registerExtension(dart.global.CanvasGradient, html$.CanvasGradient);
  dart.defineExtensionNames([
    'setTransform'
  ]);
  html$.CanvasPattern = class CanvasPattern extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.setTransform](transform) {
      return this.setTransform(transform);
    }
  };
  dart.setSignature(html$.CanvasPattern, {
    constructors: () => ({_: [html$.CanvasPattern, []]}),
    methods: () => ({[dartx.setTransform]: [dart.void, [svg$.Matrix]]})
  });
  html$.CanvasPattern[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CanvasPattern')), dart.const(new _js_helper.Native("CanvasPattern"))];
  dart.registerExtension(dart.global.CanvasPattern, html$.CanvasPattern);
  html$.CanvasRenderingContext = class CanvasRenderingContext extends core.Object {};
  const _addHitRegion_1 = Symbol('_addHitRegion_1');
  const _addHitRegion_2 = Symbol('_addHitRegion_2');
  const _createImageData_1 = Symbol('_createImageData_1');
  const _createImageData_2 = Symbol('_createImageData_2');
  const _getContextAttributes_1 = Symbol('_getContextAttributes_1');
  const _getImageData_1 = Symbol('_getImageData_1');
  const _getLineDash = Symbol('_getLineDash');
  const _putImageData_1 = Symbol('_putImageData_1');
  const _putImageData_2 = Symbol('_putImageData_2');
  const _arc = Symbol('_arc');
  dart.defineExtensionNames([
    'addHitRegion',
    'beginPath',
    'clearHitRegions',
    'clearRect',
    'clip',
    'createImageData',
    'createLinearGradient',
    'createPattern',
    'createRadialGradient',
    'drawFocusIfNeeded',
    'fillRect',
    'getContextAttributes',
    'getImageData',
    'isContextLost',
    'isPointInPath',
    'isPointInStroke',
    'measureText',
    'putImageData',
    'removeHitRegion',
    'resetTransform',
    'restore',
    'rotate',
    'save',
    'scale',
    'scrollPathIntoView',
    'setTransform',
    'stroke',
    'strokeRect',
    'strokeText',
    'transform',
    'translate',
    'arcTo',
    'bezierCurveTo',
    'closePath',
    'ellipse',
    'lineTo',
    'moveTo',
    'quadraticCurveTo',
    'rect',
    'createImageDataFromImageData',
    'setFillColorRgb',
    'setFillColorHsl',
    'setStrokeColorRgb',
    'setStrokeColorHsl',
    'arc',
    'createPatternFromImage',
    'drawImageToRect',
    'drawImage',
    'drawImageScaled',
    'drawImageScaledFromSource',
    'lineDashOffset',
    'lineDashOffset',
    'getLineDash',
    'setLineDash',
    'fillText',
    'fill',
    'backingStorePixelRatio',
    'canvas',
    'currentTransform',
    'direction',
    'fillStyle',
    'filter',
    'font',
    'globalAlpha',
    'globalCompositeOperation',
    'imageSmoothingEnabled',
    'lineCap',
    'lineJoin',
    'lineWidth',
    'miterLimit',
    'shadowBlur',
    'shadowColor',
    'shadowOffsetX',
    'shadowOffsetY',
    'strokeStyle',
    'textAlign',
    'textBaseline'
  ]);
  html$.CanvasRenderingContext2D = class CanvasRenderingContext2D extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.canvas]() {
      return this.canvas;
    }
    get [dartx.currentTransform]() {
      return this.currentTransform;
    }
    set [dartx.currentTransform](value) {
      this.currentTransform = value;
    }
    get [dartx.direction]() {
      return this.direction;
    }
    set [dartx.direction](value) {
      this.direction = value;
    }
    get [dartx.fillStyle]() {
      return this.fillStyle;
    }
    set [dartx.fillStyle](value) {
      this.fillStyle = value;
    }
    get [dartx.filter]() {
      return this.filter;
    }
    set [dartx.filter](value) {
      this.filter = value;
    }
    get [dartx.font]() {
      return this.font;
    }
    set [dartx.font](value) {
      this.font = value;
    }
    get [dartx.globalAlpha]() {
      return this.globalAlpha;
    }
    set [dartx.globalAlpha](value) {
      this.globalAlpha = value;
    }
    get [dartx.globalCompositeOperation]() {
      return this.globalCompositeOperation;
    }
    set [dartx.globalCompositeOperation](value) {
      this.globalCompositeOperation = value;
    }
    get [dartx.imageSmoothingEnabled]() {
      return this.imageSmoothingEnabled;
    }
    set [dartx.imageSmoothingEnabled](value) {
      this.imageSmoothingEnabled = value;
    }
    get [dartx.lineCap]() {
      return this.lineCap;
    }
    set [dartx.lineCap](value) {
      this.lineCap = value;
    }
    get [dartx.lineJoin]() {
      return this.lineJoin;
    }
    set [dartx.lineJoin](value) {
      this.lineJoin = value;
    }
    get [dartx.lineWidth]() {
      return this.lineWidth;
    }
    set [dartx.lineWidth](value) {
      this.lineWidth = value;
    }
    get [dartx.miterLimit]() {
      return this.miterLimit;
    }
    set [dartx.miterLimit](value) {
      this.miterLimit = value;
    }
    get [dartx.shadowBlur]() {
      return this.shadowBlur;
    }
    set [dartx.shadowBlur](value) {
      this.shadowBlur = value;
    }
    get [dartx.shadowColor]() {
      return this.shadowColor;
    }
    set [dartx.shadowColor](value) {
      this.shadowColor = value;
    }
    get [dartx.shadowOffsetX]() {
      return this.shadowOffsetX;
    }
    set [dartx.shadowOffsetX](value) {
      this.shadowOffsetX = value;
    }
    get [dartx.shadowOffsetY]() {
      return this.shadowOffsetY;
    }
    set [dartx.shadowOffsetY](value) {
      this.shadowOffsetY = value;
    }
    get [dartx.strokeStyle]() {
      return this.strokeStyle;
    }
    set [dartx.strokeStyle](value) {
      this.strokeStyle = value;
    }
    get [dartx.textAlign]() {
      return this.textAlign;
    }
    set [dartx.textAlign](value) {
      this.textAlign = value;
    }
    get [dartx.textBaseline]() {
      return this.textBaseline;
    }
    set [dartx.textBaseline](value) {
      this.textBaseline = value;
    }
    [dartx.addHitRegion](options) {
      if (options === void 0) options = null;
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        this[_addHitRegion_1](options_1);
        return;
      }
      this[_addHitRegion_2]();
      return;
    }
    [_addHitRegion_1](options) {
      return this.addHitRegion(options);
    }
    [_addHitRegion_2]() {
      return this.addHitRegion();
    }
    [dartx.beginPath]() {
      return this.beginPath();
    }
    [dartx.clearHitRegions]() {
      return this.clearHitRegions();
    }
    [dartx.clearRect](x, y, width, height) {
      return this.clearRect(x, y, width, height);
    }
    [dartx.clip](path_OR_winding, winding) {
      return this.clip(path_OR_winding, winding);
    }
    [dartx.createImageData](imagedata_OR_sw, sh) {
      if (sh === void 0) sh = null;
      if (dart.is(imagedata_OR_sw, html$.ImageData) && sh == null) {
        let imagedata_1 = html_common.convertDartToNative_ImageData(imagedata_OR_sw);
        return html_common.convertNativeToDart_ImageData(this[_createImageData_1](imagedata_1));
      }
      if (sh != null && typeof imagedata_OR_sw == 'number') {
        return html_common.convertNativeToDart_ImageData(this[_createImageData_2](imagedata_OR_sw, sh));
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    [_createImageData_1](imagedata) {
      return this.createImageData(imagedata);
    }
    [_createImageData_2](sw, sh) {
      return this.createImageData(sw, sh);
    }
    [dartx.createLinearGradient](x0, y0, x1, y1) {
      return this.createLinearGradient(x0, y0, x1, y1);
    }
    [dartx.createPattern](image, repetitionType) {
      return this.createPattern(image, repetitionType);
    }
    [dartx.createRadialGradient](x0, y0, r0, x1, y1, r1) {
      return this.createRadialGradient(x0, y0, r0, x1, y1, r1);
    }
    [dartx.drawFocusIfNeeded](element_OR_path, element) {
      return this.drawFocusIfNeeded(element_OR_path, element);
    }
    [dartx.fillRect](x, y, width, height) {
      return this.fillRect(x, y, width, height);
    }
    [dartx.getContextAttributes]() {
      return html_common.convertNativeToDart_Dictionary(this[_getContextAttributes_1]());
    }
    [_getContextAttributes_1]() {
      return this.getContextAttributes();
    }
    [dartx.getImageData](sx, sy, sw, sh) {
      return html_common.convertNativeToDart_ImageData(this[_getImageData_1](sx, sy, sw, sh));
    }
    [_getImageData_1](sx, sy, sw, sh) {
      return this.getImageData(sx, sy, sw, sh);
    }
    [_getLineDash]() {
      return this.getLineDash();
    }
    [dartx.isContextLost]() {
      return this.isContextLost();
    }
    [dartx.isPointInPath](path_OR_x, x_OR_y, winding_OR_y, winding) {
      return this.isPointInPath(path_OR_x, x_OR_y, winding_OR_y, winding);
    }
    [dartx.isPointInStroke](path_OR_x, x_OR_y, y) {
      return this.isPointInStroke(path_OR_x, x_OR_y, y);
    }
    [dartx.measureText](text) {
      return this.measureText(text);
    }
    [dartx.putImageData](imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight) {
      if (dirtyX === void 0) dirtyX = null;
      if (dirtyY === void 0) dirtyY = null;
      if (dirtyWidth === void 0) dirtyWidth = null;
      if (dirtyHeight === void 0) dirtyHeight = null;
      if (dirtyX == null && dirtyY == null && dirtyWidth == null && dirtyHeight == null) {
        let imagedata_1 = html_common.convertDartToNative_ImageData(imagedata);
        this[_putImageData_1](imagedata_1, dx, dy);
        return;
      }
      if (dirtyHeight != null && dirtyWidth != null && dirtyY != null && dirtyX != null) {
        let imagedata_1 = html_common.convertDartToNative_ImageData(imagedata);
        this[_putImageData_2](imagedata_1, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight);
        return;
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    [_putImageData_1](imagedata, dx, dy) {
      return this.putImageData(imagedata, dx, dy);
    }
    [_putImageData_2](imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight) {
      return this.putImageData(imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight);
    }
    [dartx.removeHitRegion](id) {
      return this.removeHitRegion(id);
    }
    [dartx.resetTransform]() {
      return this.resetTransform();
    }
    [dartx.restore]() {
      return this.restore();
    }
    [dartx.rotate](angle) {
      return this.rotate(angle);
    }
    [dartx.save]() {
      return this.save();
    }
    [dartx.scale](x, y) {
      return this.scale(x, y);
    }
    [dartx.scrollPathIntoView](path) {
      return this.scrollPathIntoView(path);
    }
    [dartx.setTransform](a, b, c, d, e, f) {
      return this.setTransform(a, b, c, d, e, f);
    }
    [dartx.stroke](path) {
      return this.stroke(path);
    }
    [dartx.strokeRect](x, y, width, height) {
      return this.strokeRect(x, y, width, height);
    }
    [dartx.strokeText](text, x, y, maxWidth) {
      return this.strokeText(text, x, y, maxWidth);
    }
    [dartx.transform](a, b, c, d, e, f) {
      return this.transform(a, b, c, d, e, f);
    }
    [dartx.translate](x, y) {
      return this.translate(x, y);
    }
    [_arc](x, y, radius, startAngle, endAngle, anticlockwise) {
      return this.arc(x, y, radius, startAngle, endAngle, anticlockwise);
    }
    [dartx.arcTo](x1, y1, x2, y2, radius) {
      return this.arcTo(x1, y1, x2, y2, radius);
    }
    [dartx.bezierCurveTo](cp1x, cp1y, cp2x, cp2y, x, y) {
      return this.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    }
    [dartx.closePath]() {
      return this.closePath();
    }
    [dartx.ellipse](x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {
      return this.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise);
    }
    [dartx.lineTo](x, y) {
      return this.lineTo(x, y);
    }
    [dartx.moveTo](x, y) {
      return this.moveTo(x, y);
    }
    [dartx.quadraticCurveTo](cpx, cpy, x, y) {
      return this.quadraticCurveTo(cpx, cpy, x, y);
    }
    [dartx.rect](x, y, width, height) {
      return this.rect(x, y, width, height);
    }
    [dartx.createImageDataFromImageData](imagedata) {
      return this.createImageData(imagedata);
    }
    [dartx.setFillColorRgb](r, g, b, a) {
      if (a === void 0) a = 1;
      this[dartx.fillStyle] = `rgba(${r}, ${g}, ${b}, ${a})`;
    }
    [dartx.setFillColorHsl](h, s, l, a) {
      if (a === void 0) a = 1;
      this[dartx.fillStyle] = `hsla(${h}, ${s}%, ${l}%, ${a})`;
    }
    [dartx.setStrokeColorRgb](r, g, b, a) {
      if (a === void 0) a = 1;
      this[dartx.strokeStyle] = `rgba(${r}, ${g}, ${b}, ${a})`;
    }
    [dartx.setStrokeColorHsl](h, s, l, a) {
      if (a === void 0) a = 1;
      this[dartx.strokeStyle] = `hsla(${h}, ${s}%, ${l}%, ${a})`;
    }
    [dartx.arc](x, y, radius, startAngle, endAngle, anticlockwise) {
      if (anticlockwise === void 0) anticlockwise = false;
      this.arc(x, y, radius, startAngle, endAngle, anticlockwise);
    }
    [dartx.createPatternFromImage](image, repetitionType) {
      return this.createPattern(image, repetitionType);
    }
    [dartx.drawImageToRect](source, destRect, opts) {
      let sourceRect = opts && 'sourceRect' in opts ? opts.sourceRect : null;
      if (sourceRect == null) {
        this[dartx.drawImageScaled](source, destRect[dartx.left], destRect[dartx.top], destRect[dartx.width], destRect[dartx.height]);
      } else {
        this[dartx.drawImageScaledFromSource](source, sourceRect[dartx.left], sourceRect[dartx.top], sourceRect[dartx.width], sourceRect[dartx.height], destRect[dartx.left], destRect[dartx.top], destRect[dartx.width], destRect[dartx.height]);
      }
    }
    [dartx.drawImage](source, destX, destY) {
      return this.drawImage(source, destX, destY);
    }
    [dartx.drawImageScaled](source, destX, destY, destWidth, destHeight) {
      return this.drawImage(source, destX, destY, destWidth, destHeight);
    }
    [dartx.drawImageScaledFromSource](source, sourceX, sourceY, sourceWidth, sourceHeight, destX, destY, destWidth, destHeight) {
      return this.drawImage(source, sourceX, sourceY, sourceWidth, sourceHeight, destX, destY, destWidth, destHeight);
    }
    get [dartx.lineDashOffset]() {
      return this.lineDashOffset || this.webkitLineDashOffset;
    }
    set [dartx.lineDashOffset](value) {
      typeof this.lineDashOffset != "undefined" ? this.lineDashOffset = value : this.webkitLineDashOffset = value;
    }
    [dartx.getLineDash]() {
      if (!!this.getLineDash) {
        return this.getLineDash();
      } else if (!!this.webkitLineDash) {
        return this.webkitLineDash;
      }
    }
    [dartx.setLineDash](dash) {
      if (!!this.setLineDash) {
        this.setLineDash(dash);
      } else if (!!this.webkitLineDash) {
        this.webkitLineDash = dash;
      }
    }
    [dartx.fillText](text, x, y, maxWidth) {
      if (maxWidth === void 0) maxWidth = null;
      if (maxWidth != null) {
        this.fillText(text, x, y, maxWidth);
      } else {
        this.fillText(text, x, y);
      }
    }
    [dartx.fill](winding) {
      if (winding === void 0) winding = 'nonzero';
      this.fill(winding);
    }
    get [dartx.backingStorePixelRatio]() {
      return 1.0;
    }
  };
  html$.CanvasRenderingContext2D[dart.implements] = () => [html$.CanvasRenderingContext];
  dart.setSignature(html$.CanvasRenderingContext2D, {
    constructors: () => ({_: [html$.CanvasRenderingContext2D, []]}),
    methods: () => ({
      [dartx.addHitRegion]: [dart.void, [], [core.Map]],
      [_addHitRegion_1]: [dart.void, [dart.dynamic]],
      [_addHitRegion_2]: [dart.void, []],
      [dartx.beginPath]: [dart.void, []],
      [dartx.clearHitRegions]: [dart.void, []],
      [dartx.clearRect]: [dart.void, [core.num, core.num, core.num, core.num]],
      [dartx.clip]: [dart.void, [], [dart.dynamic, core.String]],
      [dartx.createImageData]: [html$.ImageData, [dart.dynamic], [core.num]],
      [_createImageData_1]: [dart.dynamic, [dart.dynamic]],
      [_createImageData_2]: [dart.dynamic, [core.num, dart.dynamic]],
      [dartx.createLinearGradient]: [html$.CanvasGradient, [core.num, core.num, core.num, core.num]],
      [dartx.createPattern]: [html$.CanvasPattern, [core.Object, core.String]],
      [dartx.createRadialGradient]: [html$.CanvasGradient, [core.num, core.num, core.num, core.num, core.num, core.num]],
      [dartx.drawFocusIfNeeded]: [dart.void, [dart.dynamic], [html$.Element]],
      [dartx.fillRect]: [dart.void, [core.num, core.num, core.num, core.num]],
      [dartx.getContextAttributes]: [core.Map, []],
      [_getContextAttributes_1]: [dart.dynamic, []],
      [dartx.getImageData]: [html$.ImageData, [core.num, core.num, core.num, core.num]],
      [_getImageData_1]: [dart.dynamic, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]],
      [_getLineDash]: [core.List$(core.num), []],
      [dartx.isContextLost]: [core.bool, []],
      [dartx.isPointInPath]: [core.bool, [dart.dynamic, core.num], [dart.dynamic, core.String]],
      [dartx.isPointInStroke]: [core.bool, [dart.dynamic, core.num], [core.num]],
      [dartx.measureText]: [html$.TextMetrics, [core.String]],
      [dartx.putImageData]: [dart.void, [html$.ImageData, core.num, core.num], [core.num, core.num, core.num, core.num]],
      [_putImageData_1]: [dart.void, [dart.dynamic, dart.dynamic, dart.dynamic]],
      [_putImageData_2]: [dart.void, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]],
      [dartx.removeHitRegion]: [dart.void, [core.String]],
      [dartx.resetTransform]: [dart.void, []],
      [dartx.restore]: [dart.void, []],
      [dartx.rotate]: [dart.void, [core.num]],
      [dartx.save]: [dart.void, []],
      [dartx.scale]: [dart.void, [core.num, core.num]],
      [dartx.scrollPathIntoView]: [dart.void, [], [html$.Path2D]],
      [dartx.setTransform]: [dart.void, [core.num, core.num, core.num, core.num, core.num, core.num]],
      [dartx.stroke]: [dart.void, [], [html$.Path2D]],
      [dartx.strokeRect]: [dart.void, [core.num, core.num, core.num, core.num]],
      [dartx.strokeText]: [dart.void, [core.String, core.num, core.num], [core.num]],
      [dartx.transform]: [dart.void, [core.num, core.num, core.num, core.num, core.num, core.num]],
      [dartx.translate]: [dart.void, [core.num, core.num]],
      [_arc]: [dart.void, [core.num, core.num, core.num, core.num, core.num, core.bool]],
      [dartx.arcTo]: [dart.void, [core.num, core.num, core.num, core.num, core.num]],
      [dartx.bezierCurveTo]: [dart.void, [core.num, core.num, core.num, core.num, core.num, core.num]],
      [dartx.closePath]: [dart.void, []],
      [dartx.ellipse]: [dart.void, [core.num, core.num, core.num, core.num, core.num, core.num, core.num, core.bool]],
      [dartx.lineTo]: [dart.void, [core.num, core.num]],
      [dartx.moveTo]: [dart.void, [core.num, core.num]],
      [dartx.quadraticCurveTo]: [dart.void, [core.num, core.num, core.num, core.num]],
      [dartx.rect]: [dart.void, [core.num, core.num, core.num, core.num]],
      [dartx.createImageDataFromImageData]: [html$.ImageData, [html$.ImageData]],
      [dartx.setFillColorRgb]: [dart.void, [core.int, core.int, core.int], [core.num]],
      [dartx.setFillColorHsl]: [dart.void, [core.int, core.num, core.num], [core.num]],
      [dartx.setStrokeColorRgb]: [dart.void, [core.int, core.int, core.int], [core.num]],
      [dartx.setStrokeColorHsl]: [dart.void, [core.int, core.num, core.num], [core.num]],
      [dartx.arc]: [dart.void, [core.num, core.num, core.num, core.num, core.num], [core.bool]],
      [dartx.createPatternFromImage]: [html$.CanvasPattern, [html$.ImageElement, core.String]],
      [dartx.drawImageToRect]: [dart.void, [html$.CanvasImageSource, math.Rectangle$(core.num)], {sourceRect: math.Rectangle$(core.num)}],
      [dartx.drawImage]: [dart.void, [html$.CanvasImageSource, core.num, core.num]],
      [dartx.drawImageScaled]: [dart.void, [html$.CanvasImageSource, core.num, core.num, core.num, core.num]],
      [dartx.drawImageScaledFromSource]: [dart.void, [html$.CanvasImageSource, core.num, core.num, core.num, core.num, core.num, core.num, core.num, core.num]],
      [dartx.getLineDash]: [core.List$(core.num), []],
      [dartx.setLineDash]: [dart.void, [core.List$(core.num)]],
      [dartx.fillText]: [dart.void, [core.String, core.num, core.num], [core.num]],
      [dartx.fill]: [dart.void, [], [core.String]]
    })
  });
  html$.CanvasRenderingContext2D[dart.metadata] = () => [dart.const(new _metadata.DomName('CanvasRenderingContext2D')), dart.const(new _js_helper.Native("CanvasRenderingContext2D"))];
  dart.registerExtension(dart.global.CanvasRenderingContext2D, html$.CanvasRenderingContext2D);
  html$.ChildNode = class ChildNode extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$.ChildNode, {
    constructors: () => ({_: [html$.ChildNode, []]})
  });
  html$.ChildNode[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ChildNode')), dart.const(new _metadata.Experimental())];
  html$.ChromiumValuebuffer = class ChromiumValuebuffer extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$.ChromiumValuebuffer, {
    constructors: () => ({_: [html$.ChromiumValuebuffer, []]})
  });
  html$.ChromiumValuebuffer[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CHROMIUMValuebuffer')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("CHROMIUMValuebuffer"))];
  dart.registerExtension(dart.global.CHROMIUMValuebuffer, html$.ChromiumValuebuffer);
  dart.defineExtensionNames([
    'id'
  ]);
  html$.GeofencingRegion = class GeofencingRegion extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.id]() {
      return this.id;
    }
  };
  dart.setSignature(html$.GeofencingRegion, {
    constructors: () => ({_: [html$.GeofencingRegion, []]})
  });
  html$.GeofencingRegion[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('GeofencingRegion')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("GeofencingRegion"))];
  dart.registerExtension(dart.global.GeofencingRegion, html$.GeofencingRegion);
  dart.defineExtensionNames([
    'latitude',
    'longitude',
    'radius'
  ]);
  html$.CircularGeofencingRegion = class CircularGeofencingRegion extends html$.GeofencingRegion {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(init) {
      let init_1 = html_common.convertDartToNative_Dictionary(init);
      return html$.CircularGeofencingRegion._create_1(init_1);
    }
    static _create_1(init) {
      return new CircularGeofencingRegion(init);
    }
    get [dartx.latitude]() {
      return this.latitude;
    }
    get [dartx.longitude]() {
      return this.longitude;
    }
    get [dartx.radius]() {
      return this.radius;
    }
  };
  dart.setSignature(html$.CircularGeofencingRegion, {
    constructors: () => ({
      _: [html$.CircularGeofencingRegion, []],
      new: [html$.CircularGeofencingRegion, [core.Map]]
    }),
    statics: () => ({_create_1: [html$.CircularGeofencingRegion, [dart.dynamic]]}),
    names: ['_create_1']
  });
  html$.CircularGeofencingRegion[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CircularGeofencingRegion')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("CircularGeofencingRegion"))];
  html$.CircularGeofencingRegion.MAX_RADIUS = 100.0;
  html$.CircularGeofencingRegion.MIN_RADIUS = 1.0;
  dart.registerExtension(dart.global.CircularGeofencingRegion, html$.CircularGeofencingRegion);
  const _postMessage_1 = Symbol('_postMessage_1');
  const _postMessage_2 = Symbol('_postMessage_2');
  dart.defineExtensionNames([
    'postMessage',
    'frameType',
    'id',
    'url'
  ]);
  html$.Client = class Client extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.frameType]() {
      return this.frameType;
    }
    get [dartx.id]() {
      return this.id;
    }
    get [dartx.url]() {
      return this.url;
    }
    [dartx.postMessage](message, transfer) {
      if (transfer === void 0) transfer = null;
      if (transfer != null) {
        let message_1 = html_common.convertDartToNative_SerializedScriptValue(message);
        this[_postMessage_1](message_1, transfer);
        return;
      }
      let message_1 = html_common.convertDartToNative_SerializedScriptValue(message);
      this[_postMessage_2](message_1);
      return;
    }
    [_postMessage_1](message, transfer) {
      return this.postMessage(message, transfer);
    }
    [_postMessage_2](message) {
      return this.postMessage(message);
    }
  };
  dart.setSignature(html$.Client, {
    constructors: () => ({_: [html$.Client, []]}),
    methods: () => ({
      [dartx.postMessage]: [dart.void, [dart.dynamic], [core.List$(html$.MessagePort)]],
      [_postMessage_1]: [dart.void, [dart.dynamic, core.List$(html$.MessagePort)]],
      [_postMessage_2]: [dart.void, [dart.dynamic]]
    })
  });
  html$.Client[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Client')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("Client"))];
  dart.registerExtension(dart.global.Client, html$.Client);
  const _matchAll_1 = Symbol('_matchAll_1');
  const _matchAll_2 = Symbol('_matchAll_2');
  dart.defineExtensionNames([
    'claim',
    'matchAll',
    'openWindow'
  ]);
  html$.Clients = class Clients extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.claim]() {
      return this.claim();
    }
    [dartx.matchAll](options) {
      if (options === void 0) options = null;
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        return this[_matchAll_1](options_1);
      }
      return this[_matchAll_2]();
    }
    [_matchAll_1](options) {
      return this.matchAll(options);
    }
    [_matchAll_2]() {
      return this.matchAll();
    }
    [dartx.openWindow](url) {
      return this.openWindow(url);
    }
  };
  dart.setSignature(html$.Clients, {
    constructors: () => ({_: [html$.Clients, []]}),
    methods: () => ({
      [dartx.claim]: [async.Future, []],
      [dartx.matchAll]: [async.Future, [], [core.Map]],
      [_matchAll_1]: [async.Future, [dart.dynamic]],
      [_matchAll_2]: [async.Future, []],
      [dartx.openWindow]: [async.Future, [core.String]]
    })
  });
  html$.Clients[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Clients')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("Clients"))];
  dart.registerExtension(dart.global.Clients, html$.Clients);
  dart.defineExtensionNames([
    'clipboardData'
  ]);
  html$.ClipboardEvent = class ClipboardEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.clipboardData]() {
      return this.clipboardData;
    }
  };
  dart.setSignature(html$.ClipboardEvent, {
    constructors: () => ({_: [html$.ClipboardEvent, []]})
  });
  html$.ClipboardEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ClipboardEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("ClipboardEvent"))];
  dart.registerExtension(dart.global.ClipboardEvent, html$.ClipboardEvent);
  dart.defineExtensionNames([
    'code',
    'reason',
    'wasClean'
  ]);
  html$.CloseEvent = class CloseEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.CloseEvent._create_1(type, eventInitDict_1);
      }
      return html$.CloseEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new CloseEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new CloseEvent(type);
    }
    get [dartx.code]() {
      return this.code;
    }
    get [dartx.reason]() {
      return this.reason;
    }
    get [dartx.wasClean]() {
      return this.wasClean;
    }
  };
  dart.setSignature(html$.CloseEvent, {
    constructors: () => ({
      _: [html$.CloseEvent, []],
      new: [html$.CloseEvent, [core.String], [core.Map]]
    }),
    statics: () => ({
      _create_1: [html$.CloseEvent, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.CloseEvent, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.CloseEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CloseEvent')), dart.const(new _js_helper.Native("CloseEvent"))];
  dart.registerExtension(dart.global.CloseEvent, html$.CloseEvent);
  html$.Comment = class Comment extends html$.CharacterData {
    static new(data) {
      if (data === void 0) data = null;
      if (data != null) {
        return html$.document.createComment(data);
      }
      return html$.document.createComment("");
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$.Comment, {
    constructors: () => ({
      new: [html$.Comment, [], [core.String]],
      _: [html$.Comment, []]
    })
  });
  html$.Comment[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Comment')), dart.const(new _js_helper.Native("Comment"))];
  dart.registerExtension(dart.global.Comment, html$.Comment);
  const _initCompositionEvent = Symbol('_initCompositionEvent');
  const _initUIEvent = Symbol('_initUIEvent');
  const _charCode = Symbol('_charCode');
  const _keyCode = Symbol('_keyCode');
  const _get_view = Symbol('_get_view');
  const _which = Symbol('_which');
  dart.defineExtensionNames([
    'view',
    'detail',
    'sourceDevice'
  ]);
  html$.UIEvent = class UIEvent extends html$.Event {
    static new(type, opts) {
      let view = opts && 'view' in opts ? opts.view : null;
      let detail = opts && 'detail' in opts ? opts.detail : 0;
      let canBubble = opts && 'canBubble' in opts ? opts.canBubble : true;
      let cancelable = opts && 'cancelable' in opts ? opts.cancelable : true;
      if (view == null) {
        view = html$.window;
      }
      let e = dart.as(html$.document[_createEvent]("UIEvent"), html$.UIEvent);
      e[_initUIEvent](type, canBubble, cancelable, view, detail);
      return e;
    }
    static _(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.UIEvent._create_1(type, eventInitDict_1);
      }
      return html$.UIEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new UIEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new UIEvent(type);
    }
    get [_charCode]() {
      return this.charCode;
    }
    get [dartx.detail]() {
      return this.detail;
    }
    get [_keyCode]() {
      return this.keyCode;
    }
    get [dartx.sourceDevice]() {
      return this.sourceDevice;
    }
    get [dartx.view]() {
      return html$._convertNativeToDart_Window(this[_get_view]);
    }
    get [_get_view]() {
      return this.view;
    }
    get [_which]() {
      return this.which;
    }
    [_initUIEvent](type, bubbles, cancelable, view, detail) {
      return this.initUIEvent(type, bubbles, cancelable, view, detail);
    }
  };
  dart.setSignature(html$.UIEvent, {
    constructors: () => ({
      new: [html$.UIEvent, [core.String], {view: html$.Window, detail: core.int, canBubble: core.bool, cancelable: core.bool}],
      _: [html$.UIEvent, [core.String], [core.Map]]
    }),
    methods: () => ({[_initUIEvent]: [dart.void, [core.String, core.bool, core.bool, html$.Window, core.int]]}),
    statics: () => ({
      _create_1: [html$.UIEvent, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.UIEvent, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.UIEvent[dart.metadata] = () => [dart.const(new _metadata.DomName('UIEvent')), dart.const(new _js_helper.Native("UIEvent"))];
  dart.registerExtension(dart.global.UIEvent, html$.UIEvent);
  dart.defineExtensionNames([
    'data'
  ]);
  html$.CompositionEvent = class CompositionEvent extends html$.UIEvent {
    static new(type, opts) {
      let canBubble = opts && 'canBubble' in opts ? opts.canBubble : false;
      let cancelable = opts && 'cancelable' in opts ? opts.cancelable : false;
      let view = opts && 'view' in opts ? opts.view : null;
      let data = opts && 'data' in opts ? opts.data : null;
      let locale = opts && 'locale' in opts ? opts.locale : null;
      if (view == null) {
        view = html$.window;
      }
      let e = dart.as(html$.document[_createEvent]("CompositionEvent"), html$.CompositionEvent);
      if (dart.notNull(html_common.Device.isFirefox)) {
        e.initCompositionEvent(type, canBubble, cancelable, view, data, locale);
      } else {
        e[_initCompositionEvent](type, canBubble, cancelable, view, data);
      }
      return e;
    }
    static _(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.CompositionEvent._create_1(type, eventInitDict_1);
      }
      return html$.CompositionEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new CompositionEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new CompositionEvent(type);
    }
    get [dartx.data]() {
      return this.data;
    }
    [_initCompositionEvent](type, bubbles, cancelable, view, data) {
      return this.initCompositionEvent(type, bubbles, cancelable, view, data);
    }
  };
  dart.setSignature(html$.CompositionEvent, {
    constructors: () => ({
      new: [html$.CompositionEvent, [core.String], {canBubble: core.bool, cancelable: core.bool, view: html$.Window, data: core.String, locale: core.String}],
      _: [html$.CompositionEvent, [core.String], [core.Map]]
    }),
    methods: () => ({[_initCompositionEvent]: [dart.void, [core.String, core.bool, core.bool, html$.Window, core.String]]}),
    statics: () => ({
      _create_1: [html$.CompositionEvent, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.CompositionEvent, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.CompositionEvent[dart.metadata] = () => [dart.const(new _metadata.DomName('CompositionEvent')), dart.const(new _js_helper.Native("CompositionEvent"))];
  dart.registerExtension(dart.global.CompositionEvent, html$.CompositionEvent);
  dart.defineExtensionNames([
    'disconnect',
    'supports',
    'opacity',
    'scrollLeft',
    'scrollTop',
    'transform'
  ]);
  html$.CompositorProxy = class CompositorProxy extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(element, attributeArray) {
      return html$.CompositorProxy._create_1(element, attributeArray);
    }
    static _create_1(element, attributeArray) {
      return new CompositorProxy(element, attributeArray);
    }
    get [dartx.opacity]() {
      return this.opacity;
    }
    set [dartx.opacity](value) {
      this.opacity = value;
    }
    get [dartx.scrollLeft]() {
      return this.scrollLeft;
    }
    set [dartx.scrollLeft](value) {
      this.scrollLeft = value;
    }
    get [dartx.scrollTop]() {
      return this.scrollTop;
    }
    set [dartx.scrollTop](value) {
      this.scrollTop = value;
    }
    get [dartx.transform]() {
      return this.transform;
    }
    set [dartx.transform](value) {
      this.transform = value;
    }
    [dartx.disconnect]() {
      return this.disconnect();
    }
    [dartx.supports](attribute) {
      return this.supports(attribute);
    }
  };
  dart.setSignature(html$.CompositorProxy, {
    constructors: () => ({
      _: [html$.CompositorProxy, []],
      new: [html$.CompositorProxy, [html$.Element, core.List$(core.String)]]
    }),
    methods: () => ({
      [dartx.disconnect]: [dart.void, []],
      [dartx.supports]: [core.bool, [core.String]]
    }),
    statics: () => ({_create_1: [html$.CompositorProxy, [dart.dynamic, dart.dynamic]]}),
    names: ['_create_1']
  });
  html$.CompositorProxy[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CompositorProxy')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("CompositorProxy"))];
  dart.registerExtension(dart.global.CompositorProxy, html$.CompositorProxy);
  dart.defineExtensionNames([
    'postMessage',
    'terminate',
    'onError',
    'onMessage'
  ]);
  html$.CompositorWorker = class CompositorWorker extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(scriptUrl) {
      return html$.CompositorWorker._create_1(scriptUrl);
    }
    static _create_1(scriptUrl) {
      return new CompositorWorker(scriptUrl);
    }
    [dartx.postMessage](message, transfer) {
      if (transfer === void 0) transfer = null;
      if (transfer != null) {
        let message_1 = html_common.convertDartToNative_SerializedScriptValue(message);
        this[_postMessage_1](message_1, transfer);
        return;
      }
      let message_1 = html_common.convertDartToNative_SerializedScriptValue(message);
      this[_postMessage_2](message_1);
      return;
    }
    [_postMessage_1](message, transfer) {
      return this.postMessage(message, transfer);
    }
    [_postMessage_2](message) {
      return this.postMessage(message);
    }
    [dartx.terminate]() {
      return this.terminate();
    }
    get [dartx.onError]() {
      return html$.CompositorWorker.errorEvent.forTarget(this);
    }
    get [dartx.onMessage]() {
      return html$.CompositorWorker.messageEvent.forTarget(this);
    }
  };
  html$.CompositorWorker[dart.implements] = () => [html$.AbstractWorker];
  dart.setSignature(html$.CompositorWorker, {
    constructors: () => ({
      _: [html$.CompositorWorker, []],
      new: [html$.CompositorWorker, [core.String]]
    }),
    methods: () => ({
      [dartx.postMessage]: [dart.void, [dart.dynamic], [core.List$(html$.MessagePort)]],
      [_postMessage_1]: [dart.void, [dart.dynamic, core.List$(html$.MessagePort)]],
      [_postMessage_2]: [dart.void, [dart.dynamic]],
      [dartx.terminate]: [dart.void, []]
    }),
    statics: () => ({_create_1: [html$.CompositorWorker, [dart.dynamic]]}),
    names: ['_create_1']
  });
  html$.CompositorWorker[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CompositorWorker')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("CompositorWorker"))];
  dart.defineLazy(html$.CompositorWorker, {
    get errorEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('error'));
    },
    get messageEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MessageEvent))('message'));
    }
  });
  dart.registerExtension(dart.global.CompositorWorker, html$.CompositorWorker);
  const _fetch_1 = Symbol('_fetch_1');
  const _fetch_2 = Symbol('_fetch_2');
  const _webkitRequestFileSystem = Symbol('_webkitRequestFileSystem');
  const _webkitResolveLocalFileSystemUrl = Symbol('_webkitResolveLocalFileSystemUrl');
  const _setInterval_String = Symbol('_setInterval_String');
  const _setTimeout_String = Symbol('_setTimeout_String');
  const _clearInterval = Symbol('_clearInterval');
  const _clearTimeout = Symbol('_clearTimeout');
  const _setInterval = Symbol('_setInterval');
  const _setTimeout = Symbol('_setTimeout');
  dart.defineExtensionNames([
    'close',
    'fetch',
    'importScripts',
    'webkitRequestFileSystem',
    'requestFileSystemSync',
    'resolveLocalFileSystemSyncUrl',
    'webkitResolveLocalFileSystemUrl',
    'atob',
    'btoa',
    'onError',
    'caches',
    'console',
    'crypto',
    'indexedDB',
    'location',
    'navigator',
    'performance',
    'self'
  ]);
  html$.WorkerGlobalScope = class WorkerGlobalScope extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.caches]() {
      return this.caches;
    }
    get [dartx.console]() {
      return this.console;
    }
    get [dartx.crypto]() {
      return this.crypto;
    }
    get [dartx.indexedDB]() {
      return this.indexedDB;
    }
    get [dartx.location]() {
      return this.location;
    }
    get [dartx.navigator]() {
      return this.navigator;
    }
    get [dartx.performance]() {
      return this.performance;
    }
    get [dartx.self]() {
      return this.self;
    }
    [dartx.close]() {
      return this.close();
    }
    [dartx.fetch](input, init) {
      if (init === void 0) init = null;
      if (init != null) {
        let init_1 = html_common.convertDartToNative_Dictionary(init);
        return this[_fetch_1](input, init_1);
      }
      return this[_fetch_2](input);
    }
    [_fetch_1](input, init) {
      return this.fetch(input, init);
    }
    [_fetch_2](input) {
      return this.fetch(input);
    }
    [dartx.importScripts](urls) {
      return this.importScripts(urls);
    }
    [_webkitRequestFileSystem](type, size, successCallback, errorCallback) {
      return this.webkitRequestFileSystem(type, size, successCallback, errorCallback);
    }
    [dartx.webkitRequestFileSystem](type, size) {
      let completer = async.Completer$(html$.FileSystem).new();
      this[_webkitRequestFileSystem](type, size, dart.fn(value => {
        completer.complete(value);
      }, dart.void, [html$.FileSystem]), dart.fn(error => {
        completer.completeError(error);
      }, dart.void, [html$.FileError]));
      return completer.future;
    }
    [dartx.requestFileSystemSync](type, size) {
      return this.webkitRequestFileSystemSync(type, size);
    }
    [dartx.resolveLocalFileSystemSyncUrl](url) {
      return this.webkitResolveLocalFileSystemSyncURL(url);
    }
    [_webkitResolveLocalFileSystemUrl](url, successCallback, errorCallback) {
      return this.webkitResolveLocalFileSystemURL(url, successCallback, errorCallback);
    }
    [dartx.webkitResolveLocalFileSystemUrl](url) {
      let completer = async.Completer$(html$.Entry).new();
      this[_webkitResolveLocalFileSystemUrl](url, dart.fn(value => {
        completer.complete(value);
      }, dart.void, [html$.Entry]), dart.fn(error => {
        completer.completeError(error);
      }, dart.void, [html$.FileError]));
      return completer.future;
    }
    [dartx.atob](atob) {
      return this.atob(atob);
    }
    [dartx.btoa](btoa) {
      return this.btoa(btoa);
    }
    [_setInterval_String](handler, timeout, arguments$) {
      return this.setInterval(handler, timeout, arguments$);
    }
    [_setTimeout_String](handler, timeout, arguments$) {
      return this.setTimeout(handler, timeout, arguments$);
    }
    [_clearInterval](handle) {
      return this.clearInterval(handle);
    }
    [_clearTimeout](handle) {
      return this.clearTimeout(handle);
    }
    [_setInterval](handler, timeout) {
      return this.setInterval(handler, timeout);
    }
    [_setTimeout](handler, timeout) {
      return this.setTimeout(handler, timeout);
    }
    get [dartx.onError]() {
      return html$.WorkerGlobalScope.errorEvent.forTarget(this);
    }
  };
  html$.WorkerGlobalScope[dart.implements] = () => [html$._WindowTimers, html$.WindowBase64];
  dart.setSignature(html$.WorkerGlobalScope, {
    constructors: () => ({_: [html$.WorkerGlobalScope, []]}),
    methods: () => ({
      [dartx.close]: [dart.void, []],
      [dartx.fetch]: [async.Future, [dart.dynamic], [core.Map]],
      [_fetch_1]: [async.Future, [dart.dynamic, dart.dynamic]],
      [_fetch_2]: [async.Future, [dart.dynamic]],
      [dartx.importScripts]: [dart.void, [core.String]],
      [_webkitRequestFileSystem]: [dart.void, [core.int, core.int], [html$._FileSystemCallback, html$._ErrorCallback]],
      [dartx.webkitRequestFileSystem]: [async.Future$(html$.FileSystem), [core.int, core.int]],
      [dartx.requestFileSystemSync]: [html$._DOMFileSystemSync, [core.int, core.int]],
      [dartx.resolveLocalFileSystemSyncUrl]: [html$._EntrySync, [core.String]],
      [_webkitResolveLocalFileSystemUrl]: [dart.void, [core.String, html$._EntryCallback], [html$._ErrorCallback]],
      [dartx.webkitResolveLocalFileSystemUrl]: [async.Future$(html$.Entry), [core.String]],
      [dartx.atob]: [core.String, [core.String]],
      [dartx.btoa]: [core.String, [core.String]],
      [_setInterval_String]: [core.int, [core.String], [core.int, core.Object]],
      [_setTimeout_String]: [core.int, [core.String], [core.int, core.Object]],
      [_clearInterval]: [dart.void, [], [core.int]],
      [_clearTimeout]: [dart.void, [], [core.int]],
      [_setInterval]: [core.int, [core.Object], [core.int]],
      [_setTimeout]: [core.int, [core.Object], [core.int]]
    })
  });
  html$.WorkerGlobalScope[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('WorkerGlobalScope')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("WorkerGlobalScope"))];
  html$.WorkerGlobalScope.PERSISTENT = 1;
  html$.WorkerGlobalScope.TEMPORARY = 0;
  dart.defineLazy(html$.WorkerGlobalScope, {
    get errorEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('error'));
    }
  });
  dart.registerExtension(dart.global.WorkerGlobalScope, html$.WorkerGlobalScope);
  dart.defineExtensionNames([
    'cancelAnimationFrame',
    'postMessage',
    'requestAnimationFrame',
    'onMessage'
  ]);
  html$.CompositorWorkerGlobalScope = class CompositorWorkerGlobalScope extends html$.WorkerGlobalScope {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.cancelAnimationFrame](handle) {
      return this.cancelAnimationFrame(handle);
    }
    [dartx.postMessage](message, transfer) {
      if (transfer === void 0) transfer = null;
      if (transfer != null) {
        let message_1 = html_common.convertDartToNative_SerializedScriptValue(message);
        this[_postMessage_1](message_1, transfer);
        return;
      }
      let message_1 = html_common.convertDartToNative_SerializedScriptValue(message);
      this[_postMessage_2](message_1);
      return;
    }
    [_postMessage_1](message, transfer) {
      return this.postMessage(message, transfer);
    }
    [_postMessage_2](message) {
      return this.postMessage(message);
    }
    [dartx.requestAnimationFrame](callback) {
      return this.requestAnimationFrame(callback);
    }
    get [dartx.onMessage]() {
      return html$.CompositorWorkerGlobalScope.messageEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.CompositorWorkerGlobalScope, {
    constructors: () => ({_: [html$.CompositorWorkerGlobalScope, []]}),
    methods: () => ({
      [dartx.cancelAnimationFrame]: [dart.void, [core.int]],
      [dartx.postMessage]: [dart.void, [dart.dynamic], [core.List$(html$.MessagePort)]],
      [_postMessage_1]: [dart.void, [dart.dynamic, core.List$(html$.MessagePort)]],
      [_postMessage_2]: [dart.void, [dart.dynamic]],
      [dartx.requestAnimationFrame]: [core.int, [html$.FrameRequestCallback]]
    })
  });
  html$.CompositorWorkerGlobalScope[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CompositorWorkerGlobalScope')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("CompositorWorkerGlobalScope"))];
  dart.defineLazy(html$.CompositorWorkerGlobalScope, {
    get messageEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MessageEvent))('message'));
    }
  });
  dart.registerExtension(dart.global.CompositorWorkerGlobalScope, html$.CompositorWorkerGlobalScope);
  const _isConsoleDefined = Symbol('_isConsoleDefined');
  html$.Console = class Console extends core.Object {
    _safe() {
    }
    get [_isConsoleDefined]() {
      return typeof console != "undefined";
    }
    get memory() {
      return dart.as(dart.notNull(this[_isConsoleDefined]) ? console.memory : null, html$.MemoryInfo);
    }
    assertCondition(condition, arg) {
      return dart.notNull(this[_isConsoleDefined]) ? console.assertCondition(condition, arg) : null;
    }
    clear(arg) {
      return dart.notNull(this[_isConsoleDefined]) ? console.clear(arg) : null;
    }
    count(arg) {
      return dart.notNull(this[_isConsoleDefined]) ? console.count(arg) : null;
    }
    debug(arg) {
      return dart.notNull(this[_isConsoleDefined]) ? console.debug(arg) : null;
    }
    dir(arg) {
      return dart.notNull(this[_isConsoleDefined]) ? console.dir(arg) : null;
    }
    dirxml(arg) {
      return dart.notNull(this[_isConsoleDefined]) ? console.dirxml(arg) : null;
    }
    error(arg) {
      return dart.notNull(this[_isConsoleDefined]) ? console.error(arg) : null;
    }
    group(arg) {
      return dart.notNull(this[_isConsoleDefined]) ? console.group(arg) : null;
    }
    groupCollapsed(arg) {
      return dart.notNull(this[_isConsoleDefined]) ? console.groupCollapsed(arg) : null;
    }
    groupEnd() {
      return dart.notNull(this[_isConsoleDefined]) ? console.groupEnd() : null;
    }
    info(arg) {
      return dart.notNull(this[_isConsoleDefined]) ? console.info(arg) : null;
    }
    log(arg) {
      return dart.notNull(this[_isConsoleDefined]) ? console.log(arg) : null;
    }
    markTimeline(arg) {
      return dart.notNull(this[_isConsoleDefined]) ? console.markTimeline(arg) : null;
    }
    profile(title) {
      return dart.notNull(this[_isConsoleDefined]) ? console.profile(title) : null;
    }
    profileEnd(title) {
      return dart.notNull(this[_isConsoleDefined]) ? console.profileEnd(title) : null;
    }
    table(arg) {
      return dart.notNull(this[_isConsoleDefined]) ? console.table(arg) : null;
    }
    time(title) {
      return dart.notNull(this[_isConsoleDefined]) ? console.time(title) : null;
    }
    timeEnd(title) {
      return dart.notNull(this[_isConsoleDefined]) ? console.timeEnd(title) : null;
    }
    timeStamp(arg) {
      return dart.notNull(this[_isConsoleDefined]) ? console.timeStamp(arg) : null;
    }
    trace(arg) {
      return dart.notNull(this[_isConsoleDefined]) ? console.trace(arg) : null;
    }
    warn(arg) {
      return dart.notNull(this[_isConsoleDefined]) ? console.warn(arg) : null;
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.defineNamedConstructor(html$.Console, '_safe');
  dart.setSignature(html$.Console, {
    constructors: () => ({
      _safe: [html$.Console, []],
      _: [html$.Console, []]
    }),
    methods: () => ({
      assertCondition: [dart.void, [core.bool, core.Object]],
      clear: [dart.void, [core.Object]],
      count: [dart.void, [core.Object]],
      debug: [dart.void, [core.Object]],
      dir: [dart.void, [core.Object]],
      dirxml: [dart.void, [core.Object]],
      error: [dart.void, [core.Object]],
      group: [dart.void, [core.Object]],
      groupCollapsed: [dart.void, [core.Object]],
      groupEnd: [dart.void, []],
      info: [dart.void, [core.Object]],
      log: [dart.void, [core.Object]],
      markTimeline: [dart.void, [core.Object]],
      profile: [dart.void, [core.String]],
      profileEnd: [dart.void, [core.String]],
      table: [dart.void, [core.Object]],
      time: [dart.void, [core.String]],
      timeEnd: [dart.void, [core.String]],
      timeStamp: [dart.void, [core.Object]],
      trace: [dart.void, [core.Object]],
      warn: [dart.void, [core.Object]]
    })
  });
  html$.Console[dart.metadata] = () => [dart.const(new _metadata.DomName('Console'))];
  dart.defineLazy(html$.Console, {
    get _safeConsole() {
      return dart.const(new html$.Console._safe());
    }
  });
  dart.defineExtensionNames([
    'assertCondition',
    'timeline',
    'timelineEnd'
  ]);
  html$.ConsoleBase = class ConsoleBase extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.assertCondition](condition, arg) {
      return this.assert(condition, arg);
    }
    [dartx.timeline](title) {
      return this.timeline(title);
    }
    [dartx.timelineEnd](title) {
      return this.timelineEnd(title);
    }
  };
  dart.setSignature(html$.ConsoleBase, {
    constructors: () => ({_: [html$.ConsoleBase, []]}),
    methods: () => ({
      [dartx.assertCondition]: [dart.void, [core.bool, core.Object]],
      [dartx.timeline]: [dart.void, [core.String]],
      [dartx.timelineEnd]: [dart.void, [core.String]]
    })
  });
  html$.ConsoleBase[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ConsoleBase')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("ConsoleBase"))];
  dart.registerExtension(dart.global.ConsoleBase, html$.ConsoleBase);
  dart.defineExtensionNames([
    'getDistributedNodes',
    'select'
  ]);
  html$.ContentElement = class ContentElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("content"), html$.ContentElement);
    }
    created() {
      this[dartx.select] = null;
      super.created();
    }
    static get supported() {
      return html$.Element.isTagSupported('content');
    }
    get [dartx.select]() {
      return this.select;
    }
    set [dartx.select](value) {
      this.select = value;
    }
    [dartx.getDistributedNodes]() {
      return this.getDistributedNodes();
    }
  };
  dart.defineNamedConstructor(html$.ContentElement, 'created');
  dart.setSignature(html$.ContentElement, {
    constructors: () => ({
      _: [html$.ContentElement, []],
      new: [html$.ContentElement, []],
      created: [html$.ContentElement, []]
    }),
    methods: () => ({[dartx.getDistributedNodes]: [core.List$(html$.Node), []]})
  });
  html$.ContentElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLContentElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME, '26')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("HTMLContentElement"))];
  dart.registerExtension(dart.global.HTMLContentElement, html$.ContentElement);
  dart.defineExtensionNames([
    'accuracy',
    'altitude',
    'altitudeAccuracy',
    'heading',
    'latitude',
    'longitude',
    'speed'
  ]);
  html$.Coordinates = class Coordinates extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.accuracy]() {
      return this.accuracy;
    }
    get [dartx.altitude]() {
      return this.altitude;
    }
    get [dartx.altitudeAccuracy]() {
      return this.altitudeAccuracy;
    }
    get [dartx.heading]() {
      return this.heading;
    }
    get [dartx.latitude]() {
      return this.latitude;
    }
    get [dartx.longitude]() {
      return this.longitude;
    }
    get [dartx.speed]() {
      return this.speed;
    }
  };
  dart.setSignature(html$.Coordinates, {
    constructors: () => ({_: [html$.Coordinates, []]})
  });
  html$.Coordinates[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Coordinates')), dart.const(new _js_helper.Native("Coordinates"))];
  dart.registerExtension(dart.global.Coordinates, html$.Coordinates);
  dart.defineExtensionNames([
    'iconUrl',
    'id',
    'name',
    'type'
  ]);
  html$.Credential = class Credential extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.iconUrl]() {
      return this.iconURL;
    }
    get [dartx.id]() {
      return this.id;
    }
    get [dartx.name]() {
      return this.name;
    }
    get [dartx.type]() {
      return this.type;
    }
  };
  dart.setSignature(html$.Credential, {
    constructors: () => ({_: [html$.Credential, []]})
  });
  html$.Credential[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Credential')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("Credential"))];
  dart.registerExtension(dart.global.Credential, html$.Credential);
  const _request_1 = Symbol('_request_1');
  const _request_2 = Symbol('_request_2');
  dart.defineExtensionNames([
    'notifySignedIn',
    'request',
    'requireUserMediation'
  ]);
  html$.CredentialsContainer = class CredentialsContainer extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.notifySignedIn](credential) {
      return this.notifySignedIn(credential);
    }
    [dartx.request](options) {
      if (options === void 0) options = null;
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        return this[_request_1](options_1);
      }
      return this[_request_2]();
    }
    [_request_1](options) {
      return this.request(options);
    }
    [_request_2]() {
      return this.request();
    }
    [dartx.requireUserMediation]() {
      return this.requireUserMediation();
    }
  };
  dart.setSignature(html$.CredentialsContainer, {
    constructors: () => ({_: [html$.CredentialsContainer, []]}),
    methods: () => ({
      [dartx.notifySignedIn]: [async.Future, [html$.Credential]],
      [dartx.request]: [async.Future, [], [core.Map]],
      [_request_1]: [async.Future, [dart.dynamic]],
      [_request_2]: [async.Future, []],
      [dartx.requireUserMediation]: [async.Future, []]
    })
  });
  html$.CredentialsContainer[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CredentialsContainer')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("CredentialsContainer"))];
  dart.registerExtension(dart.global.CredentialsContainer, html$.CredentialsContainer);
  dart.defineExtensionNames([
    'acceptConnection',
    'client'
  ]);
  html$.CrossOriginConnectEvent = class CrossOriginConnectEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.client]() {
      return this.client;
    }
    [dartx.acceptConnection](shouldAccept) {
      return this.acceptConnection(shouldAccept);
    }
  };
  dart.setSignature(html$.CrossOriginConnectEvent, {
    constructors: () => ({_: [html$.CrossOriginConnectEvent, []]}),
    methods: () => ({[dartx.acceptConnection]: [dart.void, [async.Future]]})
  });
  html$.CrossOriginConnectEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CrossOriginConnectEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("CrossOriginConnectEvent"))];
  dart.registerExtension(dart.global.CrossOriginConnectEvent, html$.CrossOriginConnectEvent);
  dart.defineExtensionNames([
    'postMessage',
    'origin',
    'targetUrl'
  ]);
  html$.CrossOriginServiceWorkerClient = class CrossOriginServiceWorkerClient extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.origin]() {
      return this.origin;
    }
    get [dartx.targetUrl]() {
      return this.targetUrl;
    }
    [dartx.postMessage](message, transfer) {
      if (transfer === void 0) transfer = null;
      if (transfer != null) {
        let message_1 = html_common.convertDartToNative_SerializedScriptValue(message);
        this[_postMessage_1](message_1, transfer);
        return;
      }
      let message_1 = html_common.convertDartToNative_SerializedScriptValue(message);
      this[_postMessage_2](message_1);
      return;
    }
    [_postMessage_1](message, transfer) {
      return this.postMessage(message, transfer);
    }
    [_postMessage_2](message) {
      return this.postMessage(message);
    }
  };
  dart.setSignature(html$.CrossOriginServiceWorkerClient, {
    constructors: () => ({_: [html$.CrossOriginServiceWorkerClient, []]}),
    methods: () => ({
      [dartx.postMessage]: [dart.void, [dart.dynamic], [core.List$(html$.MessagePort)]],
      [_postMessage_1]: [dart.void, [dart.dynamic, core.List$(html$.MessagePort)]],
      [_postMessage_2]: [dart.void, [dart.dynamic]]
    })
  });
  html$.CrossOriginServiceWorkerClient[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CrossOriginServiceWorkerClient')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("CrossOriginServiceWorkerClient"))];
  dart.registerExtension(dart.global.CrossOriginServiceWorkerClient, html$.CrossOriginServiceWorkerClient);
  const _getRandomValues = Symbol('_getRandomValues');
  dart.defineExtensionNames([
    'getRandomValues',
    'subtle'
  ]);
  html$.Crypto = class Crypto extends _interceptors.Interceptor {
    [dartx.getRandomValues](array) {
      return this[_getRandomValues](array);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static get supported() {
      return !!(window.crypto && window.crypto.getRandomValues);
    }
    get [dartx.subtle]() {
      return this.subtle;
    }
    [_getRandomValues](array) {
      return this.getRandomValues(array);
    }
  };
  dart.setSignature(html$.Crypto, {
    constructors: () => ({_: [html$.Crypto, []]}),
    methods: () => ({
      [dartx.getRandomValues]: [typed_data.TypedData, [typed_data.TypedData]],
      [_getRandomValues]: [typed_data.TypedData, [typed_data.TypedData]]
    })
  });
  html$.Crypto[dart.metadata] = () => [dart.const(new _metadata.DomName('Crypto')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("Crypto"))];
  dart.registerExtension(dart.global.Crypto, html$.Crypto);
  dart.defineExtensionNames([
    'algorithm',
    'extractable',
    'type',
    'usages'
  ]);
  html$.CryptoKey = class CryptoKey extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.algorithm]() {
      return this.algorithm;
    }
    get [dartx.extractable]() {
      return this.extractable;
    }
    get [dartx.type]() {
      return this.type;
    }
    get [dartx.usages]() {
      return this.usages;
    }
  };
  dart.setSignature(html$.CryptoKey, {
    constructors: () => ({_: [html$.CryptoKey, []]})
  });
  html$.CryptoKey[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CryptoKey')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("CryptoKey"))];
  dart.registerExtension(dart.global.CryptoKey, html$.CryptoKey);
  html$.Css = class Css extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$.Css, {
    constructors: () => ({_: [html$.Css, []]}),
    statics: () => ({
      supports: [core.bool, [core.String, core.String]],
      supportsCondition: [core.bool, [core.String]]
    }),
    names: ['supports', 'supportsCondition']
  });
  html$.Css[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CSS')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("CSS"))];
  dart.registerExtension(dart.global.CSS, html$.Css);
  dart.defineExtensionNames([
    'cssText',
    'parentRule',
    'parentStyleSheet',
    'type'
  ]);
  html$.CssRule = class CssRule extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.cssText]() {
      return this.cssText;
    }
    set [dartx.cssText](value) {
      this.cssText = value;
    }
    get [dartx.parentRule]() {
      return this.parentRule;
    }
    get [dartx.parentStyleSheet]() {
      return this.parentStyleSheet;
    }
    get [dartx.type]() {
      return this.type;
    }
  };
  dart.setSignature(html$.CssRule, {
    constructors: () => ({_: [html$.CssRule, []]})
  });
  html$.CssRule[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CSSRule')), dart.const(new _js_helper.Native("CSSRule"))];
  html$.CssRule.CHARSET_RULE = 2;
  html$.CssRule.FONT_FACE_RULE = 5;
  html$.CssRule.IMPORT_RULE = 3;
  html$.CssRule.KEYFRAMES_RULE = 7;
  html$.CssRule.KEYFRAME_RULE = 8;
  html$.CssRule.MEDIA_RULE = 4;
  html$.CssRule.PAGE_RULE = 6;
  html$.CssRule.STYLE_RULE = 1;
  html$.CssRule.SUPPORTS_RULE = 12;
  html$.CssRule.VIEWPORT_RULE = 15;
  html$.CssRule.WEBKIT_KEYFRAMES_RULE = 7;
  html$.CssRule.WEBKIT_KEYFRAME_RULE = 8;
  dart.registerExtension(dart.global.CSSRule, html$.CssRule);
  dart.defineExtensionNames([
    'encoding'
  ]);
  html$.CssCharsetRule = class CssCharsetRule extends html$.CssRule {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.encoding]() {
      return this.encoding;
    }
    set [dartx.encoding](value) {
      this.encoding = value;
    }
  };
  dart.setSignature(html$.CssCharsetRule, {
    constructors: () => ({_: [html$.CssCharsetRule, []]})
  });
  html$.CssCharsetRule[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CSSCharsetRule')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("CSSCharsetRule"))];
  dart.registerExtension(dart.global.CSSCharsetRule, html$.CssCharsetRule);
  dart.defineExtensionNames([
    'style'
  ]);
  html$.CssFontFaceRule = class CssFontFaceRule extends html$.CssRule {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.style]() {
      return this.style;
    }
  };
  dart.setSignature(html$.CssFontFaceRule, {
    constructors: () => ({_: [html$.CssFontFaceRule, []]})
  });
  html$.CssFontFaceRule[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CSSFontFaceRule')), dart.const(new _js_helper.Native("CSSFontFaceRule"))];
  dart.registerExtension(dart.global.CSSFontFaceRule, html$.CssFontFaceRule);
  dart.defineExtensionNames([
    'deleteRule',
    'insertRule',
    'cssRules'
  ]);
  html$.CssGroupingRule = class CssGroupingRule extends html$.CssRule {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.cssRules]() {
      return this.cssRules;
    }
    [dartx.deleteRule](index) {
      return this.deleteRule(index);
    }
    [dartx.insertRule](rule, index) {
      return this.insertRule(rule, index);
    }
  };
  dart.setSignature(html$.CssGroupingRule, {
    constructors: () => ({_: [html$.CssGroupingRule, []]}),
    methods: () => ({
      [dartx.deleteRule]: [dart.void, [core.int]],
      [dartx.insertRule]: [core.int, [core.String, core.int]]
    })
  });
  html$.CssGroupingRule[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CSSGroupingRule')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("CSSGroupingRule"))];
  dart.registerExtension(dart.global.CSSGroupingRule, html$.CssGroupingRule);
  dart.defineExtensionNames([
    'href',
    'media',
    'styleSheet'
  ]);
  html$.CssImportRule = class CssImportRule extends html$.CssRule {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.href]() {
      return this.href;
    }
    get [dartx.media]() {
      return this.media;
    }
    get [dartx.styleSheet]() {
      return this.styleSheet;
    }
  };
  dart.setSignature(html$.CssImportRule, {
    constructors: () => ({_: [html$.CssImportRule, []]})
  });
  html$.CssImportRule[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CSSImportRule')), dart.const(new _js_helper.Native("CSSImportRule"))];
  dart.registerExtension(dart.global.CSSImportRule, html$.CssImportRule);
  dart.defineExtensionNames([
    'keyText',
    'style'
  ]);
  html$.CssKeyframeRule = class CssKeyframeRule extends html$.CssRule {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.keyText]() {
      return this.keyText;
    }
    set [dartx.keyText](value) {
      this.keyText = value;
    }
    get [dartx.style]() {
      return this.style;
    }
  };
  dart.setSignature(html$.CssKeyframeRule, {
    constructors: () => ({_: [html$.CssKeyframeRule, []]})
  });
  html$.CssKeyframeRule[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CSSKeyframeRule')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("CSSKeyframeRule,MozCSSKeyframeRule,WebKitCSSKeyframeRule"))];
  dart.registerExtension(dart.global.CSSKeyframeRule, html$.CssKeyframeRule);
  dart.defineExtensionNames([
    'appendRule',
    'deleteRule',
    'findRule',
    'cssRules',
    'name'
  ]);
  html$.CssKeyframesRule = class CssKeyframesRule extends html$.CssRule {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.cssRules]() {
      return this.cssRules;
    }
    get [dartx.name]() {
      return this.name;
    }
    set [dartx.name](value) {
      this.name = value;
    }
    [__getter__](index) {
      return this.__getter__(index);
    }
    [dartx.appendRule](rule) {
      return this.appendRule(rule);
    }
    [dartx.deleteRule](select) {
      return this.deleteRule(select);
    }
    [dartx.findRule](select) {
      return this.findRule(select);
    }
  };
  dart.setSignature(html$.CssKeyframesRule, {
    constructors: () => ({_: [html$.CssKeyframesRule, []]}),
    methods: () => ({
      [__getter__]: [html$.CssKeyframeRule, [core.int]],
      [dartx.appendRule]: [dart.void, [core.String]],
      [dartx.deleteRule]: [dart.void, [core.String]],
      [dartx.findRule]: [html$.CssKeyframeRule, [core.String]]
    })
  });
  html$.CssKeyframesRule[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CSSKeyframesRule')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("CSSKeyframesRule,MozCSSKeyframesRule,WebKitCSSKeyframesRule"))];
  dart.registerExtension(dart.global.CSSKeyframesRule, html$.CssKeyframesRule);
  dart.defineExtensionNames([
    'media'
  ]);
  html$.CssMediaRule = class CssMediaRule extends html$.CssGroupingRule {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.media]() {
      return this.media;
    }
  };
  dart.setSignature(html$.CssMediaRule, {
    constructors: () => ({_: [html$.CssMediaRule, []]})
  });
  html$.CssMediaRule[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CSSMediaRule')), dart.const(new _js_helper.Native("CSSMediaRule"))];
  dart.registerExtension(dart.global.CSSMediaRule, html$.CssMediaRule);
  dart.defineExtensionNames([
    'selectorText',
    'style'
  ]);
  html$.CssPageRule = class CssPageRule extends html$.CssRule {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.selectorText]() {
      return this.selectorText;
    }
    set [dartx.selectorText](value) {
      this.selectorText = value;
    }
    get [dartx.style]() {
      return this.style;
    }
  };
  dart.setSignature(html$.CssPageRule, {
    constructors: () => ({_: [html$.CssPageRule, []]})
  });
  html$.CssPageRule[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CSSPageRule')), dart.const(new _js_helper.Native("CSSPageRule"))];
  dart.registerExtension(dart.global.CSSPageRule, html$.CssPageRule);
  const _getPropertyValueHelper = Symbol('_getPropertyValueHelper');
  const _supportsProperty = Symbol('_supportsProperty');
  const _getPropertyValue = Symbol('_getPropertyValue');
  const _setPropertyHelper = Symbol('_setPropertyHelper');
  const _browserPropertyName = Symbol('_browserPropertyName');
  const _background = Symbol('_background');
  const _backgroundAttachment = Symbol('_backgroundAttachment');
  const _backgroundColor = Symbol('_backgroundColor');
  const _backgroundImage = Symbol('_backgroundImage');
  const _backgroundPosition = Symbol('_backgroundPosition');
  const _backgroundRepeat = Symbol('_backgroundRepeat');
  const _border = Symbol('_border');
  const _borderBottom = Symbol('_borderBottom');
  const _borderBottomColor = Symbol('_borderBottomColor');
  const _borderBottomStyle = Symbol('_borderBottomStyle');
  const _borderBottomWidth = Symbol('_borderBottomWidth');
  const _borderCollapse = Symbol('_borderCollapse');
  const _borderColor = Symbol('_borderColor');
  const _borderLeft = Symbol('_borderLeft');
  const _borderLeftColor = Symbol('_borderLeftColor');
  const _borderLeftStyle = Symbol('_borderLeftStyle');
  const _borderLeftWidth = Symbol('_borderLeftWidth');
  const _borderRight = Symbol('_borderRight');
  const _borderRightColor = Symbol('_borderRightColor');
  const _borderRightStyle = Symbol('_borderRightStyle');
  const _borderRightWidth = Symbol('_borderRightWidth');
  const _borderSpacing = Symbol('_borderSpacing');
  const _borderStyle = Symbol('_borderStyle');
  const _borderTop = Symbol('_borderTop');
  const _borderTopColor = Symbol('_borderTopColor');
  const _borderTopStyle = Symbol('_borderTopStyle');
  const _borderTopWidth = Symbol('_borderTopWidth');
  const _borderWidth = Symbol('_borderWidth');
  const _bottom = Symbol('_bottom');
  const _captionSide = Symbol('_captionSide');
  const _clear$1 = Symbol('_clear');
  const _clip = Symbol('_clip');
  const _color = Symbol('_color');
  const _content = Symbol('_content');
  const _cursor = Symbol('_cursor');
  const _direction = Symbol('_direction');
  const _display = Symbol('_display');
  const _emptyCells = Symbol('_emptyCells');
  const _font = Symbol('_font');
  const _fontFamily = Symbol('_fontFamily');
  const _fontSize = Symbol('_fontSize');
  const _fontStyle = Symbol('_fontStyle');
  const _fontVariant = Symbol('_fontVariant');
  const _fontWeight = Symbol('_fontWeight');
  const _height$ = Symbol('_height');
  const _left = Symbol('_left');
  const _letterSpacing = Symbol('_letterSpacing');
  const _lineHeight = Symbol('_lineHeight');
  const _listStyle = Symbol('_listStyle');
  const _listStyleImage = Symbol('_listStyleImage');
  const _listStylePosition = Symbol('_listStylePosition');
  const _listStyleType = Symbol('_listStyleType');
  const _margin = Symbol('_margin');
  const _marginBottom = Symbol('_marginBottom');
  const _marginLeft = Symbol('_marginLeft');
  const _marginRight = Symbol('_marginRight');
  const _marginTop = Symbol('_marginTop');
  const _maxHeight = Symbol('_maxHeight');
  const _maxWidth = Symbol('_maxWidth');
  const _minHeight = Symbol('_minHeight');
  const _minWidth = Symbol('_minWidth');
  const _outline = Symbol('_outline');
  const _outlineColor = Symbol('_outlineColor');
  const _outlineStyle = Symbol('_outlineStyle');
  const _outlineWidth = Symbol('_outlineWidth');
  const _overflow = Symbol('_overflow');
  const _padding = Symbol('_padding');
  const _paddingBottom = Symbol('_paddingBottom');
  const _paddingLeft = Symbol('_paddingLeft');
  const _paddingRight = Symbol('_paddingRight');
  const _paddingTop = Symbol('_paddingTop');
  const _pageBreakAfter = Symbol('_pageBreakAfter');
  const _pageBreakBefore = Symbol('_pageBreakBefore');
  const _pageBreakInside = Symbol('_pageBreakInside');
  const _position$0 = Symbol('_position');
  const _quotes = Symbol('_quotes');
  const _right = Symbol('_right');
  const _tableLayout = Symbol('_tableLayout');
  const _textAlign = Symbol('_textAlign');
  const _textDecoration = Symbol('_textDecoration');
  const _textIndent = Symbol('_textIndent');
  const _textTransform = Symbol('_textTransform');
  const _top = Symbol('_top');
  const _unicodeBidi = Symbol('_unicodeBidi');
  const _verticalAlign = Symbol('_verticalAlign');
  const _visibility = Symbol('_visibility');
  const _whiteSpace = Symbol('_whiteSpace');
  const _width$ = Symbol('_width');
  const _wordSpacing = Symbol('_wordSpacing');
  const _zIndex = Symbol('_zIndex');
  dart.defineExtensionNames([
    'alignContent',
    'alignContent',
    'alignItems',
    'alignItems',
    'alignSelf',
    'alignSelf',
    'animation',
    'animation',
    'animationDelay',
    'animationDelay',
    'animationDirection',
    'animationDirection',
    'animationDuration',
    'animationDuration',
    'animationFillMode',
    'animationFillMode',
    'animationIterationCount',
    'animationIterationCount',
    'animationName',
    'animationName',
    'animationPlayState',
    'animationPlayState',
    'animationTimingFunction',
    'animationTimingFunction',
    'appRegion',
    'appRegion',
    'appearance',
    'appearance',
    'aspectRatio',
    'aspectRatio',
    'backfaceVisibility',
    'backfaceVisibility',
    'background',
    'background',
    'backgroundAttachment',
    'backgroundAttachment',
    'backgroundBlendMode',
    'backgroundBlendMode',
    'backgroundClip',
    'backgroundClip',
    'backgroundColor',
    'backgroundColor',
    'backgroundComposite',
    'backgroundComposite',
    'backgroundImage',
    'backgroundImage',
    'backgroundOrigin',
    'backgroundOrigin',
    'backgroundPosition',
    'backgroundPosition',
    'backgroundPositionX',
    'backgroundPositionX',
    'backgroundPositionY',
    'backgroundPositionY',
    'backgroundRepeat',
    'backgroundRepeat',
    'backgroundRepeatX',
    'backgroundRepeatX',
    'backgroundRepeatY',
    'backgroundRepeatY',
    'backgroundSize',
    'backgroundSize',
    'border',
    'border',
    'borderAfter',
    'borderAfter',
    'borderAfterColor',
    'borderAfterColor',
    'borderAfterStyle',
    'borderAfterStyle',
    'borderAfterWidth',
    'borderAfterWidth',
    'borderBefore',
    'borderBefore',
    'borderBeforeColor',
    'borderBeforeColor',
    'borderBeforeStyle',
    'borderBeforeStyle',
    'borderBeforeWidth',
    'borderBeforeWidth',
    'borderBottom',
    'borderBottom',
    'borderBottomColor',
    'borderBottomColor',
    'borderBottomLeftRadius',
    'borderBottomLeftRadius',
    'borderBottomRightRadius',
    'borderBottomRightRadius',
    'borderBottomStyle',
    'borderBottomStyle',
    'borderBottomWidth',
    'borderBottomWidth',
    'borderCollapse',
    'borderCollapse',
    'borderColor',
    'borderColor',
    'borderEnd',
    'borderEnd',
    'borderEndColor',
    'borderEndColor',
    'borderEndStyle',
    'borderEndStyle',
    'borderEndWidth',
    'borderEndWidth',
    'borderFit',
    'borderFit',
    'borderHorizontalSpacing',
    'borderHorizontalSpacing',
    'borderImage',
    'borderImage',
    'borderImageOutset',
    'borderImageOutset',
    'borderImageRepeat',
    'borderImageRepeat',
    'borderImageSlice',
    'borderImageSlice',
    'borderImageSource',
    'borderImageSource',
    'borderImageWidth',
    'borderImageWidth',
    'borderLeft',
    'borderLeft',
    'borderLeftColor',
    'borderLeftColor',
    'borderLeftStyle',
    'borderLeftStyle',
    'borderLeftWidth',
    'borderLeftWidth',
    'borderRadius',
    'borderRadius',
    'borderRight',
    'borderRight',
    'borderRightColor',
    'borderRightColor',
    'borderRightStyle',
    'borderRightStyle',
    'borderRightWidth',
    'borderRightWidth',
    'borderSpacing',
    'borderSpacing',
    'borderStart',
    'borderStart',
    'borderStartColor',
    'borderStartColor',
    'borderStartStyle',
    'borderStartStyle',
    'borderStartWidth',
    'borderStartWidth',
    'borderStyle',
    'borderStyle',
    'borderTop',
    'borderTop',
    'borderTopColor',
    'borderTopColor',
    'borderTopLeftRadius',
    'borderTopLeftRadius',
    'borderTopRightRadius',
    'borderTopRightRadius',
    'borderTopStyle',
    'borderTopStyle',
    'borderTopWidth',
    'borderTopWidth',
    'borderVerticalSpacing',
    'borderVerticalSpacing',
    'borderWidth',
    'borderWidth',
    'bottom',
    'bottom',
    'boxAlign',
    'boxAlign',
    'boxDecorationBreak',
    'boxDecorationBreak',
    'boxDirection',
    'boxDirection',
    'boxFlex',
    'boxFlex',
    'boxFlexGroup',
    'boxFlexGroup',
    'boxLines',
    'boxLines',
    'boxOrdinalGroup',
    'boxOrdinalGroup',
    'boxOrient',
    'boxOrient',
    'boxPack',
    'boxPack',
    'boxReflect',
    'boxReflect',
    'boxShadow',
    'boxShadow',
    'boxSizing',
    'boxSizing',
    'captionSide',
    'captionSide',
    'clear',
    'clear',
    'clip',
    'clip',
    'clipPath',
    'clipPath',
    'color',
    'color',
    'columnBreakAfter',
    'columnBreakAfter',
    'columnBreakBefore',
    'columnBreakBefore',
    'columnBreakInside',
    'columnBreakInside',
    'columnCount',
    'columnCount',
    'columnFill',
    'columnFill',
    'columnGap',
    'columnGap',
    'columnRule',
    'columnRule',
    'columnRuleColor',
    'columnRuleColor',
    'columnRuleStyle',
    'columnRuleStyle',
    'columnRuleWidth',
    'columnRuleWidth',
    'columnSpan',
    'columnSpan',
    'columnWidth',
    'columnWidth',
    'columns',
    'columns',
    'content',
    'content',
    'counterIncrement',
    'counterIncrement',
    'counterReset',
    'counterReset',
    'cursor',
    'cursor',
    'direction',
    'direction',
    'display',
    'display',
    'emptyCells',
    'emptyCells',
    'filter',
    'filter',
    'flex',
    'flex',
    'flexBasis',
    'flexBasis',
    'flexDirection',
    'flexDirection',
    'flexFlow',
    'flexFlow',
    'flexGrow',
    'flexGrow',
    'flexShrink',
    'flexShrink',
    'flexWrap',
    'flexWrap',
    'float',
    'float',
    'font',
    'font',
    'fontFamily',
    'fontFamily',
    'fontFeatureSettings',
    'fontFeatureSettings',
    'fontKerning',
    'fontKerning',
    'fontSize',
    'fontSize',
    'fontSizeDelta',
    'fontSizeDelta',
    'fontSmoothing',
    'fontSmoothing',
    'fontStretch',
    'fontStretch',
    'fontStyle',
    'fontStyle',
    'fontVariant',
    'fontVariant',
    'fontVariantLigatures',
    'fontVariantLigatures',
    'fontWeight',
    'fontWeight',
    'grid',
    'grid',
    'gridArea',
    'gridArea',
    'gridAutoColumns',
    'gridAutoColumns',
    'gridAutoFlow',
    'gridAutoFlow',
    'gridAutoRows',
    'gridAutoRows',
    'gridColumn',
    'gridColumn',
    'gridColumnEnd',
    'gridColumnEnd',
    'gridColumnStart',
    'gridColumnStart',
    'gridRow',
    'gridRow',
    'gridRowEnd',
    'gridRowEnd',
    'gridRowStart',
    'gridRowStart',
    'gridTemplate',
    'gridTemplate',
    'gridTemplateAreas',
    'gridTemplateAreas',
    'gridTemplateColumns',
    'gridTemplateColumns',
    'gridTemplateRows',
    'gridTemplateRows',
    'height',
    'height',
    'highlight',
    'highlight',
    'hyphenateCharacter',
    'hyphenateCharacter',
    'imageRendering',
    'imageRendering',
    'isolation',
    'isolation',
    'justifyContent',
    'justifyContent',
    'justifySelf',
    'justifySelf',
    'left',
    'left',
    'letterSpacing',
    'letterSpacing',
    'lineBoxContain',
    'lineBoxContain',
    'lineBreak',
    'lineBreak',
    'lineClamp',
    'lineClamp',
    'lineHeight',
    'lineHeight',
    'listStyle',
    'listStyle',
    'listStyleImage',
    'listStyleImage',
    'listStylePosition',
    'listStylePosition',
    'listStyleType',
    'listStyleType',
    'locale',
    'locale',
    'logicalHeight',
    'logicalHeight',
    'logicalWidth',
    'logicalWidth',
    'margin',
    'margin',
    'marginAfter',
    'marginAfter',
    'marginAfterCollapse',
    'marginAfterCollapse',
    'marginBefore',
    'marginBefore',
    'marginBeforeCollapse',
    'marginBeforeCollapse',
    'marginBottom',
    'marginBottom',
    'marginBottomCollapse',
    'marginBottomCollapse',
    'marginCollapse',
    'marginCollapse',
    'marginEnd',
    'marginEnd',
    'marginLeft',
    'marginLeft',
    'marginRight',
    'marginRight',
    'marginStart',
    'marginStart',
    'marginTop',
    'marginTop',
    'marginTopCollapse',
    'marginTopCollapse',
    'mask',
    'mask',
    'maskBoxImage',
    'maskBoxImage',
    'maskBoxImageOutset',
    'maskBoxImageOutset',
    'maskBoxImageRepeat',
    'maskBoxImageRepeat',
    'maskBoxImageSlice',
    'maskBoxImageSlice',
    'maskBoxImageSource',
    'maskBoxImageSource',
    'maskBoxImageWidth',
    'maskBoxImageWidth',
    'maskClip',
    'maskClip',
    'maskComposite',
    'maskComposite',
    'maskImage',
    'maskImage',
    'maskOrigin',
    'maskOrigin',
    'maskPosition',
    'maskPosition',
    'maskPositionX',
    'maskPositionX',
    'maskPositionY',
    'maskPositionY',
    'maskRepeat',
    'maskRepeat',
    'maskRepeatX',
    'maskRepeatX',
    'maskRepeatY',
    'maskRepeatY',
    'maskSize',
    'maskSize',
    'maskSourceType',
    'maskSourceType',
    'maxHeight',
    'maxHeight',
    'maxLogicalHeight',
    'maxLogicalHeight',
    'maxLogicalWidth',
    'maxLogicalWidth',
    'maxWidth',
    'maxWidth',
    'maxZoom',
    'maxZoom',
    'minHeight',
    'minHeight',
    'minLogicalHeight',
    'minLogicalHeight',
    'minLogicalWidth',
    'minLogicalWidth',
    'minWidth',
    'minWidth',
    'minZoom',
    'minZoom',
    'mixBlendMode',
    'mixBlendMode',
    'objectFit',
    'objectFit',
    'objectPosition',
    'objectPosition',
    'opacity',
    'opacity',
    'order',
    'order',
    'orientation',
    'orientation',
    'orphans',
    'orphans',
    'outline',
    'outline',
    'outlineColor',
    'outlineColor',
    'outlineOffset',
    'outlineOffset',
    'outlineStyle',
    'outlineStyle',
    'outlineWidth',
    'outlineWidth',
    'overflow',
    'overflow',
    'overflowWrap',
    'overflowWrap',
    'overflowX',
    'overflowX',
    'overflowY',
    'overflowY',
    'padding',
    'padding',
    'paddingAfter',
    'paddingAfter',
    'paddingBefore',
    'paddingBefore',
    'paddingBottom',
    'paddingBottom',
    'paddingEnd',
    'paddingEnd',
    'paddingLeft',
    'paddingLeft',
    'paddingRight',
    'paddingRight',
    'paddingStart',
    'paddingStart',
    'paddingTop',
    'paddingTop',
    'page',
    'page',
    'pageBreakAfter',
    'pageBreakAfter',
    'pageBreakBefore',
    'pageBreakBefore',
    'pageBreakInside',
    'pageBreakInside',
    'perspective',
    'perspective',
    'perspectiveOrigin',
    'perspectiveOrigin',
    'perspectiveOriginX',
    'perspectiveOriginX',
    'perspectiveOriginY',
    'perspectiveOriginY',
    'pointerEvents',
    'pointerEvents',
    'position',
    'position',
    'printColorAdjust',
    'printColorAdjust',
    'quotes',
    'quotes',
    'resize',
    'resize',
    'right',
    'right',
    'rtlOrdering',
    'rtlOrdering',
    'rubyPosition',
    'rubyPosition',
    'scrollBehavior',
    'scrollBehavior',
    'shapeImageThreshold',
    'shapeImageThreshold',
    'shapeMargin',
    'shapeMargin',
    'shapeOutside',
    'shapeOutside',
    'size',
    'size',
    'speak',
    'speak',
    'src',
    'src',
    'tabSize',
    'tabSize',
    'tableLayout',
    'tableLayout',
    'tapHighlightColor',
    'tapHighlightColor',
    'textAlign',
    'textAlign',
    'textAlignLast',
    'textAlignLast',
    'textCombine',
    'textCombine',
    'textDecoration',
    'textDecoration',
    'textDecorationColor',
    'textDecorationColor',
    'textDecorationLine',
    'textDecorationLine',
    'textDecorationStyle',
    'textDecorationStyle',
    'textDecorationsInEffect',
    'textDecorationsInEffect',
    'textEmphasis',
    'textEmphasis',
    'textEmphasisColor',
    'textEmphasisColor',
    'textEmphasisPosition',
    'textEmphasisPosition',
    'textEmphasisStyle',
    'textEmphasisStyle',
    'textFillColor',
    'textFillColor',
    'textIndent',
    'textIndent',
    'textJustify',
    'textJustify',
    'textLineThroughColor',
    'textLineThroughColor',
    'textLineThroughMode',
    'textLineThroughMode',
    'textLineThroughStyle',
    'textLineThroughStyle',
    'textLineThroughWidth',
    'textLineThroughWidth',
    'textOrientation',
    'textOrientation',
    'textOverflow',
    'textOverflow',
    'textOverlineColor',
    'textOverlineColor',
    'textOverlineMode',
    'textOverlineMode',
    'textOverlineStyle',
    'textOverlineStyle',
    'textOverlineWidth',
    'textOverlineWidth',
    'textRendering',
    'textRendering',
    'textSecurity',
    'textSecurity',
    'textShadow',
    'textShadow',
    'textStroke',
    'textStroke',
    'textStrokeColor',
    'textStrokeColor',
    'textStrokeWidth',
    'textStrokeWidth',
    'textTransform',
    'textTransform',
    'textUnderlineColor',
    'textUnderlineColor',
    'textUnderlineMode',
    'textUnderlineMode',
    'textUnderlinePosition',
    'textUnderlinePosition',
    'textUnderlineStyle',
    'textUnderlineStyle',
    'textUnderlineWidth',
    'textUnderlineWidth',
    'top',
    'top',
    'touchAction',
    'touchAction',
    'touchActionDelay',
    'touchActionDelay',
    'transform',
    'transform',
    'transformOrigin',
    'transformOrigin',
    'transformOriginX',
    'transformOriginX',
    'transformOriginY',
    'transformOriginY',
    'transformOriginZ',
    'transformOriginZ',
    'transformStyle',
    'transformStyle',
    'transition',
    'transition',
    'transitionDelay',
    'transitionDelay',
    'transitionDuration',
    'transitionDuration',
    'transitionProperty',
    'transitionProperty',
    'transitionTimingFunction',
    'transitionTimingFunction',
    'unicodeBidi',
    'unicodeBidi',
    'unicodeRange',
    'unicodeRange',
    'userDrag',
    'userDrag',
    'userModify',
    'userModify',
    'userSelect',
    'userSelect',
    'userZoom',
    'userZoom',
    'verticalAlign',
    'verticalAlign',
    'visibility',
    'visibility',
    'whiteSpace',
    'whiteSpace',
    'widows',
    'widows',
    'width',
    'width',
    'willChange',
    'willChange',
    'wordBreak',
    'wordBreak',
    'wordSpacing',
    'wordSpacing',
    'wordWrap',
    'wordWrap',
    'wrapFlow',
    'wrapFlow',
    'wrapThrough',
    'wrapThrough',
    'writingMode',
    'writingMode',
    'zIndex',
    'zIndex',
    'zoom',
    'zoom'
  ]);
  html$.CssStyleDeclarationBase = class CssStyleDeclarationBase extends core.Object {
    get alignContent() {
      return this[dartx.getPropertyValue]('align-content');
    }
    set alignContent(value) {
      this[dartx.setProperty]('align-content', value, '');
    }
    get alignItems() {
      return this[dartx.getPropertyValue]('align-items');
    }
    set alignItems(value) {
      this[dartx.setProperty]('align-items', value, '');
    }
    get alignSelf() {
      return this[dartx.getPropertyValue]('align-self');
    }
    set alignSelf(value) {
      this[dartx.setProperty]('align-self', value, '');
    }
    get animation() {
      return this[dartx.getPropertyValue]('animation');
    }
    set animation(value) {
      this[dartx.setProperty]('animation', value, '');
    }
    get animationDelay() {
      return this[dartx.getPropertyValue]('animation-delay');
    }
    set animationDelay(value) {
      this[dartx.setProperty]('animation-delay', value, '');
    }
    get animationDirection() {
      return this[dartx.getPropertyValue]('animation-direction');
    }
    set animationDirection(value) {
      this[dartx.setProperty]('animation-direction', value, '');
    }
    get animationDuration() {
      return this[dartx.getPropertyValue]('animation-duration');
    }
    set animationDuration(value) {
      this[dartx.setProperty]('animation-duration', value, '');
    }
    get animationFillMode() {
      return this[dartx.getPropertyValue]('animation-fill-mode');
    }
    set animationFillMode(value) {
      this[dartx.setProperty]('animation-fill-mode', value, '');
    }
    get animationIterationCount() {
      return this[dartx.getPropertyValue]('animation-iteration-count');
    }
    set animationIterationCount(value) {
      this[dartx.setProperty]('animation-iteration-count', value, '');
    }
    get animationName() {
      return this[dartx.getPropertyValue]('animation-name');
    }
    set animationName(value) {
      this[dartx.setProperty]('animation-name', value, '');
    }
    get animationPlayState() {
      return this[dartx.getPropertyValue]('animation-play-state');
    }
    set animationPlayState(value) {
      this[dartx.setProperty]('animation-play-state', value, '');
    }
    get animationTimingFunction() {
      return this[dartx.getPropertyValue]('animation-timing-function');
    }
    set animationTimingFunction(value) {
      this[dartx.setProperty]('animation-timing-function', value, '');
    }
    get appRegion() {
      return this[dartx.getPropertyValue]('app-region');
    }
    set appRegion(value) {
      this[dartx.setProperty]('app-region', value, '');
    }
    get appearance() {
      return this[dartx.getPropertyValue]('appearance');
    }
    set appearance(value) {
      this[dartx.setProperty]('appearance', value, '');
    }
    get aspectRatio() {
      return this[dartx.getPropertyValue]('aspect-ratio');
    }
    set aspectRatio(value) {
      this[dartx.setProperty]('aspect-ratio', value, '');
    }
    get backfaceVisibility() {
      return this[dartx.getPropertyValue]('backface-visibility');
    }
    set backfaceVisibility(value) {
      this[dartx.setProperty]('backface-visibility', value, '');
    }
    get background() {
      return this[dartx.getPropertyValue]('background');
    }
    set background(value) {
      this[dartx.setProperty]('background', value, '');
    }
    get backgroundAttachment() {
      return this[dartx.getPropertyValue]('background-attachment');
    }
    set backgroundAttachment(value) {
      this[dartx.setProperty]('background-attachment', value, '');
    }
    get backgroundBlendMode() {
      return this[dartx.getPropertyValue]('background-blend-mode');
    }
    set backgroundBlendMode(value) {
      this[dartx.setProperty]('background-blend-mode', value, '');
    }
    get backgroundClip() {
      return this[dartx.getPropertyValue]('background-clip');
    }
    set backgroundClip(value) {
      this[dartx.setProperty]('background-clip', value, '');
    }
    get backgroundColor() {
      return this[dartx.getPropertyValue]('background-color');
    }
    set backgroundColor(value) {
      this[dartx.setProperty]('background-color', value, '');
    }
    get backgroundComposite() {
      return this[dartx.getPropertyValue]('background-composite');
    }
    set backgroundComposite(value) {
      this[dartx.setProperty]('background-composite', value, '');
    }
    get backgroundImage() {
      return this[dartx.getPropertyValue]('background-image');
    }
    set backgroundImage(value) {
      this[dartx.setProperty]('background-image', value, '');
    }
    get backgroundOrigin() {
      return this[dartx.getPropertyValue]('background-origin');
    }
    set backgroundOrigin(value) {
      this[dartx.setProperty]('background-origin', value, '');
    }
    get backgroundPosition() {
      return this[dartx.getPropertyValue]('background-position');
    }
    set backgroundPosition(value) {
      this[dartx.setProperty]('background-position', value, '');
    }
    get backgroundPositionX() {
      return this[dartx.getPropertyValue]('background-position-x');
    }
    set backgroundPositionX(value) {
      this[dartx.setProperty]('background-position-x', value, '');
    }
    get backgroundPositionY() {
      return this[dartx.getPropertyValue]('background-position-y');
    }
    set backgroundPositionY(value) {
      this[dartx.setProperty]('background-position-y', value, '');
    }
    get backgroundRepeat() {
      return this[dartx.getPropertyValue]('background-repeat');
    }
    set backgroundRepeat(value) {
      this[dartx.setProperty]('background-repeat', value, '');
    }
    get backgroundRepeatX() {
      return this[dartx.getPropertyValue]('background-repeat-x');
    }
    set backgroundRepeatX(value) {
      this[dartx.setProperty]('background-repeat-x', value, '');
    }
    get backgroundRepeatY() {
      return this[dartx.getPropertyValue]('background-repeat-y');
    }
    set backgroundRepeatY(value) {
      this[dartx.setProperty]('background-repeat-y', value, '');
    }
    get backgroundSize() {
      return this[dartx.getPropertyValue]('background-size');
    }
    set backgroundSize(value) {
      this[dartx.setProperty]('background-size', value, '');
    }
    get border() {
      return this[dartx.getPropertyValue]('border');
    }
    set border(value) {
      this[dartx.setProperty]('border', value, '');
    }
    get borderAfter() {
      return this[dartx.getPropertyValue]('border-after');
    }
    set borderAfter(value) {
      this[dartx.setProperty]('border-after', value, '');
    }
    get borderAfterColor() {
      return this[dartx.getPropertyValue]('border-after-color');
    }
    set borderAfterColor(value) {
      this[dartx.setProperty]('border-after-color', value, '');
    }
    get borderAfterStyle() {
      return this[dartx.getPropertyValue]('border-after-style');
    }
    set borderAfterStyle(value) {
      this[dartx.setProperty]('border-after-style', value, '');
    }
    get borderAfterWidth() {
      return this[dartx.getPropertyValue]('border-after-width');
    }
    set borderAfterWidth(value) {
      this[dartx.setProperty]('border-after-width', value, '');
    }
    get borderBefore() {
      return this[dartx.getPropertyValue]('border-before');
    }
    set borderBefore(value) {
      this[dartx.setProperty]('border-before', value, '');
    }
    get borderBeforeColor() {
      return this[dartx.getPropertyValue]('border-before-color');
    }
    set borderBeforeColor(value) {
      this[dartx.setProperty]('border-before-color', value, '');
    }
    get borderBeforeStyle() {
      return this[dartx.getPropertyValue]('border-before-style');
    }
    set borderBeforeStyle(value) {
      this[dartx.setProperty]('border-before-style', value, '');
    }
    get borderBeforeWidth() {
      return this[dartx.getPropertyValue]('border-before-width');
    }
    set borderBeforeWidth(value) {
      this[dartx.setProperty]('border-before-width', value, '');
    }
    get borderBottom() {
      return this[dartx.getPropertyValue]('border-bottom');
    }
    set borderBottom(value) {
      this[dartx.setProperty]('border-bottom', value, '');
    }
    get borderBottomColor() {
      return this[dartx.getPropertyValue]('border-bottom-color');
    }
    set borderBottomColor(value) {
      this[dartx.setProperty]('border-bottom-color', value, '');
    }
    get borderBottomLeftRadius() {
      return this[dartx.getPropertyValue]('border-bottom-left-radius');
    }
    set borderBottomLeftRadius(value) {
      this[dartx.setProperty]('border-bottom-left-radius', value, '');
    }
    get borderBottomRightRadius() {
      return this[dartx.getPropertyValue]('border-bottom-right-radius');
    }
    set borderBottomRightRadius(value) {
      this[dartx.setProperty]('border-bottom-right-radius', value, '');
    }
    get borderBottomStyle() {
      return this[dartx.getPropertyValue]('border-bottom-style');
    }
    set borderBottomStyle(value) {
      this[dartx.setProperty]('border-bottom-style', value, '');
    }
    get borderBottomWidth() {
      return this[dartx.getPropertyValue]('border-bottom-width');
    }
    set borderBottomWidth(value) {
      this[dartx.setProperty]('border-bottom-width', value, '');
    }
    get borderCollapse() {
      return this[dartx.getPropertyValue]('border-collapse');
    }
    set borderCollapse(value) {
      this[dartx.setProperty]('border-collapse', value, '');
    }
    get borderColor() {
      return this[dartx.getPropertyValue]('border-color');
    }
    set borderColor(value) {
      this[dartx.setProperty]('border-color', value, '');
    }
    get borderEnd() {
      return this[dartx.getPropertyValue]('border-end');
    }
    set borderEnd(value) {
      this[dartx.setProperty]('border-end', value, '');
    }
    get borderEndColor() {
      return this[dartx.getPropertyValue]('border-end-color');
    }
    set borderEndColor(value) {
      this[dartx.setProperty]('border-end-color', value, '');
    }
    get borderEndStyle() {
      return this[dartx.getPropertyValue]('border-end-style');
    }
    set borderEndStyle(value) {
      this[dartx.setProperty]('border-end-style', value, '');
    }
    get borderEndWidth() {
      return this[dartx.getPropertyValue]('border-end-width');
    }
    set borderEndWidth(value) {
      this[dartx.setProperty]('border-end-width', value, '');
    }
    get borderFit() {
      return this[dartx.getPropertyValue]('border-fit');
    }
    set borderFit(value) {
      this[dartx.setProperty]('border-fit', value, '');
    }
    get borderHorizontalSpacing() {
      return this[dartx.getPropertyValue]('border-horizontal-spacing');
    }
    set borderHorizontalSpacing(value) {
      this[dartx.setProperty]('border-horizontal-spacing', value, '');
    }
    get borderImage() {
      return this[dartx.getPropertyValue]('border-image');
    }
    set borderImage(value) {
      this[dartx.setProperty]('border-image', value, '');
    }
    get borderImageOutset() {
      return this[dartx.getPropertyValue]('border-image-outset');
    }
    set borderImageOutset(value) {
      this[dartx.setProperty]('border-image-outset', value, '');
    }
    get borderImageRepeat() {
      return this[dartx.getPropertyValue]('border-image-repeat');
    }
    set borderImageRepeat(value) {
      this[dartx.setProperty]('border-image-repeat', value, '');
    }
    get borderImageSlice() {
      return this[dartx.getPropertyValue]('border-image-slice');
    }
    set borderImageSlice(value) {
      this[dartx.setProperty]('border-image-slice', value, '');
    }
    get borderImageSource() {
      return this[dartx.getPropertyValue]('border-image-source');
    }
    set borderImageSource(value) {
      this[dartx.setProperty]('border-image-source', value, '');
    }
    get borderImageWidth() {
      return this[dartx.getPropertyValue]('border-image-width');
    }
    set borderImageWidth(value) {
      this[dartx.setProperty]('border-image-width', value, '');
    }
    get borderLeft() {
      return this[dartx.getPropertyValue]('border-left');
    }
    set borderLeft(value) {
      this[dartx.setProperty]('border-left', value, '');
    }
    get borderLeftColor() {
      return this[dartx.getPropertyValue]('border-left-color');
    }
    set borderLeftColor(value) {
      this[dartx.setProperty]('border-left-color', value, '');
    }
    get borderLeftStyle() {
      return this[dartx.getPropertyValue]('border-left-style');
    }
    set borderLeftStyle(value) {
      this[dartx.setProperty]('border-left-style', value, '');
    }
    get borderLeftWidth() {
      return this[dartx.getPropertyValue]('border-left-width');
    }
    set borderLeftWidth(value) {
      this[dartx.setProperty]('border-left-width', value, '');
    }
    get borderRadius() {
      return this[dartx.getPropertyValue]('border-radius');
    }
    set borderRadius(value) {
      this[dartx.setProperty]('border-radius', value, '');
    }
    get borderRight() {
      return this[dartx.getPropertyValue]('border-right');
    }
    set borderRight(value) {
      this[dartx.setProperty]('border-right', value, '');
    }
    get borderRightColor() {
      return this[dartx.getPropertyValue]('border-right-color');
    }
    set borderRightColor(value) {
      this[dartx.setProperty]('border-right-color', value, '');
    }
    get borderRightStyle() {
      return this[dartx.getPropertyValue]('border-right-style');
    }
    set borderRightStyle(value) {
      this[dartx.setProperty]('border-right-style', value, '');
    }
    get borderRightWidth() {
      return this[dartx.getPropertyValue]('border-right-width');
    }
    set borderRightWidth(value) {
      this[dartx.setProperty]('border-right-width', value, '');
    }
    get borderSpacing() {
      return this[dartx.getPropertyValue]('border-spacing');
    }
    set borderSpacing(value) {
      this[dartx.setProperty]('border-spacing', value, '');
    }
    get borderStart() {
      return this[dartx.getPropertyValue]('border-start');
    }
    set borderStart(value) {
      this[dartx.setProperty]('border-start', value, '');
    }
    get borderStartColor() {
      return this[dartx.getPropertyValue]('border-start-color');
    }
    set borderStartColor(value) {
      this[dartx.setProperty]('border-start-color', value, '');
    }
    get borderStartStyle() {
      return this[dartx.getPropertyValue]('border-start-style');
    }
    set borderStartStyle(value) {
      this[dartx.setProperty]('border-start-style', value, '');
    }
    get borderStartWidth() {
      return this[dartx.getPropertyValue]('border-start-width');
    }
    set borderStartWidth(value) {
      this[dartx.setProperty]('border-start-width', value, '');
    }
    get borderStyle() {
      return this[dartx.getPropertyValue]('border-style');
    }
    set borderStyle(value) {
      this[dartx.setProperty]('border-style', value, '');
    }
    get borderTop() {
      return this[dartx.getPropertyValue]('border-top');
    }
    set borderTop(value) {
      this[dartx.setProperty]('border-top', value, '');
    }
    get borderTopColor() {
      return this[dartx.getPropertyValue]('border-top-color');
    }
    set borderTopColor(value) {
      this[dartx.setProperty]('border-top-color', value, '');
    }
    get borderTopLeftRadius() {
      return this[dartx.getPropertyValue]('border-top-left-radius');
    }
    set borderTopLeftRadius(value) {
      this[dartx.setProperty]('border-top-left-radius', value, '');
    }
    get borderTopRightRadius() {
      return this[dartx.getPropertyValue]('border-top-right-radius');
    }
    set borderTopRightRadius(value) {
      this[dartx.setProperty]('border-top-right-radius', value, '');
    }
    get borderTopStyle() {
      return this[dartx.getPropertyValue]('border-top-style');
    }
    set borderTopStyle(value) {
      this[dartx.setProperty]('border-top-style', value, '');
    }
    get borderTopWidth() {
      return this[dartx.getPropertyValue]('border-top-width');
    }
    set borderTopWidth(value) {
      this[dartx.setProperty]('border-top-width', value, '');
    }
    get borderVerticalSpacing() {
      return this[dartx.getPropertyValue]('border-vertical-spacing');
    }
    set borderVerticalSpacing(value) {
      this[dartx.setProperty]('border-vertical-spacing', value, '');
    }
    get borderWidth() {
      return this[dartx.getPropertyValue]('border-width');
    }
    set borderWidth(value) {
      this[dartx.setProperty]('border-width', value, '');
    }
    get bottom() {
      return this[dartx.getPropertyValue]('bottom');
    }
    set bottom(value) {
      this[dartx.setProperty]('bottom', value, '');
    }
    get boxAlign() {
      return this[dartx.getPropertyValue]('box-align');
    }
    set boxAlign(value) {
      this[dartx.setProperty]('box-align', value, '');
    }
    get boxDecorationBreak() {
      return this[dartx.getPropertyValue]('box-decoration-break');
    }
    set boxDecorationBreak(value) {
      this[dartx.setProperty]('box-decoration-break', value, '');
    }
    get boxDirection() {
      return this[dartx.getPropertyValue]('box-direction');
    }
    set boxDirection(value) {
      this[dartx.setProperty]('box-direction', value, '');
    }
    get boxFlex() {
      return this[dartx.getPropertyValue]('box-flex');
    }
    set boxFlex(value) {
      this[dartx.setProperty]('box-flex', value, '');
    }
    get boxFlexGroup() {
      return this[dartx.getPropertyValue]('box-flex-group');
    }
    set boxFlexGroup(value) {
      this[dartx.setProperty]('box-flex-group', value, '');
    }
    get boxLines() {
      return this[dartx.getPropertyValue]('box-lines');
    }
    set boxLines(value) {
      this[dartx.setProperty]('box-lines', value, '');
    }
    get boxOrdinalGroup() {
      return this[dartx.getPropertyValue]('box-ordinal-group');
    }
    set boxOrdinalGroup(value) {
      this[dartx.setProperty]('box-ordinal-group', value, '');
    }
    get boxOrient() {
      return this[dartx.getPropertyValue]('box-orient');
    }
    set boxOrient(value) {
      this[dartx.setProperty]('box-orient', value, '');
    }
    get boxPack() {
      return this[dartx.getPropertyValue]('box-pack');
    }
    set boxPack(value) {
      this[dartx.setProperty]('box-pack', value, '');
    }
    get boxReflect() {
      return this[dartx.getPropertyValue]('box-reflect');
    }
    set boxReflect(value) {
      this[dartx.setProperty]('box-reflect', value, '');
    }
    get boxShadow() {
      return this[dartx.getPropertyValue]('box-shadow');
    }
    set boxShadow(value) {
      this[dartx.setProperty]('box-shadow', value, '');
    }
    get boxSizing() {
      return this[dartx.getPropertyValue]('box-sizing');
    }
    set boxSizing(value) {
      this[dartx.setProperty]('box-sizing', value, '');
    }
    get captionSide() {
      return this[dartx.getPropertyValue]('caption-side');
    }
    set captionSide(value) {
      this[dartx.setProperty]('caption-side', value, '');
    }
    get clear() {
      return this[dartx.getPropertyValue]('clear');
    }
    set clear(value) {
      this[dartx.setProperty]('clear', value, '');
    }
    get clip() {
      return this[dartx.getPropertyValue]('clip');
    }
    set clip(value) {
      this[dartx.setProperty]('clip', value, '');
    }
    get clipPath() {
      return this[dartx.getPropertyValue]('clip-path');
    }
    set clipPath(value) {
      this[dartx.setProperty]('clip-path', value, '');
    }
    get color() {
      return this[dartx.getPropertyValue]('color');
    }
    set color(value) {
      this[dartx.setProperty]('color', value, '');
    }
    get columnBreakAfter() {
      return this[dartx.getPropertyValue]('column-break-after');
    }
    set columnBreakAfter(value) {
      this[dartx.setProperty]('column-break-after', value, '');
    }
    get columnBreakBefore() {
      return this[dartx.getPropertyValue]('column-break-before');
    }
    set columnBreakBefore(value) {
      this[dartx.setProperty]('column-break-before', value, '');
    }
    get columnBreakInside() {
      return this[dartx.getPropertyValue]('column-break-inside');
    }
    set columnBreakInside(value) {
      this[dartx.setProperty]('column-break-inside', value, '');
    }
    get columnCount() {
      return this[dartx.getPropertyValue]('column-count');
    }
    set columnCount(value) {
      this[dartx.setProperty]('column-count', value, '');
    }
    get columnFill() {
      return this[dartx.getPropertyValue]('column-fill');
    }
    set columnFill(value) {
      this[dartx.setProperty]('column-fill', value, '');
    }
    get columnGap() {
      return this[dartx.getPropertyValue]('column-gap');
    }
    set columnGap(value) {
      this[dartx.setProperty]('column-gap', value, '');
    }
    get columnRule() {
      return this[dartx.getPropertyValue]('column-rule');
    }
    set columnRule(value) {
      this[dartx.setProperty]('column-rule', value, '');
    }
    get columnRuleColor() {
      return this[dartx.getPropertyValue]('column-rule-color');
    }
    set columnRuleColor(value) {
      this[dartx.setProperty]('column-rule-color', value, '');
    }
    get columnRuleStyle() {
      return this[dartx.getPropertyValue]('column-rule-style');
    }
    set columnRuleStyle(value) {
      this[dartx.setProperty]('column-rule-style', value, '');
    }
    get columnRuleWidth() {
      return this[dartx.getPropertyValue]('column-rule-width');
    }
    set columnRuleWidth(value) {
      this[dartx.setProperty]('column-rule-width', value, '');
    }
    get columnSpan() {
      return this[dartx.getPropertyValue]('column-span');
    }
    set columnSpan(value) {
      this[dartx.setProperty]('column-span', value, '');
    }
    get columnWidth() {
      return this[dartx.getPropertyValue]('column-width');
    }
    set columnWidth(value) {
      this[dartx.setProperty]('column-width', value, '');
    }
    get columns() {
      return this[dartx.getPropertyValue]('columns');
    }
    set columns(value) {
      this[dartx.setProperty]('columns', value, '');
    }
    get content() {
      return this[dartx.getPropertyValue]('content');
    }
    set content(value) {
      this[dartx.setProperty]('content', value, '');
    }
    get counterIncrement() {
      return this[dartx.getPropertyValue]('counter-increment');
    }
    set counterIncrement(value) {
      this[dartx.setProperty]('counter-increment', value, '');
    }
    get counterReset() {
      return this[dartx.getPropertyValue]('counter-reset');
    }
    set counterReset(value) {
      this[dartx.setProperty]('counter-reset', value, '');
    }
    get cursor() {
      return this[dartx.getPropertyValue]('cursor');
    }
    set cursor(value) {
      this[dartx.setProperty]('cursor', value, '');
    }
    get direction() {
      return this[dartx.getPropertyValue]('direction');
    }
    set direction(value) {
      this[dartx.setProperty]('direction', value, '');
    }
    get display() {
      return this[dartx.getPropertyValue]('display');
    }
    set display(value) {
      this[dartx.setProperty]('display', value, '');
    }
    get emptyCells() {
      return this[dartx.getPropertyValue]('empty-cells');
    }
    set emptyCells(value) {
      this[dartx.setProperty]('empty-cells', value, '');
    }
    get filter() {
      return this[dartx.getPropertyValue]('filter');
    }
    set filter(value) {
      this[dartx.setProperty]('filter', value, '');
    }
    get flex() {
      return this[dartx.getPropertyValue]('flex');
    }
    set flex(value) {
      this[dartx.setProperty]('flex', value, '');
    }
    get flexBasis() {
      return this[dartx.getPropertyValue]('flex-basis');
    }
    set flexBasis(value) {
      this[dartx.setProperty]('flex-basis', value, '');
    }
    get flexDirection() {
      return this[dartx.getPropertyValue]('flex-direction');
    }
    set flexDirection(value) {
      this[dartx.setProperty]('flex-direction', value, '');
    }
    get flexFlow() {
      return this[dartx.getPropertyValue]('flex-flow');
    }
    set flexFlow(value) {
      this[dartx.setProperty]('flex-flow', value, '');
    }
    get flexGrow() {
      return this[dartx.getPropertyValue]('flex-grow');
    }
    set flexGrow(value) {
      this[dartx.setProperty]('flex-grow', value, '');
    }
    get flexShrink() {
      return this[dartx.getPropertyValue]('flex-shrink');
    }
    set flexShrink(value) {
      this[dartx.setProperty]('flex-shrink', value, '');
    }
    get flexWrap() {
      return this[dartx.getPropertyValue]('flex-wrap');
    }
    set flexWrap(value) {
      this[dartx.setProperty]('flex-wrap', value, '');
    }
    get float() {
      return this[dartx.getPropertyValue]('float');
    }
    set float(value) {
      this[dartx.setProperty]('float', value, '');
    }
    get font() {
      return this[dartx.getPropertyValue]('font');
    }
    set font(value) {
      this[dartx.setProperty]('font', value, '');
    }
    get fontFamily() {
      return this[dartx.getPropertyValue]('font-family');
    }
    set fontFamily(value) {
      this[dartx.setProperty]('font-family', value, '');
    }
    get fontFeatureSettings() {
      return this[dartx.getPropertyValue]('font-feature-settings');
    }
    set fontFeatureSettings(value) {
      this[dartx.setProperty]('font-feature-settings', value, '');
    }
    get fontKerning() {
      return this[dartx.getPropertyValue]('font-kerning');
    }
    set fontKerning(value) {
      this[dartx.setProperty]('font-kerning', value, '');
    }
    get fontSize() {
      return this[dartx.getPropertyValue]('font-size');
    }
    set fontSize(value) {
      this[dartx.setProperty]('font-size', value, '');
    }
    get fontSizeDelta() {
      return this[dartx.getPropertyValue]('font-size-delta');
    }
    set fontSizeDelta(value) {
      this[dartx.setProperty]('font-size-delta', value, '');
    }
    get fontSmoothing() {
      return this[dartx.getPropertyValue]('font-smoothing');
    }
    set fontSmoothing(value) {
      this[dartx.setProperty]('font-smoothing', value, '');
    }
    get fontStretch() {
      return this[dartx.getPropertyValue]('font-stretch');
    }
    set fontStretch(value) {
      this[dartx.setProperty]('font-stretch', value, '');
    }
    get fontStyle() {
      return this[dartx.getPropertyValue]('font-style');
    }
    set fontStyle(value) {
      this[dartx.setProperty]('font-style', value, '');
    }
    get fontVariant() {
      return this[dartx.getPropertyValue]('font-variant');
    }
    set fontVariant(value) {
      this[dartx.setProperty]('font-variant', value, '');
    }
    get fontVariantLigatures() {
      return this[dartx.getPropertyValue]('font-variant-ligatures');
    }
    set fontVariantLigatures(value) {
      this[dartx.setProperty]('font-variant-ligatures', value, '');
    }
    get fontWeight() {
      return this[dartx.getPropertyValue]('font-weight');
    }
    set fontWeight(value) {
      this[dartx.setProperty]('font-weight', value, '');
    }
    get grid() {
      return this[dartx.getPropertyValue]('grid');
    }
    set grid(value) {
      this[dartx.setProperty]('grid', value, '');
    }
    get gridArea() {
      return this[dartx.getPropertyValue]('grid-area');
    }
    set gridArea(value) {
      this[dartx.setProperty]('grid-area', value, '');
    }
    get gridAutoColumns() {
      return this[dartx.getPropertyValue]('grid-auto-columns');
    }
    set gridAutoColumns(value) {
      this[dartx.setProperty]('grid-auto-columns', value, '');
    }
    get gridAutoFlow() {
      return this[dartx.getPropertyValue]('grid-auto-flow');
    }
    set gridAutoFlow(value) {
      this[dartx.setProperty]('grid-auto-flow', value, '');
    }
    get gridAutoRows() {
      return this[dartx.getPropertyValue]('grid-auto-rows');
    }
    set gridAutoRows(value) {
      this[dartx.setProperty]('grid-auto-rows', value, '');
    }
    get gridColumn() {
      return this[dartx.getPropertyValue]('grid-column');
    }
    set gridColumn(value) {
      this[dartx.setProperty]('grid-column', value, '');
    }
    get gridColumnEnd() {
      return this[dartx.getPropertyValue]('grid-column-end');
    }
    set gridColumnEnd(value) {
      this[dartx.setProperty]('grid-column-end', value, '');
    }
    get gridColumnStart() {
      return this[dartx.getPropertyValue]('grid-column-start');
    }
    set gridColumnStart(value) {
      this[dartx.setProperty]('grid-column-start', value, '');
    }
    get gridRow() {
      return this[dartx.getPropertyValue]('grid-row');
    }
    set gridRow(value) {
      this[dartx.setProperty]('grid-row', value, '');
    }
    get gridRowEnd() {
      return this[dartx.getPropertyValue]('grid-row-end');
    }
    set gridRowEnd(value) {
      this[dartx.setProperty]('grid-row-end', value, '');
    }
    get gridRowStart() {
      return this[dartx.getPropertyValue]('grid-row-start');
    }
    set gridRowStart(value) {
      this[dartx.setProperty]('grid-row-start', value, '');
    }
    get gridTemplate() {
      return this[dartx.getPropertyValue]('grid-template');
    }
    set gridTemplate(value) {
      this[dartx.setProperty]('grid-template', value, '');
    }
    get gridTemplateAreas() {
      return this[dartx.getPropertyValue]('grid-template-areas');
    }
    set gridTemplateAreas(value) {
      this[dartx.setProperty]('grid-template-areas', value, '');
    }
    get gridTemplateColumns() {
      return this[dartx.getPropertyValue]('grid-template-columns');
    }
    set gridTemplateColumns(value) {
      this[dartx.setProperty]('grid-template-columns', value, '');
    }
    get gridTemplateRows() {
      return this[dartx.getPropertyValue]('grid-template-rows');
    }
    set gridTemplateRows(value) {
      this[dartx.setProperty]('grid-template-rows', value, '');
    }
    get height() {
      return this[dartx.getPropertyValue]('height');
    }
    set height(value) {
      this[dartx.setProperty]('height', value, '');
    }
    get highlight() {
      return this[dartx.getPropertyValue]('highlight');
    }
    set highlight(value) {
      this[dartx.setProperty]('highlight', value, '');
    }
    get hyphenateCharacter() {
      return this[dartx.getPropertyValue]('hyphenate-character');
    }
    set hyphenateCharacter(value) {
      this[dartx.setProperty]('hyphenate-character', value, '');
    }
    get imageRendering() {
      return this[dartx.getPropertyValue]('image-rendering');
    }
    set imageRendering(value) {
      this[dartx.setProperty]('image-rendering', value, '');
    }
    get isolation() {
      return this[dartx.getPropertyValue]('isolation');
    }
    set isolation(value) {
      this[dartx.setProperty]('isolation', value, '');
    }
    get justifyContent() {
      return this[dartx.getPropertyValue]('justify-content');
    }
    set justifyContent(value) {
      this[dartx.setProperty]('justify-content', value, '');
    }
    get justifySelf() {
      return this[dartx.getPropertyValue]('justify-self');
    }
    set justifySelf(value) {
      this[dartx.setProperty]('justify-self', value, '');
    }
    get left() {
      return this[dartx.getPropertyValue]('left');
    }
    set left(value) {
      this[dartx.setProperty]('left', value, '');
    }
    get letterSpacing() {
      return this[dartx.getPropertyValue]('letter-spacing');
    }
    set letterSpacing(value) {
      this[dartx.setProperty]('letter-spacing', value, '');
    }
    get lineBoxContain() {
      return this[dartx.getPropertyValue]('line-box-contain');
    }
    set lineBoxContain(value) {
      this[dartx.setProperty]('line-box-contain', value, '');
    }
    get lineBreak() {
      return this[dartx.getPropertyValue]('line-break');
    }
    set lineBreak(value) {
      this[dartx.setProperty]('line-break', value, '');
    }
    get lineClamp() {
      return this[dartx.getPropertyValue]('line-clamp');
    }
    set lineClamp(value) {
      this[dartx.setProperty]('line-clamp', value, '');
    }
    get lineHeight() {
      return this[dartx.getPropertyValue]('line-height');
    }
    set lineHeight(value) {
      this[dartx.setProperty]('line-height', value, '');
    }
    get listStyle() {
      return this[dartx.getPropertyValue]('list-style');
    }
    set listStyle(value) {
      this[dartx.setProperty]('list-style', value, '');
    }
    get listStyleImage() {
      return this[dartx.getPropertyValue]('list-style-image');
    }
    set listStyleImage(value) {
      this[dartx.setProperty]('list-style-image', value, '');
    }
    get listStylePosition() {
      return this[dartx.getPropertyValue]('list-style-position');
    }
    set listStylePosition(value) {
      this[dartx.setProperty]('list-style-position', value, '');
    }
    get listStyleType() {
      return this[dartx.getPropertyValue]('list-style-type');
    }
    set listStyleType(value) {
      this[dartx.setProperty]('list-style-type', value, '');
    }
    get locale() {
      return this[dartx.getPropertyValue]('locale');
    }
    set locale(value) {
      this[dartx.setProperty]('locale', value, '');
    }
    get logicalHeight() {
      return this[dartx.getPropertyValue]('logical-height');
    }
    set logicalHeight(value) {
      this[dartx.setProperty]('logical-height', value, '');
    }
    get logicalWidth() {
      return this[dartx.getPropertyValue]('logical-width');
    }
    set logicalWidth(value) {
      this[dartx.setProperty]('logical-width', value, '');
    }
    get margin() {
      return this[dartx.getPropertyValue]('margin');
    }
    set margin(value) {
      this[dartx.setProperty]('margin', value, '');
    }
    get marginAfter() {
      return this[dartx.getPropertyValue]('margin-after');
    }
    set marginAfter(value) {
      this[dartx.setProperty]('margin-after', value, '');
    }
    get marginAfterCollapse() {
      return this[dartx.getPropertyValue]('margin-after-collapse');
    }
    set marginAfterCollapse(value) {
      this[dartx.setProperty]('margin-after-collapse', value, '');
    }
    get marginBefore() {
      return this[dartx.getPropertyValue]('margin-before');
    }
    set marginBefore(value) {
      this[dartx.setProperty]('margin-before', value, '');
    }
    get marginBeforeCollapse() {
      return this[dartx.getPropertyValue]('margin-before-collapse');
    }
    set marginBeforeCollapse(value) {
      this[dartx.setProperty]('margin-before-collapse', value, '');
    }
    get marginBottom() {
      return this[dartx.getPropertyValue]('margin-bottom');
    }
    set marginBottom(value) {
      this[dartx.setProperty]('margin-bottom', value, '');
    }
    get marginBottomCollapse() {
      return this[dartx.getPropertyValue]('margin-bottom-collapse');
    }
    set marginBottomCollapse(value) {
      this[dartx.setProperty]('margin-bottom-collapse', value, '');
    }
    get marginCollapse() {
      return this[dartx.getPropertyValue]('margin-collapse');
    }
    set marginCollapse(value) {
      this[dartx.setProperty]('margin-collapse', value, '');
    }
    get marginEnd() {
      return this[dartx.getPropertyValue]('margin-end');
    }
    set marginEnd(value) {
      this[dartx.setProperty]('margin-end', value, '');
    }
    get marginLeft() {
      return this[dartx.getPropertyValue]('margin-left');
    }
    set marginLeft(value) {
      this[dartx.setProperty]('margin-left', value, '');
    }
    get marginRight() {
      return this[dartx.getPropertyValue]('margin-right');
    }
    set marginRight(value) {
      this[dartx.setProperty]('margin-right', value, '');
    }
    get marginStart() {
      return this[dartx.getPropertyValue]('margin-start');
    }
    set marginStart(value) {
      this[dartx.setProperty]('margin-start', value, '');
    }
    get marginTop() {
      return this[dartx.getPropertyValue]('margin-top');
    }
    set marginTop(value) {
      this[dartx.setProperty]('margin-top', value, '');
    }
    get marginTopCollapse() {
      return this[dartx.getPropertyValue]('margin-top-collapse');
    }
    set marginTopCollapse(value) {
      this[dartx.setProperty]('margin-top-collapse', value, '');
    }
    get mask() {
      return this[dartx.getPropertyValue]('mask');
    }
    set mask(value) {
      this[dartx.setProperty]('mask', value, '');
    }
    get maskBoxImage() {
      return this[dartx.getPropertyValue]('mask-box-image');
    }
    set maskBoxImage(value) {
      this[dartx.setProperty]('mask-box-image', value, '');
    }
    get maskBoxImageOutset() {
      return this[dartx.getPropertyValue]('mask-box-image-outset');
    }
    set maskBoxImageOutset(value) {
      this[dartx.setProperty]('mask-box-image-outset', value, '');
    }
    get maskBoxImageRepeat() {
      return this[dartx.getPropertyValue]('mask-box-image-repeat');
    }
    set maskBoxImageRepeat(value) {
      this[dartx.setProperty]('mask-box-image-repeat', value, '');
    }
    get maskBoxImageSlice() {
      return this[dartx.getPropertyValue]('mask-box-image-slice');
    }
    set maskBoxImageSlice(value) {
      this[dartx.setProperty]('mask-box-image-slice', value, '');
    }
    get maskBoxImageSource() {
      return this[dartx.getPropertyValue]('mask-box-image-source');
    }
    set maskBoxImageSource(value) {
      this[dartx.setProperty]('mask-box-image-source', value, '');
    }
    get maskBoxImageWidth() {
      return this[dartx.getPropertyValue]('mask-box-image-width');
    }
    set maskBoxImageWidth(value) {
      this[dartx.setProperty]('mask-box-image-width', value, '');
    }
    get maskClip() {
      return this[dartx.getPropertyValue]('mask-clip');
    }
    set maskClip(value) {
      this[dartx.setProperty]('mask-clip', value, '');
    }
    get maskComposite() {
      return this[dartx.getPropertyValue]('mask-composite');
    }
    set maskComposite(value) {
      this[dartx.setProperty]('mask-composite', value, '');
    }
    get maskImage() {
      return this[dartx.getPropertyValue]('mask-image');
    }
    set maskImage(value) {
      this[dartx.setProperty]('mask-image', value, '');
    }
    get maskOrigin() {
      return this[dartx.getPropertyValue]('mask-origin');
    }
    set maskOrigin(value) {
      this[dartx.setProperty]('mask-origin', value, '');
    }
    get maskPosition() {
      return this[dartx.getPropertyValue]('mask-position');
    }
    set maskPosition(value) {
      this[dartx.setProperty]('mask-position', value, '');
    }
    get maskPositionX() {
      return this[dartx.getPropertyValue]('mask-position-x');
    }
    set maskPositionX(value) {
      this[dartx.setProperty]('mask-position-x', value, '');
    }
    get maskPositionY() {
      return this[dartx.getPropertyValue]('mask-position-y');
    }
    set maskPositionY(value) {
      this[dartx.setProperty]('mask-position-y', value, '');
    }
    get maskRepeat() {
      return this[dartx.getPropertyValue]('mask-repeat');
    }
    set maskRepeat(value) {
      this[dartx.setProperty]('mask-repeat', value, '');
    }
    get maskRepeatX() {
      return this[dartx.getPropertyValue]('mask-repeat-x');
    }
    set maskRepeatX(value) {
      this[dartx.setProperty]('mask-repeat-x', value, '');
    }
    get maskRepeatY() {
      return this[dartx.getPropertyValue]('mask-repeat-y');
    }
    set maskRepeatY(value) {
      this[dartx.setProperty]('mask-repeat-y', value, '');
    }
    get maskSize() {
      return this[dartx.getPropertyValue]('mask-size');
    }
    set maskSize(value) {
      this[dartx.setProperty]('mask-size', value, '');
    }
    get maskSourceType() {
      return this[dartx.getPropertyValue]('mask-source-type');
    }
    set maskSourceType(value) {
      this[dartx.setProperty]('mask-source-type', value, '');
    }
    get maxHeight() {
      return this[dartx.getPropertyValue]('max-height');
    }
    set maxHeight(value) {
      this[dartx.setProperty]('max-height', value, '');
    }
    get maxLogicalHeight() {
      return this[dartx.getPropertyValue]('max-logical-height');
    }
    set maxLogicalHeight(value) {
      this[dartx.setProperty]('max-logical-height', value, '');
    }
    get maxLogicalWidth() {
      return this[dartx.getPropertyValue]('max-logical-width');
    }
    set maxLogicalWidth(value) {
      this[dartx.setProperty]('max-logical-width', value, '');
    }
    get maxWidth() {
      return this[dartx.getPropertyValue]('max-width');
    }
    set maxWidth(value) {
      this[dartx.setProperty]('max-width', value, '');
    }
    get maxZoom() {
      return this[dartx.getPropertyValue]('max-zoom');
    }
    set maxZoom(value) {
      this[dartx.setProperty]('max-zoom', value, '');
    }
    get minHeight() {
      return this[dartx.getPropertyValue]('min-height');
    }
    set minHeight(value) {
      this[dartx.setProperty]('min-height', value, '');
    }
    get minLogicalHeight() {
      return this[dartx.getPropertyValue]('min-logical-height');
    }
    set minLogicalHeight(value) {
      this[dartx.setProperty]('min-logical-height', value, '');
    }
    get minLogicalWidth() {
      return this[dartx.getPropertyValue]('min-logical-width');
    }
    set minLogicalWidth(value) {
      this[dartx.setProperty]('min-logical-width', value, '');
    }
    get minWidth() {
      return this[dartx.getPropertyValue]('min-width');
    }
    set minWidth(value) {
      this[dartx.setProperty]('min-width', value, '');
    }
    get minZoom() {
      return this[dartx.getPropertyValue]('min-zoom');
    }
    set minZoom(value) {
      this[dartx.setProperty]('min-zoom', value, '');
    }
    get mixBlendMode() {
      return this[dartx.getPropertyValue]('mix-blend-mode');
    }
    set mixBlendMode(value) {
      this[dartx.setProperty]('mix-blend-mode', value, '');
    }
    get objectFit() {
      return this[dartx.getPropertyValue]('object-fit');
    }
    set objectFit(value) {
      this[dartx.setProperty]('object-fit', value, '');
    }
    get objectPosition() {
      return this[dartx.getPropertyValue]('object-position');
    }
    set objectPosition(value) {
      this[dartx.setProperty]('object-position', value, '');
    }
    get opacity() {
      return this[dartx.getPropertyValue]('opacity');
    }
    set opacity(value) {
      this[dartx.setProperty]('opacity', value, '');
    }
    get order() {
      return this[dartx.getPropertyValue]('order');
    }
    set order(value) {
      this[dartx.setProperty]('order', value, '');
    }
    get orientation() {
      return this[dartx.getPropertyValue]('orientation');
    }
    set orientation(value) {
      this[dartx.setProperty]('orientation', value, '');
    }
    get orphans() {
      return this[dartx.getPropertyValue]('orphans');
    }
    set orphans(value) {
      this[dartx.setProperty]('orphans', value, '');
    }
    get outline() {
      return this[dartx.getPropertyValue]('outline');
    }
    set outline(value) {
      this[dartx.setProperty]('outline', value, '');
    }
    get outlineColor() {
      return this[dartx.getPropertyValue]('outline-color');
    }
    set outlineColor(value) {
      this[dartx.setProperty]('outline-color', value, '');
    }
    get outlineOffset() {
      return this[dartx.getPropertyValue]('outline-offset');
    }
    set outlineOffset(value) {
      this[dartx.setProperty]('outline-offset', value, '');
    }
    get outlineStyle() {
      return this[dartx.getPropertyValue]('outline-style');
    }
    set outlineStyle(value) {
      this[dartx.setProperty]('outline-style', value, '');
    }
    get outlineWidth() {
      return this[dartx.getPropertyValue]('outline-width');
    }
    set outlineWidth(value) {
      this[dartx.setProperty]('outline-width', value, '');
    }
    get overflow() {
      return this[dartx.getPropertyValue]('overflow');
    }
    set overflow(value) {
      this[dartx.setProperty]('overflow', value, '');
    }
    get overflowWrap() {
      return this[dartx.getPropertyValue]('overflow-wrap');
    }
    set overflowWrap(value) {
      this[dartx.setProperty]('overflow-wrap', value, '');
    }
    get overflowX() {
      return this[dartx.getPropertyValue]('overflow-x');
    }
    set overflowX(value) {
      this[dartx.setProperty]('overflow-x', value, '');
    }
    get overflowY() {
      return this[dartx.getPropertyValue]('overflow-y');
    }
    set overflowY(value) {
      this[dartx.setProperty]('overflow-y', value, '');
    }
    get padding() {
      return this[dartx.getPropertyValue]('padding');
    }
    set padding(value) {
      this[dartx.setProperty]('padding', value, '');
    }
    get paddingAfter() {
      return this[dartx.getPropertyValue]('padding-after');
    }
    set paddingAfter(value) {
      this[dartx.setProperty]('padding-after', value, '');
    }
    get paddingBefore() {
      return this[dartx.getPropertyValue]('padding-before');
    }
    set paddingBefore(value) {
      this[dartx.setProperty]('padding-before', value, '');
    }
    get paddingBottom() {
      return this[dartx.getPropertyValue]('padding-bottom');
    }
    set paddingBottom(value) {
      this[dartx.setProperty]('padding-bottom', value, '');
    }
    get paddingEnd() {
      return this[dartx.getPropertyValue]('padding-end');
    }
    set paddingEnd(value) {
      this[dartx.setProperty]('padding-end', value, '');
    }
    get paddingLeft() {
      return this[dartx.getPropertyValue]('padding-left');
    }
    set paddingLeft(value) {
      this[dartx.setProperty]('padding-left', value, '');
    }
    get paddingRight() {
      return this[dartx.getPropertyValue]('padding-right');
    }
    set paddingRight(value) {
      this[dartx.setProperty]('padding-right', value, '');
    }
    get paddingStart() {
      return this[dartx.getPropertyValue]('padding-start');
    }
    set paddingStart(value) {
      this[dartx.setProperty]('padding-start', value, '');
    }
    get paddingTop() {
      return this[dartx.getPropertyValue]('padding-top');
    }
    set paddingTop(value) {
      this[dartx.setProperty]('padding-top', value, '');
    }
    get page() {
      return this[dartx.getPropertyValue]('page');
    }
    set page(value) {
      this[dartx.setProperty]('page', value, '');
    }
    get pageBreakAfter() {
      return this[dartx.getPropertyValue]('page-break-after');
    }
    set pageBreakAfter(value) {
      this[dartx.setProperty]('page-break-after', value, '');
    }
    get pageBreakBefore() {
      return this[dartx.getPropertyValue]('page-break-before');
    }
    set pageBreakBefore(value) {
      this[dartx.setProperty]('page-break-before', value, '');
    }
    get pageBreakInside() {
      return this[dartx.getPropertyValue]('page-break-inside');
    }
    set pageBreakInside(value) {
      this[dartx.setProperty]('page-break-inside', value, '');
    }
    get perspective() {
      return this[dartx.getPropertyValue]('perspective');
    }
    set perspective(value) {
      this[dartx.setProperty]('perspective', value, '');
    }
    get perspectiveOrigin() {
      return this[dartx.getPropertyValue]('perspective-origin');
    }
    set perspectiveOrigin(value) {
      this[dartx.setProperty]('perspective-origin', value, '');
    }
    get perspectiveOriginX() {
      return this[dartx.getPropertyValue]('perspective-origin-x');
    }
    set perspectiveOriginX(value) {
      this[dartx.setProperty]('perspective-origin-x', value, '');
    }
    get perspectiveOriginY() {
      return this[dartx.getPropertyValue]('perspective-origin-y');
    }
    set perspectiveOriginY(value) {
      this[dartx.setProperty]('perspective-origin-y', value, '');
    }
    get pointerEvents() {
      return this[dartx.getPropertyValue]('pointer-events');
    }
    set pointerEvents(value) {
      this[dartx.setProperty]('pointer-events', value, '');
    }
    get position() {
      return this[dartx.getPropertyValue]('position');
    }
    set position(value) {
      this[dartx.setProperty]('position', value, '');
    }
    get printColorAdjust() {
      return this[dartx.getPropertyValue]('print-color-adjust');
    }
    set printColorAdjust(value) {
      this[dartx.setProperty]('print-color-adjust', value, '');
    }
    get quotes() {
      return this[dartx.getPropertyValue]('quotes');
    }
    set quotes(value) {
      this[dartx.setProperty]('quotes', value, '');
    }
    get resize() {
      return this[dartx.getPropertyValue]('resize');
    }
    set resize(value) {
      this[dartx.setProperty]('resize', value, '');
    }
    get right() {
      return this[dartx.getPropertyValue]('right');
    }
    set right(value) {
      this[dartx.setProperty]('right', value, '');
    }
    get rtlOrdering() {
      return this[dartx.getPropertyValue]('rtl-ordering');
    }
    set rtlOrdering(value) {
      this[dartx.setProperty]('rtl-ordering', value, '');
    }
    get rubyPosition() {
      return this[dartx.getPropertyValue]('ruby-position');
    }
    set rubyPosition(value) {
      this[dartx.setProperty]('ruby-position', value, '');
    }
    get scrollBehavior() {
      return this[dartx.getPropertyValue]('scroll-behavior');
    }
    set scrollBehavior(value) {
      this[dartx.setProperty]('scroll-behavior', value, '');
    }
    get shapeImageThreshold() {
      return this[dartx.getPropertyValue]('shape-image-threshold');
    }
    set shapeImageThreshold(value) {
      this[dartx.setProperty]('shape-image-threshold', value, '');
    }
    get shapeMargin() {
      return this[dartx.getPropertyValue]('shape-margin');
    }
    set shapeMargin(value) {
      this[dartx.setProperty]('shape-margin', value, '');
    }
    get shapeOutside() {
      return this[dartx.getPropertyValue]('shape-outside');
    }
    set shapeOutside(value) {
      this[dartx.setProperty]('shape-outside', value, '');
    }
    get size() {
      return this[dartx.getPropertyValue]('size');
    }
    set size(value) {
      this[dartx.setProperty]('size', value, '');
    }
    get speak() {
      return this[dartx.getPropertyValue]('speak');
    }
    set speak(value) {
      this[dartx.setProperty]('speak', value, '');
    }
    get src() {
      return this[dartx.getPropertyValue]('src');
    }
    set src(value) {
      this[dartx.setProperty]('src', value, '');
    }
    get tabSize() {
      return this[dartx.getPropertyValue]('tab-size');
    }
    set tabSize(value) {
      this[dartx.setProperty]('tab-size', value, '');
    }
    get tableLayout() {
      return this[dartx.getPropertyValue]('table-layout');
    }
    set tableLayout(value) {
      this[dartx.setProperty]('table-layout', value, '');
    }
    get tapHighlightColor() {
      return this[dartx.getPropertyValue]('tap-highlight-color');
    }
    set tapHighlightColor(value) {
      this[dartx.setProperty]('tap-highlight-color', value, '');
    }
    get textAlign() {
      return this[dartx.getPropertyValue]('text-align');
    }
    set textAlign(value) {
      this[dartx.setProperty]('text-align', value, '');
    }
    get textAlignLast() {
      return this[dartx.getPropertyValue]('text-align-last');
    }
    set textAlignLast(value) {
      this[dartx.setProperty]('text-align-last', value, '');
    }
    get textCombine() {
      return this[dartx.getPropertyValue]('text-combine');
    }
    set textCombine(value) {
      this[dartx.setProperty]('text-combine', value, '');
    }
    get textDecoration() {
      return this[dartx.getPropertyValue]('text-decoration');
    }
    set textDecoration(value) {
      this[dartx.setProperty]('text-decoration', value, '');
    }
    get textDecorationColor() {
      return this[dartx.getPropertyValue]('text-decoration-color');
    }
    set textDecorationColor(value) {
      this[dartx.setProperty]('text-decoration-color', value, '');
    }
    get textDecorationLine() {
      return this[dartx.getPropertyValue]('text-decoration-line');
    }
    set textDecorationLine(value) {
      this[dartx.setProperty]('text-decoration-line', value, '');
    }
    get textDecorationStyle() {
      return this[dartx.getPropertyValue]('text-decoration-style');
    }
    set textDecorationStyle(value) {
      this[dartx.setProperty]('text-decoration-style', value, '');
    }
    get textDecorationsInEffect() {
      return this[dartx.getPropertyValue]('text-decorations-in-effect');
    }
    set textDecorationsInEffect(value) {
      this[dartx.setProperty]('text-decorations-in-effect', value, '');
    }
    get textEmphasis() {
      return this[dartx.getPropertyValue]('text-emphasis');
    }
    set textEmphasis(value) {
      this[dartx.setProperty]('text-emphasis', value, '');
    }
    get textEmphasisColor() {
      return this[dartx.getPropertyValue]('text-emphasis-color');
    }
    set textEmphasisColor(value) {
      this[dartx.setProperty]('text-emphasis-color', value, '');
    }
    get textEmphasisPosition() {
      return this[dartx.getPropertyValue]('text-emphasis-position');
    }
    set textEmphasisPosition(value) {
      this[dartx.setProperty]('text-emphasis-position', value, '');
    }
    get textEmphasisStyle() {
      return this[dartx.getPropertyValue]('text-emphasis-style');
    }
    set textEmphasisStyle(value) {
      this[dartx.setProperty]('text-emphasis-style', value, '');
    }
    get textFillColor() {
      return this[dartx.getPropertyValue]('text-fill-color');
    }
    set textFillColor(value) {
      this[dartx.setProperty]('text-fill-color', value, '');
    }
    get textIndent() {
      return this[dartx.getPropertyValue]('text-indent');
    }
    set textIndent(value) {
      this[dartx.setProperty]('text-indent', value, '');
    }
    get textJustify() {
      return this[dartx.getPropertyValue]('text-justify');
    }
    set textJustify(value) {
      this[dartx.setProperty]('text-justify', value, '');
    }
    get textLineThroughColor() {
      return this[dartx.getPropertyValue]('text-line-through-color');
    }
    set textLineThroughColor(value) {
      this[dartx.setProperty]('text-line-through-color', value, '');
    }
    get textLineThroughMode() {
      return this[dartx.getPropertyValue]('text-line-through-mode');
    }
    set textLineThroughMode(value) {
      this[dartx.setProperty]('text-line-through-mode', value, '');
    }
    get textLineThroughStyle() {
      return this[dartx.getPropertyValue]('text-line-through-style');
    }
    set textLineThroughStyle(value) {
      this[dartx.setProperty]('text-line-through-style', value, '');
    }
    get textLineThroughWidth() {
      return this[dartx.getPropertyValue]('text-line-through-width');
    }
    set textLineThroughWidth(value) {
      this[dartx.setProperty]('text-line-through-width', value, '');
    }
    get textOrientation() {
      return this[dartx.getPropertyValue]('text-orientation');
    }
    set textOrientation(value) {
      this[dartx.setProperty]('text-orientation', value, '');
    }
    get textOverflow() {
      return this[dartx.getPropertyValue]('text-overflow');
    }
    set textOverflow(value) {
      this[dartx.setProperty]('text-overflow', value, '');
    }
    get textOverlineColor() {
      return this[dartx.getPropertyValue]('text-overline-color');
    }
    set textOverlineColor(value) {
      this[dartx.setProperty]('text-overline-color', value, '');
    }
    get textOverlineMode() {
      return this[dartx.getPropertyValue]('text-overline-mode');
    }
    set textOverlineMode(value) {
      this[dartx.setProperty]('text-overline-mode', value, '');
    }
    get textOverlineStyle() {
      return this[dartx.getPropertyValue]('text-overline-style');
    }
    set textOverlineStyle(value) {
      this[dartx.setProperty]('text-overline-style', value, '');
    }
    get textOverlineWidth() {
      return this[dartx.getPropertyValue]('text-overline-width');
    }
    set textOverlineWidth(value) {
      this[dartx.setProperty]('text-overline-width', value, '');
    }
    get textRendering() {
      return this[dartx.getPropertyValue]('text-rendering');
    }
    set textRendering(value) {
      this[dartx.setProperty]('text-rendering', value, '');
    }
    get textSecurity() {
      return this[dartx.getPropertyValue]('text-security');
    }
    set textSecurity(value) {
      this[dartx.setProperty]('text-security', value, '');
    }
    get textShadow() {
      return this[dartx.getPropertyValue]('text-shadow');
    }
    set textShadow(value) {
      this[dartx.setProperty]('text-shadow', value, '');
    }
    get textStroke() {
      return this[dartx.getPropertyValue]('text-stroke');
    }
    set textStroke(value) {
      this[dartx.setProperty]('text-stroke', value, '');
    }
    get textStrokeColor() {
      return this[dartx.getPropertyValue]('text-stroke-color');
    }
    set textStrokeColor(value) {
      this[dartx.setProperty]('text-stroke-color', value, '');
    }
    get textStrokeWidth() {
      return this[dartx.getPropertyValue]('text-stroke-width');
    }
    set textStrokeWidth(value) {
      this[dartx.setProperty]('text-stroke-width', value, '');
    }
    get textTransform() {
      return this[dartx.getPropertyValue]('text-transform');
    }
    set textTransform(value) {
      this[dartx.setProperty]('text-transform', value, '');
    }
    get textUnderlineColor() {
      return this[dartx.getPropertyValue]('text-underline-color');
    }
    set textUnderlineColor(value) {
      this[dartx.setProperty]('text-underline-color', value, '');
    }
    get textUnderlineMode() {
      return this[dartx.getPropertyValue]('text-underline-mode');
    }
    set textUnderlineMode(value) {
      this[dartx.setProperty]('text-underline-mode', value, '');
    }
    get textUnderlinePosition() {
      return this[dartx.getPropertyValue]('text-underline-position');
    }
    set textUnderlinePosition(value) {
      this[dartx.setProperty]('text-underline-position', value, '');
    }
    get textUnderlineStyle() {
      return this[dartx.getPropertyValue]('text-underline-style');
    }
    set textUnderlineStyle(value) {
      this[dartx.setProperty]('text-underline-style', value, '');
    }
    get textUnderlineWidth() {
      return this[dartx.getPropertyValue]('text-underline-width');
    }
    set textUnderlineWidth(value) {
      this[dartx.setProperty]('text-underline-width', value, '');
    }
    get top() {
      return this[dartx.getPropertyValue]('top');
    }
    set top(value) {
      this[dartx.setProperty]('top', value, '');
    }
    get touchAction() {
      return this[dartx.getPropertyValue]('touch-action');
    }
    set touchAction(value) {
      this[dartx.setProperty]('touch-action', value, '');
    }
    get touchActionDelay() {
      return this[dartx.getPropertyValue]('touch-action-delay');
    }
    set touchActionDelay(value) {
      this[dartx.setProperty]('touch-action-delay', value, '');
    }
    get transform() {
      return this[dartx.getPropertyValue]('transform');
    }
    set transform(value) {
      this[dartx.setProperty]('transform', value, '');
    }
    get transformOrigin() {
      return this[dartx.getPropertyValue]('transform-origin');
    }
    set transformOrigin(value) {
      this[dartx.setProperty]('transform-origin', value, '');
    }
    get transformOriginX() {
      return this[dartx.getPropertyValue]('transform-origin-x');
    }
    set transformOriginX(value) {
      this[dartx.setProperty]('transform-origin-x', value, '');
    }
    get transformOriginY() {
      return this[dartx.getPropertyValue]('transform-origin-y');
    }
    set transformOriginY(value) {
      this[dartx.setProperty]('transform-origin-y', value, '');
    }
    get transformOriginZ() {
      return this[dartx.getPropertyValue]('transform-origin-z');
    }
    set transformOriginZ(value) {
      this[dartx.setProperty]('transform-origin-z', value, '');
    }
    get transformStyle() {
      return this[dartx.getPropertyValue]('transform-style');
    }
    set transformStyle(value) {
      this[dartx.setProperty]('transform-style', value, '');
    }
    get transition() {
      return this[dartx.getPropertyValue]('transition');
    }
    set transition(value) {
      this[dartx.setProperty]('transition', value, '');
    }
    get transitionDelay() {
      return this[dartx.getPropertyValue]('transition-delay');
    }
    set transitionDelay(value) {
      this[dartx.setProperty]('transition-delay', value, '');
    }
    get transitionDuration() {
      return this[dartx.getPropertyValue]('transition-duration');
    }
    set transitionDuration(value) {
      this[dartx.setProperty]('transition-duration', value, '');
    }
    get transitionProperty() {
      return this[dartx.getPropertyValue]('transition-property');
    }
    set transitionProperty(value) {
      this[dartx.setProperty]('transition-property', value, '');
    }
    get transitionTimingFunction() {
      return this[dartx.getPropertyValue]('transition-timing-function');
    }
    set transitionTimingFunction(value) {
      this[dartx.setProperty]('transition-timing-function', value, '');
    }
    get unicodeBidi() {
      return this[dartx.getPropertyValue]('unicode-bidi');
    }
    set unicodeBidi(value) {
      this[dartx.setProperty]('unicode-bidi', value, '');
    }
    get unicodeRange() {
      return this[dartx.getPropertyValue]('unicode-range');
    }
    set unicodeRange(value) {
      this[dartx.setProperty]('unicode-range', value, '');
    }
    get userDrag() {
      return this[dartx.getPropertyValue]('user-drag');
    }
    set userDrag(value) {
      this[dartx.setProperty]('user-drag', value, '');
    }
    get userModify() {
      return this[dartx.getPropertyValue]('user-modify');
    }
    set userModify(value) {
      this[dartx.setProperty]('user-modify', value, '');
    }
    get userSelect() {
      return this[dartx.getPropertyValue]('user-select');
    }
    set userSelect(value) {
      this[dartx.setProperty]('user-select', value, '');
    }
    get userZoom() {
      return this[dartx.getPropertyValue]('user-zoom');
    }
    set userZoom(value) {
      this[dartx.setProperty]('user-zoom', value, '');
    }
    get verticalAlign() {
      return this[dartx.getPropertyValue]('vertical-align');
    }
    set verticalAlign(value) {
      this[dartx.setProperty]('vertical-align', value, '');
    }
    get visibility() {
      return this[dartx.getPropertyValue]('visibility');
    }
    set visibility(value) {
      this[dartx.setProperty]('visibility', value, '');
    }
    get whiteSpace() {
      return this[dartx.getPropertyValue]('white-space');
    }
    set whiteSpace(value) {
      this[dartx.setProperty]('white-space', value, '');
    }
    get widows() {
      return this[dartx.getPropertyValue]('widows');
    }
    set widows(value) {
      this[dartx.setProperty]('widows', value, '');
    }
    get width() {
      return this[dartx.getPropertyValue]('width');
    }
    set width(value) {
      this[dartx.setProperty]('width', value, '');
    }
    get willChange() {
      return this[dartx.getPropertyValue]('will-change');
    }
    set willChange(value) {
      this[dartx.setProperty]('will-change', value, '');
    }
    get wordBreak() {
      return this[dartx.getPropertyValue]('word-break');
    }
    set wordBreak(value) {
      this[dartx.setProperty]('word-break', value, '');
    }
    get wordSpacing() {
      return this[dartx.getPropertyValue]('word-spacing');
    }
    set wordSpacing(value) {
      this[dartx.setProperty]('word-spacing', value, '');
    }
    get wordWrap() {
      return this[dartx.getPropertyValue]('word-wrap');
    }
    set wordWrap(value) {
      this[dartx.setProperty]('word-wrap', value, '');
    }
    get wrapFlow() {
      return this[dartx.getPropertyValue]('wrap-flow');
    }
    set wrapFlow(value) {
      this[dartx.setProperty]('wrap-flow', value, '');
    }
    get wrapThrough() {
      return this[dartx.getPropertyValue]('wrap-through');
    }
    set wrapThrough(value) {
      this[dartx.setProperty]('wrap-through', value, '');
    }
    get writingMode() {
      return this[dartx.getPropertyValue]('writing-mode');
    }
    set writingMode(value) {
      this[dartx.setProperty]('writing-mode', value, '');
    }
    get zIndex() {
      return this[dartx.getPropertyValue]('z-index');
    }
    set zIndex(value) {
      this[dartx.setProperty]('z-index', value, '');
    }
    get zoom() {
      return this[dartx.getPropertyValue]('zoom');
    }
    set zoom(value) {
      this[dartx.setProperty]('zoom', value, '');
    }
  };
  dart.setSignature(html$.CssStyleDeclarationBase, {});
  dart.defineExtensionMembers(html$.CssStyleDeclarationBase, [
    'alignContent',
    'alignContent',
    'alignItems',
    'alignItems',
    'alignSelf',
    'alignSelf',
    'animation',
    'animation',
    'animationDelay',
    'animationDelay',
    'animationDirection',
    'animationDirection',
    'animationDuration',
    'animationDuration',
    'animationFillMode',
    'animationFillMode',
    'animationIterationCount',
    'animationIterationCount',
    'animationName',
    'animationName',
    'animationPlayState',
    'animationPlayState',
    'animationTimingFunction',
    'animationTimingFunction',
    'appRegion',
    'appRegion',
    'appearance',
    'appearance',
    'aspectRatio',
    'aspectRatio',
    'backfaceVisibility',
    'backfaceVisibility',
    'background',
    'background',
    'backgroundAttachment',
    'backgroundAttachment',
    'backgroundBlendMode',
    'backgroundBlendMode',
    'backgroundClip',
    'backgroundClip',
    'backgroundColor',
    'backgroundColor',
    'backgroundComposite',
    'backgroundComposite',
    'backgroundImage',
    'backgroundImage',
    'backgroundOrigin',
    'backgroundOrigin',
    'backgroundPosition',
    'backgroundPosition',
    'backgroundPositionX',
    'backgroundPositionX',
    'backgroundPositionY',
    'backgroundPositionY',
    'backgroundRepeat',
    'backgroundRepeat',
    'backgroundRepeatX',
    'backgroundRepeatX',
    'backgroundRepeatY',
    'backgroundRepeatY',
    'backgroundSize',
    'backgroundSize',
    'border',
    'border',
    'borderAfter',
    'borderAfter',
    'borderAfterColor',
    'borderAfterColor',
    'borderAfterStyle',
    'borderAfterStyle',
    'borderAfterWidth',
    'borderAfterWidth',
    'borderBefore',
    'borderBefore',
    'borderBeforeColor',
    'borderBeforeColor',
    'borderBeforeStyle',
    'borderBeforeStyle',
    'borderBeforeWidth',
    'borderBeforeWidth',
    'borderBottom',
    'borderBottom',
    'borderBottomColor',
    'borderBottomColor',
    'borderBottomLeftRadius',
    'borderBottomLeftRadius',
    'borderBottomRightRadius',
    'borderBottomRightRadius',
    'borderBottomStyle',
    'borderBottomStyle',
    'borderBottomWidth',
    'borderBottomWidth',
    'borderCollapse',
    'borderCollapse',
    'borderColor',
    'borderColor',
    'borderEnd',
    'borderEnd',
    'borderEndColor',
    'borderEndColor',
    'borderEndStyle',
    'borderEndStyle',
    'borderEndWidth',
    'borderEndWidth',
    'borderFit',
    'borderFit',
    'borderHorizontalSpacing',
    'borderHorizontalSpacing',
    'borderImage',
    'borderImage',
    'borderImageOutset',
    'borderImageOutset',
    'borderImageRepeat',
    'borderImageRepeat',
    'borderImageSlice',
    'borderImageSlice',
    'borderImageSource',
    'borderImageSource',
    'borderImageWidth',
    'borderImageWidth',
    'borderLeft',
    'borderLeft',
    'borderLeftColor',
    'borderLeftColor',
    'borderLeftStyle',
    'borderLeftStyle',
    'borderLeftWidth',
    'borderLeftWidth',
    'borderRadius',
    'borderRadius',
    'borderRight',
    'borderRight',
    'borderRightColor',
    'borderRightColor',
    'borderRightStyle',
    'borderRightStyle',
    'borderRightWidth',
    'borderRightWidth',
    'borderSpacing',
    'borderSpacing',
    'borderStart',
    'borderStart',
    'borderStartColor',
    'borderStartColor',
    'borderStartStyle',
    'borderStartStyle',
    'borderStartWidth',
    'borderStartWidth',
    'borderStyle',
    'borderStyle',
    'borderTop',
    'borderTop',
    'borderTopColor',
    'borderTopColor',
    'borderTopLeftRadius',
    'borderTopLeftRadius',
    'borderTopRightRadius',
    'borderTopRightRadius',
    'borderTopStyle',
    'borderTopStyle',
    'borderTopWidth',
    'borderTopWidth',
    'borderVerticalSpacing',
    'borderVerticalSpacing',
    'borderWidth',
    'borderWidth',
    'bottom',
    'bottom',
    'boxAlign',
    'boxAlign',
    'boxDecorationBreak',
    'boxDecorationBreak',
    'boxDirection',
    'boxDirection',
    'boxFlex',
    'boxFlex',
    'boxFlexGroup',
    'boxFlexGroup',
    'boxLines',
    'boxLines',
    'boxOrdinalGroup',
    'boxOrdinalGroup',
    'boxOrient',
    'boxOrient',
    'boxPack',
    'boxPack',
    'boxReflect',
    'boxReflect',
    'boxShadow',
    'boxShadow',
    'boxSizing',
    'boxSizing',
    'captionSide',
    'captionSide',
    'clear',
    'clear',
    'clip',
    'clip',
    'clipPath',
    'clipPath',
    'color',
    'color',
    'columnBreakAfter',
    'columnBreakAfter',
    'columnBreakBefore',
    'columnBreakBefore',
    'columnBreakInside',
    'columnBreakInside',
    'columnCount',
    'columnCount',
    'columnFill',
    'columnFill',
    'columnGap',
    'columnGap',
    'columnRule',
    'columnRule',
    'columnRuleColor',
    'columnRuleColor',
    'columnRuleStyle',
    'columnRuleStyle',
    'columnRuleWidth',
    'columnRuleWidth',
    'columnSpan',
    'columnSpan',
    'columnWidth',
    'columnWidth',
    'columns',
    'columns',
    'content',
    'content',
    'counterIncrement',
    'counterIncrement',
    'counterReset',
    'counterReset',
    'cursor',
    'cursor',
    'direction',
    'direction',
    'display',
    'display',
    'emptyCells',
    'emptyCells',
    'filter',
    'filter',
    'flex',
    'flex',
    'flexBasis',
    'flexBasis',
    'flexDirection',
    'flexDirection',
    'flexFlow',
    'flexFlow',
    'flexGrow',
    'flexGrow',
    'flexShrink',
    'flexShrink',
    'flexWrap',
    'flexWrap',
    'float',
    'float',
    'font',
    'font',
    'fontFamily',
    'fontFamily',
    'fontFeatureSettings',
    'fontFeatureSettings',
    'fontKerning',
    'fontKerning',
    'fontSize',
    'fontSize',
    'fontSizeDelta',
    'fontSizeDelta',
    'fontSmoothing',
    'fontSmoothing',
    'fontStretch',
    'fontStretch',
    'fontStyle',
    'fontStyle',
    'fontVariant',
    'fontVariant',
    'fontVariantLigatures',
    'fontVariantLigatures',
    'fontWeight',
    'fontWeight',
    'grid',
    'grid',
    'gridArea',
    'gridArea',
    'gridAutoColumns',
    'gridAutoColumns',
    'gridAutoFlow',
    'gridAutoFlow',
    'gridAutoRows',
    'gridAutoRows',
    'gridColumn',
    'gridColumn',
    'gridColumnEnd',
    'gridColumnEnd',
    'gridColumnStart',
    'gridColumnStart',
    'gridRow',
    'gridRow',
    'gridRowEnd',
    'gridRowEnd',
    'gridRowStart',
    'gridRowStart',
    'gridTemplate',
    'gridTemplate',
    'gridTemplateAreas',
    'gridTemplateAreas',
    'gridTemplateColumns',
    'gridTemplateColumns',
    'gridTemplateRows',
    'gridTemplateRows',
    'height',
    'height',
    'highlight',
    'highlight',
    'hyphenateCharacter',
    'hyphenateCharacter',
    'imageRendering',
    'imageRendering',
    'isolation',
    'isolation',
    'justifyContent',
    'justifyContent',
    'justifySelf',
    'justifySelf',
    'left',
    'left',
    'letterSpacing',
    'letterSpacing',
    'lineBoxContain',
    'lineBoxContain',
    'lineBreak',
    'lineBreak',
    'lineClamp',
    'lineClamp',
    'lineHeight',
    'lineHeight',
    'listStyle',
    'listStyle',
    'listStyleImage',
    'listStyleImage',
    'listStylePosition',
    'listStylePosition',
    'listStyleType',
    'listStyleType',
    'locale',
    'locale',
    'logicalHeight',
    'logicalHeight',
    'logicalWidth',
    'logicalWidth',
    'margin',
    'margin',
    'marginAfter',
    'marginAfter',
    'marginAfterCollapse',
    'marginAfterCollapse',
    'marginBefore',
    'marginBefore',
    'marginBeforeCollapse',
    'marginBeforeCollapse',
    'marginBottom',
    'marginBottom',
    'marginBottomCollapse',
    'marginBottomCollapse',
    'marginCollapse',
    'marginCollapse',
    'marginEnd',
    'marginEnd',
    'marginLeft',
    'marginLeft',
    'marginRight',
    'marginRight',
    'marginStart',
    'marginStart',
    'marginTop',
    'marginTop',
    'marginTopCollapse',
    'marginTopCollapse',
    'mask',
    'mask',
    'maskBoxImage',
    'maskBoxImage',
    'maskBoxImageOutset',
    'maskBoxImageOutset',
    'maskBoxImageRepeat',
    'maskBoxImageRepeat',
    'maskBoxImageSlice',
    'maskBoxImageSlice',
    'maskBoxImageSource',
    'maskBoxImageSource',
    'maskBoxImageWidth',
    'maskBoxImageWidth',
    'maskClip',
    'maskClip',
    'maskComposite',
    'maskComposite',
    'maskImage',
    'maskImage',
    'maskOrigin',
    'maskOrigin',
    'maskPosition',
    'maskPosition',
    'maskPositionX',
    'maskPositionX',
    'maskPositionY',
    'maskPositionY',
    'maskRepeat',
    'maskRepeat',
    'maskRepeatX',
    'maskRepeatX',
    'maskRepeatY',
    'maskRepeatY',
    'maskSize',
    'maskSize',
    'maskSourceType',
    'maskSourceType',
    'maxHeight',
    'maxHeight',
    'maxLogicalHeight',
    'maxLogicalHeight',
    'maxLogicalWidth',
    'maxLogicalWidth',
    'maxWidth',
    'maxWidth',
    'maxZoom',
    'maxZoom',
    'minHeight',
    'minHeight',
    'minLogicalHeight',
    'minLogicalHeight',
    'minLogicalWidth',
    'minLogicalWidth',
    'minWidth',
    'minWidth',
    'minZoom',
    'minZoom',
    'mixBlendMode',
    'mixBlendMode',
    'objectFit',
    'objectFit',
    'objectPosition',
    'objectPosition',
    'opacity',
    'opacity',
    'order',
    'order',
    'orientation',
    'orientation',
    'orphans',
    'orphans',
    'outline',
    'outline',
    'outlineColor',
    'outlineColor',
    'outlineOffset',
    'outlineOffset',
    'outlineStyle',
    'outlineStyle',
    'outlineWidth',
    'outlineWidth',
    'overflow',
    'overflow',
    'overflowWrap',
    'overflowWrap',
    'overflowX',
    'overflowX',
    'overflowY',
    'overflowY',
    'padding',
    'padding',
    'paddingAfter',
    'paddingAfter',
    'paddingBefore',
    'paddingBefore',
    'paddingBottom',
    'paddingBottom',
    'paddingEnd',
    'paddingEnd',
    'paddingLeft',
    'paddingLeft',
    'paddingRight',
    'paddingRight',
    'paddingStart',
    'paddingStart',
    'paddingTop',
    'paddingTop',
    'page',
    'page',
    'pageBreakAfter',
    'pageBreakAfter',
    'pageBreakBefore',
    'pageBreakBefore',
    'pageBreakInside',
    'pageBreakInside',
    'perspective',
    'perspective',
    'perspectiveOrigin',
    'perspectiveOrigin',
    'perspectiveOriginX',
    'perspectiveOriginX',
    'perspectiveOriginY',
    'perspectiveOriginY',
    'pointerEvents',
    'pointerEvents',
    'position',
    'position',
    'printColorAdjust',
    'printColorAdjust',
    'quotes',
    'quotes',
    'resize',
    'resize',
    'right',
    'right',
    'rtlOrdering',
    'rtlOrdering',
    'rubyPosition',
    'rubyPosition',
    'scrollBehavior',
    'scrollBehavior',
    'shapeImageThreshold',
    'shapeImageThreshold',
    'shapeMargin',
    'shapeMargin',
    'shapeOutside',
    'shapeOutside',
    'size',
    'size',
    'speak',
    'speak',
    'src',
    'src',
    'tabSize',
    'tabSize',
    'tableLayout',
    'tableLayout',
    'tapHighlightColor',
    'tapHighlightColor',
    'textAlign',
    'textAlign',
    'textAlignLast',
    'textAlignLast',
    'textCombine',
    'textCombine',
    'textDecoration',
    'textDecoration',
    'textDecorationColor',
    'textDecorationColor',
    'textDecorationLine',
    'textDecorationLine',
    'textDecorationStyle',
    'textDecorationStyle',
    'textDecorationsInEffect',
    'textDecorationsInEffect',
    'textEmphasis',
    'textEmphasis',
    'textEmphasisColor',
    'textEmphasisColor',
    'textEmphasisPosition',
    'textEmphasisPosition',
    'textEmphasisStyle',
    'textEmphasisStyle',
    'textFillColor',
    'textFillColor',
    'textIndent',
    'textIndent',
    'textJustify',
    'textJustify',
    'textLineThroughColor',
    'textLineThroughColor',
    'textLineThroughMode',
    'textLineThroughMode',
    'textLineThroughStyle',
    'textLineThroughStyle',
    'textLineThroughWidth',
    'textLineThroughWidth',
    'textOrientation',
    'textOrientation',
    'textOverflow',
    'textOverflow',
    'textOverlineColor',
    'textOverlineColor',
    'textOverlineMode',
    'textOverlineMode',
    'textOverlineStyle',
    'textOverlineStyle',
    'textOverlineWidth',
    'textOverlineWidth',
    'textRendering',
    'textRendering',
    'textSecurity',
    'textSecurity',
    'textShadow',
    'textShadow',
    'textStroke',
    'textStroke',
    'textStrokeColor',
    'textStrokeColor',
    'textStrokeWidth',
    'textStrokeWidth',
    'textTransform',
    'textTransform',
    'textUnderlineColor',
    'textUnderlineColor',
    'textUnderlineMode',
    'textUnderlineMode',
    'textUnderlinePosition',
    'textUnderlinePosition',
    'textUnderlineStyle',
    'textUnderlineStyle',
    'textUnderlineWidth',
    'textUnderlineWidth',
    'top',
    'top',
    'touchAction',
    'touchAction',
    'touchActionDelay',
    'touchActionDelay',
    'transform',
    'transform',
    'transformOrigin',
    'transformOrigin',
    'transformOriginX',
    'transformOriginX',
    'transformOriginY',
    'transformOriginY',
    'transformOriginZ',
    'transformOriginZ',
    'transformStyle',
    'transformStyle',
    'transition',
    'transition',
    'transitionDelay',
    'transitionDelay',
    'transitionDuration',
    'transitionDuration',
    'transitionProperty',
    'transitionProperty',
    'transitionTimingFunction',
    'transitionTimingFunction',
    'unicodeBidi',
    'unicodeBidi',
    'unicodeRange',
    'unicodeRange',
    'userDrag',
    'userDrag',
    'userModify',
    'userModify',
    'userSelect',
    'userSelect',
    'userZoom',
    'userZoom',
    'verticalAlign',
    'verticalAlign',
    'visibility',
    'visibility',
    'whiteSpace',
    'whiteSpace',
    'widows',
    'widows',
    'width',
    'width',
    'willChange',
    'willChange',
    'wordBreak',
    'wordBreak',
    'wordSpacing',
    'wordSpacing',
    'wordWrap',
    'wordWrap',
    'wrapFlow',
    'wrapFlow',
    'wrapThrough',
    'wrapThrough',
    'writingMode',
    'writingMode',
    'zIndex',
    'zIndex',
    'zoom',
    'zoom'
  ]);
  dart.defineExtensionNames([
    'getPropertyValue',
    'supportsProperty',
    'setProperty',
    'getPropertyPriority',
    'item',
    'removeProperty',
    'background',
    'background',
    'backgroundAttachment',
    'backgroundAttachment',
    'backgroundColor',
    'backgroundColor',
    'backgroundImage',
    'backgroundImage',
    'backgroundPosition',
    'backgroundPosition',
    'backgroundRepeat',
    'backgroundRepeat',
    'border',
    'border',
    'borderBottom',
    'borderBottom',
    'borderBottomColor',
    'borderBottomColor',
    'borderBottomStyle',
    'borderBottomStyle',
    'borderBottomWidth',
    'borderBottomWidth',
    'borderCollapse',
    'borderCollapse',
    'borderColor',
    'borderColor',
    'borderLeft',
    'borderLeft',
    'borderLeftColor',
    'borderLeftColor',
    'borderLeftStyle',
    'borderLeftStyle',
    'borderLeftWidth',
    'borderLeftWidth',
    'borderRight',
    'borderRight',
    'borderRightColor',
    'borderRightColor',
    'borderRightStyle',
    'borderRightStyle',
    'borderRightWidth',
    'borderRightWidth',
    'borderSpacing',
    'borderSpacing',
    'borderStyle',
    'borderStyle',
    'borderTop',
    'borderTop',
    'borderTopColor',
    'borderTopColor',
    'borderTopStyle',
    'borderTopStyle',
    'borderTopWidth',
    'borderTopWidth',
    'borderWidth',
    'borderWidth',
    'bottom',
    'bottom',
    'captionSide',
    'captionSide',
    'clear',
    'clear',
    'clip',
    'clip',
    'color',
    'color',
    'content',
    'content',
    'cursor',
    'cursor',
    'direction',
    'direction',
    'display',
    'display',
    'emptyCells',
    'emptyCells',
    'font',
    'font',
    'fontFamily',
    'fontFamily',
    'fontSize',
    'fontSize',
    'fontStyle',
    'fontStyle',
    'fontVariant',
    'fontVariant',
    'fontWeight',
    'fontWeight',
    'height',
    'height',
    'left',
    'left',
    'letterSpacing',
    'letterSpacing',
    'lineHeight',
    'lineHeight',
    'listStyle',
    'listStyle',
    'listStyleImage',
    'listStyleImage',
    'listStylePosition',
    'listStylePosition',
    'listStyleType',
    'listStyleType',
    'margin',
    'margin',
    'marginBottom',
    'marginBottom',
    'marginLeft',
    'marginLeft',
    'marginRight',
    'marginRight',
    'marginTop',
    'marginTop',
    'maxHeight',
    'maxHeight',
    'maxWidth',
    'maxWidth',
    'minHeight',
    'minHeight',
    'minWidth',
    'minWidth',
    'outline',
    'outline',
    'outlineColor',
    'outlineColor',
    'outlineStyle',
    'outlineStyle',
    'outlineWidth',
    'outlineWidth',
    'overflow',
    'overflow',
    'padding',
    'padding',
    'paddingBottom',
    'paddingBottom',
    'paddingLeft',
    'paddingLeft',
    'paddingRight',
    'paddingRight',
    'paddingTop',
    'paddingTop',
    'pageBreakAfter',
    'pageBreakAfter',
    'pageBreakBefore',
    'pageBreakBefore',
    'pageBreakInside',
    'pageBreakInside',
    'position',
    'position',
    'quotes',
    'quotes',
    'right',
    'right',
    'tableLayout',
    'tableLayout',
    'textAlign',
    'textAlign',
    'textDecoration',
    'textDecoration',
    'textIndent',
    'textIndent',
    'textTransform',
    'textTransform',
    'top',
    'top',
    'unicodeBidi',
    'unicodeBidi',
    'verticalAlign',
    'verticalAlign',
    'visibility',
    'visibility',
    'whiteSpace',
    'whiteSpace',
    'width',
    'width',
    'wordSpacing',
    'wordSpacing',
    'zIndex',
    'zIndex',
    'cssText',
    'length',
    'parentRule'
  ]);
  html$.CssStyleDeclaration = class CssStyleDeclaration extends dart.mixin(_interceptors.Interceptor, html$.CssStyleDeclarationBase) {
    static new() {
      return html$.CssStyleDeclaration.css('');
    }
    static css(css) {
      let style = html$.Element.tag('div')[dartx.style];
      style[dartx.cssText] = css;
      return style;
    }
    [dartx.getPropertyValue](propertyName) {
      let propValue = this[_getPropertyValueHelper](propertyName);
      return propValue != null ? propValue : '';
    }
    [_getPropertyValueHelper](propertyName) {
      if (dart.notNull(this[_supportsProperty](html$.CssStyleDeclaration._camelCase(propertyName)))) {
        return this[_getPropertyValue](propertyName);
      } else {
        return this[_getPropertyValue](dart.notNull(html_common.Device.cssPrefix) + dart.notNull(propertyName));
      }
    }
    [dartx.supportsProperty](propertyName) {
      return dart.notNull(this[_supportsProperty](propertyName)) || dart.notNull(this[_supportsProperty](html$.CssStyleDeclaration._camelCase(dart.notNull(html_common.Device.cssPrefix) + dart.notNull(propertyName))));
    }
    [_supportsProperty](propertyName) {
      return propertyName in this;
    }
    [dartx.setProperty](propertyName, value, priority) {
      if (priority === void 0) priority = null;
      return this[_setPropertyHelper](this[_browserPropertyName](propertyName), value, priority);
    }
    [_browserPropertyName](propertyName) {
      let name = html$.CssStyleDeclaration._readCache(propertyName);
      if (typeof name == 'string') return name;
      if (dart.notNull(this[_supportsProperty](html$.CssStyleDeclaration._camelCase(propertyName)))) {
        name = propertyName;
      } else {
        name = dart.notNull(html_common.Device.cssPrefix) + dart.notNull(propertyName);
      }
      html$.CssStyleDeclaration._writeCache(propertyName, name);
      return name;
    }
    static _readCache(key) {
      return html$.CssStyleDeclaration._propertyCache[key];
    }
    static _writeCache(key, value) {
      html$.CssStyleDeclaration._propertyCache[key] = value;
    }
    static _camelCase(hyphenated) {
      let replacedMs = hyphenated.replace(/^-ms-/, "ms-");
      let fToUpper = dart.const(new _foreign_helper.JS_CONST('function(_, letter) { return letter.toUpperCase(); }'));
      return replacedMs.replace(/-([\da-z])/ig, fToUpper);
    }
    [_setPropertyHelper](propertyName, value, priority) {
      if (priority === void 0) priority = null;
      if (value == null) value = '';
      if (priority == null) priority = '';
      this.setProperty(propertyName, value, priority);
    }
    static get supportsTransitions() {
      return html$.document[dartx.body][dartx.style][dartx.supportsProperty]('transition');
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.cssText]() {
      return this.cssText;
    }
    set [dartx.cssText](value) {
      this.cssText = value;
    }
    get [dartx.length]() {
      return this.length;
    }
    get [dartx.parentRule]() {
      return this.parentRule;
    }
    [dartx.getPropertyPriority](property) {
      return this.getPropertyPriority(property);
    }
    [_getPropertyValue](property) {
      return this.getPropertyValue(property);
    }
    [dartx.item](index) {
      return this.item(index);
    }
    [dartx.removeProperty](property) {
      return this.removeProperty(property);
    }
    get [dartx.background]() {
      return this[_background];
    }
    set [dartx.background](value) {
      this[_background] = value == null ? '' : value;
    }
    get [_background]() {
      return this.background;
    }
    set [_background](value) {
      this.background = value;
    }
    get [dartx.backgroundAttachment]() {
      return this[_backgroundAttachment];
    }
    set [dartx.backgroundAttachment](value) {
      this[_backgroundAttachment] = value == null ? '' : value;
    }
    get [_backgroundAttachment]() {
      return this.backgroundAttachment;
    }
    set [_backgroundAttachment](value) {
      this.backgroundAttachment = value;
    }
    get [dartx.backgroundColor]() {
      return this[_backgroundColor];
    }
    set [dartx.backgroundColor](value) {
      this[_backgroundColor] = value == null ? '' : value;
    }
    get [_backgroundColor]() {
      return this.backgroundColor;
    }
    set [_backgroundColor](value) {
      this.backgroundColor = value;
    }
    get [dartx.backgroundImage]() {
      return this[_backgroundImage];
    }
    set [dartx.backgroundImage](value) {
      this[_backgroundImage] = value == null ? '' : value;
    }
    get [_backgroundImage]() {
      return this.backgroundImage;
    }
    set [_backgroundImage](value) {
      this.backgroundImage = value;
    }
    get [dartx.backgroundPosition]() {
      return this[_backgroundPosition];
    }
    set [dartx.backgroundPosition](value) {
      this[_backgroundPosition] = value == null ? '' : value;
    }
    get [_backgroundPosition]() {
      return this.backgroundPosition;
    }
    set [_backgroundPosition](value) {
      this.backgroundPosition = value;
    }
    get [dartx.backgroundRepeat]() {
      return this[_backgroundRepeat];
    }
    set [dartx.backgroundRepeat](value) {
      this[_backgroundRepeat] = value == null ? '' : value;
    }
    get [_backgroundRepeat]() {
      return this.backgroundRepeat;
    }
    set [_backgroundRepeat](value) {
      this.backgroundRepeat = value;
    }
    get [dartx.border]() {
      return this[_border];
    }
    set [dartx.border](value) {
      this[_border] = value == null ? '' : value;
    }
    get [_border]() {
      return this.border;
    }
    set [_border](value) {
      this.border = value;
    }
    get [dartx.borderBottom]() {
      return this[_borderBottom];
    }
    set [dartx.borderBottom](value) {
      this[_borderBottom] = value == null ? '' : value;
    }
    get [_borderBottom]() {
      return this.borderBottom;
    }
    set [_borderBottom](value) {
      this.borderBottom = value;
    }
    get [dartx.borderBottomColor]() {
      return this[_borderBottomColor];
    }
    set [dartx.borderBottomColor](value) {
      this[_borderBottomColor] = value == null ? '' : value;
    }
    get [_borderBottomColor]() {
      return this.borderBottomColor;
    }
    set [_borderBottomColor](value) {
      this.borderBottomColor = value;
    }
    get [dartx.borderBottomStyle]() {
      return this[_borderBottomStyle];
    }
    set [dartx.borderBottomStyle](value) {
      this[_borderBottomStyle] = value == null ? '' : value;
    }
    get [_borderBottomStyle]() {
      return this.borderBottomStyle;
    }
    set [_borderBottomStyle](value) {
      this.borderBottomStyle = value;
    }
    get [dartx.borderBottomWidth]() {
      return this[_borderBottomWidth];
    }
    set [dartx.borderBottomWidth](value) {
      this[_borderBottomWidth] = value == null ? '' : value;
    }
    get [_borderBottomWidth]() {
      return this.borderBottomWidth;
    }
    set [_borderBottomWidth](value) {
      this.borderBottomWidth = value;
    }
    get [dartx.borderCollapse]() {
      return this[_borderCollapse];
    }
    set [dartx.borderCollapse](value) {
      this[_borderCollapse] = value == null ? '' : value;
    }
    get [_borderCollapse]() {
      return this.borderCollapse;
    }
    set [_borderCollapse](value) {
      this.borderCollapse = value;
    }
    get [dartx.borderColor]() {
      return this[_borderColor];
    }
    set [dartx.borderColor](value) {
      this[_borderColor] = value == null ? '' : value;
    }
    get [_borderColor]() {
      return this.borderColor;
    }
    set [_borderColor](value) {
      this.borderColor = value;
    }
    get [dartx.borderLeft]() {
      return this[_borderLeft];
    }
    set [dartx.borderLeft](value) {
      this[_borderLeft] = value == null ? '' : value;
    }
    get [_borderLeft]() {
      return this.borderLeft;
    }
    set [_borderLeft](value) {
      this.borderLeft = value;
    }
    get [dartx.borderLeftColor]() {
      return this[_borderLeftColor];
    }
    set [dartx.borderLeftColor](value) {
      this[_borderLeftColor] = value == null ? '' : value;
    }
    get [_borderLeftColor]() {
      return this.borderLeftColor;
    }
    set [_borderLeftColor](value) {
      this.borderLeftColor = value;
    }
    get [dartx.borderLeftStyle]() {
      return this[_borderLeftStyle];
    }
    set [dartx.borderLeftStyle](value) {
      this[_borderLeftStyle] = value == null ? '' : value;
    }
    get [_borderLeftStyle]() {
      return this.borderLeftStyle;
    }
    set [_borderLeftStyle](value) {
      this.borderLeftStyle = value;
    }
    get [dartx.borderLeftWidth]() {
      return this[_borderLeftWidth];
    }
    set [dartx.borderLeftWidth](value) {
      this[_borderLeftWidth] = value == null ? '' : value;
    }
    get [_borderLeftWidth]() {
      return this.borderLeftWidth;
    }
    set [_borderLeftWidth](value) {
      this.borderLeftWidth = value;
    }
    get [dartx.borderRight]() {
      return this[_borderRight];
    }
    set [dartx.borderRight](value) {
      this[_borderRight] = value == null ? '' : value;
    }
    get [_borderRight]() {
      return this.borderRight;
    }
    set [_borderRight](value) {
      this.borderRight = value;
    }
    get [dartx.borderRightColor]() {
      return this[_borderRightColor];
    }
    set [dartx.borderRightColor](value) {
      this[_borderRightColor] = value == null ? '' : value;
    }
    get [_borderRightColor]() {
      return this.borderRightColor;
    }
    set [_borderRightColor](value) {
      this.borderRightColor = value;
    }
    get [dartx.borderRightStyle]() {
      return this[_borderRightStyle];
    }
    set [dartx.borderRightStyle](value) {
      this[_borderRightStyle] = value == null ? '' : value;
    }
    get [_borderRightStyle]() {
      return this.borderRightStyle;
    }
    set [_borderRightStyle](value) {
      this.borderRightStyle = value;
    }
    get [dartx.borderRightWidth]() {
      return this[_borderRightWidth];
    }
    set [dartx.borderRightWidth](value) {
      this[_borderRightWidth] = value == null ? '' : value;
    }
    get [_borderRightWidth]() {
      return this.borderRightWidth;
    }
    set [_borderRightWidth](value) {
      this.borderRightWidth = value;
    }
    get [dartx.borderSpacing]() {
      return this[_borderSpacing];
    }
    set [dartx.borderSpacing](value) {
      this[_borderSpacing] = value == null ? '' : value;
    }
    get [_borderSpacing]() {
      return this.borderSpacing;
    }
    set [_borderSpacing](value) {
      this.borderSpacing = value;
    }
    get [dartx.borderStyle]() {
      return this[_borderStyle];
    }
    set [dartx.borderStyle](value) {
      this[_borderStyle] = value == null ? '' : value;
    }
    get [_borderStyle]() {
      return this.borderStyle;
    }
    set [_borderStyle](value) {
      this.borderStyle = value;
    }
    get [dartx.borderTop]() {
      return this[_borderTop];
    }
    set [dartx.borderTop](value) {
      this[_borderTop] = value == null ? '' : value;
    }
    get [_borderTop]() {
      return this.borderTop;
    }
    set [_borderTop](value) {
      this.borderTop = value;
    }
    get [dartx.borderTopColor]() {
      return this[_borderTopColor];
    }
    set [dartx.borderTopColor](value) {
      this[_borderTopColor] = value == null ? '' : value;
    }
    get [_borderTopColor]() {
      return this.borderTopColor;
    }
    set [_borderTopColor](value) {
      this.borderTopColor = value;
    }
    get [dartx.borderTopStyle]() {
      return this[_borderTopStyle];
    }
    set [dartx.borderTopStyle](value) {
      this[_borderTopStyle] = value == null ? '' : value;
    }
    get [_borderTopStyle]() {
      return this.borderTopStyle;
    }
    set [_borderTopStyle](value) {
      this.borderTopStyle = value;
    }
    get [dartx.borderTopWidth]() {
      return this[_borderTopWidth];
    }
    set [dartx.borderTopWidth](value) {
      this[_borderTopWidth] = value == null ? '' : value;
    }
    get [_borderTopWidth]() {
      return this.borderTopWidth;
    }
    set [_borderTopWidth](value) {
      this.borderTopWidth = value;
    }
    get [dartx.borderWidth]() {
      return this[_borderWidth];
    }
    set [dartx.borderWidth](value) {
      this[_borderWidth] = value == null ? '' : value;
    }
    get [_borderWidth]() {
      return this.borderWidth;
    }
    set [_borderWidth](value) {
      this.borderWidth = value;
    }
    get [dartx.bottom]() {
      return this[_bottom];
    }
    set [dartx.bottom](value) {
      this[_bottom] = value == null ? '' : value;
    }
    get [_bottom]() {
      return this.bottom;
    }
    set [_bottom](value) {
      this.bottom = value;
    }
    get [dartx.captionSide]() {
      return this[_captionSide];
    }
    set [dartx.captionSide](value) {
      this[_captionSide] = value == null ? '' : value;
    }
    get [_captionSide]() {
      return this.captionSide;
    }
    set [_captionSide](value) {
      this.captionSide = value;
    }
    get [dartx.clear]() {
      return this[_clear$1];
    }
    set [dartx.clear](value) {
      this[_clear$1] = value == null ? '' : value;
    }
    get [_clear$1]() {
      return this.clear;
    }
    set [_clear$1](value) {
      this.clear = value;
    }
    get [dartx.clip]() {
      return this[_clip];
    }
    set [dartx.clip](value) {
      this[_clip] = value == null ? '' : value;
    }
    get [_clip]() {
      return this.clip;
    }
    set [_clip](value) {
      this.clip = value;
    }
    get [dartx.color]() {
      return this[_color];
    }
    set [dartx.color](value) {
      this[_color] = value == null ? '' : value;
    }
    get [_color]() {
      return this.color;
    }
    set [_color](value) {
      this.color = value;
    }
    get [dartx.content]() {
      return this[_content];
    }
    set [dartx.content](value) {
      this[_content] = value == null ? '' : value;
    }
    get [_content]() {
      return this.content;
    }
    set [_content](value) {
      this.content = value;
    }
    get [dartx.cursor]() {
      return this[_cursor];
    }
    set [dartx.cursor](value) {
      this[_cursor] = value == null ? '' : value;
    }
    get [_cursor]() {
      return this.cursor;
    }
    set [_cursor](value) {
      this.cursor = value;
    }
    get [dartx.direction]() {
      return this[_direction];
    }
    set [dartx.direction](value) {
      this[_direction] = value == null ? '' : value;
    }
    get [_direction]() {
      return this.direction;
    }
    set [_direction](value) {
      this.direction = value;
    }
    get [dartx.display]() {
      return this[_display];
    }
    set [dartx.display](value) {
      this[_display] = value == null ? '' : value;
    }
    get [_display]() {
      return this.display;
    }
    set [_display](value) {
      this.display = value;
    }
    get [dartx.emptyCells]() {
      return this[_emptyCells];
    }
    set [dartx.emptyCells](value) {
      this[_emptyCells] = value == null ? '' : value;
    }
    get [_emptyCells]() {
      return this.emptyCells;
    }
    set [_emptyCells](value) {
      this.emptyCells = value;
    }
    get [dartx.font]() {
      return this[_font];
    }
    set [dartx.font](value) {
      this[_font] = value == null ? '' : value;
    }
    get [_font]() {
      return this.font;
    }
    set [_font](value) {
      this.font = value;
    }
    get [dartx.fontFamily]() {
      return this[_fontFamily];
    }
    set [dartx.fontFamily](value) {
      this[_fontFamily] = value == null ? '' : value;
    }
    get [_fontFamily]() {
      return this.fontFamily;
    }
    set [_fontFamily](value) {
      this.fontFamily = value;
    }
    get [dartx.fontSize]() {
      return this[_fontSize];
    }
    set [dartx.fontSize](value) {
      this[_fontSize] = value == null ? '' : value;
    }
    get [_fontSize]() {
      return this.fontSize;
    }
    set [_fontSize](value) {
      this.fontSize = value;
    }
    get [dartx.fontStyle]() {
      return this[_fontStyle];
    }
    set [dartx.fontStyle](value) {
      this[_fontStyle] = value == null ? '' : value;
    }
    get [_fontStyle]() {
      return this.fontStyle;
    }
    set [_fontStyle](value) {
      this.fontStyle = value;
    }
    get [dartx.fontVariant]() {
      return this[_fontVariant];
    }
    set [dartx.fontVariant](value) {
      this[_fontVariant] = value == null ? '' : value;
    }
    get [_fontVariant]() {
      return this.fontVariant;
    }
    set [_fontVariant](value) {
      this.fontVariant = value;
    }
    get [dartx.fontWeight]() {
      return this[_fontWeight];
    }
    set [dartx.fontWeight](value) {
      this[_fontWeight] = value == null ? '' : value;
    }
    get [_fontWeight]() {
      return this.fontWeight;
    }
    set [_fontWeight](value) {
      this.fontWeight = value;
    }
    get [dartx.height]() {
      return this[_height$];
    }
    set [dartx.height](value) {
      this[_height$] = value == null ? '' : value;
    }
    get [_height$]() {
      return this.height;
    }
    set [_height$](value) {
      this.height = value;
    }
    get [dartx.left]() {
      return this[_left];
    }
    set [dartx.left](value) {
      this[_left] = value == null ? '' : value;
    }
    get [_left]() {
      return this.left;
    }
    set [_left](value) {
      this.left = value;
    }
    get [dartx.letterSpacing]() {
      return this[_letterSpacing];
    }
    set [dartx.letterSpacing](value) {
      this[_letterSpacing] = value == null ? '' : value;
    }
    get [_letterSpacing]() {
      return this.letterSpacing;
    }
    set [_letterSpacing](value) {
      this.letterSpacing = value;
    }
    get [dartx.lineHeight]() {
      return this[_lineHeight];
    }
    set [dartx.lineHeight](value) {
      this[_lineHeight] = value == null ? '' : value;
    }
    get [_lineHeight]() {
      return this.lineHeight;
    }
    set [_lineHeight](value) {
      this.lineHeight = value;
    }
    get [dartx.listStyle]() {
      return this[_listStyle];
    }
    set [dartx.listStyle](value) {
      this[_listStyle] = value == null ? '' : value;
    }
    get [_listStyle]() {
      return this.listStyle;
    }
    set [_listStyle](value) {
      this.listStyle = value;
    }
    get [dartx.listStyleImage]() {
      return this[_listStyleImage];
    }
    set [dartx.listStyleImage](value) {
      this[_listStyleImage] = value == null ? '' : value;
    }
    get [_listStyleImage]() {
      return this.listStyleImage;
    }
    set [_listStyleImage](value) {
      this.listStyleImage = value;
    }
    get [dartx.listStylePosition]() {
      return this[_listStylePosition];
    }
    set [dartx.listStylePosition](value) {
      this[_listStylePosition] = value == null ? '' : value;
    }
    get [_listStylePosition]() {
      return this.listStylePosition;
    }
    set [_listStylePosition](value) {
      this.listStylePosition = value;
    }
    get [dartx.listStyleType]() {
      return this[_listStyleType];
    }
    set [dartx.listStyleType](value) {
      this[_listStyleType] = value == null ? '' : value;
    }
    get [_listStyleType]() {
      return this.listStyleType;
    }
    set [_listStyleType](value) {
      this.listStyleType = value;
    }
    get [dartx.margin]() {
      return this[_margin];
    }
    set [dartx.margin](value) {
      this[_margin] = value == null ? '' : value;
    }
    get [_margin]() {
      return this.margin;
    }
    set [_margin](value) {
      this.margin = value;
    }
    get [dartx.marginBottom]() {
      return this[_marginBottom];
    }
    set [dartx.marginBottom](value) {
      this[_marginBottom] = value == null ? '' : value;
    }
    get [_marginBottom]() {
      return this.marginBottom;
    }
    set [_marginBottom](value) {
      this.marginBottom = value;
    }
    get [dartx.marginLeft]() {
      return this[_marginLeft];
    }
    set [dartx.marginLeft](value) {
      this[_marginLeft] = value == null ? '' : value;
    }
    get [_marginLeft]() {
      return this.marginLeft;
    }
    set [_marginLeft](value) {
      this.marginLeft = value;
    }
    get [dartx.marginRight]() {
      return this[_marginRight];
    }
    set [dartx.marginRight](value) {
      this[_marginRight] = value == null ? '' : value;
    }
    get [_marginRight]() {
      return this.marginRight;
    }
    set [_marginRight](value) {
      this.marginRight = value;
    }
    get [dartx.marginTop]() {
      return this[_marginTop];
    }
    set [dartx.marginTop](value) {
      this[_marginTop] = value == null ? '' : value;
    }
    get [_marginTop]() {
      return this.marginTop;
    }
    set [_marginTop](value) {
      this.marginTop = value;
    }
    get [dartx.maxHeight]() {
      return this[_maxHeight];
    }
    set [dartx.maxHeight](value) {
      this[_maxHeight] = value == null ? '' : value;
    }
    get [_maxHeight]() {
      return this.maxHeight;
    }
    set [_maxHeight](value) {
      this.maxHeight = value;
    }
    get [dartx.maxWidth]() {
      return this[_maxWidth];
    }
    set [dartx.maxWidth](value) {
      this[_maxWidth] = value == null ? '' : value;
    }
    get [_maxWidth]() {
      return this.maxWidth;
    }
    set [_maxWidth](value) {
      this.maxWidth = value;
    }
    get [dartx.minHeight]() {
      return this[_minHeight];
    }
    set [dartx.minHeight](value) {
      this[_minHeight] = value == null ? '' : value;
    }
    get [_minHeight]() {
      return this.minHeight;
    }
    set [_minHeight](value) {
      this.minHeight = value;
    }
    get [dartx.minWidth]() {
      return this[_minWidth];
    }
    set [dartx.minWidth](value) {
      this[_minWidth] = value == null ? '' : value;
    }
    get [_minWidth]() {
      return this.minWidth;
    }
    set [_minWidth](value) {
      this.minWidth = value;
    }
    get [dartx.outline]() {
      return this[_outline];
    }
    set [dartx.outline](value) {
      this[_outline] = value == null ? '' : value;
    }
    get [_outline]() {
      return this.outline;
    }
    set [_outline](value) {
      this.outline = value;
    }
    get [dartx.outlineColor]() {
      return this[_outlineColor];
    }
    set [dartx.outlineColor](value) {
      this[_outlineColor] = value == null ? '' : value;
    }
    get [_outlineColor]() {
      return this.outlineColor;
    }
    set [_outlineColor](value) {
      this.outlineColor = value;
    }
    get [dartx.outlineStyle]() {
      return this[_outlineStyle];
    }
    set [dartx.outlineStyle](value) {
      this[_outlineStyle] = value == null ? '' : value;
    }
    get [_outlineStyle]() {
      return this.outlineStyle;
    }
    set [_outlineStyle](value) {
      this.outlineStyle = value;
    }
    get [dartx.outlineWidth]() {
      return this[_outlineWidth];
    }
    set [dartx.outlineWidth](value) {
      this[_outlineWidth] = value == null ? '' : value;
    }
    get [_outlineWidth]() {
      return this.outlineWidth;
    }
    set [_outlineWidth](value) {
      this.outlineWidth = value;
    }
    get [dartx.overflow]() {
      return this[_overflow];
    }
    set [dartx.overflow](value) {
      this[_overflow] = value == null ? '' : value;
    }
    get [_overflow]() {
      return this.overflow;
    }
    set [_overflow](value) {
      this.overflow = value;
    }
    get [dartx.padding]() {
      return this[_padding];
    }
    set [dartx.padding](value) {
      this[_padding] = value == null ? '' : value;
    }
    get [_padding]() {
      return this.padding;
    }
    set [_padding](value) {
      this.padding = value;
    }
    get [dartx.paddingBottom]() {
      return this[_paddingBottom];
    }
    set [dartx.paddingBottom](value) {
      this[_paddingBottom] = value == null ? '' : value;
    }
    get [_paddingBottom]() {
      return this.paddingBottom;
    }
    set [_paddingBottom](value) {
      this.paddingBottom = value;
    }
    get [dartx.paddingLeft]() {
      return this[_paddingLeft];
    }
    set [dartx.paddingLeft](value) {
      this[_paddingLeft] = value == null ? '' : value;
    }
    get [_paddingLeft]() {
      return this.paddingLeft;
    }
    set [_paddingLeft](value) {
      this.paddingLeft = value;
    }
    get [dartx.paddingRight]() {
      return this[_paddingRight];
    }
    set [dartx.paddingRight](value) {
      this[_paddingRight] = value == null ? '' : value;
    }
    get [_paddingRight]() {
      return this.paddingRight;
    }
    set [_paddingRight](value) {
      this.paddingRight = value;
    }
    get [dartx.paddingTop]() {
      return this[_paddingTop];
    }
    set [dartx.paddingTop](value) {
      this[_paddingTop] = value == null ? '' : value;
    }
    get [_paddingTop]() {
      return this.paddingTop;
    }
    set [_paddingTop](value) {
      this.paddingTop = value;
    }
    get [dartx.pageBreakAfter]() {
      return this[_pageBreakAfter];
    }
    set [dartx.pageBreakAfter](value) {
      this[_pageBreakAfter] = value == null ? '' : value;
    }
    get [_pageBreakAfter]() {
      return this.pageBreakAfter;
    }
    set [_pageBreakAfter](value) {
      this.pageBreakAfter = value;
    }
    get [dartx.pageBreakBefore]() {
      return this[_pageBreakBefore];
    }
    set [dartx.pageBreakBefore](value) {
      this[_pageBreakBefore] = value == null ? '' : value;
    }
    get [_pageBreakBefore]() {
      return this.pageBreakBefore;
    }
    set [_pageBreakBefore](value) {
      this.pageBreakBefore = value;
    }
    get [dartx.pageBreakInside]() {
      return this[_pageBreakInside];
    }
    set [dartx.pageBreakInside](value) {
      this[_pageBreakInside] = value == null ? '' : value;
    }
    get [_pageBreakInside]() {
      return this.pageBreakInside;
    }
    set [_pageBreakInside](value) {
      this.pageBreakInside = value;
    }
    get [dartx.position]() {
      return this[_position$0];
    }
    set [dartx.position](value) {
      this[_position$0] = value == null ? '' : value;
    }
    get [_position$0]() {
      return this.position;
    }
    set [_position$0](value) {
      this.position = value;
    }
    get [dartx.quotes]() {
      return this[_quotes];
    }
    set [dartx.quotes](value) {
      this[_quotes] = value == null ? '' : value;
    }
    get [_quotes]() {
      return this.quotes;
    }
    set [_quotes](value) {
      this.quotes = value;
    }
    get [dartx.right]() {
      return this[_right];
    }
    set [dartx.right](value) {
      this[_right] = value == null ? '' : value;
    }
    get [_right]() {
      return this.right;
    }
    set [_right](value) {
      this.right = value;
    }
    get [dartx.tableLayout]() {
      return this[_tableLayout];
    }
    set [dartx.tableLayout](value) {
      this[_tableLayout] = value == null ? '' : value;
    }
    get [_tableLayout]() {
      return this.tableLayout;
    }
    set [_tableLayout](value) {
      this.tableLayout = value;
    }
    get [dartx.textAlign]() {
      return this[_textAlign];
    }
    set [dartx.textAlign](value) {
      this[_textAlign] = value == null ? '' : value;
    }
    get [_textAlign]() {
      return this.textAlign;
    }
    set [_textAlign](value) {
      this.textAlign = value;
    }
    get [dartx.textDecoration]() {
      return this[_textDecoration];
    }
    set [dartx.textDecoration](value) {
      this[_textDecoration] = value == null ? '' : value;
    }
    get [_textDecoration]() {
      return this.textDecoration;
    }
    set [_textDecoration](value) {
      this.textDecoration = value;
    }
    get [dartx.textIndent]() {
      return this[_textIndent];
    }
    set [dartx.textIndent](value) {
      this[_textIndent] = value == null ? '' : value;
    }
    get [_textIndent]() {
      return this.textIndent;
    }
    set [_textIndent](value) {
      this.textIndent = value;
    }
    get [dartx.textTransform]() {
      return this[_textTransform];
    }
    set [dartx.textTransform](value) {
      this[_textTransform] = value == null ? '' : value;
    }
    get [_textTransform]() {
      return this.textTransform;
    }
    set [_textTransform](value) {
      this.textTransform = value;
    }
    get [dartx.top]() {
      return this[_top];
    }
    set [dartx.top](value) {
      this[_top] = value == null ? '' : value;
    }
    get [_top]() {
      return this.top;
    }
    set [_top](value) {
      this.top = value;
    }
    get [dartx.unicodeBidi]() {
      return this[_unicodeBidi];
    }
    set [dartx.unicodeBidi](value) {
      this[_unicodeBidi] = value == null ? '' : value;
    }
    get [_unicodeBidi]() {
      return this.unicodeBidi;
    }
    set [_unicodeBidi](value) {
      this.unicodeBidi = value;
    }
    get [dartx.verticalAlign]() {
      return this[_verticalAlign];
    }
    set [dartx.verticalAlign](value) {
      this[_verticalAlign] = value == null ? '' : value;
    }
    get [_verticalAlign]() {
      return this.verticalAlign;
    }
    set [_verticalAlign](value) {
      this.verticalAlign = value;
    }
    get [dartx.visibility]() {
      return this[_visibility];
    }
    set [dartx.visibility](value) {
      this[_visibility] = value == null ? '' : value;
    }
    get [_visibility]() {
      return this.visibility;
    }
    set [_visibility](value) {
      this.visibility = value;
    }
    get [dartx.whiteSpace]() {
      return this[_whiteSpace];
    }
    set [dartx.whiteSpace](value) {
      this[_whiteSpace] = value == null ? '' : value;
    }
    get [_whiteSpace]() {
      return this.whiteSpace;
    }
    set [_whiteSpace](value) {
      this.whiteSpace = value;
    }
    get [dartx.width]() {
      return this[_width$];
    }
    set [dartx.width](value) {
      this[_width$] = value == null ? '' : value;
    }
    get [_width$]() {
      return this.width;
    }
    set [_width$](value) {
      this.width = value;
    }
    get [dartx.wordSpacing]() {
      return this[_wordSpacing];
    }
    set [dartx.wordSpacing](value) {
      this[_wordSpacing] = value == null ? '' : value;
    }
    get [_wordSpacing]() {
      return this.wordSpacing;
    }
    set [_wordSpacing](value) {
      this.wordSpacing = value;
    }
    get [dartx.zIndex]() {
      return this[_zIndex];
    }
    set [dartx.zIndex](value) {
      this[_zIndex] = value == null ? '' : value;
    }
    get [_zIndex]() {
      return this.zIndex;
    }
    set [_zIndex](value) {
      this.zIndex = value;
    }
  };
  dart.setSignature(html$.CssStyleDeclaration, {
    constructors: () => ({
      new: [html$.CssStyleDeclaration, []],
      css: [html$.CssStyleDeclaration, [core.String]],
      _: [html$.CssStyleDeclaration, []]
    }),
    methods: () => ({
      [dartx.getPropertyValue]: [core.String, [core.String]],
      [_getPropertyValueHelper]: [core.String, [core.String]],
      [dartx.supportsProperty]: [core.bool, [core.String]],
      [_supportsProperty]: [core.bool, [core.String]],
      [dartx.setProperty]: [dart.void, [core.String, core.String], [core.String]],
      [_browserPropertyName]: [core.String, [core.String]],
      [_setPropertyHelper]: [dart.void, [core.String, core.String], [core.String]],
      [dartx.getPropertyPriority]: [core.String, [core.String]],
      [_getPropertyValue]: [core.String, [core.String]],
      [dartx.item]: [core.String, [core.int]],
      [dartx.removeProperty]: [core.String, [core.String]]
    }),
    statics: () => ({
      _readCache: [core.String, [core.String]],
      _writeCache: [dart.void, [core.String, core.String]],
      _camelCase: [core.String, [core.String]]
    }),
    names: ['_readCache', '_writeCache', '_camelCase']
  });
  html$.CssStyleDeclaration[dart.metadata] = () => [dart.const(new _metadata.DomName('CSSStyleDeclaration')), dart.const(new _js_helper.Native("CSSStyleDeclaration,MSStyleCSSProperties,CSS2Properties"))];
  dart.defineLazy(html$.CssStyleDeclaration, {
    get _propertyCache() {
      return {};
    }
  });
  dart.registerExtension(dart.global.CSSStyleDeclaration, html$.CssStyleDeclaration);
  const _elementIterable = Symbol('_elementIterable');
  const _elementCssStyleDeclarationSetIterable = Symbol('_elementCssStyleDeclarationSetIterable');
  const _setAll = Symbol('_setAll');
  html$._CssStyleDeclarationSet = class _CssStyleDeclarationSet extends dart.mixin(core.Object, html$.CssStyleDeclarationBase) {
    _CssStyleDeclarationSet(elementIterable) {
      this[_elementIterable] = elementIterable;
      this[_elementCssStyleDeclarationSetIterable] = null;
      this[_elementCssStyleDeclarationSetIterable] = core.List.from(this[_elementIterable])[dartx.map](html$.CssStyleDeclaration)(dart.fn(e => dart.as(dart.dload(e, 'style'), html$.CssStyleDeclaration), html$.CssStyleDeclaration, [dart.dynamic]));
    }
    getPropertyValue(propertyName) {
      return this[_elementCssStyleDeclarationSetIterable][dartx.first][dartx.getPropertyValue](propertyName);
    }
    setProperty(propertyName, value, priority) {
      if (priority === void 0) priority = null;
      this[_elementCssStyleDeclarationSetIterable][dartx.forEach](dart.fn(e => e[dartx.setProperty](propertyName, value, priority), dart.void, [html$.CssStyleDeclaration]));
    }
    [_setAll](propertyName, value) {
      value = value == null ? '' : value;
      for (let element of this[_elementIterable]) {
        element.style[propertyName] = value;
      }
    }
    set background(value) {
      this[_setAll]('background', value);
    }
    get background() {
      return super.background;
    }
    set backgroundAttachment(value) {
      this[_setAll]('backgroundAttachment', value);
    }
    get backgroundAttachment() {
      return super.backgroundAttachment;
    }
    set backgroundColor(value) {
      this[_setAll]('backgroundColor', value);
    }
    get backgroundColor() {
      return super.backgroundColor;
    }
    set backgroundImage(value) {
      this[_setAll]('backgroundImage', value);
    }
    get backgroundImage() {
      return super.backgroundImage;
    }
    set backgroundPosition(value) {
      this[_setAll]('backgroundPosition', value);
    }
    get backgroundPosition() {
      return super.backgroundPosition;
    }
    set backgroundRepeat(value) {
      this[_setAll]('backgroundRepeat', value);
    }
    get backgroundRepeat() {
      return super.backgroundRepeat;
    }
    set border(value) {
      this[_setAll]('border', value);
    }
    get border() {
      return super.border;
    }
    set borderBottom(value) {
      this[_setAll]('borderBottom', value);
    }
    get borderBottom() {
      return super.borderBottom;
    }
    set borderBottomColor(value) {
      this[_setAll]('borderBottomColor', value);
    }
    get borderBottomColor() {
      return super.borderBottomColor;
    }
    set borderBottomStyle(value) {
      this[_setAll]('borderBottomStyle', value);
    }
    get borderBottomStyle() {
      return super.borderBottomStyle;
    }
    set borderBottomWidth(value) {
      this[_setAll]('borderBottomWidth', value);
    }
    get borderBottomWidth() {
      return super.borderBottomWidth;
    }
    set borderCollapse(value) {
      this[_setAll]('borderCollapse', value);
    }
    get borderCollapse() {
      return super.borderCollapse;
    }
    set borderColor(value) {
      this[_setAll]('borderColor', value);
    }
    get borderColor() {
      return super.borderColor;
    }
    set borderLeft(value) {
      this[_setAll]('borderLeft', value);
    }
    get borderLeft() {
      return super.borderLeft;
    }
    set borderLeftColor(value) {
      this[_setAll]('borderLeftColor', value);
    }
    get borderLeftColor() {
      return super.borderLeftColor;
    }
    set borderLeftStyle(value) {
      this[_setAll]('borderLeftStyle', value);
    }
    get borderLeftStyle() {
      return super.borderLeftStyle;
    }
    set borderLeftWidth(value) {
      this[_setAll]('borderLeftWidth', value);
    }
    get borderLeftWidth() {
      return super.borderLeftWidth;
    }
    set borderRight(value) {
      this[_setAll]('borderRight', value);
    }
    get borderRight() {
      return super.borderRight;
    }
    set borderRightColor(value) {
      this[_setAll]('borderRightColor', value);
    }
    get borderRightColor() {
      return super.borderRightColor;
    }
    set borderRightStyle(value) {
      this[_setAll]('borderRightStyle', value);
    }
    get borderRightStyle() {
      return super.borderRightStyle;
    }
    set borderRightWidth(value) {
      this[_setAll]('borderRightWidth', value);
    }
    get borderRightWidth() {
      return super.borderRightWidth;
    }
    set borderSpacing(value) {
      this[_setAll]('borderSpacing', value);
    }
    get borderSpacing() {
      return super.borderSpacing;
    }
    set borderStyle(value) {
      this[_setAll]('borderStyle', value);
    }
    get borderStyle() {
      return super.borderStyle;
    }
    set borderTop(value) {
      this[_setAll]('borderTop', value);
    }
    get borderTop() {
      return super.borderTop;
    }
    set borderTopColor(value) {
      this[_setAll]('borderTopColor', value);
    }
    get borderTopColor() {
      return super.borderTopColor;
    }
    set borderTopStyle(value) {
      this[_setAll]('borderTopStyle', value);
    }
    get borderTopStyle() {
      return super.borderTopStyle;
    }
    set borderTopWidth(value) {
      this[_setAll]('borderTopWidth', value);
    }
    get borderTopWidth() {
      return super.borderTopWidth;
    }
    set borderWidth(value) {
      this[_setAll]('borderWidth', value);
    }
    get borderWidth() {
      return super.borderWidth;
    }
    set bottom(value) {
      this[_setAll]('bottom', value);
    }
    get bottom() {
      return super.bottom;
    }
    set captionSide(value) {
      this[_setAll]('captionSide', value);
    }
    get captionSide() {
      return super.captionSide;
    }
    set clear(value) {
      this[_setAll]('clear', value);
    }
    get clear() {
      return super.clear;
    }
    set clip(value) {
      this[_setAll]('clip', value);
    }
    get clip() {
      return super.clip;
    }
    set color(value) {
      this[_setAll]('color', value);
    }
    get color() {
      return super.color;
    }
    set content(value) {
      this[_setAll]('content', value);
    }
    get content() {
      return super.content;
    }
    set cursor(value) {
      this[_setAll]('cursor', value);
    }
    get cursor() {
      return super.cursor;
    }
    set direction(value) {
      this[_setAll]('direction', value);
    }
    get direction() {
      return super.direction;
    }
    set display(value) {
      this[_setAll]('display', value);
    }
    get display() {
      return super.display;
    }
    set emptyCells(value) {
      this[_setAll]('emptyCells', value);
    }
    get emptyCells() {
      return super.emptyCells;
    }
    set font(value) {
      this[_setAll]('font', value);
    }
    get font() {
      return super.font;
    }
    set fontFamily(value) {
      this[_setAll]('fontFamily', value);
    }
    get fontFamily() {
      return super.fontFamily;
    }
    set fontSize(value) {
      this[_setAll]('fontSize', value);
    }
    get fontSize() {
      return super.fontSize;
    }
    set fontStyle(value) {
      this[_setAll]('fontStyle', value);
    }
    get fontStyle() {
      return super.fontStyle;
    }
    set fontVariant(value) {
      this[_setAll]('fontVariant', value);
    }
    get fontVariant() {
      return super.fontVariant;
    }
    set fontWeight(value) {
      this[_setAll]('fontWeight', value);
    }
    get fontWeight() {
      return super.fontWeight;
    }
    set height(value) {
      this[_setAll]('height', value);
    }
    get height() {
      return super.height;
    }
    set left(value) {
      this[_setAll]('left', value);
    }
    get left() {
      return super.left;
    }
    set letterSpacing(value) {
      this[_setAll]('letterSpacing', value);
    }
    get letterSpacing() {
      return super.letterSpacing;
    }
    set lineHeight(value) {
      this[_setAll]('lineHeight', value);
    }
    get lineHeight() {
      return super.lineHeight;
    }
    set listStyle(value) {
      this[_setAll]('listStyle', value);
    }
    get listStyle() {
      return super.listStyle;
    }
    set listStyleImage(value) {
      this[_setAll]('listStyleImage', value);
    }
    get listStyleImage() {
      return super.listStyleImage;
    }
    set listStylePosition(value) {
      this[_setAll]('listStylePosition', value);
    }
    get listStylePosition() {
      return super.listStylePosition;
    }
    set listStyleType(value) {
      this[_setAll]('listStyleType', value);
    }
    get listStyleType() {
      return super.listStyleType;
    }
    set margin(value) {
      this[_setAll]('margin', value);
    }
    get margin() {
      return super.margin;
    }
    set marginBottom(value) {
      this[_setAll]('marginBottom', value);
    }
    get marginBottom() {
      return super.marginBottom;
    }
    set marginLeft(value) {
      this[_setAll]('marginLeft', value);
    }
    get marginLeft() {
      return super.marginLeft;
    }
    set marginRight(value) {
      this[_setAll]('marginRight', value);
    }
    get marginRight() {
      return super.marginRight;
    }
    set marginTop(value) {
      this[_setAll]('marginTop', value);
    }
    get marginTop() {
      return super.marginTop;
    }
    set maxHeight(value) {
      this[_setAll]('maxHeight', value);
    }
    get maxHeight() {
      return super.maxHeight;
    }
    set maxWidth(value) {
      this[_setAll]('maxWidth', value);
    }
    get maxWidth() {
      return super.maxWidth;
    }
    set minHeight(value) {
      this[_setAll]('minHeight', value);
    }
    get minHeight() {
      return super.minHeight;
    }
    set minWidth(value) {
      this[_setAll]('minWidth', value);
    }
    get minWidth() {
      return super.minWidth;
    }
    set outline(value) {
      this[_setAll]('outline', value);
    }
    get outline() {
      return super.outline;
    }
    set outlineColor(value) {
      this[_setAll]('outlineColor', value);
    }
    get outlineColor() {
      return super.outlineColor;
    }
    set outlineStyle(value) {
      this[_setAll]('outlineStyle', value);
    }
    get outlineStyle() {
      return super.outlineStyle;
    }
    set outlineWidth(value) {
      this[_setAll]('outlineWidth', value);
    }
    get outlineWidth() {
      return super.outlineWidth;
    }
    set overflow(value) {
      this[_setAll]('overflow', value);
    }
    get overflow() {
      return super.overflow;
    }
    set padding(value) {
      this[_setAll]('padding', value);
    }
    get padding() {
      return super.padding;
    }
    set paddingBottom(value) {
      this[_setAll]('paddingBottom', value);
    }
    get paddingBottom() {
      return super.paddingBottom;
    }
    set paddingLeft(value) {
      this[_setAll]('paddingLeft', value);
    }
    get paddingLeft() {
      return super.paddingLeft;
    }
    set paddingRight(value) {
      this[_setAll]('paddingRight', value);
    }
    get paddingRight() {
      return super.paddingRight;
    }
    set paddingTop(value) {
      this[_setAll]('paddingTop', value);
    }
    get paddingTop() {
      return super.paddingTop;
    }
    set pageBreakAfter(value) {
      this[_setAll]('pageBreakAfter', value);
    }
    get pageBreakAfter() {
      return super.pageBreakAfter;
    }
    set pageBreakBefore(value) {
      this[_setAll]('pageBreakBefore', value);
    }
    get pageBreakBefore() {
      return super.pageBreakBefore;
    }
    set pageBreakInside(value) {
      this[_setAll]('pageBreakInside', value);
    }
    get pageBreakInside() {
      return super.pageBreakInside;
    }
    set position(value) {
      this[_setAll]('position', value);
    }
    get position() {
      return super.position;
    }
    set quotes(value) {
      this[_setAll]('quotes', value);
    }
    get quotes() {
      return super.quotes;
    }
    set right(value) {
      this[_setAll]('right', value);
    }
    get right() {
      return super.right;
    }
    set tableLayout(value) {
      this[_setAll]('tableLayout', value);
    }
    get tableLayout() {
      return super.tableLayout;
    }
    set textAlign(value) {
      this[_setAll]('textAlign', value);
    }
    get textAlign() {
      return super.textAlign;
    }
    set textDecoration(value) {
      this[_setAll]('textDecoration', value);
    }
    get textDecoration() {
      return super.textDecoration;
    }
    set textIndent(value) {
      this[_setAll]('textIndent', value);
    }
    get textIndent() {
      return super.textIndent;
    }
    set textTransform(value) {
      this[_setAll]('textTransform', value);
    }
    get textTransform() {
      return super.textTransform;
    }
    set top(value) {
      this[_setAll]('top', value);
    }
    get top() {
      return super.top;
    }
    set unicodeBidi(value) {
      this[_setAll]('unicodeBidi', value);
    }
    get unicodeBidi() {
      return super.unicodeBidi;
    }
    set verticalAlign(value) {
      this[_setAll]('verticalAlign', value);
    }
    get verticalAlign() {
      return super.verticalAlign;
    }
    set visibility(value) {
      this[_setAll]('visibility', value);
    }
    get visibility() {
      return super.visibility;
    }
    set whiteSpace(value) {
      this[_setAll]('whiteSpace', value);
    }
    get whiteSpace() {
      return super.whiteSpace;
    }
    set width(value) {
      this[_setAll]('width', value);
    }
    get width() {
      return super.width;
    }
    set wordSpacing(value) {
      this[_setAll]('wordSpacing', value);
    }
    get wordSpacing() {
      return super.wordSpacing;
    }
    set zIndex(value) {
      this[_setAll]('zIndex', value);
    }
    get zIndex() {
      return super.zIndex;
    }
  };
  dart.setSignature(html$._CssStyleDeclarationSet, {
    constructors: () => ({_CssStyleDeclarationSet: [html$._CssStyleDeclarationSet, [core.Iterable$(html$.Element)]]}),
    methods: () => ({
      getPropertyValue: [core.String, [core.String]],
      setProperty: [dart.void, [core.String, core.String], [core.String]],
      [_setAll]: [dart.void, [core.String, core.String]]
    })
  });
  dart.defineExtensionMembers(html$._CssStyleDeclarationSet, [
    'getPropertyValue',
    'setProperty',
    'background',
    'backgroundAttachment',
    'backgroundColor',
    'backgroundImage',
    'backgroundPosition',
    'backgroundRepeat',
    'border',
    'borderBottom',
    'borderBottomColor',
    'borderBottomStyle',
    'borderBottomWidth',
    'borderCollapse',
    'borderColor',
    'borderLeft',
    'borderLeftColor',
    'borderLeftStyle',
    'borderLeftWidth',
    'borderRight',
    'borderRightColor',
    'borderRightStyle',
    'borderRightWidth',
    'borderSpacing',
    'borderStyle',
    'borderTop',
    'borderTopColor',
    'borderTopStyle',
    'borderTopWidth',
    'borderWidth',
    'bottom',
    'captionSide',
    'clear',
    'clip',
    'color',
    'content',
    'cursor',
    'direction',
    'display',
    'emptyCells',
    'font',
    'fontFamily',
    'fontSize',
    'fontStyle',
    'fontVariant',
    'fontWeight',
    'height',
    'left',
    'letterSpacing',
    'lineHeight',
    'listStyle',
    'listStyleImage',
    'listStylePosition',
    'listStyleType',
    'margin',
    'marginBottom',
    'marginLeft',
    'marginRight',
    'marginTop',
    'maxHeight',
    'maxWidth',
    'minHeight',
    'minWidth',
    'outline',
    'outlineColor',
    'outlineStyle',
    'outlineWidth',
    'overflow',
    'padding',
    'paddingBottom',
    'paddingLeft',
    'paddingRight',
    'paddingTop',
    'pageBreakAfter',
    'pageBreakBefore',
    'pageBreakInside',
    'position',
    'quotes',
    'right',
    'tableLayout',
    'textAlign',
    'textDecoration',
    'textIndent',
    'textTransform',
    'top',
    'unicodeBidi',
    'verticalAlign',
    'visibility',
    'whiteSpace',
    'width',
    'wordSpacing',
    'zIndex'
  ]);
  dart.defineExtensionNames([
    'selectorText',
    'style'
  ]);
  html$.CssStyleRule = class CssStyleRule extends html$.CssRule {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.selectorText]() {
      return this.selectorText;
    }
    set [dartx.selectorText](value) {
      this.selectorText = value;
    }
    get [dartx.style]() {
      return this.style;
    }
  };
  dart.setSignature(html$.CssStyleRule, {
    constructors: () => ({_: [html$.CssStyleRule, []]})
  });
  html$.CssStyleRule[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CSSStyleRule')), dart.const(new _js_helper.Native("CSSStyleRule"))];
  dart.registerExtension(dart.global.CSSStyleRule, html$.CssStyleRule);
  dart.defineExtensionNames([
    'disabled',
    'href',
    'media',
    'ownerNode',
    'parentStyleSheet',
    'title',
    'type'
  ]);
  html$.StyleSheet = class StyleSheet extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.disabled]() {
      return this.disabled;
    }
    set [dartx.disabled](value) {
      this.disabled = value;
    }
    get [dartx.href]() {
      return this.href;
    }
    get [dartx.media]() {
      return this.media;
    }
    get [dartx.ownerNode]() {
      return this.ownerNode;
    }
    get [dartx.parentStyleSheet]() {
      return this.parentStyleSheet;
    }
    get [dartx.title]() {
      return this.title;
    }
    get [dartx.type]() {
      return this.type;
    }
  };
  dart.setSignature(html$.StyleSheet, {
    constructors: () => ({_: [html$.StyleSheet, []]})
  });
  html$.StyleSheet[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('StyleSheet')), dart.const(new _js_helper.Native("StyleSheet"))];
  dart.registerExtension(dart.global.StyleSheet, html$.StyleSheet);
  dart.defineExtensionNames([
    'addRule',
    'deleteRule',
    'insertRule',
    'removeRule',
    'cssRules',
    'ownerRule',
    'rules'
  ]);
  html$.CssStyleSheet = class CssStyleSheet extends html$.StyleSheet {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.cssRules]() {
      return this.cssRules;
    }
    get [dartx.ownerRule]() {
      return this.ownerRule;
    }
    get [dartx.rules]() {
      return this.rules;
    }
    [dartx.addRule](selector, style, index) {
      return this.addRule(selector, style, index);
    }
    [dartx.deleteRule](index) {
      return this.deleteRule(index);
    }
    [dartx.insertRule](rule, index) {
      return this.insertRule(rule, index);
    }
    [dartx.removeRule](index) {
      return this.removeRule(index);
    }
  };
  dart.setSignature(html$.CssStyleSheet, {
    constructors: () => ({_: [html$.CssStyleSheet, []]}),
    methods: () => ({
      [dartx.addRule]: [core.int, [core.String, core.String], [core.int]],
      [dartx.deleteRule]: [dart.void, [core.int]],
      [dartx.insertRule]: [core.int, [core.String], [core.int]],
      [dartx.removeRule]: [dart.void, [core.int]]
    })
  });
  html$.CssStyleSheet[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CSSStyleSheet')), dart.const(new _js_helper.Native("CSSStyleSheet"))];
  dart.registerExtension(dart.global.CSSStyleSheet, html$.CssStyleSheet);
  dart.defineExtensionNames([
    'deleteRule',
    'insertRule',
    'conditionText',
    'cssRules'
  ]);
  html$.CssSupportsRule = class CssSupportsRule extends html$.CssRule {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.conditionText]() {
      return this.conditionText;
    }
    get [dartx.cssRules]() {
      return this.cssRules;
    }
    [dartx.deleteRule](index) {
      return this.deleteRule(index);
    }
    [dartx.insertRule](rule, index) {
      return this.insertRule(rule, index);
    }
  };
  dart.setSignature(html$.CssSupportsRule, {
    constructors: () => ({_: [html$.CssSupportsRule, []]}),
    methods: () => ({
      [dartx.deleteRule]: [dart.void, [core.int]],
      [dartx.insertRule]: [core.int, [core.String, core.int]]
    })
  });
  html$.CssSupportsRule[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CSSSupportsRule')), dart.const(new _js_helper.Native("CSSSupportsRule"))];
  dart.registerExtension(dart.global.CSSSupportsRule, html$.CssSupportsRule);
  dart.defineExtensionNames([
    'style'
  ]);
  html$.CssViewportRule = class CssViewportRule extends html$.CssRule {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.style]() {
      return this.style;
    }
  };
  dart.setSignature(html$.CssViewportRule, {
    constructors: () => ({_: [html$.CssViewportRule, []]})
  });
  html$.CssViewportRule[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CSSViewportRule')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("CSSViewportRule"))];
  dart.registerExtension(dart.global.CSSViewportRule, html$.CssViewportRule);
  const _dartDetail = Symbol('_dartDetail');
  const _initCustomEvent = Symbol('_initCustomEvent');
  const _detail = Symbol('_detail');
  const _get__detail = Symbol('_get__detail');
  dart.defineExtensionNames([
    'detail'
  ]);
  html$.CustomEvent = class CustomEvent extends html$.Event {
    get [_dartDetail]() {
      return this._dartDetail;
    }
    set [_dartDetail](value) {
      this._dartDetail = value;
    }
    static new(type, opts) {
      let canBubble = opts && 'canBubble' in opts ? opts.canBubble : true;
      let cancelable = opts && 'cancelable' in opts ? opts.cancelable : true;
      let detail = opts && 'detail' in opts ? opts.detail : null;
      let e = dart.as(html$.document[_createEvent]('CustomEvent'), html$.CustomEvent);
      e[_dartDetail] = detail;
      if (dart.is(detail, core.List) || dart.is(detail, core.Map) || typeof detail == 'string' || typeof detail == 'number') {
        try {
          detail = html_common.convertDartToNative_SerializedScriptValue(detail);
          e[_initCustomEvent](type, canBubble, cancelable, detail);
        } catch (_) {
          e[_initCustomEvent](type, canBubble, cancelable, null);
        }

      } else {
        e[_initCustomEvent](type, canBubble, cancelable, null);
      }
      return e;
    }
    get [dartx.detail]() {
      if (this[_dartDetail] != null) {
        return this[_dartDetail];
      }
      return this[_detail];
    }
    static _(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.CustomEvent._create_1(type, eventInitDict_1);
      }
      return html$.CustomEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new CustomEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new CustomEvent(type);
    }
    get [_detail]() {
      return html_common.convertNativeToDart_SerializedScriptValue(this[_get__detail]);
    }
    get [_get__detail]() {
      return this.detail;
    }
    [_initCustomEvent](type, bubbles, cancelable, detail) {
      return this.initCustomEvent(type, bubbles, cancelable, detail);
    }
  };
  dart.setSignature(html$.CustomEvent, {
    constructors: () => ({
      new: [html$.CustomEvent, [core.String], {canBubble: core.bool, cancelable: core.bool, detail: core.Object}],
      _: [html$.CustomEvent, [core.String], [core.Map]]
    }),
    methods: () => ({[_initCustomEvent]: [dart.void, [core.String, core.bool, core.bool, core.Object]]}),
    statics: () => ({
      _create_1: [html$.CustomEvent, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.CustomEvent, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.CustomEvent[dart.metadata] = () => [dart.const(new _metadata.DomName('CustomEvent')), dart.const(new _js_helper.Native("CustomEvent"))];
  dart.registerExtension(dart.global.CustomEvent, html$.CustomEvent);
  html$.DListElement = class DListElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("dl"), html$.DListElement);
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(html$.DListElement, 'created');
  dart.setSignature(html$.DListElement, {
    constructors: () => ({
      _: [html$.DListElement, []],
      new: [html$.DListElement, []],
      created: [html$.DListElement, []]
    })
  });
  html$.DListElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLDListElement')), dart.const(new _js_helper.Native("HTMLDListElement"))];
  dart.registerExtension(dart.global.HTMLDListElement, html$.DListElement);
  dart.defineExtensionNames([
    'options'
  ]);
  html$.DataListElement = class DataListElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("datalist"), html$.DataListElement);
    }
    created() {
      this[dartx.options] = null;
      super.created();
    }
    static get supported() {
      return html$.Element.isTagSupported('datalist');
    }
    get [dartx.options]() {
      return this.options;
    }
  };
  dart.defineNamedConstructor(html$.DataListElement, 'created');
  dart.setSignature(html$.DataListElement, {
    constructors: () => ({
      _: [html$.DataListElement, []],
      new: [html$.DataListElement, []],
      created: [html$.DataListElement, []]
    })
  });
  html$.DataListElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLDataListElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _js_helper.Native("HTMLDataListElement"))];
  dart.registerExtension(dart.global.HTMLDataListElement, html$.DataListElement);
  dart.defineExtensionNames([
    'clearData',
    'getData',
    'setData',
    'setDragImage',
    'dropEffect',
    'effectAllowed',
    'files',
    'items',
    'types'
  ]);
  html$.DataTransfer = class DataTransfer extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.dropEffect]() {
      return this.dropEffect;
    }
    set [dartx.dropEffect](value) {
      this.dropEffect = value;
    }
    get [dartx.effectAllowed]() {
      return this.effectAllowed;
    }
    set [dartx.effectAllowed](value) {
      this.effectAllowed = value;
    }
    get [dartx.files]() {
      return this.files;
    }
    get [dartx.items]() {
      return this.items;
    }
    get [dartx.types]() {
      return this.types;
    }
    [dartx.clearData](format) {
      return this.clearData(format);
    }
    [dartx.getData](format) {
      return this.getData(format);
    }
    [dartx.setData](format, data) {
      return this.setData(format, data);
    }
    [dartx.setDragImage](image, x, y) {
      return this.setDragImage(image, x, y);
    }
  };
  dart.setSignature(html$.DataTransfer, {
    constructors: () => ({_: [html$.DataTransfer, []]}),
    methods: () => ({
      [dartx.clearData]: [dart.void, [], [core.String]],
      [dartx.getData]: [core.String, [core.String]],
      [dartx.setData]: [dart.void, [core.String, core.String]],
      [dartx.setDragImage]: [dart.void, [html$.Element, core.int, core.int]]
    })
  });
  html$.DataTransfer[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DataTransfer')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("DataTransfer"))];
  dart.registerExtension(dart.global.DataTransfer, html$.DataTransfer);
  const _getAsString = Symbol('_getAsString');
  dart.defineExtensionNames([
    'getAsFile',
    'getAsString',
    'getAsEntry',
    'kind',
    'type'
  ]);
  html$.DataTransferItem = class DataTransferItem extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.kind]() {
      return this.kind;
    }
    get [dartx.type]() {
      return this.type;
    }
    [dartx.getAsFile]() {
      return this.getAsFile();
    }
    [_getAsString](callback) {
      return this.getAsString(callback);
    }
    [dartx.getAsString]() {
      let completer = async.Completer$(core.String).new();
      this[_getAsString](dart.fn(value => {
        completer.complete(value);
      }, dart.void, [core.String]));
      return completer.future;
    }
    [dartx.getAsEntry]() {
      return this.webkitGetAsEntry();
    }
  };
  dart.setSignature(html$.DataTransferItem, {
    constructors: () => ({_: [html$.DataTransferItem, []]}),
    methods: () => ({
      [dartx.getAsFile]: [html$.Blob, []],
      [_getAsString]: [dart.void, [html$._StringCallback]],
      [dartx.getAsString]: [async.Future$(core.String), []],
      [dartx.getAsEntry]: [html$.Entry, []]
    })
  });
  html$.DataTransferItem[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DataTransferItem')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("DataTransferItem"))];
  dart.registerExtension(dart.global.DataTransferItem, html$.DataTransferItem);
  dart.defineExtensionNames([
    'add',
    'addData',
    'addFile',
    'clear',
    'item',
    'remove',
    'get',
    'length'
  ]);
  html$.DataTransferItemList = class DataTransferItemList extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.add](data_OR_file, type) {
      return this.add(data_OR_file, type);
    }
    [dartx.addData](data, type) {
      return this.add(data, type);
    }
    [dartx.addFile](file) {
      return this.add(file);
    }
    [dartx.clear]() {
      return this.clear();
    }
    [dartx.item](index) {
      return this.item(index);
    }
    [dartx.remove](index) {
      return this.remove(index);
    }
    [dartx.get](index) {
      return this[index];
    }
  };
  dart.setSignature(html$.DataTransferItemList, {
    constructors: () => ({_: [html$.DataTransferItemList, []]}),
    methods: () => ({
      [dartx.add]: [html$.DataTransferItem, [dart.dynamic], [core.String]],
      [dartx.addData]: [html$.DataTransferItem, [core.String, core.String]],
      [dartx.addFile]: [html$.DataTransferItem, [html$.File]],
      [dartx.clear]: [dart.void, []],
      [dartx.item]: [html$.DataTransferItem, [core.int]],
      [dartx.remove]: [dart.void, [core.int]],
      [dartx.get]: [html$.DataTransferItem, [core.int]]
    })
  });
  html$.DataTransferItemList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DataTransferItemList')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("DataTransferItemList"))];
  dart.registerExtension(dart.global.DataTransferItemList, html$.DataTransferItemList);
  html$.DatabaseCallback = dart.typedef('DatabaseCallback', () => dart.functionType(dart.void, [web_sql.SqlDatabase]));
  dart.defineExtensionNames([
    'postMessage',
    'onMessage'
  ]);
  html$.DedicatedWorkerGlobalScope = class DedicatedWorkerGlobalScope extends html$.WorkerGlobalScope {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.postMessage](message, transfer) {
      if (transfer === void 0) transfer = null;
      if (transfer != null) {
        let message_1 = html_common.convertDartToNative_SerializedScriptValue(message);
        this[_postMessage_1](message_1, transfer);
        return;
      }
      let message_1 = html_common.convertDartToNative_SerializedScriptValue(message);
      this[_postMessage_2](message_1);
      return;
    }
    [_postMessage_1](message, transfer) {
      return this.postMessage(message, transfer);
    }
    [_postMessage_2](message) {
      return this.postMessage(message);
    }
    get [dartx.onMessage]() {
      return html$.DedicatedWorkerGlobalScope.messageEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.DedicatedWorkerGlobalScope, {
    constructors: () => ({_: [html$.DedicatedWorkerGlobalScope, []]}),
    methods: () => ({
      [dartx.postMessage]: [dart.void, [dart.dynamic], [core.List$(html$.MessagePort)]],
      [_postMessage_1]: [dart.void, [dart.dynamic, core.List$(html$.MessagePort)]],
      [_postMessage_2]: [dart.void, [dart.dynamic]]
    })
  });
  html$.DedicatedWorkerGlobalScope[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DedicatedWorkerGlobalScope')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("DedicatedWorkerGlobalScope"))];
  dart.defineLazy(html$.DedicatedWorkerGlobalScope, {
    get messageEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MessageEvent))('message'));
    }
  });
  dart.registerExtension(dart.global.DedicatedWorkerGlobalScope, html$.DedicatedWorkerGlobalScope);
  dart.defineExtensionNames([
    'session'
  ]);
  html$.DefaultSessionStartEvent = class DefaultSessionStartEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.DefaultSessionStartEvent._create_1(type, eventInitDict_1);
      }
      return html$.DefaultSessionStartEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new DefaultSessionStartEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new DefaultSessionStartEvent(type);
    }
    get [dartx.session]() {
      return this.session;
    }
  };
  dart.setSignature(html$.DefaultSessionStartEvent, {
    constructors: () => ({
      _: [html$.DefaultSessionStartEvent, []],
      new: [html$.DefaultSessionStartEvent, [core.String], [core.Map]]
    }),
    statics: () => ({
      _create_1: [html$.DefaultSessionStartEvent, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.DefaultSessionStartEvent, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.DefaultSessionStartEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DefaultSessionStartEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("DefaultSessionStartEvent"))];
  dart.registerExtension(dart.global.DefaultSessionStartEvent, html$.DefaultSessionStartEvent);
  dart.defineExtensionNames([
    'queryUsageAndQuota',
    'requestQuota'
  ]);
  html$.DeprecatedStorageInfo = class DeprecatedStorageInfo extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.queryUsageAndQuota](storageType, usageCallback, errorCallback) {
      return this.queryUsageAndQuota(storageType, usageCallback, errorCallback);
    }
    [dartx.requestQuota](storageType, newQuotaInBytes, quotaCallback, errorCallback) {
      return this.requestQuota(storageType, newQuotaInBytes, quotaCallback, errorCallback);
    }
  };
  dart.setSignature(html$.DeprecatedStorageInfo, {
    constructors: () => ({_: [html$.DeprecatedStorageInfo, []]}),
    methods: () => ({
      [dartx.queryUsageAndQuota]: [dart.void, [core.int], [html$.StorageUsageCallback, html$.StorageErrorCallback]],
      [dartx.requestQuota]: [dart.void, [core.int, core.int], [html$.StorageQuotaCallback, html$.StorageErrorCallback]]
    })
  });
  html$.DeprecatedStorageInfo[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DeprecatedStorageInfo')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("DeprecatedStorageInfo"))];
  html$.DeprecatedStorageInfo.PERSISTENT = 1;
  html$.DeprecatedStorageInfo.TEMPORARY = 0;
  dart.registerExtension(dart.global.DeprecatedStorageInfo, html$.DeprecatedStorageInfo);
  dart.defineExtensionNames([
    'queryUsageAndQuota',
    'requestQuota'
  ]);
  html$.DeprecatedStorageQuota = class DeprecatedStorageQuota extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.queryUsageAndQuota](usageCallback, errorCallback) {
      return this.queryUsageAndQuota(usageCallback, errorCallback);
    }
    [dartx.requestQuota](newQuotaInBytes, quotaCallback, errorCallback) {
      return this.requestQuota(newQuotaInBytes, quotaCallback, errorCallback);
    }
  };
  dart.setSignature(html$.DeprecatedStorageQuota, {
    constructors: () => ({_: [html$.DeprecatedStorageQuota, []]}),
    methods: () => ({
      [dartx.queryUsageAndQuota]: [dart.void, [html$.StorageUsageCallback], [html$.StorageErrorCallback]],
      [dartx.requestQuota]: [dart.void, [core.int], [html$.StorageQuotaCallback, html$.StorageErrorCallback]]
    })
  });
  html$.DeprecatedStorageQuota[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DeprecatedStorageQuota')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("DeprecatedStorageQuota"))];
  dart.registerExtension(dart.global.DeprecatedStorageQuota, html$.DeprecatedStorageQuota);
  dart.defineExtensionNames([
    'open'
  ]);
  html$.DetailsElement = class DetailsElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("details"), html$.DetailsElement);
    }
    created() {
      this[dartx.open] = null;
      super.created();
    }
    static get supported() {
      return html$.Element.isTagSupported('details');
    }
    get [dartx.open]() {
      return this.open;
    }
    set [dartx.open](value) {
      this.open = value;
    }
  };
  dart.defineNamedConstructor(html$.DetailsElement, 'created');
  dart.setSignature(html$.DetailsElement, {
    constructors: () => ({
      _: [html$.DetailsElement, []],
      new: [html$.DetailsElement, []],
      created: [html$.DetailsElement, []]
    })
  });
  html$.DetailsElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLDetailsElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("HTMLDetailsElement"))];
  dart.registerExtension(dart.global.HTMLDetailsElement, html$.DetailsElement);
  dart.defineExtensionNames([
    'x',
    'y',
    'z'
  ]);
  html$.DeviceAcceleration = class DeviceAcceleration extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
    get [dartx.z]() {
      return this.z;
    }
  };
  dart.setSignature(html$.DeviceAcceleration, {
    constructors: () => ({_: [html$.DeviceAcceleration, []]})
  });
  html$.DeviceAcceleration[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DeviceAcceleration')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("DeviceAcceleration"))];
  dart.registerExtension(dart.global.DeviceAcceleration, html$.DeviceAcceleration);
  dart.defineExtensionNames([
    'value'
  ]);
  html$.DeviceLightEvent = class DeviceLightEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.DeviceLightEvent._create_1(type, eventInitDict_1);
      }
      return html$.DeviceLightEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new DeviceLightEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new DeviceLightEvent(type);
    }
    get [dartx.value]() {
      return this.value;
    }
  };
  dart.setSignature(html$.DeviceLightEvent, {
    constructors: () => ({
      _: [html$.DeviceLightEvent, []],
      new: [html$.DeviceLightEvent, [core.String], [core.Map]]
    }),
    statics: () => ({
      _create_1: [html$.DeviceLightEvent, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.DeviceLightEvent, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.DeviceLightEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DeviceLightEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("DeviceLightEvent"))];
  dart.registerExtension(dart.global.DeviceLightEvent, html$.DeviceLightEvent);
  dart.defineExtensionNames([
    'initDeviceMotionEvent',
    'acceleration',
    'accelerationIncludingGravity',
    'interval',
    'rotationRate'
  ]);
  html$.DeviceMotionEvent = class DeviceMotionEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.acceleration]() {
      return this.acceleration;
    }
    get [dartx.accelerationIncludingGravity]() {
      return this.accelerationIncludingGravity;
    }
    get [dartx.interval]() {
      return this.interval;
    }
    get [dartx.rotationRate]() {
      return this.rotationRate;
    }
    [dartx.initDeviceMotionEvent](type, bubbles, cancelable, acceleration, accelerationIncludingGravity, rotationRate, interval) {
      return this.initDeviceMotionEvent(type, bubbles, cancelable, acceleration, accelerationIncludingGravity, rotationRate, interval);
    }
  };
  dart.setSignature(html$.DeviceMotionEvent, {
    constructors: () => ({_: [html$.DeviceMotionEvent, []]}),
    methods: () => ({[dartx.initDeviceMotionEvent]: [dart.void, [core.String, core.bool, core.bool, html$.DeviceAcceleration, html$.DeviceAcceleration, html$.DeviceRotationRate, core.num]]})
  });
  html$.DeviceMotionEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DeviceMotionEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("DeviceMotionEvent"))];
  dart.registerExtension(dart.global.DeviceMotionEvent, html$.DeviceMotionEvent);
  const _initDeviceOrientationEvent = Symbol('_initDeviceOrientationEvent');
  dart.defineExtensionNames([
    'absolute',
    'alpha',
    'beta',
    'gamma'
  ]);
  html$.DeviceOrientationEvent = class DeviceOrientationEvent extends html$.Event {
    static new(type, opts) {
      let canBubble = opts && 'canBubble' in opts ? opts.canBubble : true;
      let cancelable = opts && 'cancelable' in opts ? opts.cancelable : true;
      let alpha = opts && 'alpha' in opts ? opts.alpha : 0;
      let beta = opts && 'beta' in opts ? opts.beta : 0;
      let gamma = opts && 'gamma' in opts ? opts.gamma : 0;
      let absolute = opts && 'absolute' in opts ? opts.absolute : false;
      let e = dart.as(html$.document[_createEvent]("DeviceOrientationEvent"), html$.DeviceOrientationEvent);
      e[_initDeviceOrientationEvent](type, canBubble, cancelable, alpha, beta, gamma, absolute);
      return e;
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.absolute]() {
      return this.absolute;
    }
    get [dartx.alpha]() {
      return this.alpha;
    }
    get [dartx.beta]() {
      return this.beta;
    }
    get [dartx.gamma]() {
      return this.gamma;
    }
    [_initDeviceOrientationEvent](type, bubbles, cancelable, alpha, beta, gamma, absolute) {
      return this.initDeviceOrientationEvent(type, bubbles, cancelable, alpha, beta, gamma, absolute);
    }
  };
  dart.setSignature(html$.DeviceOrientationEvent, {
    constructors: () => ({
      new: [html$.DeviceOrientationEvent, [core.String], {canBubble: core.bool, cancelable: core.bool, alpha: core.num, beta: core.num, gamma: core.num, absolute: core.bool}],
      _: [html$.DeviceOrientationEvent, []]
    }),
    methods: () => ({[_initDeviceOrientationEvent]: [dart.void, [core.String, core.bool, core.bool, core.num, core.num, core.num, core.bool]]})
  });
  html$.DeviceOrientationEvent[dart.metadata] = () => [dart.const(new _metadata.DomName('DeviceOrientationEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("DeviceOrientationEvent"))];
  dart.registerExtension(dart.global.DeviceOrientationEvent, html$.DeviceOrientationEvent);
  dart.defineExtensionNames([
    'alpha',
    'beta',
    'gamma'
  ]);
  html$.DeviceRotationRate = class DeviceRotationRate extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.alpha]() {
      return this.alpha;
    }
    get [dartx.beta]() {
      return this.beta;
    }
    get [dartx.gamma]() {
      return this.gamma;
    }
  };
  dart.setSignature(html$.DeviceRotationRate, {
    constructors: () => ({_: [html$.DeviceRotationRate, []]})
  });
  html$.DeviceRotationRate[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DeviceRotationRate')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("DeviceRotationRate"))];
  dart.registerExtension(dart.global.DeviceRotationRate, html$.DeviceRotationRate);
  dart.defineExtensionNames([
    'close',
    'show',
    'showModal',
    'open',
    'returnValue'
  ]);
  html$.DialogElement = class DialogElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      this[dartx.open] = null;
      this[dartx.returnValue] = null;
      super.created();
    }
    get [dartx.open]() {
      return this.open;
    }
    set [dartx.open](value) {
      this.open = value;
    }
    get [dartx.returnValue]() {
      return this.returnValue;
    }
    set [dartx.returnValue](value) {
      this.returnValue = value;
    }
    [dartx.close](returnValue) {
      return this.close(returnValue);
    }
    [dartx.show]() {
      return this.show();
    }
    [dartx.showModal]() {
      return this.showModal();
    }
  };
  dart.defineNamedConstructor(html$.DialogElement, 'created');
  dart.setSignature(html$.DialogElement, {
    constructors: () => ({
      _: [html$.DialogElement, []],
      created: [html$.DialogElement, []]
    }),
    methods: () => ({
      [dartx.close]: [dart.void, [core.String]],
      [dartx.show]: [dart.void, []],
      [dartx.showModal]: [dart.void, []]
    })
  });
  html$.DialogElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLDialogElement')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("HTMLDialogElement"))];
  dart.registerExtension(dart.global.HTMLDialogElement, html$.DialogElement);
  const _getDirectory = Symbol('_getDirectory');
  const _getFile = Symbol('_getFile');
  const __getDirectory_1 = Symbol('__getDirectory_1');
  const __getDirectory_2 = Symbol('__getDirectory_2');
  const __getDirectory_3 = Symbol('__getDirectory_3');
  const __getDirectory_4 = Symbol('__getDirectory_4');
  const __getDirectory = Symbol('__getDirectory');
  const __getFile_1 = Symbol('__getFile_1');
  const __getFile_2 = Symbol('__getFile_2');
  const __getFile_3 = Symbol('__getFile_3');
  const __getFile_4 = Symbol('__getFile_4');
  const __getFile = Symbol('__getFile');
  const _removeRecursively = Symbol('_removeRecursively');
  const _copyTo = Symbol('_copyTo');
  const _getMetadata = Symbol('_getMetadata');
  const _getParent = Symbol('_getParent');
  const _moveTo = Symbol('_moveTo');
  const _remove$ = Symbol('_remove');
  dart.defineExtensionNames([
    'copyTo',
    'getMetadata',
    'getParent',
    'moveTo',
    'remove',
    'toUrl',
    'filesystem',
    'fullPath',
    'isDirectory',
    'isFile',
    'name'
  ]);
  html$.Entry = class Entry extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.filesystem]() {
      return this.filesystem;
    }
    get [dartx.fullPath]() {
      return this.fullPath;
    }
    get [dartx.isDirectory]() {
      return this.isDirectory;
    }
    get [dartx.isFile]() {
      return this.isFile;
    }
    get [dartx.name]() {
      return this.name;
    }
    [_copyTo](parent, opts) {
      return this.copyTo(parent, opts);
    }
    [dartx.copyTo](parent, opts) {
      let name = opts && 'name' in opts ? opts.name : null;
      let completer = async.Completer$(html$.Entry).new();
      this[_copyTo](parent, {name: name, successCallback: dart.fn(value => {
          completer.complete(value);
        }, dart.void, [html$.Entry]), errorCallback: dart.fn(error => {
          completer.completeError(error);
        }, dart.void, [html$.FileError])});
      return completer.future;
    }
    [_getMetadata](successCallback, errorCallback) {
      return this.getMetadata(successCallback, errorCallback);
    }
    [dartx.getMetadata]() {
      let completer = async.Completer$(html$.Metadata).new();
      this[_getMetadata](dart.fn(value => {
        completer.complete(value);
      }, dart.void, [html$.Metadata]), dart.fn(error => {
        completer.completeError(error);
      }, dart.void, [html$.FileError]));
      return completer.future;
    }
    [_getParent](successCallback, errorCallback) {
      return this.getParent(successCallback, errorCallback);
    }
    [dartx.getParent]() {
      let completer = async.Completer$(html$.Entry).new();
      this[_getParent](dart.fn(value => {
        completer.complete(value);
      }, dart.void, [html$.Entry]), dart.fn(error => {
        completer.completeError(error);
      }, dart.void, [html$.FileError]));
      return completer.future;
    }
    [_moveTo](parent, opts) {
      return this.moveTo(parent, opts);
    }
    [dartx.moveTo](parent, opts) {
      let name = opts && 'name' in opts ? opts.name : null;
      let completer = async.Completer$(html$.Entry).new();
      this[_moveTo](parent, {name: name, successCallback: dart.fn(value => {
          completer.complete(value);
        }, dart.void, [html$.Entry]), errorCallback: dart.fn(error => {
          completer.completeError(error);
        }, dart.void, [html$.FileError])});
      return completer.future;
    }
    [_remove$](successCallback, errorCallback) {
      return this.remove(successCallback, errorCallback);
    }
    [dartx.remove]() {
      let completer = async.Completer.new();
      this[_remove$](dart.fn(() => {
        completer.complete();
      }, dart.void, []), dart.fn(error => {
        completer.completeError(error);
      }, dart.void, [html$.FileError]));
      return completer.future;
    }
    [dartx.toUrl]() {
      return this.toURL();
    }
  };
  dart.setSignature(html$.Entry, {
    constructors: () => ({_: [html$.Entry, []]}),
    methods: () => ({
      [_copyTo]: [dart.void, [html$.DirectoryEntry], {name: core.String, successCallback: html$._EntryCallback, errorCallback: html$._ErrorCallback}],
      [dartx.copyTo]: [async.Future$(html$.Entry), [html$.DirectoryEntry], {name: core.String}],
      [_getMetadata]: [dart.void, [html$.MetadataCallback], [html$._ErrorCallback]],
      [dartx.getMetadata]: [async.Future$(html$.Metadata), []],
      [_getParent]: [dart.void, [], [html$._EntryCallback, html$._ErrorCallback]],
      [dartx.getParent]: [async.Future$(html$.Entry), []],
      [_moveTo]: [dart.void, [html$.DirectoryEntry], {name: core.String, successCallback: html$._EntryCallback, errorCallback: html$._ErrorCallback}],
      [dartx.moveTo]: [async.Future$(html$.Entry), [html$.DirectoryEntry], {name: core.String}],
      [_remove$]: [dart.void, [html$.VoidCallback], [html$._ErrorCallback]],
      [dartx.remove]: [async.Future, []],
      [dartx.toUrl]: [core.String, []]
    })
  });
  html$.Entry[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Entry')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("Entry"))];
  dart.registerExtension(dart.global.Entry, html$.Entry);
  dart.defineExtensionNames([
    'createDirectory',
    'getDirectory',
    'createFile',
    'getFile',
    'createReader',
    'removeRecursively'
  ]);
  html$.DirectoryEntry = class DirectoryEntry extends html$.Entry {
    [dartx.createDirectory](path, opts) {
      let exclusive = opts && 'exclusive' in opts ? opts.exclusive : false;
      return this[_getDirectory](path, {options: dart.map({create: true, exclusive: exclusive})});
    }
    [dartx.getDirectory](path) {
      return this[_getDirectory](path);
    }
    [dartx.createFile](path, opts) {
      let exclusive = opts && 'exclusive' in opts ? opts.exclusive : false;
      return this[_getFile](path, {options: dart.map({create: true, exclusive: exclusive})});
    }
    [dartx.getFile](path) {
      return this[_getFile](path);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.createReader]() {
      return this.createReader();
    }
    [__getDirectory](path, opts) {
      let options = opts && 'options' in opts ? opts.options : null;
      let successCallback = opts && 'successCallback' in opts ? opts.successCallback : null;
      let errorCallback = opts && 'errorCallback' in opts ? opts.errorCallback : null;
      if (errorCallback != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        this[__getDirectory_1](path, options_1, successCallback, errorCallback);
        return;
      }
      if (successCallback != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        this[__getDirectory_2](path, options_1, successCallback);
        return;
      }
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        this[__getDirectory_3](path, options_1);
        return;
      }
      this[__getDirectory_4](path);
      return;
    }
    [__getDirectory_1](path, options, successCallback, errorCallback) {
      return this.getDirectory(path, options, successCallback, errorCallback);
    }
    [__getDirectory_2](path, options, successCallback) {
      return this.getDirectory(path, options, successCallback);
    }
    [__getDirectory_3](path, options) {
      return this.getDirectory(path, options);
    }
    [__getDirectory_4](path) {
      return this.getDirectory(path);
    }
    [_getDirectory](path, opts) {
      let options = opts && 'options' in opts ? opts.options : null;
      let completer = async.Completer$(html$.Entry).new();
      this[__getDirectory](path, {options: options, successCallback: dart.fn(value => {
          completer.complete(value);
        }, dart.void, [html$.Entry]), errorCallback: dart.fn(error => {
          completer.completeError(error);
        }, dart.void, [html$.FileError])});
      return completer.future;
    }
    [__getFile](path, opts) {
      let options = opts && 'options' in opts ? opts.options : null;
      let successCallback = opts && 'successCallback' in opts ? opts.successCallback : null;
      let errorCallback = opts && 'errorCallback' in opts ? opts.errorCallback : null;
      if (errorCallback != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        this[__getFile_1](path, options_1, successCallback, errorCallback);
        return;
      }
      if (successCallback != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        this[__getFile_2](path, options_1, successCallback);
        return;
      }
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        this[__getFile_3](path, options_1);
        return;
      }
      this[__getFile_4](path);
      return;
    }
    [__getFile_1](path, options, successCallback, errorCallback) {
      return this.getFile(path, options, successCallback, errorCallback);
    }
    [__getFile_2](path, options, successCallback) {
      return this.getFile(path, options, successCallback);
    }
    [__getFile_3](path, options) {
      return this.getFile(path, options);
    }
    [__getFile_4](path) {
      return this.getFile(path);
    }
    [_getFile](path, opts) {
      let options = opts && 'options' in opts ? opts.options : null;
      let completer = async.Completer$(html$.Entry).new();
      this[__getFile](path, {options: options, successCallback: dart.fn(value => {
          completer.complete(value);
        }, dart.void, [html$.Entry]), errorCallback: dart.fn(error => {
          completer.completeError(error);
        }, dart.void, [html$.FileError])});
      return completer.future;
    }
    [_removeRecursively](successCallback, errorCallback) {
      return this.removeRecursively(successCallback, errorCallback);
    }
    [dartx.removeRecursively]() {
      let completer = async.Completer.new();
      this[_removeRecursively](dart.fn(() => {
        completer.complete();
      }, dart.void, []), dart.fn(error => {
        completer.completeError(error);
      }, dart.void, [html$.FileError]));
      return completer.future;
    }
  };
  dart.setSignature(html$.DirectoryEntry, {
    constructors: () => ({_: [html$.DirectoryEntry, []]}),
    methods: () => ({
      [dartx.createDirectory]: [async.Future$(html$.Entry), [core.String], {exclusive: core.bool}],
      [dartx.getDirectory]: [async.Future$(html$.Entry), [core.String]],
      [dartx.createFile]: [async.Future$(html$.Entry), [core.String], {exclusive: core.bool}],
      [dartx.getFile]: [async.Future$(html$.Entry), [core.String]],
      [dartx.createReader]: [html$.DirectoryReader, []],
      [__getDirectory]: [dart.void, [core.String], {options: core.Map, successCallback: html$._EntryCallback, errorCallback: html$._ErrorCallback}],
      [__getDirectory_1]: [dart.void, [dart.dynamic, dart.dynamic, html$._EntryCallback, html$._ErrorCallback]],
      [__getDirectory_2]: [dart.void, [dart.dynamic, dart.dynamic, html$._EntryCallback]],
      [__getDirectory_3]: [dart.void, [dart.dynamic, dart.dynamic]],
      [__getDirectory_4]: [dart.void, [dart.dynamic]],
      [_getDirectory]: [async.Future$(html$.Entry), [core.String], {options: core.Map}],
      [__getFile]: [dart.void, [core.String], {options: core.Map, successCallback: html$._EntryCallback, errorCallback: html$._ErrorCallback}],
      [__getFile_1]: [dart.void, [dart.dynamic, dart.dynamic, html$._EntryCallback, html$._ErrorCallback]],
      [__getFile_2]: [dart.void, [dart.dynamic, dart.dynamic, html$._EntryCallback]],
      [__getFile_3]: [dart.void, [dart.dynamic, dart.dynamic]],
      [__getFile_4]: [dart.void, [dart.dynamic]],
      [_getFile]: [async.Future$(html$.Entry), [core.String], {options: core.Map}],
      [_removeRecursively]: [dart.void, [html$.VoidCallback], [html$._ErrorCallback]],
      [dartx.removeRecursively]: [async.Future, []]
    })
  });
  html$.DirectoryEntry[dart.metadata] = () => [dart.const(new _metadata.DomName('DirectoryEntry')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("DirectoryEntry"))];
  dart.registerExtension(dart.global.DirectoryEntry, html$.DirectoryEntry);
  const _readEntries = Symbol('_readEntries');
  dart.defineExtensionNames([
    'readEntries'
  ]);
  html$.DirectoryReader = class DirectoryReader extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [_readEntries](successCallback, errorCallback) {
      return this.readEntries(successCallback, errorCallback);
    }
    [dartx.readEntries]() {
      let completer = async.Completer$(core.List$(html$.Entry)).new();
      this[_readEntries](dart.fn(value => {
        completer.complete(value);
      }, dart.void, [core.List$(html$.Entry)]), dart.fn(error => {
        completer.completeError(error);
      }, dart.void, [html$.FileError]));
      return completer.future;
    }
  };
  dart.setSignature(html$.DirectoryReader, {
    constructors: () => ({_: [html$.DirectoryReader, []]}),
    methods: () => ({
      [_readEntries]: [dart.void, [html$._EntriesCallback], [html$._ErrorCallback]],
      [dartx.readEntries]: [async.Future$(core.List$(html$.Entry)), []]
    })
  });
  html$.DirectoryReader[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DirectoryReader')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("DirectoryReader"))];
  dart.registerExtension(dart.global.DirectoryReader, html$.DirectoryReader);
  html$.DivElement = class DivElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("div"), html$.DivElement);
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(html$.DivElement, 'created');
  dart.setSignature(html$.DivElement, {
    constructors: () => ({
      _: [html$.DivElement, []],
      new: [html$.DivElement, []],
      created: [html$.DivElement, []]
    })
  });
  html$.DivElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLDivElement')), dart.const(new _js_helper.Native("HTMLDivElement"))];
  dart.registerExtension(dart.global.HTMLDivElement, html$.DivElement);
  const _body = Symbol('_body');
  const _get_window = Symbol('_get_window');
  const _head$ = Symbol('_head');
  const _lastModified = Symbol('_lastModified');
  const _preferredStylesheetSet = Symbol('_preferredStylesheetSet');
  const _referrer = Symbol('_referrer');
  const _selectedStylesheetSet = Symbol('_selectedStylesheetSet');
  const _styleSheets = Symbol('_styleSheets');
  const _title = Symbol('_title');
  const _visibilityState = Symbol('_visibilityState');
  const _webkitFullscreenElement = Symbol('_webkitFullscreenElement');
  const _webkitFullscreenEnabled = Symbol('_webkitFullscreenEnabled');
  const _webkitHidden = Symbol('_webkitHidden');
  const _webkitVisibilityState = Symbol('_webkitVisibilityState');
  const _caretRangeFromPoint = Symbol('_caretRangeFromPoint');
  const _createElement = Symbol('_createElement');
  const _createElementNS = Symbol('_createElementNS');
  const _createTouch_1 = Symbol('_createTouch_1');
  const _createTouch = Symbol('_createTouch');
  const _createTouchList = Symbol('_createTouchList');
  const _elementFromPoint = Symbol('_elementFromPoint');
  const _getCssCanvasContext = Symbol('_getCssCanvasContext');
  const _webkitExitFullscreen = Symbol('_webkitExitFullscreen');
  const _createElement_2 = Symbol('_createElement_2');
  const _createElementNS_2 = Symbol('_createElementNS_2');
  const _createNodeIterator = Symbol('_createNodeIterator');
  const _createTreeWalker = Symbol('_createTreeWalker');
  dart.defineExtensionNames([
    'window',
    'adoptNode',
    'createDocumentFragment',
    'createRange',
    'elementsFromPoint',
    'execCommand',
    'exitFullscreen',
    'exitPointerLock',
    'getElementsByClassName',
    'getElementsByName',
    'getElementsByTagName',
    'importNode',
    'queryCommandEnabled',
    'queryCommandIndeterm',
    'queryCommandState',
    'queryCommandSupported',
    'queryCommandValue',
    'transformDocumentToTreeView',
    'getElementById',
    'querySelector',
    'onAbort',
    'onBeforeCopy',
    'onBeforeCut',
    'onBeforePaste',
    'onBlur',
    'onCanPlay',
    'onCanPlayThrough',
    'onChange',
    'onClick',
    'onContextMenu',
    'onCopy',
    'onCut',
    'onDoubleClick',
    'onDrag',
    'onDragEnd',
    'onDragEnter',
    'onDragLeave',
    'onDragOver',
    'onDragStart',
    'onDrop',
    'onDurationChange',
    'onEmptied',
    'onEnded',
    'onError',
    'onFocus',
    'onInput',
    'onInvalid',
    'onKeyDown',
    'onKeyPress',
    'onKeyUp',
    'onLoad',
    'onLoadedData',
    'onLoadedMetadata',
    'onMouseDown',
    'onMouseEnter',
    'onMouseLeave',
    'onMouseMove',
    'onMouseOut',
    'onMouseOver',
    'onMouseUp',
    'onMouseWheel',
    'onPaste',
    'onPause',
    'onPlay',
    'onPlaying',
    'onPointerLockChange',
    'onPointerLockError',
    'onRateChange',
    'onReadyStateChange',
    'onReset',
    'onResize',
    'onScroll',
    'onSearch',
    'onSecurityPolicyViolation',
    'onSeeked',
    'onSeeking',
    'onSelect',
    'onSelectionChange',
    'onSelectStart',
    'onStalled',
    'onSubmit',
    'onSuspend',
    'onTimeUpdate',
    'onTouchCancel',
    'onTouchEnd',
    'onTouchMove',
    'onTouchStart',
    'onVolumeChange',
    'onWaiting',
    'onFullscreenChange',
    'onFullscreenError',
    'querySelectorAll',
    'query',
    'queryAll',
    'supportsRegisterElement',
    'supportsRegister',
    'createElement',
    'createElementNS',
    'visibilityState',
    'activeElement',
    'contentType',
    'cookie',
    'currentScript',
    'documentElement',
    'domain',
    'fonts',
    'fullscreenElement',
    'fullscreenEnabled',
    'hidden',
    'implementation',
    'origin',
    'pointerLockElement',
    'readyState',
    'rootElement',
    'scrollingElement',
    'timeline'
  ]);
  html$.Document = class Document extends html$.Node {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.activeElement]() {
      return this.activeElement;
    }
    get [_body]() {
      return this.body;
    }
    set [_body](value) {
      this.body = value;
    }
    get [dartx.contentType]() {
      return this.contentType;
    }
    get [dartx.cookie]() {
      return this.cookie;
    }
    set [dartx.cookie](value) {
      this.cookie = value;
    }
    get [dartx.currentScript]() {
      return this.currentScript;
    }
    get [dartx.window]() {
      return html$._convertNativeToDart_Window(this[_get_window]);
    }
    get [_get_window]() {
      return this.defaultView;
    }
    get [dartx.documentElement]() {
      return this.documentElement;
    }
    get [dartx.domain]() {
      return this.domain;
    }
    get [dartx.fonts]() {
      return this.fonts;
    }
    get [dartx.fullscreenElement]() {
      return this.fullscreenElement;
    }
    get [dartx.fullscreenEnabled]() {
      return this.fullscreenEnabled;
    }
    get [_head$]() {
      return this.head;
    }
    get [dartx.hidden]() {
      return this.hidden;
    }
    get [dartx.implementation]() {
      return this.implementation;
    }
    get [_lastModified]() {
      return this.lastModified;
    }
    get [dartx.origin]() {
      return this.origin;
    }
    get [dartx.pointerLockElement]() {
      return this.pointerLockElement;
    }
    get [_preferredStylesheetSet]() {
      return this.preferredStylesheetSet;
    }
    get [dartx.readyState]() {
      return this.readyState;
    }
    get [_referrer]() {
      return this.referrer;
    }
    get [dartx.rootElement]() {
      return this.rootElement;
    }
    get [dartx.scrollingElement]() {
      return this.scrollingElement;
    }
    get [_selectedStylesheetSet]() {
      return this.selectedStylesheetSet;
    }
    set [_selectedStylesheetSet](value) {
      this.selectedStylesheetSet = value;
    }
    get [_styleSheets]() {
      return this.styleSheets;
    }
    get [dartx.timeline]() {
      return this.timeline;
    }
    get [_title]() {
      return this.title;
    }
    set [_title](value) {
      this.title = value;
    }
    get [_visibilityState]() {
      return this.visibilityState;
    }
    get [_webkitFullscreenElement]() {
      return this.webkitFullscreenElement;
    }
    get [_webkitFullscreenEnabled]() {
      return this.webkitFullscreenEnabled;
    }
    get [_webkitHidden]() {
      return this.webkitHidden;
    }
    get [_webkitVisibilityState]() {
      return this.webkitVisibilityState;
    }
    [dartx.adoptNode](node) {
      return this.adoptNode(node);
    }
    [_caretRangeFromPoint](x, y) {
      return this.caretRangeFromPoint(x, y);
    }
    [dartx.createDocumentFragment]() {
      return this.createDocumentFragment();
    }
    [_createElement](localName_OR_tagName, typeExtension) {
      return this.createElement(localName_OR_tagName, typeExtension);
    }
    [_createElementNS](namespaceURI, qualifiedName, typeExtension) {
      return this.createElementNS(namespaceURI, qualifiedName, typeExtension);
    }
    [_createEvent](eventType) {
      return this.createEvent(eventType);
    }
    [dartx.createRange]() {
      return this.createRange();
    }
    [_createTextNode](data) {
      return this.createTextNode(data);
    }
    [_createTouch](window, target, identifier, pageX, pageY, screenX, screenY, radiusX, radiusY, rotationAngle, force) {
      let target_1 = html$._convertDartToNative_EventTarget(target);
      return this[_createTouch_1](window, target_1, identifier, pageX, pageY, screenX, screenY, radiusX, radiusY, rotationAngle, force);
    }
    [_createTouch_1](window, target, identifier, pageX, pageY, screenX, screenY, radiusX, radiusY, rotationAngle, force) {
      return this.createTouch(window, target, identifier, pageX, pageY, screenX, screenY, radiusX, radiusY, rotationAngle, force);
    }
    [_createTouchList](touches) {
      return this.createTouchList(touches);
    }
    [_elementFromPoint](x, y) {
      return this.elementFromPoint(x, y);
    }
    [dartx.elementsFromPoint](x, y) {
      return this.elementsFromPoint(x, y);
    }
    [dartx.execCommand](commandId, showUI, value) {
      return this.execCommand(commandId, showUI, value);
    }
    [dartx.exitFullscreen]() {
      return this.exitFullscreen();
    }
    [dartx.exitPointerLock]() {
      return this.exitPointerLock();
    }
    [_getCssCanvasContext](contextId, name, width, height) {
      return this.getCSSCanvasContext(contextId, name, width, height);
    }
    [dartx.getElementsByClassName](classNames) {
      return this.getElementsByClassName(classNames);
    }
    [dartx.getElementsByName](elementName) {
      return this.getElementsByName(elementName);
    }
    [dartx.getElementsByTagName](localName) {
      return this.getElementsByTagName(localName);
    }
    [dartx.importNode](node, deep) {
      return this.importNode(node, deep);
    }
    [dartx.queryCommandEnabled](commandId) {
      return this.queryCommandEnabled(commandId);
    }
    [dartx.queryCommandIndeterm](commandId) {
      return this.queryCommandIndeterm(commandId);
    }
    [dartx.queryCommandState](commandId) {
      return this.queryCommandState(commandId);
    }
    [dartx.queryCommandSupported](commandId) {
      return this.queryCommandSupported(commandId);
    }
    [dartx.queryCommandValue](commandId) {
      return this.queryCommandValue(commandId);
    }
    [dartx.transformDocumentToTreeView](noStyleMessage) {
      return this.transformDocumentToTreeView(noStyleMessage);
    }
    [_webkitExitFullscreen]() {
      return this.webkitExitFullscreen();
    }
    [dartx.getElementById](elementId) {
      return this.getElementById(elementId);
    }
    get [_childElementCount]() {
      return this.childElementCount;
    }
    get [_children]() {
      return this.children;
    }
    get [_firstElementChild]() {
      return this.firstElementChild;
    }
    get [_lastElementChild]() {
      return this.lastElementChild;
    }
    [dartx.querySelector](selectors) {
      return this.querySelector(selectors);
    }
    [_querySelectorAll](selectors) {
      return this.querySelectorAll(selectors);
    }
    get [dartx.onAbort]() {
      return html$.Element.abortEvent.forTarget(this);
    }
    get [dartx.onBeforeCopy]() {
      return html$.Element.beforeCopyEvent.forTarget(this);
    }
    get [dartx.onBeforeCut]() {
      return html$.Element.beforeCutEvent.forTarget(this);
    }
    get [dartx.onBeforePaste]() {
      return html$.Element.beforePasteEvent.forTarget(this);
    }
    get [dartx.onBlur]() {
      return html$.Element.blurEvent.forTarget(this);
    }
    get [dartx.onCanPlay]() {
      return html$.Element.canPlayEvent.forTarget(this);
    }
    get [dartx.onCanPlayThrough]() {
      return html$.Element.canPlayThroughEvent.forTarget(this);
    }
    get [dartx.onChange]() {
      return html$.Element.changeEvent.forTarget(this);
    }
    get [dartx.onClick]() {
      return html$.Element.clickEvent.forTarget(this);
    }
    get [dartx.onContextMenu]() {
      return html$.Element.contextMenuEvent.forTarget(this);
    }
    get [dartx.onCopy]() {
      return html$.Element.copyEvent.forTarget(this);
    }
    get [dartx.onCut]() {
      return html$.Element.cutEvent.forTarget(this);
    }
    get [dartx.onDoubleClick]() {
      return html$.Element.doubleClickEvent.forTarget(this);
    }
    get [dartx.onDrag]() {
      return html$.Element.dragEvent.forTarget(this);
    }
    get [dartx.onDragEnd]() {
      return html$.Element.dragEndEvent.forTarget(this);
    }
    get [dartx.onDragEnter]() {
      return html$.Element.dragEnterEvent.forTarget(this);
    }
    get [dartx.onDragLeave]() {
      return html$.Element.dragLeaveEvent.forTarget(this);
    }
    get [dartx.onDragOver]() {
      return html$.Element.dragOverEvent.forTarget(this);
    }
    get [dartx.onDragStart]() {
      return html$.Element.dragStartEvent.forTarget(this);
    }
    get [dartx.onDrop]() {
      return html$.Element.dropEvent.forTarget(this);
    }
    get [dartx.onDurationChange]() {
      return html$.Element.durationChangeEvent.forTarget(this);
    }
    get [dartx.onEmptied]() {
      return html$.Element.emptiedEvent.forTarget(this);
    }
    get [dartx.onEnded]() {
      return html$.Element.endedEvent.forTarget(this);
    }
    get [dartx.onError]() {
      return html$.Element.errorEvent.forTarget(this);
    }
    get [dartx.onFocus]() {
      return html$.Element.focusEvent.forTarget(this);
    }
    get [dartx.onInput]() {
      return html$.Element.inputEvent.forTarget(this);
    }
    get [dartx.onInvalid]() {
      return html$.Element.invalidEvent.forTarget(this);
    }
    get [dartx.onKeyDown]() {
      return html$.Element.keyDownEvent.forTarget(this);
    }
    get [dartx.onKeyPress]() {
      return html$.Element.keyPressEvent.forTarget(this);
    }
    get [dartx.onKeyUp]() {
      return html$.Element.keyUpEvent.forTarget(this);
    }
    get [dartx.onLoad]() {
      return html$.Element.loadEvent.forTarget(this);
    }
    get [dartx.onLoadedData]() {
      return html$.Element.loadedDataEvent.forTarget(this);
    }
    get [dartx.onLoadedMetadata]() {
      return html$.Element.loadedMetadataEvent.forTarget(this);
    }
    get [dartx.onMouseDown]() {
      return html$.Element.mouseDownEvent.forTarget(this);
    }
    get [dartx.onMouseEnter]() {
      return html$.Element.mouseEnterEvent.forTarget(this);
    }
    get [dartx.onMouseLeave]() {
      return html$.Element.mouseLeaveEvent.forTarget(this);
    }
    get [dartx.onMouseMove]() {
      return html$.Element.mouseMoveEvent.forTarget(this);
    }
    get [dartx.onMouseOut]() {
      return html$.Element.mouseOutEvent.forTarget(this);
    }
    get [dartx.onMouseOver]() {
      return html$.Element.mouseOverEvent.forTarget(this);
    }
    get [dartx.onMouseUp]() {
      return html$.Element.mouseUpEvent.forTarget(this);
    }
    get [dartx.onMouseWheel]() {
      return html$.Element.mouseWheelEvent.forTarget(this);
    }
    get [dartx.onPaste]() {
      return html$.Element.pasteEvent.forTarget(this);
    }
    get [dartx.onPause]() {
      return html$.Element.pauseEvent.forTarget(this);
    }
    get [dartx.onPlay]() {
      return html$.Element.playEvent.forTarget(this);
    }
    get [dartx.onPlaying]() {
      return html$.Element.playingEvent.forTarget(this);
    }
    get [dartx.onPointerLockChange]() {
      return html$.Document.pointerLockChangeEvent.forTarget(this);
    }
    get [dartx.onPointerLockError]() {
      return html$.Document.pointerLockErrorEvent.forTarget(this);
    }
    get [dartx.onRateChange]() {
      return html$.Element.rateChangeEvent.forTarget(this);
    }
    get [dartx.onReadyStateChange]() {
      return html$.Document.readyStateChangeEvent.forTarget(this);
    }
    get [dartx.onReset]() {
      return html$.Element.resetEvent.forTarget(this);
    }
    get [dartx.onResize]() {
      return html$.Element.resizeEvent.forTarget(this);
    }
    get [dartx.onScroll]() {
      return html$.Element.scrollEvent.forTarget(this);
    }
    get [dartx.onSearch]() {
      return html$.Element.searchEvent.forTarget(this);
    }
    get [dartx.onSecurityPolicyViolation]() {
      return html$.Document.securityPolicyViolationEvent.forTarget(this);
    }
    get [dartx.onSeeked]() {
      return html$.Element.seekedEvent.forTarget(this);
    }
    get [dartx.onSeeking]() {
      return html$.Element.seekingEvent.forTarget(this);
    }
    get [dartx.onSelect]() {
      return html$.Element.selectEvent.forTarget(this);
    }
    get [dartx.onSelectionChange]() {
      return html$.Document.selectionChangeEvent.forTarget(this);
    }
    get [dartx.onSelectStart]() {
      return html$.Element.selectStartEvent.forTarget(this);
    }
    get [dartx.onStalled]() {
      return html$.Element.stalledEvent.forTarget(this);
    }
    get [dartx.onSubmit]() {
      return html$.Element.submitEvent.forTarget(this);
    }
    get [dartx.onSuspend]() {
      return html$.Element.suspendEvent.forTarget(this);
    }
    get [dartx.onTimeUpdate]() {
      return html$.Element.timeUpdateEvent.forTarget(this);
    }
    get [dartx.onTouchCancel]() {
      return html$.Element.touchCancelEvent.forTarget(this);
    }
    get [dartx.onTouchEnd]() {
      return html$.Element.touchEndEvent.forTarget(this);
    }
    get [dartx.onTouchMove]() {
      return html$.Element.touchMoveEvent.forTarget(this);
    }
    get [dartx.onTouchStart]() {
      return html$.Element.touchStartEvent.forTarget(this);
    }
    get [dartx.onVolumeChange]() {
      return html$.Element.volumeChangeEvent.forTarget(this);
    }
    get [dartx.onWaiting]() {
      return html$.Element.waitingEvent.forTarget(this);
    }
    get [dartx.onFullscreenChange]() {
      return html$.Element.fullscreenChangeEvent.forTarget(this);
    }
    get [dartx.onFullscreenError]() {
      return html$.Element.fullscreenErrorEvent.forTarget(this);
    }
    [dartx.querySelectorAll](T) {
      return selectors => {
        return new (html$._FrozenElementList$(T))._wrap(this[_querySelectorAll](selectors));
      };
    }
    [dartx.query](relativeSelectors) {
      return this[dartx.querySelector](relativeSelectors);
    }
    [dartx.queryAll](T) {
      return relativeSelectors => {
        return this[dartx.querySelectorAll](T)(relativeSelectors);
      };
    }
    get [dartx.supportsRegisterElement]() {
      return "registerElement" in this;
    }
    get [dartx.supportsRegister]() {
      return this[dartx.supportsRegisterElement];
    }
    [dartx.createElement](tagName, typeExtension) {
      if (typeExtension === void 0) typeExtension = null;
      return dart.as(typeExtension == null ? this[_createElement_2](tagName) : this[_createElement](tagName, typeExtension), html$.Element);
    }
    [_createElement_2](tagName) {
      return this.createElement(tagName);
    }
    [_createElementNS_2](namespaceURI, qualifiedName) {
      return this.createElementNS(namespaceURI, qualifiedName);
    }
    [dartx.createElementNS](namespaceURI, qualifiedName, typeExtension) {
      if (typeExtension === void 0) typeExtension = null;
      return dart.as(typeExtension == null ? this[_createElementNS_2](namespaceURI, qualifiedName) : this[_createElementNS](namespaceURI, qualifiedName, typeExtension), html$.Element);
    }
    [_createNodeIterator](root, whatToShow, filter) {
      if (whatToShow === void 0) whatToShow = null;
      if (filter === void 0) filter = null;
      return this.createNodeIterator(root, whatToShow, filter, false);
    }
    [_createTreeWalker](root, whatToShow, filter) {
      if (whatToShow === void 0) whatToShow = null;
      if (filter === void 0) filter = null;
      return this.createTreeWalker(root, whatToShow, filter, false);
    }
    get [dartx.visibilityState]() {
      return this.visibilityState || this.mozVisibilityState || this.msVisibilityState || this.webkitVisibilityState;
    }
  };
  dart.setSignature(html$.Document, {
    constructors: () => ({_: [html$.Document, []]}),
    methods: () => ({
      [dartx.adoptNode]: [html$.Node, [html$.Node]],
      [_caretRangeFromPoint]: [html$.Range, [core.int, core.int]],
      [dartx.createDocumentFragment]: [html$.DocumentFragment, []],
      [_createElement]: [html$.Element, [core.String], [core.String]],
      [_createElementNS]: [html$.Element, [core.String, core.String], [core.String]],
      [_createEvent]: [html$.Event, [core.String]],
      [dartx.createRange]: [html$.Range, []],
      [_createTextNode]: [html$.Text, [core.String]],
      [_createTouch]: [html$.Touch, [html$.Window, html$.EventTarget, core.int, core.num, core.num, core.num, core.num, core.num, core.num, core.num, core.num]],
      [_createTouch_1]: [html$.Touch, [html$.Window, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]],
      [_createTouchList]: [html$.TouchList, [html$.Touch]],
      [_elementFromPoint]: [html$.Element, [core.int, core.int]],
      [dartx.elementsFromPoint]: [core.List$(html$.Element), [core.int, core.int]],
      [dartx.execCommand]: [core.bool, [core.String], [core.bool, core.String]],
      [dartx.exitFullscreen]: [dart.void, []],
      [dartx.exitPointerLock]: [dart.void, []],
      [_getCssCanvasContext]: [core.Object, [core.String, core.String, core.int, core.int]],
      [dartx.getElementsByClassName]: [core.List$(html$.Node), [core.String]],
      [dartx.getElementsByName]: [core.List$(html$.Node), [core.String]],
      [dartx.getElementsByTagName]: [core.List$(html$.Node), [core.String]],
      [dartx.importNode]: [html$.Node, [html$.Node], [core.bool]],
      [dartx.queryCommandEnabled]: [core.bool, [core.String]],
      [dartx.queryCommandIndeterm]: [core.bool, [core.String]],
      [dartx.queryCommandState]: [core.bool, [core.String]],
      [dartx.queryCommandSupported]: [core.bool, [core.String]],
      [dartx.queryCommandValue]: [core.String, [core.String]],
      [dartx.transformDocumentToTreeView]: [dart.void, [core.String]],
      [_webkitExitFullscreen]: [dart.void, []],
      [dartx.getElementById]: [html$.Element, [core.String]],
      [dartx.querySelector]: [html$.Element, [core.String]],
      [_querySelectorAll]: [core.List$(html$.Node), [core.String]],
      [dartx.querySelectorAll]: [T => [html$.ElementList$(T), [core.String]]],
      [dartx.query]: [html$.Element, [core.String]],
      [dartx.queryAll]: [T => [html$.ElementList$(T), [core.String]]],
      [dartx.createElement]: [html$.Element, [core.String], [core.String]],
      [_createElement_2]: [dart.dynamic, [core.String]],
      [_createElementNS_2]: [dart.dynamic, [core.String, core.String]],
      [dartx.createElementNS]: [html$.Element, [core.String, core.String], [core.String]],
      [_createNodeIterator]: [html$.NodeIterator, [html$.Node], [core.int, html$.NodeFilter]],
      [_createTreeWalker]: [html$.TreeWalker, [html$.Node], [core.int, html$.NodeFilter]]
    })
  });
  html$.Document[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Document')), dart.const(new _js_helper.Native("Document"))];
  dart.defineLazy(html$.Document, {
    get pointerLockChangeEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('pointerlockchange'));
    },
    get pointerLockErrorEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('pointerlockerror'));
    },
    get readyStateChangeEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('readystatechange'));
    },
    get securityPolicyViolationEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.SecurityPolicyViolationEvent))('securitypolicyviolation'));
    },
    get selectionChangeEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('selectionchange'));
    }
  });
  dart.registerExtension(dart.global.Document, html$.Document);
  const _docChildren = Symbol('_docChildren');
  dart.defineExtensionNames([
    'children',
    'children',
    'querySelectorAll',
    'innerHtml',
    'innerHtml',
    'setInnerHtml',
    'appendText',
    'appendHtml',
    'query',
    'queryAll',
    'getElementById',
    'querySelector'
  ]);
  html$.DocumentFragment = class DocumentFragment extends html$.Node {
    static new() {
      return html$.document[dartx.createDocumentFragment]();
    }
    static html(html, opts) {
      let validator = opts && 'validator' in opts ? opts.validator : null;
      let treeSanitizer = opts && 'treeSanitizer' in opts ? opts.treeSanitizer : null;
      return html$.document[dartx.body][dartx.createFragment](html, {validator: validator, treeSanitizer: treeSanitizer});
    }
    static svg(svgContent, opts) {
      let validator = opts && 'validator' in opts ? opts.validator : null;
      let treeSanitizer = opts && 'treeSanitizer' in opts ? opts.treeSanitizer : null;
      return svg$.SvgSvgElement.new()[dartx.createFragment](svgContent, {validator: validator, treeSanitizer: treeSanitizer});
    }
    get [_children]() {
      return dart.throw(new core.UnimplementedError('Use _docChildren instead'));
    }
    get [_docChildren]() {
      return this._docChildren;
    }
    set [_docChildren](value) {
      this._docChildren = value;
    }
    get [dartx.children]() {
      if (this[_docChildren] == null) {
        this[_docChildren] = new html_common.FilteredElementList(this);
      }
      return this[_docChildren];
    }
    set [dartx.children](value) {
      let copy = value[dartx.toList]();
      let children = this[dartx.children];
      children[dartx.clear]();
      children[dartx.addAll](copy);
    }
    [dartx.querySelectorAll](T) {
      return selectors => {
        return new (html$._FrozenElementList$(T))._wrap(this[_querySelectorAll](selectors));
      };
    }
    get [dartx.innerHtml]() {
      let e = html$.Element.tag("div");
      e[dartx.append](this[dartx.clone](true));
      return e[dartx.innerHtml];
    }
    set [dartx.innerHtml](value) {
      this[dartx.setInnerHtml](value);
    }
    [dartx.setInnerHtml](html, opts) {
      let validator = opts && 'validator' in opts ? opts.validator : null;
      let treeSanitizer = opts && 'treeSanitizer' in opts ? opts.treeSanitizer : null;
      this[dartx.nodes][dartx.clear]();
      this[dartx.append](html$.document[dartx.body][dartx.createFragment](html, {validator: validator, treeSanitizer: treeSanitizer}));
    }
    [dartx.appendText](text) {
      this[dartx.append](html$.Text.new(text));
    }
    [dartx.appendHtml](text, opts) {
      let validator = opts && 'validator' in opts ? opts.validator : null;
      let NodeTreeSanitizer = opts && 'NodeTreeSanitizer' in opts ? opts.NodeTreeSanitizer : null;
      let treeSanitizer = opts && 'treeSanitizer' in opts ? opts.treeSanitizer : null;
      this[dartx.append](html$.DocumentFragment.html(text, {validator: validator, treeSanitizer: dart.as(treeSanitizer, html$.NodeTreeSanitizer)}));
    }
    [dartx.query](relativeSelectors) {
      return this[dartx.querySelector](relativeSelectors);
    }
    [dartx.queryAll](T) {
      return relativeSelectors => {
        return this[dartx.querySelectorAll](T)(relativeSelectors);
      };
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.getElementById](elementId) {
      return this.getElementById(elementId);
    }
    get [_childElementCount]() {
      return this.childElementCount;
    }
    get [_firstElementChild]() {
      return this.firstElementChild;
    }
    get [_lastElementChild]() {
      return this.lastElementChild;
    }
    [dartx.querySelector](selectors) {
      return this.querySelector(selectors);
    }
    [_querySelectorAll](selectors) {
      return this.querySelectorAll(selectors);
    }
  };
  html$.DocumentFragment[dart.implements] = () => [html$.NonElementParentNode, html$.ParentNode];
  dart.setSignature(html$.DocumentFragment, {
    constructors: () => ({
      new: [html$.DocumentFragment, []],
      html: [html$.DocumentFragment, [core.String], {validator: html$.NodeValidator, treeSanitizer: html$.NodeTreeSanitizer}],
      svg: [html$.DocumentFragment, [core.String], {validator: html$.NodeValidator, treeSanitizer: html$.NodeTreeSanitizer}],
      _: [html$.DocumentFragment, []]
    }),
    methods: () => ({
      [dartx.querySelectorAll]: [T => [html$.ElementList$(T), [core.String]]],
      [dartx.setInnerHtml]: [dart.void, [core.String], {validator: html$.NodeValidator, treeSanitizer: html$.NodeTreeSanitizer}],
      [dartx.appendText]: [dart.void, [core.String]],
      [dartx.appendHtml]: [dart.void, [core.String], {validator: html$.NodeValidator, NodeTreeSanitizer: dart.dynamic, treeSanitizer: dart.dynamic}],
      [dartx.query]: [html$.Element, [core.String]],
      [dartx.queryAll]: [T => [html$.ElementList$(T), [core.String]]],
      [dartx.getElementById]: [html$.Element, [core.String]],
      [dartx.querySelector]: [html$.Element, [core.String]],
      [_querySelectorAll]: [core.List$(html$.Node), [core.String]]
    })
  });
  html$.DocumentFragment[dart.metadata] = () => [dart.const(new _metadata.DomName('DocumentFragment')), dart.const(new _js_helper.Native("DocumentFragment"))];
  dart.registerExtension(dart.global.DocumentFragment, html$.DocumentFragment);
  dart.defineExtensionNames([
    'message',
    'name'
  ]);
  html$.DomError = class DomError extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(name, message) {
      if (message === void 0) message = null;
      if (message != null) {
        return html$.DomError._create_1(name, message);
      }
      return html$.DomError._create_2(name);
    }
    static _create_1(name, message) {
      return new DOMError(name, message);
    }
    static _create_2(name) {
      return new DOMError(name);
    }
    get [dartx.message]() {
      return this.message;
    }
    get [dartx.name]() {
      return this.name;
    }
  };
  dart.setSignature(html$.DomError, {
    constructors: () => ({
      _: [html$.DomError, []],
      new: [html$.DomError, [core.String], [core.String]]
    }),
    statics: () => ({
      _create_1: [html$.DomError, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.DomError, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.DomError[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DOMError')), dart.const(new _js_helper.Native("DOMError"))];
  dart.registerExtension(dart.global.DOMError, html$.DomError);
  dart.defineExtensionNames([
    'name',
    'toString',
    'message'
  ]);
  html$.DomException = class DomException extends _interceptors.Interceptor {
    get [dartx.name]() {
      let errorName = this.name;
      if (dart.notNull(html_common.Device.isWebKit) && errorName == 'SECURITY_ERR') return 'SecurityError';
      if (dart.notNull(html_common.Device.isWebKit) && errorName == 'SYNTAX_ERR') return 'SyntaxError';
      return errorName;
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.message]() {
      return this.message;
    }
    [dartx.toString]() {
      return String(this);
    }
  };
  dart.setSignature(html$.DomException, {
    constructors: () => ({_: [html$.DomException, []]})
  });
  html$.DomException[dart.metadata] = () => [dart.const(new _metadata.DomName('DOMException')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("DOMException"))];
  html$.DomException.INDEX_SIZE = 'IndexSizeError';
  html$.DomException.HIERARCHY_REQUEST = 'HierarchyRequestError';
  html$.DomException.WRONG_DOCUMENT = 'WrongDocumentError';
  html$.DomException.INVALID_CHARACTER = 'InvalidCharacterError';
  html$.DomException.NO_MODIFICATION_ALLOWED = 'NoModificationAllowedError';
  html$.DomException.NOT_FOUND = 'NotFoundError';
  html$.DomException.NOT_SUPPORTED = 'NotSupportedError';
  html$.DomException.INVALID_STATE = 'InvalidStateError';
  html$.DomException.SYNTAX = 'SyntaxError';
  html$.DomException.INVALID_MODIFICATION = 'InvalidModificationError';
  html$.DomException.NAMESPACE = 'NamespaceError';
  html$.DomException.INVALID_ACCESS = 'InvalidAccessError';
  html$.DomException.TYPE_MISMATCH = 'TypeMismatchError';
  html$.DomException.SECURITY = 'SecurityError';
  html$.DomException.NETWORK = 'NetworkError';
  html$.DomException.ABORT = 'AbortError';
  html$.DomException.URL_MISMATCH = 'URLMismatchError';
  html$.DomException.QUOTA_EXCEEDED = 'QuotaExceededError';
  html$.DomException.TIMEOUT = 'TimeoutError';
  html$.DomException.INVALID_NODE_TYPE = 'InvalidNodeTypeError';
  html$.DomException.DATA_CLONE = 'DataCloneError';
  dart.registerExtension(dart.global.DOMException, html$.DomException);
  dart.defineExtensionNames([
    'createDocument',
    'createDocumentType',
    'createHtmlDocument',
    'hasFeature'
  ]);
  html$.DomImplementation = class DomImplementation extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.createDocument](namespaceURI, qualifiedName, doctype) {
      return this.createDocument(namespaceURI, qualifiedName, doctype);
    }
    [dartx.createDocumentType](qualifiedName, publicId, systemId) {
      return this.createDocumentType(qualifiedName, publicId, systemId);
    }
    [dartx.createHtmlDocument](title) {
      return this.createHTMLDocument(title);
    }
    [dartx.hasFeature]() {
      return this.hasFeature();
    }
  };
  dart.setSignature(html$.DomImplementation, {
    constructors: () => ({_: [html$.DomImplementation, []]}),
    methods: () => ({
      [dartx.createDocument]: [html$.XmlDocument, [core.String, core.String, html$._DocumentType]],
      [dartx.createDocumentType]: [html$._DocumentType, [core.String, core.String, core.String]],
      [dartx.createHtmlDocument]: [html$.HtmlDocument, [core.String]],
      [dartx.hasFeature]: [core.bool, []]
    })
  });
  html$.DomImplementation[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DOMImplementation')), dart.const(new _js_helper.Native("DOMImplementation"))];
  dart.registerExtension(dart.global.DOMImplementation, html$.DomImplementation);
  dart.defineExtensionNames([
    'next'
  ]);
  html$.DomIterator = class DomIterator extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.next](value) {
      return this.next(value);
    }
  };
  dart.setSignature(html$.DomIterator, {
    constructors: () => ({_: [html$.DomIterator, []]}),
    methods: () => ({[dartx.next]: [core.Object, [], [core.Object]]})
  });
  html$.DomIterator[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Iterator')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("Iterator"))];
  dart.registerExtension(dart.global.Iterator, html$.DomIterator);
  dart.defineExtensionNames([
    'a',
    'b',
    'c',
    'd',
    'e',
    'f',
    'is2D',
    'isIdentity',
    'm11',
    'm12',
    'm13',
    'm14',
    'm21',
    'm22',
    'm23',
    'm24',
    'm31',
    'm32',
    'm33',
    'm34',
    'm41',
    'm42',
    'm43',
    'm44',
    'multiply',
    'scale',
    'scale3d',
    'scaleNonUniform',
    'toFloat32Array',
    'toFloat64Array',
    'translate'
  ]);
  html$.DomMatrixReadOnly = class DomMatrixReadOnly extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.a]() {
      return this.a;
    }
    get [dartx.b]() {
      return this.b;
    }
    get [dartx.c]() {
      return this.c;
    }
    get [dartx.d]() {
      return this.d;
    }
    get [dartx.e]() {
      return this.e;
    }
    get [dartx.f]() {
      return this.f;
    }
    get [dartx.is2D]() {
      return this.is2D;
    }
    get [dartx.isIdentity]() {
      return this.isIdentity;
    }
    get [dartx.m11]() {
      return this.m11;
    }
    get [dartx.m12]() {
      return this.m12;
    }
    get [dartx.m13]() {
      return this.m13;
    }
    get [dartx.m14]() {
      return this.m14;
    }
    get [dartx.m21]() {
      return this.m21;
    }
    get [dartx.m22]() {
      return this.m22;
    }
    get [dartx.m23]() {
      return this.m23;
    }
    get [dartx.m24]() {
      return this.m24;
    }
    get [dartx.m31]() {
      return this.m31;
    }
    get [dartx.m32]() {
      return this.m32;
    }
    get [dartx.m33]() {
      return this.m33;
    }
    get [dartx.m34]() {
      return this.m34;
    }
    get [dartx.m41]() {
      return this.m41;
    }
    get [dartx.m42]() {
      return this.m42;
    }
    get [dartx.m43]() {
      return this.m43;
    }
    get [dartx.m44]() {
      return this.m44;
    }
    [dartx.multiply](other) {
      return this.multiply(other);
    }
    [dartx.scale](scale, originX, originY) {
      return this.scale(scale, originX, originY);
    }
    [dartx.scale3d](scale, originX, originY, originZ) {
      return this.scale3d(scale, originX, originY, originZ);
    }
    [dartx.scaleNonUniform](scaleX, scaleY, scaleZn, originX, originY, originZ) {
      return this.scaleNonUniform(scaleX, scaleY, scaleZn, originX, originY, originZ);
    }
    [dartx.toFloat32Array]() {
      return this.toFloat32Array();
    }
    [dartx.toFloat64Array]() {
      return this.toFloat64Array();
    }
    [dartx.translate](tx, ty, tz) {
      return this.translate(tx, ty, tz);
    }
  };
  dart.setSignature(html$.DomMatrixReadOnly, {
    constructors: () => ({_: [html$.DomMatrixReadOnly, []]}),
    methods: () => ({
      [dartx.multiply]: [html$.DomMatrix, [html$.DomMatrix]],
      [dartx.scale]: [html$.DomMatrix, [core.num], [core.num, core.num]],
      [dartx.scale3d]: [html$.DomMatrix, [core.num], [core.num, core.num, core.num]],
      [dartx.scaleNonUniform]: [html$.DomMatrix, [core.num], [core.num, core.num, core.num, core.num, core.num]],
      [dartx.toFloat32Array]: [typed_data.Float32List, []],
      [dartx.toFloat64Array]: [typed_data.Float64List, []],
      [dartx.translate]: [html$.DomMatrix, [core.num, core.num], [core.num]]
    })
  });
  html$.DomMatrixReadOnly[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DOMMatrixReadOnly')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("DOMMatrixReadOnly"))];
  dart.registerExtension(dart.global.DOMMatrixReadOnly, html$.DomMatrixReadOnly);
  dart.defineExtensionNames([
    'a',
    'a',
    'b',
    'b',
    'c',
    'c',
    'd',
    'd',
    'e',
    'e',
    'f',
    'f',
    'm11',
    'm11',
    'm12',
    'm12',
    'm13',
    'm13',
    'm14',
    'm14',
    'm21',
    'm21',
    'm22',
    'm22',
    'm23',
    'm23',
    'm24',
    'm24',
    'm31',
    'm31',
    'm32',
    'm32',
    'm33',
    'm33',
    'm34',
    'm34',
    'm41',
    'm41',
    'm42',
    'm42',
    'm43',
    'm43',
    'm44',
    'm44',
    'multiplySelf',
    'preMultiplySelf',
    'scale3dSelf',
    'scaleNonUniformSelf',
    'scaleSelf',
    'translateSelf'
  ]);
  html$.DomMatrix = class DomMatrix extends html$.DomMatrixReadOnly {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(other) {
      if (other === void 0) other = null;
      if (other == null) {
        return html$.DomMatrix._create_1();
      }
      if (dart.is(other, html$.DomMatrixReadOnly) || other == null) {
        return html$.DomMatrix._create_2(other);
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    static _create_1() {
      return new DOMMatrix();
    }
    static _create_2(other) {
      return new DOMMatrix(other);
    }
    get [dartx.a]() {
      return this.a;
    }
    set [dartx.a](value) {
      this.a = value;
    }
    get [dartx.b]() {
      return this.b;
    }
    set [dartx.b](value) {
      this.b = value;
    }
    get [dartx.c]() {
      return this.c;
    }
    set [dartx.c](value) {
      this.c = value;
    }
    get [dartx.d]() {
      return this.d;
    }
    set [dartx.d](value) {
      this.d = value;
    }
    get [dartx.e]() {
      return this.e;
    }
    set [dartx.e](value) {
      this.e = value;
    }
    get [dartx.f]() {
      return this.f;
    }
    set [dartx.f](value) {
      this.f = value;
    }
    get [dartx.m11]() {
      return this.m11;
    }
    set [dartx.m11](value) {
      this.m11 = value;
    }
    get [dartx.m12]() {
      return this.m12;
    }
    set [dartx.m12](value) {
      this.m12 = value;
    }
    get [dartx.m13]() {
      return this.m13;
    }
    set [dartx.m13](value) {
      this.m13 = value;
    }
    get [dartx.m14]() {
      return this.m14;
    }
    set [dartx.m14](value) {
      this.m14 = value;
    }
    get [dartx.m21]() {
      return this.m21;
    }
    set [dartx.m21](value) {
      this.m21 = value;
    }
    get [dartx.m22]() {
      return this.m22;
    }
    set [dartx.m22](value) {
      this.m22 = value;
    }
    get [dartx.m23]() {
      return this.m23;
    }
    set [dartx.m23](value) {
      this.m23 = value;
    }
    get [dartx.m24]() {
      return this.m24;
    }
    set [dartx.m24](value) {
      this.m24 = value;
    }
    get [dartx.m31]() {
      return this.m31;
    }
    set [dartx.m31](value) {
      this.m31 = value;
    }
    get [dartx.m32]() {
      return this.m32;
    }
    set [dartx.m32](value) {
      this.m32 = value;
    }
    get [dartx.m33]() {
      return this.m33;
    }
    set [dartx.m33](value) {
      this.m33 = value;
    }
    get [dartx.m34]() {
      return this.m34;
    }
    set [dartx.m34](value) {
      this.m34 = value;
    }
    get [dartx.m41]() {
      return this.m41;
    }
    set [dartx.m41](value) {
      this.m41 = value;
    }
    get [dartx.m42]() {
      return this.m42;
    }
    set [dartx.m42](value) {
      this.m42 = value;
    }
    get [dartx.m43]() {
      return this.m43;
    }
    set [dartx.m43](value) {
      this.m43 = value;
    }
    get [dartx.m44]() {
      return this.m44;
    }
    set [dartx.m44](value) {
      this.m44 = value;
    }
    [dartx.multiplySelf](other) {
      return this.multiplySelf(other);
    }
    [dartx.preMultiplySelf](other) {
      return this.preMultiplySelf(other);
    }
    [dartx.scale3dSelf](scale, originX, originY, originZ) {
      return this.scale3dSelf(scale, originX, originY, originZ);
    }
    [dartx.scaleNonUniformSelf](scaleX, scaleY, scaleZ, originX, originY, originZ) {
      return this.scaleNonUniformSelf(scaleX, scaleY, scaleZ, originX, originY, originZ);
    }
    [dartx.scaleSelf](scale, originX, originY) {
      return this.scaleSelf(scale, originX, originY);
    }
    [dartx.translateSelf](tx, ty, tz) {
      return this.translateSelf(tx, ty, tz);
    }
  };
  dart.setSignature(html$.DomMatrix, {
    constructors: () => ({
      _: [html$.DomMatrix, []],
      new: [html$.DomMatrix, [], [html$.DomMatrixReadOnly]]
    }),
    methods: () => ({
      [dartx.multiplySelf]: [html$.DomMatrix, [html$.DomMatrix]],
      [dartx.preMultiplySelf]: [html$.DomMatrix, [html$.DomMatrix]],
      [dartx.scale3dSelf]: [html$.DomMatrix, [core.num], [core.num, core.num, core.num]],
      [dartx.scaleNonUniformSelf]: [html$.DomMatrix, [core.num], [core.num, core.num, core.num, core.num, core.num]],
      [dartx.scaleSelf]: [html$.DomMatrix, [core.num], [core.num, core.num]],
      [dartx.translateSelf]: [html$.DomMatrix, [core.num, core.num], [core.num]]
    }),
    statics: () => ({
      _create_1: [html$.DomMatrix, []],
      _create_2: [html$.DomMatrix, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.DomMatrix[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DOMMatrix')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("DOMMatrix"))];
  dart.registerExtension(dart.global.DOMMatrix, html$.DomMatrix);
  dart.defineExtensionNames([
    'parseFromString'
  ]);
  html$.DomParser = class DomParser extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.DomParser._create_1();
    }
    static _create_1() {
      return new DOMParser();
    }
    [dartx.parseFromString](str, type) {
      return this.parseFromString(str, type);
    }
  };
  dart.setSignature(html$.DomParser, {
    constructors: () => ({
      _: [html$.DomParser, []],
      new: [html$.DomParser, []]
    }),
    methods: () => ({[dartx.parseFromString]: [html$.Document, [core.String, core.String]]}),
    statics: () => ({_create_1: [html$.DomParser, []]}),
    names: ['_create_1']
  });
  html$.DomParser[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DOMParser')), dart.const(new _js_helper.Native("DOMParser"))];
  dart.registerExtension(dart.global.DOMParser, html$.DomParser);
  dart.defineExtensionNames([
    'w',
    'x',
    'y',
    'z'
  ]);
  html$.DomPointReadOnly = class DomPointReadOnly extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(x, y, z, w) {
      return html$.DomPointReadOnly._create_1(x, y, z, w);
    }
    static _create_1(x, y, z, w) {
      return new DOMPointReadOnly(x, y, z, w);
    }
    get [dartx.w]() {
      return this.w;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
    get [dartx.z]() {
      return this.z;
    }
  };
  dart.setSignature(html$.DomPointReadOnly, {
    constructors: () => ({
      _: [html$.DomPointReadOnly, []],
      new: [html$.DomPointReadOnly, [core.num, core.num, core.num, core.num]]
    }),
    statics: () => ({_create_1: [html$.DomPointReadOnly, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]]}),
    names: ['_create_1']
  });
  html$.DomPointReadOnly[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DOMPointReadOnly')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("DOMPointReadOnly"))];
  dart.registerExtension(dart.global.DOMPointReadOnly, html$.DomPointReadOnly);
  dart.defineExtensionNames([
    'w',
    'w',
    'x',
    'x',
    'y',
    'y',
    'z',
    'z'
  ]);
  html$.DomPoint = class DomPoint extends html$.DomPointReadOnly {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(point_OR_x, y, z, w) {
      if (point_OR_x === void 0) point_OR_x = null;
      if (y === void 0) y = null;
      if (z === void 0) z = null;
      if (w === void 0) w = null;
      if ((dart.is(point_OR_x, core.Map) || point_OR_x == null) && y == null && z == null && w == null) {
        let point_1 = html_common.convertDartToNative_Dictionary(dart.as(point_OR_x, core.Map));
        return html$.DomPoint._create_1(point_1);
      }
      if (point_OR_x == null && y == null && z == null && w == null) {
        return html$.DomPoint._create_2();
      }
      if ((typeof point_OR_x == 'number' || point_OR_x == null) && y == null && z == null && w == null) {
        return html$.DomPoint._create_3(point_OR_x);
      }
      if ((typeof y == 'number' || y == null) && (typeof point_OR_x == 'number' || point_OR_x == null) && z == null && w == null) {
        return html$.DomPoint._create_4(point_OR_x, y);
      }
      if ((typeof z == 'number' || z == null) && (typeof y == 'number' || y == null) && (typeof point_OR_x == 'number' || point_OR_x == null) && w == null) {
        return html$.DomPoint._create_5(point_OR_x, y, z);
      }
      if ((typeof w == 'number' || w == null) && (typeof z == 'number' || z == null) && (typeof y == 'number' || y == null) && (typeof point_OR_x == 'number' || point_OR_x == null)) {
        return html$.DomPoint._create_6(point_OR_x, y, z, w);
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    static _create_1(point_OR_x) {
      return new DOMPoint(point_OR_x);
    }
    static _create_2() {
      return new DOMPoint();
    }
    static _create_3(point_OR_x) {
      return new DOMPoint(point_OR_x);
    }
    static _create_4(point_OR_x, y) {
      return new DOMPoint(point_OR_x, y);
    }
    static _create_5(point_OR_x, y, z) {
      return new DOMPoint(point_OR_x, y, z);
    }
    static _create_6(point_OR_x, y, z, w) {
      return new DOMPoint(point_OR_x, y, z, w);
    }
    static get supported() {
      return !!window.DOMPoint || !!window.WebKitPoint;
    }
    get [dartx.w]() {
      return this.w;
    }
    set [dartx.w](value) {
      this.w = value;
    }
    get [dartx.x]() {
      return this.x;
    }
    set [dartx.x](value) {
      this.x = value;
    }
    get [dartx.y]() {
      return this.y;
    }
    set [dartx.y](value) {
      this.y = value;
    }
    get [dartx.z]() {
      return this.z;
    }
    set [dartx.z](value) {
      this.z = value;
    }
  };
  dart.setSignature(html$.DomPoint, {
    constructors: () => ({
      _: [html$.DomPoint, []],
      new: [html$.DomPoint, [], [dart.dynamic, core.num, core.num, core.num]]
    }),
    statics: () => ({
      _create_1: [html$.DomPoint, [dart.dynamic]],
      _create_2: [html$.DomPoint, []],
      _create_3: [html$.DomPoint, [dart.dynamic]],
      _create_4: [html$.DomPoint, [dart.dynamic, dart.dynamic]],
      _create_5: [html$.DomPoint, [dart.dynamic, dart.dynamic, dart.dynamic]],
      _create_6: [html$.DomPoint, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]]
    }),
    names: ['_create_1', '_create_2', '_create_3', '_create_4', '_create_5', '_create_6']
  });
  html$.DomPoint[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DOMPoint')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("DOMPoint"))];
  dart.registerExtension(dart.global.DOMPoint, html$.DomPoint);
  dart.defineExtensionNames([
    'toString',
    '==',
    'hashCode',
    'intersection',
    'intersects',
    'boundingBox',
    'containsRectangle',
    'containsPoint',
    'topLeft',
    'topRight',
    'bottomRight',
    'bottomLeft',
    'bottom',
    'height',
    'left',
    'right',
    'top',
    'width',
    'x',
    'y'
  ]);
  html$.DomRectReadOnly = class DomRectReadOnly extends _interceptors.Interceptor {
    [dartx.toString]() {
      return `Rectangle (${this[dartx.left]}, ${this[dartx.top]}) ${this[dartx.width]} x ${this[dartx.height]}`;
    }
    [dartx['==']](other) {
      if (!dart.is(other, math.Rectangle$(core.num))) return false;
      return dart.equals(this[dartx.left], dart.dload(other, 'left')) && dart.equals(this[dartx.top], dart.dload(other, 'top')) && dart.equals(this[dartx.width], dart.dload(other, 'width')) && dart.equals(this[dartx.height], dart.dload(other, 'height'));
    }
    get [dartx.hashCode]() {
      return html$._JenkinsSmiHash.hash4(dart.hashCode(this[dartx.left]), dart.hashCode(this[dartx.top]), dart.hashCode(this[dartx.width]), dart.hashCode(this[dartx.height]));
    }
    [dartx.intersection](other) {
      let x0 = math.max(core.num)(this[dartx.left], other[dartx.left]);
      let x1 = math.min(core.num)(dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]), dart.notNull(other[dartx.left]) + dart.notNull(other[dartx.width]));
      if (dart.notNull(x0) <= dart.notNull(x1)) {
        let y0 = math.max(core.num)(this[dartx.top], other[dartx.top]);
        let y1 = math.min(core.num)(dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]), dart.notNull(other[dartx.top]) + dart.notNull(other[dartx.height]));
        if (dart.notNull(y0) <= dart.notNull(y1)) {
          return new (math.Rectangle$(core.num))(x0, y0, dart.notNull(x1) - dart.notNull(x0), dart.notNull(y1) - dart.notNull(y0));
        }
      }
      return null;
    }
    [dartx.intersects](other) {
      return dart.notNull(this[dartx.left]) <= dart.notNull(other[dartx.left]) + dart.notNull(other[dartx.width]) && dart.notNull(other[dartx.left]) <= dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]) && dart.notNull(this[dartx.top]) <= dart.notNull(other[dartx.top]) + dart.notNull(other[dartx.height]) && dart.notNull(other[dartx.top]) <= dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]);
    }
    [dartx.boundingBox](other) {
      let right = math.max(core.num)(dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]), dart.notNull(other[dartx.left]) + dart.notNull(other[dartx.width]));
      let bottom = math.max(core.num)(dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]), dart.notNull(other[dartx.top]) + dart.notNull(other[dartx.height]));
      let left = math.min(core.num)(this[dartx.left], other[dartx.left]);
      let top = math.min(core.num)(this[dartx.top], other[dartx.top]);
      return new (math.Rectangle$(core.num))(left, top, dart.notNull(right) - dart.notNull(left), dart.notNull(bottom) - dart.notNull(top));
    }
    [dartx.containsRectangle](another) {
      return dart.notNull(this[dartx.left]) <= dart.notNull(another[dartx.left]) && dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]) >= dart.notNull(another[dartx.left]) + dart.notNull(another[dartx.width]) && dart.notNull(this[dartx.top]) <= dart.notNull(another[dartx.top]) && dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]) >= dart.notNull(another[dartx.top]) + dart.notNull(another[dartx.height]);
    }
    [dartx.containsPoint](another) {
      return dart.notNull(another.x) >= dart.notNull(this[dartx.left]) && dart.notNull(another.x) <= dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]) && dart.notNull(another.y) >= dart.notNull(this[dartx.top]) && dart.notNull(another.y) <= dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]);
    }
    get [dartx.topLeft]() {
      return new (math.Point$(core.num))(this[dartx.left], this[dartx.top]);
    }
    get [dartx.topRight]() {
      return new (math.Point$(core.num))(dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]), this[dartx.top]);
    }
    get [dartx.bottomRight]() {
      return new (math.Point$(core.num))(dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]), dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]));
    }
    get [dartx.bottomLeft]() {
      return new (math.Point$(core.num))(this[dartx.left], dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]));
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(x, y, width, height) {
      return html$.DomRectReadOnly._create_1(x, y, width, height);
    }
    static _create_1(x, y, width, height) {
      return new DOMRectReadOnly(x, y, width, height);
    }
    get [dartx.bottom]() {
      return this.bottom;
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.left]() {
      return this.left;
    }
    get [dartx.right]() {
      return this.right;
    }
    get [dartx.top]() {
      return this.top;
    }
    get [dartx.width]() {
      return this.width;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
  };
  html$.DomRectReadOnly[dart.implements] = () => [math.Rectangle$(core.num)];
  dart.setSignature(html$.DomRectReadOnly, {
    constructors: () => ({
      _: [html$.DomRectReadOnly, []],
      new: [html$.DomRectReadOnly, [core.num, core.num, core.num, core.num]]
    }),
    methods: () => ({
      [dartx.intersection]: [math.Rectangle$(core.num), [math.Rectangle$(core.num)]],
      [dartx.intersects]: [core.bool, [math.Rectangle$(core.num)]],
      [dartx.boundingBox]: [math.Rectangle$(core.num), [math.Rectangle$(core.num)]],
      [dartx.containsRectangle]: [core.bool, [math.Rectangle$(core.num)]],
      [dartx.containsPoint]: [core.bool, [math.Point$(core.num)]]
    }),
    statics: () => ({_create_1: [html$.DomRectReadOnly, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]]}),
    names: ['_create_1']
  });
  html$.DomRectReadOnly[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DOMRectReadOnly')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("DOMRectReadOnly"))];
  dart.registerExtension(dart.global.DOMRectReadOnly, html$.DomRectReadOnly);
  dart.defineExtensionNames([
    'add',
    'contains',
    'item',
    'remove',
    'toggle',
    'length'
  ]);
  html$.DomTokenList = class DomTokenList extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.add](tokens) {
      return this.add(tokens);
    }
    [dartx.contains](token) {
      return this.contains(token);
    }
    [dartx.item](index) {
      return this.item(index);
    }
    [dartx.remove](tokens) {
      return this.remove(tokens);
    }
    [dartx.toggle](token, force) {
      return this.toggle(token, force);
    }
  };
  dart.setSignature(html$.DomTokenList, {
    constructors: () => ({_: [html$.DomTokenList, []]}),
    methods: () => ({
      [dartx.add]: [dart.void, [core.String]],
      [dartx.contains]: [core.bool, [core.String]],
      [dartx.item]: [core.String, [core.int]],
      [dartx.remove]: [dart.void, [core.String]],
      [dartx.toggle]: [core.bool, [core.String], [core.bool]]
    })
  });
  html$.DomTokenList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DOMTokenList')), dart.const(new _js_helper.Native("DOMTokenList"))];
  dart.registerExtension(dart.global.DOMTokenList, html$.DomTokenList);
  dart.defineExtensionNames([
    'value'
  ]);
  html$.DomSettableTokenList = class DomSettableTokenList extends html$.DomTokenList {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.value]() {
      return this.value;
    }
    set [dartx.value](value) {
      this.value = value;
    }
  };
  dart.setSignature(html$.DomSettableTokenList, {
    constructors: () => ({_: [html$.DomSettableTokenList, []]})
  });
  html$.DomSettableTokenList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DOMSettableTokenList')), dart.const(new _js_helper.Native("DOMSettableTokenList"))];
  dart.registerExtension(dart.global.DOMSettableTokenList, html$.DomSettableTokenList);
  html$.ImmutableListMixin$ = dart.generic(E => {
    dart.defineExtensionNames([
      'iterator',
      'add',
      'addAll',
      'sort',
      'shuffle',
      'insert',
      'insertAll',
      'setAll',
      'removeAt',
      'removeLast',
      'remove',
      'removeWhere',
      'retainWhere',
      'setRange',
      'removeRange',
      'replaceRange',
      'fillRange'
    ]);
    class ImmutableListMixin extends core.Object {
      get iterator() {
        return new (html$.FixedSizeListIterator$(E))(this);
      }
      [Symbol.iterator]() {
        return new dart.JsIterator(this[dartx.iterator]);
      }
      add(value) {
        dart.as(value, E);
        dart.throw(new core.UnsupportedError("Cannot add to immutable List."));
      }
      addAll(iterable) {
        dart.as(iterable, core.Iterable$(E));
        dart.throw(new core.UnsupportedError("Cannot add to immutable List."));
      }
      sort(compare) {
        if (compare === void 0) compare = null;
        dart.as(compare, dart.functionType(core.int, [E, E]));
        dart.throw(new core.UnsupportedError("Cannot sort immutable List."));
      }
      shuffle(random) {
        if (random === void 0) random = null;
        dart.throw(new core.UnsupportedError("Cannot shuffle immutable List."));
      }
      insert(index, element) {
        dart.as(element, E);
        dart.throw(new core.UnsupportedError("Cannot add to immutable List."));
      }
      insertAll(index, iterable) {
        dart.as(iterable, core.Iterable$(E));
        dart.throw(new core.UnsupportedError("Cannot add to immutable List."));
      }
      setAll(index, iterable) {
        dart.as(iterable, core.Iterable$(E));
        dart.throw(new core.UnsupportedError("Cannot modify an immutable List."));
      }
      removeAt(pos) {
        dart.throw(new core.UnsupportedError("Cannot remove from immutable List."));
      }
      removeLast() {
        dart.throw(new core.UnsupportedError("Cannot remove from immutable List."));
      }
      remove(object) {
        dart.throw(new core.UnsupportedError("Cannot remove from immutable List."));
      }
      removeWhere(test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        dart.throw(new core.UnsupportedError("Cannot remove from immutable List."));
      }
      retainWhere(test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        dart.throw(new core.UnsupportedError("Cannot remove from immutable List."));
      }
      setRange(start, end, iterable, skipCount) {
        dart.as(iterable, core.Iterable$(E));
        if (skipCount === void 0) skipCount = 0;
        dart.throw(new core.UnsupportedError("Cannot setRange on immutable List."));
      }
      removeRange(start, end) {
        dart.throw(new core.UnsupportedError("Cannot removeRange on immutable List."));
      }
      replaceRange(start, end, iterable) {
        dart.as(iterable, core.Iterable$(E));
        dart.throw(new core.UnsupportedError("Cannot modify an immutable List."));
      }
      fillRange(start, end, fillValue) {
        if (fillValue === void 0) fillValue = null;
        dart.as(fillValue, E);
        dart.throw(new core.UnsupportedError("Cannot modify an immutable List."));
      }
    }
    ImmutableListMixin[dart.implements] = () => [core.List$(E)];
    dart.setSignature(ImmutableListMixin, {
      methods: () => ({
        add: [dart.void, [E]],
        addAll: [dart.void, [core.Iterable$(E)]],
        sort: [dart.void, [], [dart.functionType(core.int, [E, E])]],
        shuffle: [dart.void, [], [math.Random]],
        insert: [dart.void, [core.int, E]],
        insertAll: [dart.void, [core.int, core.Iterable$(E)]],
        setAll: [dart.void, [core.int, core.Iterable$(E)]],
        removeAt: [E, [core.int]],
        removeLast: [E, []],
        remove: [core.bool, [core.Object]],
        removeWhere: [dart.void, [dart.functionType(core.bool, [E])]],
        retainWhere: [dart.void, [dart.functionType(core.bool, [E])]],
        setRange: [dart.void, [core.int, core.int, core.Iterable$(E)], [core.int]],
        removeRange: [dart.void, [core.int, core.int]],
        replaceRange: [dart.void, [core.int, core.int, core.Iterable$(E)]],
        fillRange: [dart.void, [core.int, core.int], [E]]
      })
    });
    dart.defineExtensionMembers(ImmutableListMixin, [
      'add',
      'addAll',
      'sort',
      'shuffle',
      'insert',
      'insertAll',
      'setAll',
      'removeAt',
      'removeLast',
      'remove',
      'removeWhere',
      'retainWhere',
      'setRange',
      'removeRange',
      'replaceRange',
      'fillRange',
      'iterator'
    ]);
    return ImmutableListMixin;
  });
  html$.ImmutableListMixin = html$.ImmutableListMixin$();
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'item'
  ]);
  html$.DomStringList = class DomStringList extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(core.String), html$.ImmutableListMixin$(core.String)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return this[dartx.item](index);
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return this[0];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return this[dart.notNull(len) - 1];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return this[0];
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [__getter__](index) {
      return this.__getter__(index);
    }
    [dartx.item](index) {
      return this.item(index);
    }
  };
  html$.DomStringList[dart.implements] = () => [core.List$(core.String)];
  dart.setSignature(html$.DomStringList, {
    constructors: () => ({_: [html$.DomStringList, []]}),
    methods: () => ({
      [dartx.get]: [core.String, [core.int]],
      [dartx.set]: [dart.void, [core.int, core.String]],
      [dartx.elementAt]: [core.String, [core.int]],
      [__getter__]: [core.String, [core.int]],
      [dartx.item]: [core.String, [core.int]]
    })
  });
  html$.DomStringList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DOMStringList')), dart.const(new _js_helper.Native("DOMStringList"))];
  dart.registerExtension(dart.global.DOMStringList, html$.DomStringList);
  html$.DomStringMap = class DomStringMap extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$.DomStringMap, {
    constructors: () => ({_: [html$.DomStringMap, []]})
  });
  html$.DomStringMap[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DOMStringMap'))];
  html$.EffectModel = class EffectModel extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$.EffectModel, {
    constructors: () => ({_: [html$.EffectModel, []]})
  });
  html$.EffectModel[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('EffectModel')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("EffectModel"))];
  dart.registerExtension(dart.global.EffectModel, html$.EffectModel);
  const _childElements = Symbol('_childElements');
  const _element$ = Symbol('_element');
  const _filter$ = Symbol('_filter');
  html$._ChildrenElementList = class _ChildrenElementList extends collection.ListBase$(html$.Element) {
    _wrap(element) {
      this[_childElements] = dart.as(element[_children], html$.HtmlCollection);
      this[_element$] = element;
    }
    contains(element) {
      return this[_childElements][dartx.contains](element);
    }
    get isEmpty() {
      return this[_element$][_firstElementChild] == null;
    }
    get length() {
      return this[_childElements][dartx.length];
    }
    get(index) {
      return dart.as(this[_childElements][dartx.get](index), html$.Element);
    }
    set(index, value) {
      this[_element$][_replaceChild](value, this[_childElements][dartx.get](index));
      return value;
    }
    set length(newLength) {
      dart.throw(new core.UnsupportedError('Cannot resize element lists'));
    }
    add(value) {
      this[_element$][dartx.append](value);
      return value;
    }
    get iterator() {
      return this[dartx.toList]()[dartx.iterator];
    }
    addAll(iterable) {
      if (dart.is(iterable, html$._ChildNodeListLazy)) {
        iterable = core.List$(html$.Element).from(iterable);
      }
      for (let element of iterable) {
        this[_element$][dartx.append](element);
      }
    }
    sort(compare) {
      if (compare === void 0) compare = null;
      dart.throw(new core.UnsupportedError('Cannot sort element lists'));
    }
    shuffle(random) {
      if (random === void 0) random = null;
      dart.throw(new core.UnsupportedError('Cannot shuffle element lists'));
    }
    removeWhere(test) {
      this[_filter$](test, false);
    }
    retainWhere(test) {
      this[_filter$](test, true);
    }
    [_filter$](test, retainMatching) {
      let removed = null;
      if (dart.notNull(retainMatching)) {
        removed = this[_element$][dartx.children][dartx.where](dart.fn(e => !dart.notNull(test(e)), core.bool, [html$.Element]));
      } else {
        removed = this[_element$][dartx.children][dartx.where](test);
      }
      for (let e of dart.as(removed, core.Iterable))
        dart.dsend(e, 'remove');
    }
    setRange(start, end, iterable, skipCount) {
      if (skipCount === void 0) skipCount = 0;
      dart.throw(new core.UnimplementedError());
    }
    replaceRange(start, end, iterable) {
      dart.throw(new core.UnimplementedError());
    }
    fillRange(start, end, fillValue) {
      if (fillValue === void 0) fillValue = null;
      dart.throw(new core.UnimplementedError());
    }
    remove(object) {
      if (dart.is(object, html$.Element)) {
        let element = object;
        if (core.identical(element[dartx.parentNode], this[_element$])) {
          this[_element$][_removeChild](element);
          return true;
        }
      }
      return false;
    }
    insert(index, element) {
      if (dart.notNull(index) < 0 || dart.notNull(index) > dart.notNull(this.length)) {
        dart.throw(new core.RangeError.range(index, 0, this.length));
      }
      if (index == this.length) {
        this[_element$][dartx.append](element);
      } else {
        this[_element$][dartx.insertBefore](element, this.get(index));
      }
    }
    setAll(index, iterable) {
      dart.throw(new core.UnimplementedError());
    }
    clear() {
      this[_element$][_clearChildren]();
    }
    removeAt(index) {
      let result = this.get(index);
      if (result != null) {
        this[_element$][_removeChild](result);
      }
      return result;
    }
    removeLast() {
      let result = this.last;
      if (result != null) {
        this[_element$][_removeChild](result);
      }
      return result;
    }
    get first() {
      let result = this[_element$][_firstElementChild];
      if (result == null) dart.throw(new core.StateError("No elements"));
      return result;
    }
    get last() {
      let result = this[_element$][_lastElementChild];
      if (result == null) dart.throw(new core.StateError("No elements"));
      return result;
    }
    get single() {
      if (dart.notNull(this.length) > 1) dart.throw(new core.StateError("More than one element"));
      return this.first;
    }
    get rawList() {
      return this[_childElements];
    }
  };
  dart.defineNamedConstructor(html$._ChildrenElementList, '_wrap');
  html$._ChildrenElementList[dart.implements] = () => [html_common.NodeListWrapper];
  dart.setSignature(html$._ChildrenElementList, {
    constructors: () => ({_wrap: [html$._ChildrenElementList, [html$.Element]]}),
    methods: () => ({
      get: [html$.Element, [core.int]],
      set: [dart.void, [core.int, html$.Element]],
      add: [html$.Element, [html$.Element]],
      addAll: [dart.void, [core.Iterable$(html$.Element)]],
      sort: [dart.void, [], [dart.functionType(core.int, [html$.Element, html$.Element])]],
      removeWhere: [dart.void, [dart.functionType(core.bool, [html$.Element])]],
      retainWhere: [dart.void, [dart.functionType(core.bool, [html$.Element])]],
      [_filter$]: [dart.void, [dart.functionType(core.bool, [html$.Element]), core.bool]],
      setRange: [dart.void, [core.int, core.int, core.Iterable$(html$.Element)], [core.int]],
      replaceRange: [dart.void, [core.int, core.int, core.Iterable$(html$.Element)]],
      fillRange: [dart.void, [core.int, core.int], [html$.Element]],
      insert: [dart.void, [core.int, html$.Element]],
      setAll: [dart.void, [core.int, core.Iterable$(html$.Element)]],
      removeAt: [html$.Element, [core.int]],
      removeLast: [html$.Element, []]
    })
  });
  dart.defineExtensionMembers(html$._ChildrenElementList, [
    'contains',
    'get',
    'set',
    'add',
    'addAll',
    'sort',
    'shuffle',
    'removeWhere',
    'retainWhere',
    'setRange',
    'replaceRange',
    'fillRange',
    'remove',
    'insert',
    'setAll',
    'clear',
    'removeAt',
    'removeLast',
    'isEmpty',
    'length',
    'length',
    'iterator',
    'first',
    'last',
    'single'
  ]);
  html$.ElementList$ = dart.generic(T => {
    class ElementList extends collection.ListBase$(T) {}
    return ElementList;
  });
  html$.ElementList = html$.ElementList$();
  const _nodeList = Symbol('_nodeList');
  const _forElementList = Symbol('_forElementList');
  html$._FrozenElementList$ = dart.generic(E => {
    class _FrozenElementList extends collection.ListBase$(E) {
      _wrap(nodeList) {
        this[_nodeList] = nodeList;
      }
      get length() {
        return this[_nodeList][dartx.length];
      }
      get(index) {
        return html$._downcast(html$.Node, E)(this[_nodeList][dartx.get](index));
      }
      set(index, value) {
        dart.as(value, E);
        dart.throw(new core.UnsupportedError('Cannot modify list'));
        return value;
      }
      set length(newLength) {
        dart.throw(new core.UnsupportedError('Cannot modify list'));
      }
      sort(compare) {
        if (compare === void 0) compare = null;
        dart.as(compare, core.Comparator$(E));
        dart.throw(new core.UnsupportedError('Cannot sort list'));
      }
      shuffle(random) {
        if (random === void 0) random = null;
        dart.throw(new core.UnsupportedError('Cannot shuffle list'));
      }
      get first() {
        return html$._downcast(html$.Node, E)(this[_nodeList][dartx.first]);
      }
      get last() {
        return html$._downcast(html$.Node, E)(this[_nodeList][dartx.last]);
      }
      get single() {
        return html$._downcast(html$.Node, E)(this[_nodeList][dartx.single]);
      }
      get classes() {
        return html$._MultiElementCssClassSet.new(this);
      }
      get style() {
        return new html$._CssStyleDeclarationSet(this);
      }
      set classes(value) {
        this[dartx.forEach](dart.fn(e => {
          dart.as(e, E);
          return e[dartx.classes] = value;
        }, core.Iterable$(core.String), [E]));
      }
      get contentEdge() {
        return new html$._ContentCssListRect(this);
      }
      get paddingEdge() {
        return this.first[dartx.paddingEdge];
      }
      get borderEdge() {
        return this.first[dartx.borderEdge];
      }
      get marginEdge() {
        return this.first[dartx.marginEdge];
      }
      get rawList() {
        return this[_nodeList];
      }
      get onAbort() {
        return html$.Element.abortEvent[_forElementList](this);
      }
      get onBeforeCopy() {
        return html$.Element.beforeCopyEvent[_forElementList](this);
      }
      get onBeforeCut() {
        return html$.Element.beforeCutEvent[_forElementList](this);
      }
      get onBeforePaste() {
        return html$.Element.beforePasteEvent[_forElementList](this);
      }
      get onBlur() {
        return html$.Element.blurEvent[_forElementList](this);
      }
      get onCanPlay() {
        return html$.Element.canPlayEvent[_forElementList](this);
      }
      get onCanPlayThrough() {
        return html$.Element.canPlayThroughEvent[_forElementList](this);
      }
      get onChange() {
        return html$.Element.changeEvent[_forElementList](this);
      }
      get onClick() {
        return html$.Element.clickEvent[_forElementList](this);
      }
      get onContextMenu() {
        return html$.Element.contextMenuEvent[_forElementList](this);
      }
      get onCopy() {
        return html$.Element.copyEvent[_forElementList](this);
      }
      get onCut() {
        return html$.Element.cutEvent[_forElementList](this);
      }
      get onDoubleClick() {
        return html$.Element.doubleClickEvent[_forElementList](this);
      }
      get onDrag() {
        return html$.Element.dragEvent[_forElementList](this);
      }
      get onDragEnd() {
        return html$.Element.dragEndEvent[_forElementList](this);
      }
      get onDragEnter() {
        return html$.Element.dragEnterEvent[_forElementList](this);
      }
      get onDragLeave() {
        return html$.Element.dragLeaveEvent[_forElementList](this);
      }
      get onDragOver() {
        return html$.Element.dragOverEvent[_forElementList](this);
      }
      get onDragStart() {
        return html$.Element.dragStartEvent[_forElementList](this);
      }
      get onDrop() {
        return html$.Element.dropEvent[_forElementList](this);
      }
      get onDurationChange() {
        return html$.Element.durationChangeEvent[_forElementList](this);
      }
      get onEmptied() {
        return html$.Element.emptiedEvent[_forElementList](this);
      }
      get onEnded() {
        return html$.Element.endedEvent[_forElementList](this);
      }
      get onError() {
        return html$.Element.errorEvent[_forElementList](this);
      }
      get onFocus() {
        return html$.Element.focusEvent[_forElementList](this);
      }
      get onInput() {
        return html$.Element.inputEvent[_forElementList](this);
      }
      get onInvalid() {
        return html$.Element.invalidEvent[_forElementList](this);
      }
      get onKeyDown() {
        return html$.Element.keyDownEvent[_forElementList](this);
      }
      get onKeyPress() {
        return html$.Element.keyPressEvent[_forElementList](this);
      }
      get onKeyUp() {
        return html$.Element.keyUpEvent[_forElementList](this);
      }
      get onLoad() {
        return html$.Element.loadEvent[_forElementList](this);
      }
      get onLoadedData() {
        return html$.Element.loadedDataEvent[_forElementList](this);
      }
      get onLoadedMetadata() {
        return html$.Element.loadedMetadataEvent[_forElementList](this);
      }
      get onMouseDown() {
        return html$.Element.mouseDownEvent[_forElementList](this);
      }
      get onMouseEnter() {
        return html$.Element.mouseEnterEvent[_forElementList](this);
      }
      get onMouseLeave() {
        return html$.Element.mouseLeaveEvent[_forElementList](this);
      }
      get onMouseMove() {
        return html$.Element.mouseMoveEvent[_forElementList](this);
      }
      get onMouseOut() {
        return html$.Element.mouseOutEvent[_forElementList](this);
      }
      get onMouseOver() {
        return html$.Element.mouseOverEvent[_forElementList](this);
      }
      get onMouseUp() {
        return html$.Element.mouseUpEvent[_forElementList](this);
      }
      get onMouseWheel() {
        return html$.Element.mouseWheelEvent[_forElementList](this);
      }
      get onPaste() {
        return html$.Element.pasteEvent[_forElementList](this);
      }
      get onPause() {
        return html$.Element.pauseEvent[_forElementList](this);
      }
      get onPlay() {
        return html$.Element.playEvent[_forElementList](this);
      }
      get onPlaying() {
        return html$.Element.playingEvent[_forElementList](this);
      }
      get onRateChange() {
        return html$.Element.rateChangeEvent[_forElementList](this);
      }
      get onReset() {
        return html$.Element.resetEvent[_forElementList](this);
      }
      get onResize() {
        return html$.Element.resizeEvent[_forElementList](this);
      }
      get onScroll() {
        return html$.Element.scrollEvent[_forElementList](this);
      }
      get onSearch() {
        return html$.Element.searchEvent[_forElementList](this);
      }
      get onSeeked() {
        return html$.Element.seekedEvent[_forElementList](this);
      }
      get onSeeking() {
        return html$.Element.seekingEvent[_forElementList](this);
      }
      get onSelect() {
        return html$.Element.selectEvent[_forElementList](this);
      }
      get onSelectStart() {
        return html$.Element.selectStartEvent[_forElementList](this);
      }
      get onStalled() {
        return html$.Element.stalledEvent[_forElementList](this);
      }
      get onSubmit() {
        return html$.Element.submitEvent[_forElementList](this);
      }
      get onSuspend() {
        return html$.Element.suspendEvent[_forElementList](this);
      }
      get onTimeUpdate() {
        return html$.Element.timeUpdateEvent[_forElementList](this);
      }
      get onTouchCancel() {
        return html$.Element.touchCancelEvent[_forElementList](this);
      }
      get onTouchEnd() {
        return html$.Element.touchEndEvent[_forElementList](this);
      }
      get onTouchEnter() {
        return html$.Element.touchEnterEvent[_forElementList](this);
      }
      get onTouchLeave() {
        return html$.Element.touchLeaveEvent[_forElementList](this);
      }
      get onTouchMove() {
        return html$.Element.touchMoveEvent[_forElementList](this);
      }
      get onTouchStart() {
        return html$.Element.touchStartEvent[_forElementList](this);
      }
      get onTransitionEnd() {
        return html$.Element.transitionEndEvent[_forElementList](this);
      }
      get onVolumeChange() {
        return html$.Element.volumeChangeEvent[_forElementList](this);
      }
      get onWaiting() {
        return html$.Element.waitingEvent[_forElementList](this);
      }
      get onFullscreenChange() {
        return html$.Element.fullscreenChangeEvent[_forElementList](this);
      }
      get onFullscreenError() {
        return html$.Element.fullscreenErrorEvent[_forElementList](this);
      }
    }
    dart.defineNamedConstructor(_FrozenElementList, '_wrap');
    _FrozenElementList[dart.implements] = () => [html$.ElementList$(E), html_common.NodeListWrapper];
    dart.setSignature(_FrozenElementList, {
      constructors: () => ({_wrap: [html$._FrozenElementList$(E), [core.List$(html$.Node)]]}),
      methods: () => ({
        get: [E, [core.int]],
        set: [dart.void, [core.int, E]],
        sort: [dart.void, [], [core.Comparator$(E)]]
      })
    });
    dart.defineExtensionMembers(_FrozenElementList, [
      'get',
      'set',
      'sort',
      'shuffle',
      'length',
      'length',
      'first',
      'last',
      'single'
    ]);
    return _FrozenElementList;
  });
  html$._FrozenElementList = html$._FrozenElementList$();
  html$._ElementFactoryProvider = class _ElementFactoryProvider extends core.Object {
    static createElement_tag(tag, typeExtension) {
      if (typeExtension != null) {
        return document.createElement(tag, typeExtension);
      }
      return document.createElement(tag);
    }
  };
  dart.setSignature(html$._ElementFactoryProvider, {
    statics: () => ({createElement_tag: [dart.dynamic, [core.String, core.String]]}),
    names: ['createElement_tag']
  });
  const _value$1 = Symbol('_value');
  html$.ScrollAlignment = class ScrollAlignment extends core.Object {
    _internal(value) {
      this[_value$1] = value;
    }
    toString() {
      return `ScrollAlignment.${this[_value$1]}`;
    }
  };
  dart.defineNamedConstructor(html$.ScrollAlignment, '_internal');
  dart.setSignature(html$.ScrollAlignment, {
    constructors: () => ({_internal: [html$.ScrollAlignment, [dart.dynamic]]})
  });
  dart.defineLazy(html$.ScrollAlignment, {
    get TOP() {
      return dart.const(new html$.ScrollAlignment._internal('TOP'));
    },
    get CENTER() {
      return dart.const(new html$.ScrollAlignment._internal('CENTER'));
    },
    get BOTTOM() {
      return dart.const(new html$.ScrollAlignment._internal('BOTTOM'));
    }
  });
  const __setter__ = Symbol('__setter__');
  dart.defineExtensionNames([
    'height',
    'name',
    'src',
    'type',
    'width'
  ]);
  html$.EmbedElement = class EmbedElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("embed"), html$.EmbedElement);
    }
    created() {
      this[dartx.height] = null;
      this[dartx.name] = null;
      this[dartx.src] = null;
      this[dartx.type] = null;
      this[dartx.width] = null;
      super.created();
    }
    static get supported() {
      return html$.Element.isTagSupported('embed');
    }
    get [dartx.height]() {
      return this.height;
    }
    set [dartx.height](value) {
      this.height = value;
    }
    get [dartx.name]() {
      return this.name;
    }
    set [dartx.name](value) {
      this.name = value;
    }
    get [dartx.src]() {
      return this.src;
    }
    set [dartx.src](value) {
      this.src = value;
    }
    get [dartx.type]() {
      return this.type;
    }
    set [dartx.type](value) {
      this.type = value;
    }
    get [dartx.width]() {
      return this.width;
    }
    set [dartx.width](value) {
      this.width = value;
    }
    [__getter__](index_OR_name) {
      return this.__getter__(index_OR_name);
    }
    [__setter__](index_OR_name, value) {
      return this.__setter__(index_OR_name, value);
    }
  };
  dart.defineNamedConstructor(html$.EmbedElement, 'created');
  dart.setSignature(html$.EmbedElement, {
    constructors: () => ({
      _: [html$.EmbedElement, []],
      new: [html$.EmbedElement, []],
      created: [html$.EmbedElement, []]
    }),
    methods: () => ({
      [__getter__]: [core.bool, [dart.dynamic]],
      [__setter__]: [dart.void, [dart.dynamic, html$.Node]]
    })
  });
  html$.EmbedElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLEmbedElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("HTMLEmbedElement"))];
  dart.registerExtension(dart.global.HTMLEmbedElement, html$.EmbedElement);
  html$._EntriesCallback = dart.typedef('_EntriesCallback', () => dart.functionType(dart.void, [core.List$(html$.Entry)]));
  html$._EntryCallback = dart.typedef('_EntryCallback', () => dart.functionType(dart.void, [html$.Entry]));
  html$._ErrorCallback = dart.typedef('_ErrorCallback', () => dart.functionType(dart.void, [html$.FileError]));
  dart.defineExtensionNames([
    'colno',
    'error',
    'filename',
    'lineno',
    'message'
  ]);
  html$.ErrorEvent = class ErrorEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.ErrorEvent._create_1(type, eventInitDict_1);
      }
      return html$.ErrorEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new ErrorEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new ErrorEvent(type);
    }
    get [dartx.colno]() {
      return this.colno;
    }
    get [dartx.error]() {
      return this.error;
    }
    get [dartx.filename]() {
      return this.filename;
    }
    get [dartx.lineno]() {
      return this.lineno;
    }
    get [dartx.message]() {
      return this.message;
    }
  };
  dart.setSignature(html$.ErrorEvent, {
    constructors: () => ({
      _: [html$.ErrorEvent, []],
      new: [html$.ErrorEvent, [core.String], [core.Map]]
    }),
    statics: () => ({
      _create_1: [html$.ErrorEvent, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.ErrorEvent, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.ErrorEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ErrorEvent')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("ErrorEvent"))];
  dart.registerExtension(dart.global.ErrorEvent, html$.ErrorEvent);
  dart.defineExtensionNames([
    'close',
    'onError',
    'onMessage',
    'onOpen',
    'readyState',
    'url',
    'withCredentials'
  ]);
  html$.EventSource = class EventSource extends html$.EventTarget {
    static new(url, opts) {
      let withCredentials = opts && 'withCredentials' in opts ? opts.withCredentials : false;
      let parsedOptions = dart.map({withCredentials: withCredentials});
      return html$.EventSource._factoryEventSource(url, parsedOptions);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static _factoryEventSource(url, eventSourceInitDict) {
      if (eventSourceInitDict === void 0) eventSourceInitDict = null;
      if (eventSourceInitDict != null) {
        let eventSourceInitDict_1 = html_common.convertDartToNative_Dictionary(eventSourceInitDict);
        return html$.EventSource._create_1(url, eventSourceInitDict_1);
      }
      return html$.EventSource._create_2(url);
    }
    static _create_1(url, eventSourceInitDict) {
      return new EventSource(url, eventSourceInitDict);
    }
    static _create_2(url) {
      return new EventSource(url);
    }
    get [dartx.readyState]() {
      return this.readyState;
    }
    get [dartx.url]() {
      return this.url;
    }
    get [dartx.withCredentials]() {
      return this.withCredentials;
    }
    [dartx.close]() {
      return this.close();
    }
    get [dartx.onError]() {
      return html$.EventSource.errorEvent.forTarget(this);
    }
    get [dartx.onMessage]() {
      return html$.EventSource.messageEvent.forTarget(this);
    }
    get [dartx.onOpen]() {
      return html$.EventSource.openEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.EventSource, {
    constructors: () => ({
      new: [html$.EventSource, [core.String], {withCredentials: dart.dynamic}],
      _: [html$.EventSource, []]
    }),
    methods: () => ({[dartx.close]: [dart.void, []]}),
    statics: () => ({
      _factoryEventSource: [html$.EventSource, [core.String], [core.Map]],
      _create_1: [html$.EventSource, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.EventSource, [dart.dynamic]]
    }),
    names: ['_factoryEventSource', '_create_1', '_create_2']
  });
  html$.EventSource[dart.metadata] = () => [dart.const(new _metadata.DomName('EventSource')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("EventSource"))];
  html$.EventSource.CLOSED = 2;
  html$.EventSource.CONNECTING = 0;
  html$.EventSource.OPEN = 1;
  dart.defineLazy(html$.EventSource, {
    get errorEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('error'));
    },
    get messageEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MessageEvent))('message'));
    },
    get openEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('open'));
    }
  });
  dart.registerExtension(dart.global.EventSource, html$.EventSource);
  const _ptr = Symbol('_ptr');
  html$.Events = class Events extends core.Object {
    Events(ptr) {
      this[_ptr] = ptr;
    }
    get(type) {
      return new (html$._EventStream$(html$.Event))(this[_ptr], type, false);
    }
  };
  dart.setSignature(html$.Events, {
    constructors: () => ({Events: [html$.Events, [html$.EventTarget]]}),
    methods: () => ({get: [async.Stream, [core.String]]})
  });
  html$.ElementEvents = class ElementEvents extends html$.Events {
    ElementEvents(ptr) {
      super.Events(ptr);
    }
    get(type) {
      if (dart.notNull(html$.ElementEvents.webkitEvents[dartx.keys][dartx.contains](type[dartx.toLowerCase]()))) {
        if (dart.notNull(html_common.Device.isWebKit)) {
          return new (html$._ElementEventStreamImpl$(html$.Event))(this[_ptr], html$.ElementEvents.webkitEvents[dartx.get](type[dartx.toLowerCase]()), false);
        }
      }
      return new (html$._ElementEventStreamImpl$(html$.Event))(this[_ptr], type, false);
    }
  };
  dart.setSignature(html$.ElementEvents, {
    constructors: () => ({ElementEvents: [html$.ElementEvents, [html$.Element]]})
  });
  dart.defineLazy(html$.ElementEvents, {
    get webkitEvents() {
      return dart.map({animationend: 'webkitAnimationEnd', animationiteration: 'webkitAnimationIteration', animationstart: 'webkitAnimationStart', fullscreenchange: 'webkitfullscreenchange', fullscreenerror: 'webkitfullscreenerror', keyadded: 'webkitkeyadded', keyerror: 'webkitkeyerror', keymessage: 'webkitkeymessage', needkey: 'webkitneedkey', pointerlockchange: 'webkitpointerlockchange', pointerlockerror: 'webkitpointerlockerror', resourcetimingbufferfull: 'webkitresourcetimingbufferfull', transitionend: 'webkitTransitionEnd', speechchange: 'webkitSpeechChange'});
    }
  });
  dart.defineExtensionNames([
    'waitUntil'
  ]);
  html$.ExtendableEvent = class ExtendableEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.ExtendableEvent._create_1(type, eventInitDict_1);
      }
      return html$.ExtendableEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new ExtendableEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new ExtendableEvent(type);
    }
    [dartx.waitUntil](value) {
      return this.waitUntil(value);
    }
  };
  dart.setSignature(html$.ExtendableEvent, {
    constructors: () => ({
      _: [html$.ExtendableEvent, []],
      new: [html$.ExtendableEvent, [core.String], [core.Map]]
    }),
    methods: () => ({[dartx.waitUntil]: [dart.void, [core.Object]]}),
    statics: () => ({
      _create_1: [html$.ExtendableEvent, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.ExtendableEvent, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.ExtendableEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ExtendableEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("ExtendableEvent"))];
  dart.registerExtension(dart.global.ExtendableEvent, html$.ExtendableEvent);
  dart.defineExtensionNames([
    'protocol',
    'provider'
  ]);
  html$.FederatedCredential = class FederatedCredential extends html$.Credential {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(data) {
      let data_1 = html_common.convertDartToNative_Dictionary(data);
      return html$.FederatedCredential._create_1(data_1);
    }
    static _create_1(data) {
      return new FederatedCredential(data);
    }
    get [dartx.protocol]() {
      return this.protocol;
    }
    get [dartx.provider]() {
      return this.provider;
    }
  };
  dart.setSignature(html$.FederatedCredential, {
    constructors: () => ({
      _: [html$.FederatedCredential, []],
      new: [html$.FederatedCredential, [core.Map]]
    }),
    statics: () => ({_create_1: [html$.FederatedCredential, [dart.dynamic]]}),
    names: ['_create_1']
  });
  html$.FederatedCredential[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('FederatedCredential')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("FederatedCredential"))];
  dart.registerExtension(dart.global.FederatedCredential, html$.FederatedCredential);
  dart.defineExtensionNames([
    'respondWith',
    'isReload',
    'request'
  ]);
  html$.FetchEvent = class FetchEvent extends html$.ExtendableEvent {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.FetchEvent._create_1(type, eventInitDict_1);
      }
      return html$.FetchEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new FetchEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new FetchEvent(type);
    }
    get [dartx.isReload]() {
      return this.isReload;
    }
    get [dartx.request]() {
      return this.request;
    }
    [dartx.respondWith](value) {
      return this.respondWith(value);
    }
  };
  dart.setSignature(html$.FetchEvent, {
    constructors: () => ({
      _: [html$.FetchEvent, []],
      new: [html$.FetchEvent, [core.String], [core.Map]]
    }),
    methods: () => ({[dartx.respondWith]: [dart.void, [core.Object]]}),
    statics: () => ({
      _create_1: [html$.FetchEvent, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.FetchEvent, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.FetchEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('FetchEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("FetchEvent"))];
  dart.registerExtension(dart.global.FetchEvent, html$.FetchEvent);
  dart.defineExtensionNames([
    'checkValidity',
    'reportValidity',
    'setCustomValidity',
    'disabled',
    'elements',
    'form',
    'name',
    'type',
    'validationMessage',
    'validity',
    'willValidate'
  ]);
  html$.FieldSetElement = class FieldSetElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("fieldset"), html$.FieldSetElement);
    }
    created() {
      this[dartx.disabled] = null;
      this[dartx.elements] = null;
      this[dartx.form] = null;
      this[dartx.name] = null;
      this[dartx.type] = null;
      this[dartx.validationMessage] = null;
      this[dartx.validity] = null;
      this[dartx.willValidate] = null;
      super.created();
    }
    get [dartx.disabled]() {
      return this.disabled;
    }
    set [dartx.disabled](value) {
      this.disabled = value;
    }
    get [dartx.elements]() {
      return this.elements;
    }
    get [dartx.form]() {
      return this.form;
    }
    get [dartx.name]() {
      return this.name;
    }
    set [dartx.name](value) {
      this.name = value;
    }
    get [dartx.type]() {
      return this.type;
    }
    get [dartx.validationMessage]() {
      return this.validationMessage;
    }
    get [dartx.validity]() {
      return this.validity;
    }
    get [dartx.willValidate]() {
      return this.willValidate;
    }
    [dartx.checkValidity]() {
      return this.checkValidity();
    }
    [dartx.reportValidity]() {
      return this.reportValidity();
    }
    [dartx.setCustomValidity](error) {
      return this.setCustomValidity(error);
    }
  };
  dart.defineNamedConstructor(html$.FieldSetElement, 'created');
  dart.setSignature(html$.FieldSetElement, {
    constructors: () => ({
      _: [html$.FieldSetElement, []],
      new: [html$.FieldSetElement, []],
      created: [html$.FieldSetElement, []]
    }),
    methods: () => ({
      [dartx.checkValidity]: [core.bool, []],
      [dartx.reportValidity]: [core.bool, []],
      [dartx.setCustomValidity]: [dart.void, [core.String]]
    })
  });
  html$.FieldSetElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLFieldSetElement')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("HTMLFieldSetElement"))];
  dart.registerExtension(dart.global.HTMLFieldSetElement, html$.FieldSetElement);
  const _get_lastModifiedDate = Symbol('_get_lastModifiedDate');
  dart.defineExtensionNames([
    'lastModifiedDate',
    'lastModified',
    'name',
    'relativePath'
  ]);
  html$.File = class File extends html$.Blob {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(fileBits, fileName, options) {
      if (options === void 0) options = null;
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        return html$.File._create_1(fileBits, fileName, options_1);
      }
      return html$.File._create_2(fileBits, fileName);
    }
    static _create_1(fileBits, fileName, options) {
      return new File(fileBits, fileName, options);
    }
    static _create_2(fileBits, fileName) {
      return new File(fileBits, fileName);
    }
    get [dartx.lastModified]() {
      return this.lastModified;
    }
    get [dartx.lastModifiedDate]() {
      return html_common.convertNativeToDart_DateTime(this[_get_lastModifiedDate]);
    }
    get [_get_lastModifiedDate]() {
      return this.lastModifiedDate;
    }
    get [dartx.name]() {
      return this.name;
    }
    get [dartx.relativePath]() {
      return this.webkitRelativePath;
    }
  };
  dart.setSignature(html$.File, {
    constructors: () => ({
      _: [html$.File, []],
      new: [html$.File, [core.List$(core.Object), core.String], [core.Map]]
    }),
    statics: () => ({
      _create_1: [html$.File, [dart.dynamic, dart.dynamic, dart.dynamic]],
      _create_2: [html$.File, [dart.dynamic, dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.File[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('File')), dart.const(new _js_helper.Native("File"))];
  dart.registerExtension(dart.global.File, html$.File);
  html$._FileCallback = dart.typedef('_FileCallback', () => dart.functionType(dart.void, [html$.File]));
  const _createWriter = Symbol('_createWriter');
  const _file = Symbol('_file');
  dart.defineExtensionNames([
    'createWriter',
    'file'
  ]);
  html$.FileEntry = class FileEntry extends html$.Entry {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [_createWriter](successCallback, errorCallback) {
      return this.createWriter(successCallback, errorCallback);
    }
    [dartx.createWriter]() {
      let completer = async.Completer$(html$.FileWriter).new();
      this[_createWriter](dart.fn(value => {
        completer.complete(value);
      }, dart.void, [html$.FileWriter]), dart.fn(error => {
        completer.completeError(error);
      }, dart.void, [html$.FileError]));
      return completer.future;
    }
    [_file](successCallback, errorCallback) {
      return this.file(successCallback, errorCallback);
    }
    [dartx.file]() {
      let completer = async.Completer$(html$.File).new();
      this[_file](dart.fn(value => {
        completer.complete(value);
      }, dart.void, [html$.File]), dart.fn(error => {
        completer.completeError(error);
      }, dart.void, [html$.FileError]));
      return completer.future;
    }
  };
  dart.setSignature(html$.FileEntry, {
    constructors: () => ({_: [html$.FileEntry, []]}),
    methods: () => ({
      [_createWriter]: [dart.void, [html$._FileWriterCallback], [html$._ErrorCallback]],
      [dartx.createWriter]: [async.Future$(html$.FileWriter), []],
      [_file]: [dart.void, [html$._FileCallback], [html$._ErrorCallback]],
      [dartx.file]: [async.Future$(html$.File), []]
    })
  });
  html$.FileEntry[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('FileEntry')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("FileEntry"))];
  dart.registerExtension(dart.global.FileEntry, html$.FileEntry);
  dart.defineExtensionNames([
    'code'
  ]);
  html$.FileError = class FileError extends html$.DomError {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.code]() {
      return this.code;
    }
  };
  dart.setSignature(html$.FileError, {
    constructors: () => ({_: [html$.FileError, []]})
  });
  html$.FileError[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('FileError')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("FileError"))];
  html$.FileError.ABORT_ERR = 3;
  html$.FileError.ENCODING_ERR = 5;
  html$.FileError.INVALID_MODIFICATION_ERR = 9;
  html$.FileError.INVALID_STATE_ERR = 7;
  html$.FileError.NOT_FOUND_ERR = 1;
  html$.FileError.NOT_READABLE_ERR = 4;
  html$.FileError.NO_MODIFICATION_ALLOWED_ERR = 6;
  html$.FileError.PATH_EXISTS_ERR = 12;
  html$.FileError.QUOTA_EXCEEDED_ERR = 10;
  html$.FileError.SECURITY_ERR = 2;
  html$.FileError.SYNTAX_ERR = 8;
  html$.FileError.TYPE_MISMATCH_ERR = 11;
  dart.registerExtension(dart.global.FileError, html$.FileError);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'item'
  ]);
  html$.FileList = class FileList extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(html$.File), html$.ImmutableListMixin$(html$.File)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return this[index];
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return this[0];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return this[dart.notNull(len) - 1];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return this[0];
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [dartx.item](index) {
      return this.item(index);
    }
  };
  html$.FileList[dart.implements] = () => [_js_helper.JavaScriptIndexingBehavior, core.List$(html$.File)];
  dart.setSignature(html$.FileList, {
    constructors: () => ({_: [html$.FileList, []]}),
    methods: () => ({
      [dartx.get]: [html$.File, [core.int]],
      [dartx.set]: [dart.void, [core.int, html$.File]],
      [dartx.elementAt]: [html$.File, [core.int]],
      [dartx.item]: [html$.File, [core.int]]
    })
  });
  html$.FileList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('FileList')), dart.const(new _js_helper.Native("FileList"))];
  dart.registerExtension(dart.global.FileList, html$.FileList);
  dart.defineExtensionNames([
    'result',
    'abort',
    'readAsArrayBuffer',
    'readAsDataUrl',
    'readAsText',
    'onAbort',
    'onError',
    'onLoad',
    'onLoadEnd',
    'onLoadStart',
    'onProgress',
    'error',
    'readyState'
  ]);
  html$.FileReader = class FileReader extends html$.EventTarget {
    get [dartx.result]() {
      let res = this.result;
      if (dart.is(res, typed_data.ByteBuffer)) {
        return typed_data.Uint8List.view(res);
      }
      return res;
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.FileReader._create_1();
    }
    static _create_1() {
      return new FileReader();
    }
    get [dartx.error]() {
      return this.error;
    }
    get [dartx.readyState]() {
      return this.readyState;
    }
    [dartx.abort]() {
      return this.abort();
    }
    [dartx.readAsArrayBuffer](blob) {
      return this.readAsArrayBuffer(blob);
    }
    [dartx.readAsDataUrl](blob) {
      return this.readAsDataURL(blob);
    }
    [dartx.readAsText](blob, label) {
      return this.readAsText(blob, label);
    }
    get [dartx.onAbort]() {
      return html$.FileReader.abortEvent.forTarget(this);
    }
    get [dartx.onError]() {
      return html$.FileReader.errorEvent.forTarget(this);
    }
    get [dartx.onLoad]() {
      return html$.FileReader.loadEvent.forTarget(this);
    }
    get [dartx.onLoadEnd]() {
      return html$.FileReader.loadEndEvent.forTarget(this);
    }
    get [dartx.onLoadStart]() {
      return html$.FileReader.loadStartEvent.forTarget(this);
    }
    get [dartx.onProgress]() {
      return html$.FileReader.progressEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.FileReader, {
    constructors: () => ({
      _: [html$.FileReader, []],
      new: [html$.FileReader, []]
    }),
    methods: () => ({
      [dartx.abort]: [dart.void, []],
      [dartx.readAsArrayBuffer]: [dart.void, [html$.Blob]],
      [dartx.readAsDataUrl]: [dart.void, [html$.Blob]],
      [dartx.readAsText]: [dart.void, [html$.Blob], [core.String]]
    }),
    statics: () => ({_create_1: [html$.FileReader, []]}),
    names: ['_create_1']
  });
  html$.FileReader[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('FileReader')), dart.const(new _js_helper.Native("FileReader"))];
  html$.FileReader.DONE = 2;
  html$.FileReader.EMPTY = 0;
  html$.FileReader.LOADING = 1;
  dart.defineLazy(html$.FileReader, {
    get abortEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.ProgressEvent))('abort'));
    },
    get errorEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('error'));
    },
    get loadEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.ProgressEvent))('load'));
    },
    get loadEndEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.ProgressEvent))('loadend'));
    },
    get loadStartEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.ProgressEvent))('loadstart'));
    },
    get progressEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.ProgressEvent))('progress'));
    }
  });
  dart.registerExtension(dart.global.FileReader, html$.FileReader);
  dart.defineExtensionNames([
    'type'
  ]);
  html$.FileStream = class FileStream extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.type]() {
      return this.type;
    }
  };
  dart.setSignature(html$.FileStream, {
    constructors: () => ({_: [html$.FileStream, []]})
  });
  html$.FileStream[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Stream')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("Stream"))];
  dart.registerExtension(dart.global.Stream, html$.FileStream);
  dart.defineExtensionNames([
    'name',
    'root'
  ]);
  html$.FileSystem = class FileSystem extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static get supported() {
      return !!window.webkitRequestFileSystem;
    }
    get [dartx.name]() {
      return this.name;
    }
    get [dartx.root]() {
      return this.root;
    }
  };
  dart.setSignature(html$.FileSystem, {
    constructors: () => ({_: [html$.FileSystem, []]})
  });
  html$.FileSystem[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DOMFileSystem')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("DOMFileSystem"))];
  dart.registerExtension(dart.global.DOMFileSystem, html$.FileSystem);
  html$._FileSystemCallback = dart.typedef('_FileSystemCallback', () => dart.functionType(dart.void, [html$.FileSystem]));
  dart.defineExtensionNames([
    'abort',
    'seek',
    'truncate',
    'write',
    'onAbort',
    'onError',
    'onProgress',
    'onWrite',
    'onWriteEnd',
    'onWriteStart',
    'error',
    'length',
    'position',
    'readyState'
  ]);
  html$.FileWriter = class FileWriter extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.error]() {
      return this.error;
    }
    get [dartx.length]() {
      return this.length;
    }
    get [dartx.position]() {
      return this.position;
    }
    get [dartx.readyState]() {
      return this.readyState;
    }
    [dartx.abort]() {
      return this.abort();
    }
    [dartx.seek](position) {
      return this.seek(position);
    }
    [dartx.truncate](size) {
      return this.truncate(size);
    }
    [dartx.write](data) {
      return this.write(data);
    }
    get [dartx.onAbort]() {
      return html$.FileWriter.abortEvent.forTarget(this);
    }
    get [dartx.onError]() {
      return html$.FileWriter.errorEvent.forTarget(this);
    }
    get [dartx.onProgress]() {
      return html$.FileWriter.progressEvent.forTarget(this);
    }
    get [dartx.onWrite]() {
      return html$.FileWriter.writeEvent.forTarget(this);
    }
    get [dartx.onWriteEnd]() {
      return html$.FileWriter.writeEndEvent.forTarget(this);
    }
    get [dartx.onWriteStart]() {
      return html$.FileWriter.writeStartEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.FileWriter, {
    constructors: () => ({_: [html$.FileWriter, []]}),
    methods: () => ({
      [dartx.abort]: [dart.void, []],
      [dartx.seek]: [dart.void, [core.int]],
      [dartx.truncate]: [dart.void, [core.int]],
      [dartx.write]: [dart.void, [html$.Blob]]
    })
  });
  html$.FileWriter[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('FileWriter')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("FileWriter"))];
  html$.FileWriter.DONE = 2;
  html$.FileWriter.INIT = 0;
  html$.FileWriter.WRITING = 1;
  dart.defineLazy(html$.FileWriter, {
    get abortEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.ProgressEvent))('abort'));
    },
    get errorEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('error'));
    },
    get progressEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.ProgressEvent))('progress'));
    },
    get writeEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.ProgressEvent))('write'));
    },
    get writeEndEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.ProgressEvent))('writeend'));
    },
    get writeStartEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.ProgressEvent))('writestart'));
    }
  });
  dart.registerExtension(dart.global.FileWriter, html$.FileWriter);
  html$._FileWriterCallback = dart.typedef('_FileWriterCallback', () => dart.functionType(dart.void, [html$.FileWriter]));
  const _get_relatedTarget = Symbol('_get_relatedTarget');
  dart.defineExtensionNames([
    'relatedTarget'
  ]);
  html$.FocusEvent = class FocusEvent extends html$.UIEvent {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.FocusEvent._create_1(type, eventInitDict_1);
      }
      return html$.FocusEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new FocusEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new FocusEvent(type);
    }
    get [dartx.relatedTarget]() {
      return html$._convertNativeToDart_EventTarget(this[_get_relatedTarget]);
    }
    get [_get_relatedTarget]() {
      return this.relatedTarget;
    }
  };
  dart.setSignature(html$.FocusEvent, {
    constructors: () => ({
      _: [html$.FocusEvent, []],
      new: [html$.FocusEvent, [core.String], [core.Map]]
    }),
    statics: () => ({
      _create_1: [html$.FocusEvent, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.FocusEvent, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.FocusEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('FocusEvent')), dart.const(new _js_helper.Native("FocusEvent"))];
  dart.registerExtension(dart.global.FocusEvent, html$.FocusEvent);
  dart.defineExtensionNames([
    'load',
    'family',
    'featureSettings',
    'loaded',
    'status',
    'stretch',
    'style',
    'unicodeRange',
    'variant',
    'weight'
  ]);
  html$.FontFace = class FontFace extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(family, source, descriptors) {
      if (descriptors === void 0) descriptors = null;
      if (descriptors != null) {
        let descriptors_1 = html_common.convertDartToNative_Dictionary(descriptors);
        return html$.FontFace._create_1(family, source, descriptors_1);
      }
      return html$.FontFace._create_2(family, source);
    }
    static _create_1(family, source, descriptors) {
      return new FontFace(family, source, descriptors);
    }
    static _create_2(family, source) {
      return new FontFace(family, source);
    }
    get [dartx.family]() {
      return this.family;
    }
    set [dartx.family](value) {
      this.family = value;
    }
    get [dartx.featureSettings]() {
      return this.featureSettings;
    }
    set [dartx.featureSettings](value) {
      this.featureSettings = value;
    }
    get [dartx.loaded]() {
      return this.loaded;
    }
    get [dartx.status]() {
      return this.status;
    }
    get [dartx.stretch]() {
      return this.stretch;
    }
    set [dartx.stretch](value) {
      this.stretch = value;
    }
    get [dartx.style]() {
      return this.style;
    }
    set [dartx.style](value) {
      this.style = value;
    }
    get [dartx.unicodeRange]() {
      return this.unicodeRange;
    }
    set [dartx.unicodeRange](value) {
      this.unicodeRange = value;
    }
    get [dartx.variant]() {
      return this.variant;
    }
    set [dartx.variant](value) {
      this.variant = value;
    }
    get [dartx.weight]() {
      return this.weight;
    }
    set [dartx.weight](value) {
      this.weight = value;
    }
    [dartx.load]() {
      return this.load();
    }
  };
  dart.setSignature(html$.FontFace, {
    constructors: () => ({
      _: [html$.FontFace, []],
      new: [html$.FontFace, [core.String, core.Object], [core.Map]]
    }),
    methods: () => ({[dartx.load]: [async.Future, []]}),
    statics: () => ({
      _create_1: [html$.FontFace, [dart.dynamic, dart.dynamic, dart.dynamic]],
      _create_2: [html$.FontFace, [dart.dynamic, dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.FontFace[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('FontFace')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("FontFace"))];
  dart.registerExtension(dart.global.FontFace, html$.FontFace);
  dart.defineExtensionNames([
    'add',
    'check',
    'clear',
    'delete',
    'forEach',
    'has',
    'size',
    'status'
  ]);
  html$.FontFaceSet = class FontFaceSet extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.size]() {
      return this.size;
    }
    get [dartx.status]() {
      return this.status;
    }
    [dartx.add](fontFace) {
      return this.add(fontFace);
    }
    [dartx.check](font, text) {
      return this.check(font, text);
    }
    [dartx.clear]() {
      return this.clear();
    }
    [dartx.delete](fontFace) {
      return this.delete(fontFace);
    }
    [dartx.forEach](callback, thisArg) {
      return this.forEach(callback, thisArg);
    }
    [dartx.has](fontFace) {
      return this.has(fontFace);
    }
  };
  dart.setSignature(html$.FontFaceSet, {
    constructors: () => ({_: [html$.FontFaceSet, []]}),
    methods: () => ({
      [dartx.add]: [dart.void, [html$.FontFace]],
      [dartx.check]: [core.bool, [core.String], [core.String]],
      [dartx.clear]: [dart.void, []],
      [dartx.delete]: [core.bool, [html$.FontFace]],
      [dartx.forEach]: [dart.void, [html$.FontFaceSetForEachCallback], [core.Object]],
      [dartx.has]: [core.bool, [html$.FontFace]]
    })
  });
  html$.FontFaceSet[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('FontFaceSet')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("FontFaceSet"))];
  dart.registerExtension(dart.global.FontFaceSet, html$.FontFaceSet);
  html$.FontFaceSetForEachCallback = dart.typedef('FontFaceSetForEachCallback', () => dart.functionType(dart.void, [html$.FontFace, html$.FontFace, html$.FontFaceSet]));
  dart.defineExtensionNames([
    'fontfaces'
  ]);
  html$.FontFaceSetLoadEvent = class FontFaceSetLoadEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.fontfaces]() {
      return this.fontfaces;
    }
  };
  dart.setSignature(html$.FontFaceSetLoadEvent, {
    constructors: () => ({_: [html$.FontFaceSetLoadEvent, []]})
  });
  html$.FontFaceSetLoadEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('FontFaceSetLoadEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("FontFaceSetLoadEvent"))];
  dart.registerExtension(dart.global.FontFaceSetLoadEvent, html$.FontFaceSetLoadEvent);
  dart.defineExtensionNames([
    'append',
    'appendBlob',
    'delete',
    'get',
    'getAll',
    'has',
    'set'
  ]);
  html$.FormData = class FormData extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(form) {
      if (form === void 0) form = null;
      if (form != null) {
        return html$.FormData._create_1(form);
      }
      return html$.FormData._create_2();
    }
    static _create_1(form) {
      return new FormData(form);
    }
    static _create_2() {
      return new FormData();
    }
    static get supported() {
      return !!window.FormData;
    }
    [dartx.append](name, value) {
      return this.append(name, value);
    }
    [dartx.appendBlob](name, value, filename) {
      return this.append(name, value, filename);
    }
    [dartx.delete](name) {
      return this.delete(name);
    }
    [dartx.get](name) {
      return this.get(name);
    }
    [dartx.getAll](name) {
      return this.getAll(name);
    }
    [dartx.has](name) {
      return this.has(name);
    }
    [dartx.set](name, value, filename) {
      return this.set(name, value, filename);
    }
  };
  dart.setSignature(html$.FormData, {
    constructors: () => ({
      _: [html$.FormData, []],
      new: [html$.FormData, [], [html$.FormElement]]
    }),
    methods: () => ({
      [dartx.append]: [dart.void, [core.String, core.String]],
      [dartx.appendBlob]: [dart.void, [core.String, html$.Blob], [core.String]],
      [dartx.delete]: [dart.void, [core.String]],
      [dartx.get]: [core.Object, [core.String]],
      [dartx.getAll]: [core.List$(core.Object), [core.String]],
      [dartx.has]: [core.bool, [core.String]],
      [dartx.set]: [dart.void, [core.String, dart.dynamic], [core.String]]
    }),
    statics: () => ({
      _create_1: [html$.FormData, [dart.dynamic]],
      _create_2: [html$.FormData, []]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.FormData[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('FormData')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _js_helper.Native("FormData"))];
  dart.registerExtension(dart.global.FormData, html$.FormData);
  const _requestAutocomplete_1 = Symbol('_requestAutocomplete_1');
  dart.defineExtensionNames([
    'checkValidity',
    'item',
    'reportValidity',
    'requestAutocomplete',
    'reset',
    'submit',
    'acceptCharset',
    'action',
    'autocomplete',
    'encoding',
    'enctype',
    'length',
    'method',
    'name',
    'noValidate',
    'target'
  ]);
  html$.FormElement = class FormElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("form"), html$.FormElement);
    }
    created() {
      this[dartx.acceptCharset] = null;
      this[dartx.action] = null;
      this[dartx.autocomplete] = null;
      this[dartx.encoding] = null;
      this[dartx.enctype] = null;
      this[dartx.length] = null;
      this[dartx.method] = null;
      this[dartx.name] = null;
      this[dartx.noValidate] = null;
      this[dartx.target] = null;
      super.created();
    }
    get [dartx.acceptCharset]() {
      return this.acceptCharset;
    }
    set [dartx.acceptCharset](value) {
      this.acceptCharset = value;
    }
    get [dartx.action]() {
      return this.action;
    }
    set [dartx.action](value) {
      this.action = value;
    }
    get [dartx.autocomplete]() {
      return this.autocomplete;
    }
    set [dartx.autocomplete](value) {
      this.autocomplete = value;
    }
    get [dartx.encoding]() {
      return this.encoding;
    }
    set [dartx.encoding](value) {
      this.encoding = value;
    }
    get [dartx.enctype]() {
      return this.enctype;
    }
    set [dartx.enctype](value) {
      this.enctype = value;
    }
    get [dartx.length]() {
      return this.length;
    }
    get [dartx.method]() {
      return this.method;
    }
    set [dartx.method](value) {
      this.method = value;
    }
    get [dartx.name]() {
      return this.name;
    }
    set [dartx.name](value) {
      this.name = value;
    }
    get [dartx.noValidate]() {
      return this.noValidate;
    }
    set [dartx.noValidate](value) {
      this.noValidate = value;
    }
    get [dartx.target]() {
      return this.target;
    }
    set [dartx.target](value) {
      this.target = value;
    }
    [__getter__](name) {
      return this.__getter__(name);
    }
    [dartx.checkValidity]() {
      return this.checkValidity();
    }
    [dartx.item](index) {
      return this.item(index);
    }
    [dartx.reportValidity]() {
      return this.reportValidity();
    }
    [dartx.requestAutocomplete](details) {
      let details_1 = html_common.convertDartToNative_Dictionary(details);
      this[_requestAutocomplete_1](details_1);
      return;
    }
    [_requestAutocomplete_1](details) {
      return this.requestAutocomplete(details);
    }
    [dartx.reset]() {
      return this.reset();
    }
    [dartx.submit]() {
      return this.submit();
    }
  };
  dart.defineNamedConstructor(html$.FormElement, 'created');
  dart.setSignature(html$.FormElement, {
    constructors: () => ({
      _: [html$.FormElement, []],
      new: [html$.FormElement, []],
      created: [html$.FormElement, []]
    }),
    methods: () => ({
      [__getter__]: [core.Object, [core.String]],
      [dartx.checkValidity]: [core.bool, []],
      [dartx.item]: [html$.Element, [core.int]],
      [dartx.reportValidity]: [core.bool, []],
      [dartx.requestAutocomplete]: [dart.void, [core.Map]],
      [_requestAutocomplete_1]: [dart.void, [dart.dynamic]],
      [dartx.reset]: [dart.void, []],
      [dartx.submit]: [dart.void, []]
    })
  });
  html$.FormElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLFormElement')), dart.const(new _js_helper.Native("HTMLFormElement"))];
  dart.registerExtension(dart.global.HTMLFormElement, html$.FormElement);
  html$.FrameRequestCallback = dart.typedef('FrameRequestCallback', () => dart.functionType(dart.void, [core.num]));
  dart.defineExtensionNames([
    'axes',
    'buttons',
    'connected',
    'id',
    'index',
    'mapping',
    'timestamp'
  ]);
  html$.Gamepad = class Gamepad extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.axes]() {
      return this.axes;
    }
    get [dartx.buttons]() {
      return this.buttons;
    }
    get [dartx.connected]() {
      return this.connected;
    }
    get [dartx.id]() {
      return this.id;
    }
    get [dartx.index]() {
      return this.index;
    }
    get [dartx.mapping]() {
      return this.mapping;
    }
    get [dartx.timestamp]() {
      return this.timestamp;
    }
  };
  dart.setSignature(html$.Gamepad, {
    constructors: () => ({_: [html$.Gamepad, []]})
  });
  html$.Gamepad[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Gamepad')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("Gamepad"))];
  dart.registerExtension(dart.global.Gamepad, html$.Gamepad);
  dart.defineExtensionNames([
    'pressed',
    'value'
  ]);
  html$.GamepadButton = class GamepadButton extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.pressed]() {
      return this.pressed;
    }
    get [dartx.value]() {
      return this.value;
    }
  };
  dart.setSignature(html$.GamepadButton, {
    constructors: () => ({_: [html$.GamepadButton, []]})
  });
  html$.GamepadButton[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('GamepadButton')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("GamepadButton"))];
  dart.registerExtension(dart.global.GamepadButton, html$.GamepadButton);
  dart.defineExtensionNames([
    'gamepad'
  ]);
  html$.GamepadEvent = class GamepadEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.GamepadEvent._create_1(type, eventInitDict_1);
      }
      return html$.GamepadEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new GamepadEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new GamepadEvent(type);
    }
    get [dartx.gamepad]() {
      return this.gamepad;
    }
  };
  dart.setSignature(html$.GamepadEvent, {
    constructors: () => ({
      _: [html$.GamepadEvent, []],
      new: [html$.GamepadEvent, [core.String], [core.Map]]
    }),
    statics: () => ({
      _create_1: [html$.GamepadEvent, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.GamepadEvent, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.GamepadEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('GamepadEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("GamepadEvent"))];
  dart.registerExtension(dart.global.GamepadEvent, html$.GamepadEvent);
  dart.defineExtensionNames([
    'getRegisteredRegions',
    'registerRegion',
    'unregisterRegion'
  ]);
  html$.Geofencing = class Geofencing extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.getRegisteredRegions]() {
      return this.getRegisteredRegions();
    }
    [dartx.registerRegion](region) {
      return this.registerRegion(region);
    }
    [dartx.unregisterRegion](regionId) {
      return this.unregisterRegion(regionId);
    }
  };
  dart.setSignature(html$.Geofencing, {
    constructors: () => ({_: [html$.Geofencing, []]}),
    methods: () => ({
      [dartx.getRegisteredRegions]: [async.Future, []],
      [dartx.registerRegion]: [async.Future, [html$.GeofencingRegion]],
      [dartx.unregisterRegion]: [async.Future, [core.String]]
    })
  });
  html$.Geofencing[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Geofencing')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("Geofencing"))];
  dart.registerExtension(dart.global.Geofencing, html$.Geofencing);
  dart.defineExtensionNames([
    'id',
    'region'
  ]);
  html$.GeofencingEvent = class GeofencingEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.id]() {
      return this.id;
    }
    get [dartx.region]() {
      return this.region;
    }
  };
  dart.setSignature(html$.GeofencingEvent, {
    constructors: () => ({_: [html$.GeofencingEvent, []]})
  });
  html$.GeofencingEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('GeofencingEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("GeofencingEvent"))];
  dart.registerExtension(dart.global.GeofencingEvent, html$.GeofencingEvent);
  const _getCurrentPosition = Symbol('_getCurrentPosition');
  const _ensurePosition = Symbol('_ensurePosition');
  const _watchPosition = Symbol('_watchPosition');
  const _clearWatch = Symbol('_clearWatch');
  const _getCurrentPosition_1 = Symbol('_getCurrentPosition_1');
  const _getCurrentPosition_2 = Symbol('_getCurrentPosition_2');
  const _getCurrentPosition_3 = Symbol('_getCurrentPosition_3');
  const _watchPosition_1 = Symbol('_watchPosition_1');
  const _watchPosition_2 = Symbol('_watchPosition_2');
  const _watchPosition_3 = Symbol('_watchPosition_3');
  dart.defineExtensionNames([
    'getCurrentPosition',
    'watchPosition'
  ]);
  html$.Geolocation = class Geolocation extends _interceptors.Interceptor {
    [dartx.getCurrentPosition](opts) {
      let enableHighAccuracy = opts && 'enableHighAccuracy' in opts ? opts.enableHighAccuracy : null;
      let timeout = opts && 'timeout' in opts ? opts.timeout : null;
      let maximumAge = opts && 'maximumAge' in opts ? opts.maximumAge : null;
      let options = dart.map();
      if (enableHighAccuracy != null) {
        options[dartx.set]('enableHighAccuracy', enableHighAccuracy);
      }
      if (timeout != null) {
        options[dartx.set]('timeout', timeout.inMilliseconds);
      }
      if (maximumAge != null) {
        options[dartx.set]('maximumAge', maximumAge.inMilliseconds);
      }
      let completer = async.Completer$(html$.Geoposition).new();
      try {
        this[_getCurrentPosition](dart.fn(position => {
          completer.complete(this[_ensurePosition](position));
        }, dart.void, [html$.Geoposition]), dart.fn(error => {
          completer.completeError(error);
        }, dart.void, [html$.PositionError]), options);
      } catch (e) {
        let stacktrace = dart.stackTrace(e);
        completer.completeError(e, stacktrace);
      }

      return completer.future;
    }
    [dartx.watchPosition](opts) {
      let enableHighAccuracy = opts && 'enableHighAccuracy' in opts ? opts.enableHighAccuracy : null;
      let timeout = opts && 'timeout' in opts ? opts.timeout : null;
      let maximumAge = opts && 'maximumAge' in opts ? opts.maximumAge : null;
      let options = dart.map();
      if (enableHighAccuracy != null) {
        options[dartx.set]('enableHighAccuracy', enableHighAccuracy);
      }
      if (timeout != null) {
        options[dartx.set]('timeout', timeout.inMilliseconds);
      }
      if (maximumAge != null) {
        options[dartx.set]('maximumAge', maximumAge.inMilliseconds);
      }
      let watchId = null;
      let controller = null;
      controller = async.StreamController$(html$.Geoposition).new({sync: true, onListen: dart.fn(() => {
          dart.assert(watchId == null);
          watchId = this[_watchPosition](dart.fn(position => {
            controller.add(this[_ensurePosition](position));
          }, dart.void, [html$.Geoposition]), dart.fn(error => {
            controller.addError(error);
          }, dart.void, [html$.PositionError]), options);
        }, dart.void, []), onCancel: dart.fn(() => {
          dart.assert(watchId != null);
          this[_clearWatch](watchId);
        })});
      return controller.stream;
    }
    [_ensurePosition](domPosition) {
      try {
        if (dart.is(domPosition, html$.Geoposition)) {
          return domPosition;
        }
      } catch (e) {
      }

      return new html$._GeopositionWrapper(domPosition);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [_clearWatch](watchID) {
      return this.clearWatch(watchID);
    }
    [_getCurrentPosition](successCallback, errorCallback, options) {
      if (errorCallback === void 0) errorCallback = null;
      if (options === void 0) options = null;
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        this[_getCurrentPosition_1](successCallback, errorCallback, options_1);
        return;
      }
      if (errorCallback != null) {
        this[_getCurrentPosition_2](successCallback, errorCallback);
        return;
      }
      this[_getCurrentPosition_3](successCallback);
      return;
    }
    [_getCurrentPosition_1](successCallback, errorCallback, options) {
      return this.getCurrentPosition(successCallback, errorCallback, options);
    }
    [_getCurrentPosition_2](successCallback, errorCallback) {
      return this.getCurrentPosition(successCallback, errorCallback);
    }
    [_getCurrentPosition_3](successCallback) {
      return this.getCurrentPosition(successCallback);
    }
    [_watchPosition](successCallback, errorCallback, options) {
      if (errorCallback === void 0) errorCallback = null;
      if (options === void 0) options = null;
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        return this[_watchPosition_1](successCallback, errorCallback, options_1);
      }
      if (errorCallback != null) {
        return this[_watchPosition_2](successCallback, errorCallback);
      }
      return this[_watchPosition_3](successCallback);
    }
    [_watchPosition_1](successCallback, errorCallback, options) {
      return this.watchPosition(successCallback, errorCallback, options);
    }
    [_watchPosition_2](successCallback, errorCallback) {
      return this.watchPosition(successCallback, errorCallback);
    }
    [_watchPosition_3](successCallback) {
      return this.watchPosition(successCallback);
    }
  };
  dart.setSignature(html$.Geolocation, {
    constructors: () => ({_: [html$.Geolocation, []]}),
    methods: () => ({
      [dartx.getCurrentPosition]: [async.Future$(html$.Geoposition), [], {enableHighAccuracy: core.bool, timeout: core.Duration, maximumAge: core.Duration}],
      [dartx.watchPosition]: [async.Stream$(html$.Geoposition), [], {enableHighAccuracy: core.bool, timeout: core.Duration, maximumAge: core.Duration}],
      [_ensurePosition]: [html$.Geoposition, [dart.dynamic]],
      [_clearWatch]: [dart.void, [core.int]],
      [_getCurrentPosition]: [dart.void, [html$._PositionCallback], [html$._PositionErrorCallback, core.Map]],
      [_getCurrentPosition_1]: [dart.void, [html$._PositionCallback, html$._PositionErrorCallback, dart.dynamic]],
      [_getCurrentPosition_2]: [dart.void, [html$._PositionCallback, html$._PositionErrorCallback]],
      [_getCurrentPosition_3]: [dart.void, [html$._PositionCallback]],
      [_watchPosition]: [core.int, [html$._PositionCallback], [html$._PositionErrorCallback, core.Map]],
      [_watchPosition_1]: [core.int, [html$._PositionCallback, html$._PositionErrorCallback, dart.dynamic]],
      [_watchPosition_2]: [core.int, [html$._PositionCallback, html$._PositionErrorCallback]],
      [_watchPosition_3]: [core.int, [html$._PositionCallback]]
    })
  });
  html$.Geolocation[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Geolocation')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("Geolocation"))];
  dart.registerExtension(dart.global.Geolocation, html$.Geolocation);
  html$._GeopositionWrapper = class _GeopositionWrapper extends core.Object {
    _GeopositionWrapper(ptr) {
      this[_ptr] = ptr;
    }
    get coords() {
      return this[_ptr].coords;
    }
    get timestamp() {
      return this[_ptr].timestamp;
    }
  };
  html$._GeopositionWrapper[dart.implements] = () => [html$.Geoposition];
  dart.setSignature(html$._GeopositionWrapper, {
    constructors: () => ({_GeopositionWrapper: [html$._GeopositionWrapper, [dart.dynamic]]})
  });
  dart.defineExtensionNames([
    'coords',
    'timestamp'
  ]);
  html$.Geoposition = class Geoposition extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.coords]() {
      return this.coords;
    }
    get [dartx.timestamp]() {
      return this.timestamp;
    }
  };
  dart.setSignature(html$.Geoposition, {
    constructors: () => ({_: [html$.Geoposition, []]})
  });
  html$.Geoposition[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Geoposition')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("Geoposition"))];
  dart.registerExtension(dart.global.Geoposition, html$.Geoposition);
  dart.defineExtensionNames([
    'onAbort',
    'onBlur',
    'onCanPlay',
    'onCanPlayThrough',
    'onChange',
    'onClick',
    'onContextMenu',
    'onDoubleClick',
    'onDrag',
    'onDragEnd',
    'onDragEnter',
    'onDragLeave',
    'onDragOver',
    'onDragStart',
    'onDrop',
    'onDurationChange',
    'onEmptied',
    'onEnded',
    'onError',
    'onFocus',
    'onInput',
    'onInvalid',
    'onKeyDown',
    'onKeyPress',
    'onKeyUp',
    'onLoad',
    'onLoadedData',
    'onLoadedMetadata',
    'onMouseDown',
    'onMouseEnter',
    'onMouseLeave',
    'onMouseMove',
    'onMouseOut',
    'onMouseOver',
    'onMouseUp',
    'onMouseWheel',
    'onPause',
    'onPlay',
    'onPlaying',
    'onRateChange',
    'onReset',
    'onResize',
    'onScroll',
    'onSeeked',
    'onSeeking',
    'onSelect',
    'onStalled',
    'onSubmit',
    'onSuspend',
    'onTimeUpdate',
    'onVolumeChange',
    'onWaiting'
  ]);
  html$.GlobalEventHandlers = class GlobalEventHandlers extends core.Object {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get onAbort() {
      return html$.GlobalEventHandlers.abortEvent.forTarget(this);
    }
    get onBlur() {
      return html$.GlobalEventHandlers.blurEvent.forTarget(this);
    }
    get onCanPlay() {
      return html$.GlobalEventHandlers.canPlayEvent.forTarget(this);
    }
    get onCanPlayThrough() {
      return html$.GlobalEventHandlers.canPlayThroughEvent.forTarget(this);
    }
    get onChange() {
      return html$.GlobalEventHandlers.changeEvent.forTarget(this);
    }
    get onClick() {
      return html$.GlobalEventHandlers.clickEvent.forTarget(this);
    }
    get onContextMenu() {
      return html$.GlobalEventHandlers.contextMenuEvent.forTarget(this);
    }
    get onDoubleClick() {
      return html$.GlobalEventHandlers.doubleClickEvent.forTarget(this);
    }
    get onDrag() {
      return html$.GlobalEventHandlers.dragEvent.forTarget(this);
    }
    get onDragEnd() {
      return html$.GlobalEventHandlers.dragEndEvent.forTarget(this);
    }
    get onDragEnter() {
      return html$.GlobalEventHandlers.dragEnterEvent.forTarget(this);
    }
    get onDragLeave() {
      return html$.GlobalEventHandlers.dragLeaveEvent.forTarget(this);
    }
    get onDragOver() {
      return html$.GlobalEventHandlers.dragOverEvent.forTarget(this);
    }
    get onDragStart() {
      return html$.GlobalEventHandlers.dragStartEvent.forTarget(this);
    }
    get onDrop() {
      return html$.GlobalEventHandlers.dropEvent.forTarget(this);
    }
    get onDurationChange() {
      return html$.GlobalEventHandlers.durationChangeEvent.forTarget(this);
    }
    get onEmptied() {
      return html$.GlobalEventHandlers.emptiedEvent.forTarget(this);
    }
    get onEnded() {
      return html$.GlobalEventHandlers.endedEvent.forTarget(this);
    }
    get onError() {
      return html$.GlobalEventHandlers.errorEvent.forTarget(this);
    }
    get onFocus() {
      return html$.GlobalEventHandlers.focusEvent.forTarget(this);
    }
    get onInput() {
      return html$.GlobalEventHandlers.inputEvent.forTarget(this);
    }
    get onInvalid() {
      return html$.GlobalEventHandlers.invalidEvent.forTarget(this);
    }
    get onKeyDown() {
      return html$.GlobalEventHandlers.keyDownEvent.forTarget(this);
    }
    get onKeyPress() {
      return html$.GlobalEventHandlers.keyPressEvent.forTarget(this);
    }
    get onKeyUp() {
      return html$.GlobalEventHandlers.keyUpEvent.forTarget(this);
    }
    get onLoad() {
      return html$.GlobalEventHandlers.loadEvent.forTarget(this);
    }
    get onLoadedData() {
      return html$.GlobalEventHandlers.loadedDataEvent.forTarget(this);
    }
    get onLoadedMetadata() {
      return html$.GlobalEventHandlers.loadedMetadataEvent.forTarget(this);
    }
    get onMouseDown() {
      return html$.GlobalEventHandlers.mouseDownEvent.forTarget(this);
    }
    get onMouseEnter() {
      return html$.GlobalEventHandlers.mouseEnterEvent.forTarget(this);
    }
    get onMouseLeave() {
      return html$.GlobalEventHandlers.mouseLeaveEvent.forTarget(this);
    }
    get onMouseMove() {
      return html$.GlobalEventHandlers.mouseMoveEvent.forTarget(this);
    }
    get onMouseOut() {
      return html$.GlobalEventHandlers.mouseOutEvent.forTarget(this);
    }
    get onMouseOver() {
      return html$.GlobalEventHandlers.mouseOverEvent.forTarget(this);
    }
    get onMouseUp() {
      return html$.GlobalEventHandlers.mouseUpEvent.forTarget(this);
    }
    get onMouseWheel() {
      return html$.GlobalEventHandlers.mouseWheelEvent.forTarget(this);
    }
    get onPause() {
      return html$.GlobalEventHandlers.pauseEvent.forTarget(this);
    }
    get onPlay() {
      return html$.GlobalEventHandlers.playEvent.forTarget(this);
    }
    get onPlaying() {
      return html$.GlobalEventHandlers.playingEvent.forTarget(this);
    }
    get onRateChange() {
      return html$.GlobalEventHandlers.rateChangeEvent.forTarget(this);
    }
    get onReset() {
      return html$.GlobalEventHandlers.resetEvent.forTarget(this);
    }
    get onResize() {
      return html$.GlobalEventHandlers.resizeEvent.forTarget(this);
    }
    get onScroll() {
      return html$.GlobalEventHandlers.scrollEvent.forTarget(this);
    }
    get onSeeked() {
      return html$.GlobalEventHandlers.seekedEvent.forTarget(this);
    }
    get onSeeking() {
      return html$.GlobalEventHandlers.seekingEvent.forTarget(this);
    }
    get onSelect() {
      return html$.GlobalEventHandlers.selectEvent.forTarget(this);
    }
    get onStalled() {
      return html$.GlobalEventHandlers.stalledEvent.forTarget(this);
    }
    get onSubmit() {
      return html$.GlobalEventHandlers.submitEvent.forTarget(this);
    }
    get onSuspend() {
      return html$.GlobalEventHandlers.suspendEvent.forTarget(this);
    }
    get onTimeUpdate() {
      return html$.GlobalEventHandlers.timeUpdateEvent.forTarget(this);
    }
    get onVolumeChange() {
      return html$.GlobalEventHandlers.volumeChangeEvent.forTarget(this);
    }
    get onWaiting() {
      return html$.GlobalEventHandlers.waitingEvent.forTarget(this);
    }
  };
  html$.GlobalEventHandlers[dart.implements] = () => [html$.EventTarget];
  dart.setSignature(html$.GlobalEventHandlers, {
    constructors: () => ({_: [html$.GlobalEventHandlers, []]})
  });
  dart.defineExtensionMembers(html$.GlobalEventHandlers, [
    'onAbort',
    'onBlur',
    'onCanPlay',
    'onCanPlayThrough',
    'onChange',
    'onClick',
    'onContextMenu',
    'onDoubleClick',
    'onDrag',
    'onDragEnd',
    'onDragEnter',
    'onDragLeave',
    'onDragOver',
    'onDragStart',
    'onDrop',
    'onDurationChange',
    'onEmptied',
    'onEnded',
    'onError',
    'onFocus',
    'onInput',
    'onInvalid',
    'onKeyDown',
    'onKeyPress',
    'onKeyUp',
    'onLoad',
    'onLoadedData',
    'onLoadedMetadata',
    'onMouseDown',
    'onMouseEnter',
    'onMouseLeave',
    'onMouseMove',
    'onMouseOut',
    'onMouseOver',
    'onMouseUp',
    'onMouseWheel',
    'onPause',
    'onPlay',
    'onPlaying',
    'onRateChange',
    'onReset',
    'onResize',
    'onScroll',
    'onSeeked',
    'onSeeking',
    'onSelect',
    'onStalled',
    'onSubmit',
    'onSuspend',
    'onTimeUpdate',
    'onVolumeChange',
    'onWaiting'
  ]);
  html$.GlobalEventHandlers[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('GlobalEventHandlers')), dart.const(new _metadata.Experimental())];
  dart.defineLazy(html$.GlobalEventHandlers, {
    get abortEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('abort'));
    },
    get blurEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('blur'));
    },
    get canPlayEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('canplay'));
    },
    get canPlayThroughEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('canplaythrough'));
    },
    get changeEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('change'));
    },
    get clickEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MouseEvent))('click'));
    },
    get contextMenuEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MouseEvent))('contextmenu'));
    },
    get doubleClickEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('dblclick'));
    },
    get dragEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MouseEvent))('drag'));
    },
    get dragEndEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MouseEvent))('dragend'));
    },
    get dragEnterEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MouseEvent))('dragenter'));
    },
    get dragLeaveEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MouseEvent))('dragleave'));
    },
    get dragOverEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MouseEvent))('dragover'));
    },
    get dragStartEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MouseEvent))('dragstart'));
    },
    get dropEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MouseEvent))('drop'));
    },
    get durationChangeEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('durationchange'));
    },
    get emptiedEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('emptied'));
    },
    get endedEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('ended'));
    },
    get errorEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('error'));
    },
    get focusEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('focus'));
    },
    get inputEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('input'));
    },
    get invalidEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('invalid'));
    },
    get keyDownEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.KeyboardEvent))('keydown'));
    },
    get keyPressEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.KeyboardEvent))('keypress'));
    },
    get keyUpEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.KeyboardEvent))('keyup'));
    },
    get loadEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('load'));
    },
    get loadedDataEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('loadeddata'));
    },
    get loadedMetadataEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('loadedmetadata'));
    },
    get mouseDownEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MouseEvent))('mousedown'));
    },
    get mouseEnterEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MouseEvent))('mouseenter'));
    },
    get mouseLeaveEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MouseEvent))('mouseleave'));
    },
    get mouseMoveEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MouseEvent))('mousemove'));
    },
    get mouseOutEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MouseEvent))('mouseout'));
    },
    get mouseOverEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MouseEvent))('mouseover'));
    },
    get mouseUpEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MouseEvent))('mouseup'));
    },
    get mouseWheelEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.WheelEvent))('mousewheel'));
    },
    get pauseEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('pause'));
    },
    get playEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('play'));
    },
    get playingEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('playing'));
    },
    get rateChangeEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('ratechange'));
    },
    get resetEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('reset'));
    },
    get resizeEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('resize'));
    },
    get scrollEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('scroll'));
    },
    get seekedEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('seeked'));
    },
    get seekingEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('seeking'));
    },
    get selectEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('select'));
    },
    get stalledEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('stalled'));
    },
    get submitEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('submit'));
    },
    get suspendEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('suspend'));
    },
    get timeUpdateEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('timeupdate'));
    },
    get volumeChangeEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('volumechange'));
    },
    get waitingEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('waiting'));
    }
  });
  dart.defineExtensionNames([
    'color'
  ]);
  html$.HRElement = class HRElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("hr"), html$.HRElement);
    }
    created() {
      this[dartx.color] = null;
      super.created();
    }
    get [dartx.color]() {
      return this.color;
    }
    set [dartx.color](value) {
      this.color = value;
    }
  };
  dart.defineNamedConstructor(html$.HRElement, 'created');
  dart.setSignature(html$.HRElement, {
    constructors: () => ({
      _: [html$.HRElement, []],
      new: [html$.HRElement, []],
      created: [html$.HRElement, []]
    })
  });
  html$.HRElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLHRElement')), dart.const(new _js_helper.Native("HTMLHRElement"))];
  dart.registerExtension(dart.global.HTMLHRElement, html$.HRElement);
  const _initHashChangeEvent = Symbol('_initHashChangeEvent');
  dart.defineExtensionNames([
    'newUrl',
    'oldUrl'
  ]);
  html$.HashChangeEvent = class HashChangeEvent extends html$.Event {
    static new(type, opts) {
      let canBubble = opts && 'canBubble' in opts ? opts.canBubble : true;
      let cancelable = opts && 'cancelable' in opts ? opts.cancelable : true;
      let oldUrl = opts && 'oldUrl' in opts ? opts.oldUrl : null;
      let newUrl = opts && 'newUrl' in opts ? opts.newUrl : null;
      let options = dart.map({canBubble: canBubble, cancelable: cancelable, oldURL: oldUrl, newURL: newUrl});
      return new HashChangeEvent(type, html_common.convertDartToNative_Dictionary(options));
    }
    static _(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.HashChangeEvent._create_1(type, eventInitDict_1);
      }
      return html$.HashChangeEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new HashChangeEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new HashChangeEvent(type);
    }
    static get supported() {
      return html_common.Device.isEventTypeSupported('HashChangeEvent');
    }
    get [dartx.newUrl]() {
      return this.newURL;
    }
    get [dartx.oldUrl]() {
      return this.oldURL;
    }
    [_initHashChangeEvent](type, canBubble, cancelable, oldURL, newURL) {
      return this.initHashChangeEvent(type, canBubble, cancelable, oldURL, newURL);
    }
  };
  dart.setSignature(html$.HashChangeEvent, {
    constructors: () => ({
      new: [html$.HashChangeEvent, [core.String], {canBubble: core.bool, cancelable: core.bool, oldUrl: core.String, newUrl: core.String}],
      _: [html$.HashChangeEvent, [core.String], [core.Map]]
    }),
    methods: () => ({[_initHashChangeEvent]: [dart.void, [core.String, core.bool, core.bool, core.String, core.String]]}),
    statics: () => ({
      _create_1: [html$.HashChangeEvent, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.HashChangeEvent, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.HashChangeEvent[dart.metadata] = () => [dart.const(new _metadata.DomName('HashChangeEvent')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("HashChangeEvent"))];
  dart.registerExtension(dart.global.HashChangeEvent, html$.HashChangeEvent);
  html$.HeadElement = class HeadElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("head"), html$.HeadElement);
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(html$.HeadElement, 'created');
  dart.setSignature(html$.HeadElement, {
    constructors: () => ({
      _: [html$.HeadElement, []],
      new: [html$.HeadElement, []],
      created: [html$.HeadElement, []]
    })
  });
  html$.HeadElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLHeadElement')), dart.const(new _js_helper.Native("HTMLHeadElement"))];
  dart.registerExtension(dart.global.HTMLHeadElement, html$.HeadElement);
  html$.Headers = class Headers extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(input) {
      if (input === void 0) input = null;
      if (input == null) {
        return html$.Headers._create_1();
      }
      if (dart.is(input, html$.Headers)) {
        return html$.Headers._create_2(input);
      }
      if (dart.is(input, core.Map)) {
        let input_1 = html_common.convertDartToNative_Dictionary(input);
        return html$.Headers._create_3(input_1);
      }
      if (dart.is(input, core.List$(core.Object))) {
        return html$.Headers._create_4(input);
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    static _create_1() {
      return new Headers();
    }
    static _create_2(input) {
      return new Headers(input);
    }
    static _create_3(input) {
      return new Headers(input);
    }
    static _create_4(input) {
      return new Headers(input);
    }
  };
  dart.setSignature(html$.Headers, {
    constructors: () => ({
      _: [html$.Headers, []],
      new: [html$.Headers, [], [dart.dynamic]]
    }),
    statics: () => ({
      _create_1: [html$.Headers, []],
      _create_2: [html$.Headers, [dart.dynamic]],
      _create_3: [html$.Headers, [dart.dynamic]],
      _create_4: [html$.Headers, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2', '_create_3', '_create_4']
  });
  html$.Headers[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Headers')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("Headers"))];
  dart.registerExtension(dart.global.Headers, html$.Headers);
  html$.HeadingElement = class HeadingElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static h1() {
      return dart.as(html$.document[dartx.createElement]("h1"), html$.HeadingElement);
    }
    static h2() {
      return dart.as(html$.document[dartx.createElement]("h2"), html$.HeadingElement);
    }
    static h3() {
      return dart.as(html$.document[dartx.createElement]("h3"), html$.HeadingElement);
    }
    static h4() {
      return dart.as(html$.document[dartx.createElement]("h4"), html$.HeadingElement);
    }
    static h5() {
      return dart.as(html$.document[dartx.createElement]("h5"), html$.HeadingElement);
    }
    static h6() {
      return dart.as(html$.document[dartx.createElement]("h6"), html$.HeadingElement);
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(html$.HeadingElement, 'created');
  dart.setSignature(html$.HeadingElement, {
    constructors: () => ({
      _: [html$.HeadingElement, []],
      h1: [html$.HeadingElement, []],
      h2: [html$.HeadingElement, []],
      h3: [html$.HeadingElement, []],
      h4: [html$.HeadingElement, []],
      h5: [html$.HeadingElement, []],
      h6: [html$.HeadingElement, []],
      created: [html$.HeadingElement, []]
    })
  });
  html$.HeadingElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLHeadingElement')), dart.const(new _js_helper.Native("HTMLHeadingElement"))];
  dart.registerExtension(dart.global.HTMLHeadingElement, html$.HeadingElement);
  const _get_options = Symbol('_get_options');
  const _get_state = Symbol('_get_state');
  const _pushState_1 = Symbol('_pushState_1');
  const _pushState_2 = Symbol('_pushState_2');
  const _replaceState_1 = Symbol('_replaceState_1');
  const _replaceState_2 = Symbol('_replaceState_2');
  dart.defineExtensionNames([
    'options',
    'state',
    'back',
    'forward',
    'go',
    'pushState',
    'replaceState',
    'length'
  ]);
  html$.History = class History extends _interceptors.Interceptor {
    static get supportsState() {
      return !!window.history.pushState;
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    get [dartx.options]() {
      return html_common.convertNativeToDart_Dictionary(this[_get_options]);
    }
    get [_get_options]() {
      return this.options;
    }
    get [dartx.state]() {
      return html_common.convertNativeToDart_SerializedScriptValue(this[_get_state]);
    }
    get [_get_state]() {
      return this.state;
    }
    [dartx.back]() {
      return this.back();
    }
    [dartx.forward]() {
      return this.forward();
    }
    [dartx.go](delta) {
      return this.go(delta);
    }
    [dartx.pushState](data, title, url, options) {
      if (options === void 0) options = null;
      if (options != null) {
        let data_1 = html_common.convertDartToNative_SerializedScriptValue(data);
        let options_2 = html_common.convertDartToNative_Dictionary(options);
        this[_pushState_1](data_1, title, url, options_2);
        return;
      }
      let data_1 = html_common.convertDartToNative_SerializedScriptValue(data);
      this[_pushState_2](data_1, title, url);
      return;
    }
    [_pushState_1](data, title, url, options) {
      return this.pushState(data, title, url, options);
    }
    [_pushState_2](data, title, url) {
      return this.pushState(data, title, url);
    }
    [dartx.replaceState](data, title, url, options) {
      if (options === void 0) options = null;
      if (options != null) {
        let data_1 = html_common.convertDartToNative_SerializedScriptValue(data);
        let options_2 = html_common.convertDartToNative_Dictionary(options);
        this[_replaceState_1](data_1, title, url, options_2);
        return;
      }
      let data_1 = html_common.convertDartToNative_SerializedScriptValue(data);
      this[_replaceState_2](data_1, title, url);
      return;
    }
    [_replaceState_1](data, title, url, options) {
      return this.replaceState(data, title, url, options);
    }
    [_replaceState_2](data, title, url) {
      return this.replaceState(data, title, url);
    }
  };
  html$.History[dart.implements] = () => [html$.HistoryBase];
  dart.setSignature(html$.History, {
    constructors: () => ({_: [html$.History, []]}),
    methods: () => ({
      [dartx.back]: [dart.void, []],
      [dartx.forward]: [dart.void, []],
      [dartx.go]: [dart.void, [], [core.int]],
      [dartx.pushState]: [dart.void, [dart.dynamic, core.String, core.String], [core.Map]],
      [_pushState_1]: [dart.void, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]],
      [_pushState_2]: [dart.void, [dart.dynamic, dart.dynamic, dart.dynamic]],
      [dartx.replaceState]: [dart.void, [dart.dynamic, core.String, core.String], [core.Map]],
      [_replaceState_1]: [dart.void, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]],
      [_replaceState_2]: [dart.void, [dart.dynamic, dart.dynamic, dart.dynamic]]
    })
  });
  html$.History[dart.metadata] = () => [dart.const(new _metadata.DomName('History')), dart.const(new _js_helper.Native("History"))];
  dart.registerExtension(dart.global.History, html$.History);
  dart.defineExtensionNames([
    'deviceId',
    'deviceName',
    'hardwareUnitId'
  ]);
  html$.VRDevice = class VRDevice extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.deviceId]() {
      return this.deviceId;
    }
    get [dartx.deviceName]() {
      return this.deviceName;
    }
    get [dartx.hardwareUnitId]() {
      return this.hardwareUnitId;
    }
  };
  dart.setSignature(html$.VRDevice, {
    constructors: () => ({_: [html$.VRDevice, []]})
  });
  html$.VRDevice[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('VRDevice')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("VRDevice"))];
  dart.registerExtension(dart.global.VRDevice, html$.VRDevice);
  dart.defineExtensionNames([
    'getEyeParameters',
    'setFieldOfView'
  ]);
  html$.HmdvrDevice = class HmdvrDevice extends html$.VRDevice {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.getEyeParameters](whichEye) {
      return this.getEyeParameters(whichEye);
    }
    [dartx.setFieldOfView](leftFov, rightFov) {
      return this.setFieldOfView(leftFov, rightFov);
    }
  };
  dart.setSignature(html$.HmdvrDevice, {
    constructors: () => ({_: [html$.HmdvrDevice, []]}),
    methods: () => ({
      [dartx.getEyeParameters]: [html$.VREyeParameters, [core.String]],
      [dartx.setFieldOfView]: [dart.void, [], [html$.VRFieldOfView, html$.VRFieldOfView]]
    })
  });
  html$.HmdvrDevice[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HMDVRDevice')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("HMDVRDevice"))];
  dart.registerExtension(dart.global.HMDVRDevice, html$.HmdvrDevice);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'item',
    'namedItem'
  ]);
  html$.HtmlCollection = class HtmlCollection extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(html$.Node), html$.ImmutableListMixin$(html$.Node)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return this[index];
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return this[0];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return this[dart.notNull(len) - 1];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return this[0];
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [dartx.item](index) {
      return this.item(index);
    }
    [dartx.namedItem](name) {
      return this.namedItem(name);
    }
  };
  html$.HtmlCollection[dart.implements] = () => [_js_helper.JavaScriptIndexingBehavior, core.List$(html$.Node)];
  dart.setSignature(html$.HtmlCollection, {
    constructors: () => ({_: [html$.HtmlCollection, []]}),
    methods: () => ({
      [dartx.get]: [html$.Node, [core.int]],
      [dartx.set]: [dart.void, [core.int, html$.Node]],
      [dartx.elementAt]: [html$.Node, [core.int]],
      [dartx.item]: [html$.Node, [core.int]],
      [dartx.namedItem]: [core.Object, [core.String]]
    })
  });
  html$.HtmlCollection[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLCollection')), dart.const(new _js_helper.Native("HTMLCollection"))];
  dart.registerExtension(dart.global.HTMLCollection, html$.HtmlCollection);
  dart.defineExtensionNames([
    'caretRangeFromPoint',
    'elementFromPoint',
    'getCssCanvasContext',
    'head',
    'lastModified',
    'preferredStylesheetSet',
    'referrer',
    'selectedStylesheetSet',
    'selectedStylesheetSet',
    'styleSheets',
    'title',
    'title',
    'exitFullscreen',
    'registerElement',
    'register',
    'onVisibilityChange',
    'createElementUpgrader',
    'body'
  ]);
  html$.HtmlDocument = class HtmlDocument extends html$.Document {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.body]() {
      return this.body;
    }
    set [dartx.body](value) {
      this.body = value;
    }
    [dartx.caretRangeFromPoint](x, y) {
      return this[_caretRangeFromPoint](x, y);
    }
    [dartx.elementFromPoint](x, y) {
      return this[_elementFromPoint](x, y);
    }
    static get supportsCssCanvasContext() {
      return !!document.getCSSCanvasContext;
    }
    [dartx.getCssCanvasContext](contextId, name, width, height) {
      return dart.as(this[_getCssCanvasContext](contextId, name, width, height), html$.CanvasRenderingContext);
    }
    get [dartx.head]() {
      return this[_head$];
    }
    get [dartx.lastModified]() {
      return this[_lastModified];
    }
    get [dartx.preferredStylesheetSet]() {
      return this[_preferredStylesheetSet];
    }
    get [dartx.referrer]() {
      return this[_referrer];
    }
    get [dartx.selectedStylesheetSet]() {
      return this[_selectedStylesheetSet];
    }
    set [dartx.selectedStylesheetSet](value) {
      this[_selectedStylesheetSet] = value;
    }
    get [dartx.styleSheets]() {
      return this[_styleSheets];
    }
    get [dartx.title]() {
      return this[_title];
    }
    set [dartx.title](value) {
      this[_title] = value;
    }
    [dartx.exitFullscreen]() {
      this[_webkitExitFullscreen]();
    }
    [dartx.registerElement](tag, customElementClass, opts) {
      let extendsTag = opts && 'extendsTag' in opts ? opts.extendsTag : null;
      html$._registerCustomElement(window, this, tag, customElementClass, extendsTag);
    }
    [dartx.register](tag, customElementClass, opts) {
      let extendsTag = opts && 'extendsTag' in opts ? opts.extendsTag : null;
      return this[dartx.registerElement](tag, customElementClass, {extendsTag: extendsTag});
    }
    static _determineVisibilityChangeEventType(e) {
      if (typeof e.hidden !== "undefined") {
        return 'visibilitychange';
      } else if (typeof e.mozHidden !== "undefined") {
        return 'mozvisibilitychange';
      } else if (typeof e.msHidden !== "undefined") {
        return 'msvisibilitychange';
      } else if (typeof e.webkitHidden !== "undefined") {
        return 'webkitvisibilitychange';
      }
      return 'visibilitychange';
    }
    get [dartx.onVisibilityChange]() {
      return html$.HtmlDocument.visibilityChangeEvent.forTarget(this);
    }
    [dartx.createElementUpgrader](type, opts) {
      let extendsTag = opts && 'extendsTag' in opts ? opts.extendsTag : null;
      return new html$._JSElementUpgrader(this, type, extendsTag);
    }
  };
  dart.setSignature(html$.HtmlDocument, {
    constructors: () => ({_: [html$.HtmlDocument, []]}),
    methods: () => ({
      [dartx.caretRangeFromPoint]: [html$.Range, [core.int, core.int]],
      [dartx.elementFromPoint]: [html$.Element, [core.int, core.int]],
      [dartx.getCssCanvasContext]: [html$.CanvasRenderingContext, [core.String, core.String, core.int, core.int]],
      [dartx.registerElement]: [dart.void, [core.String, core.Type], {extendsTag: core.String}],
      [dartx.register]: [dart.void, [core.String, core.Type], {extendsTag: core.String}],
      [dartx.createElementUpgrader]: [html$.ElementUpgrader, [core.Type], {extendsTag: core.String}]
    }),
    statics: () => ({_determineVisibilityChangeEventType: [core.String, [html$.EventTarget]]}),
    names: ['_determineVisibilityChangeEventType']
  });
  html$.HtmlDocument[dart.metadata] = () => [dart.const(new _metadata.DomName('HTMLDocument')), dart.const(new _js_helper.Native("HTMLDocument"))];
  dart.defineLazy(html$.HtmlDocument, {
    get visibilityChangeEvent() {
      return dart.const(new (html$._CustomEventStreamProvider$(html$.Event))(html$.HtmlDocument._determineVisibilityChangeEventType));
    }
  });
  dart.registerExtension(dart.global.HTMLDocument, html$.HtmlDocument);
  dart.defineExtensionNames([
    'item',
    'namedItem'
  ]);
  html$.HtmlFormControlsCollection = class HtmlFormControlsCollection extends html$.HtmlCollection {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.item](index) {
      return this.item(index);
    }
    [dartx.namedItem](name) {
      return this.namedItem(name);
    }
  };
  dart.setSignature(html$.HtmlFormControlsCollection, {
    constructors: () => ({_: [html$.HtmlFormControlsCollection, []]})
  });
  html$.HtmlFormControlsCollection[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLFormControlsCollection')), dart.const(new _js_helper.Native("HTMLFormControlsCollection"))];
  dart.registerExtension(dart.global.HTMLFormControlsCollection, html$.HtmlFormControlsCollection);
  html$.HtmlHtmlElement = class HtmlHtmlElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("html"), html$.HtmlHtmlElement);
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(html$.HtmlHtmlElement, 'created');
  dart.setSignature(html$.HtmlHtmlElement, {
    constructors: () => ({
      _: [html$.HtmlHtmlElement, []],
      new: [html$.HtmlHtmlElement, []],
      created: [html$.HtmlHtmlElement, []]
    })
  });
  html$.HtmlHtmlElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLHtmlElement')), dart.const(new _js_helper.Native("HTMLHtmlElement"))];
  dart.registerExtension(dart.global.HTMLHtmlElement, html$.HtmlHtmlElement);
  const _item = Symbol('_item');
  html$.HtmlOptionsCollection = class HtmlOptionsCollection extends html$.HtmlCollection {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [_item](index) {
      return this.item(index);
    }
  };
  dart.setSignature(html$.HtmlOptionsCollection, {
    constructors: () => ({_: [html$.HtmlOptionsCollection, []]}),
    methods: () => ({[_item]: [html$.Node, [core.int]]})
  });
  html$.HtmlOptionsCollection[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLOptionsCollection')), dart.const(new _js_helper.Native("HTMLOptionsCollection"))];
  dart.registerExtension(dart.global.HTMLOptionsCollection, html$.HtmlOptionsCollection);
  const _get_response = Symbol('_get_response');
  dart.defineExtensionNames([
    'onAbort',
    'onError',
    'onLoad',
    'onLoadEnd',
    'onLoadStart',
    'onProgress',
    'onTimeout'
  ]);
  html$.HttpRequestEventTarget = class HttpRequestEventTarget extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.onAbort]() {
      return html$.HttpRequestEventTarget.abortEvent.forTarget(this);
    }
    get [dartx.onError]() {
      return html$.HttpRequestEventTarget.errorEvent.forTarget(this);
    }
    get [dartx.onLoad]() {
      return html$.HttpRequestEventTarget.loadEvent.forTarget(this);
    }
    get [dartx.onLoadEnd]() {
      return html$.HttpRequestEventTarget.loadEndEvent.forTarget(this);
    }
    get [dartx.onLoadStart]() {
      return html$.HttpRequestEventTarget.loadStartEvent.forTarget(this);
    }
    get [dartx.onProgress]() {
      return html$.HttpRequestEventTarget.progressEvent.forTarget(this);
    }
    get [dartx.onTimeout]() {
      return html$.HttpRequestEventTarget.timeoutEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.HttpRequestEventTarget, {
    constructors: () => ({_: [html$.HttpRequestEventTarget, []]})
  });
  html$.HttpRequestEventTarget[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('XMLHttpRequestEventTarget')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("XMLHttpRequestEventTarget"))];
  dart.defineLazy(html$.HttpRequestEventTarget, {
    get abortEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.ProgressEvent))('abort'));
    },
    get errorEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.ProgressEvent))('error'));
    },
    get loadEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.ProgressEvent))('load'));
    },
    get loadEndEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.ProgressEvent))('loadend'));
    },
    get loadStartEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.ProgressEvent))('loadstart'));
    },
    get progressEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.ProgressEvent))('progress'));
    },
    get timeoutEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.ProgressEvent))('timeout'));
    }
  });
  dart.registerExtension(dart.global.XMLHttpRequestEventTarget, html$.HttpRequestEventTarget);
  dart.defineExtensionNames([
    'responseHeaders',
    'open',
    'response',
    'abort',
    'getAllResponseHeaders',
    'getResponseHeader',
    'overrideMimeType',
    'send',
    'setRequestHeader',
    'onReadyStateChange',
    'readyState',
    'responseText',
    'responseType',
    'responseUrl',
    'responseXml',
    'status',
    'statusText',
    'timeout',
    'upload',
    'withCredentials'
  ]);
  html$.HttpRequest = class HttpRequest extends html$.HttpRequestEventTarget {
    static getString(url, opts) {
      let withCredentials = opts && 'withCredentials' in opts ? opts.withCredentials : null;
      let onProgress = opts && 'onProgress' in opts ? opts.onProgress : null;
      return html$.HttpRequest.request(url, {withCredentials: withCredentials, onProgress: onProgress}).then(core.String)(dart.fn(xhr => xhr[dartx.responseText], core.String, [html$.HttpRequest]));
    }
    static postFormData(url, data, opts) {
      let withCredentials = opts && 'withCredentials' in opts ? opts.withCredentials : null;
      let responseType = opts && 'responseType' in opts ? opts.responseType : null;
      let requestHeaders = opts && 'requestHeaders' in opts ? opts.requestHeaders : null;
      let onProgress = opts && 'onProgress' in opts ? opts.onProgress : null;
      let parts = [];
      data[dartx.forEach](dart.fn((key, value) => {
        parts[dartx.add](`${core.Uri.encodeQueryComponent(key)}=` + `${core.Uri.encodeQueryComponent(value)}`);
      }, dart.void, [core.String, core.String]));
      let formData = parts[dartx.join]('&');
      if (requestHeaders == null) {
        requestHeaders = dart.map({}, core.String, core.String);
      }
      requestHeaders[dartx.putIfAbsent]('Content-Type', dart.fn(() => 'application/x-www-form-urlencoded; charset=UTF-8', core.String, []));
      return html$.HttpRequest.request(url, {method: 'POST', withCredentials: withCredentials, responseType: responseType, requestHeaders: requestHeaders, sendData: formData, onProgress: onProgress});
    }
    static request(url, opts) {
      let method = opts && 'method' in opts ? opts.method : null;
      let withCredentials = opts && 'withCredentials' in opts ? opts.withCredentials : null;
      let responseType = opts && 'responseType' in opts ? opts.responseType : null;
      let mimeType = opts && 'mimeType' in opts ? opts.mimeType : null;
      let requestHeaders = opts && 'requestHeaders' in opts ? opts.requestHeaders : null;
      let sendData = opts && 'sendData' in opts ? opts.sendData : null;
      let onProgress = opts && 'onProgress' in opts ? opts.onProgress : null;
      let completer = async.Completer$(html$.HttpRequest).new();
      let xhr = html$.HttpRequest.new();
      if (method == null) {
        method = 'GET';
      }
      xhr[dartx.open](method, url, {async: true});
      if (withCredentials != null) {
        xhr[dartx.withCredentials] = withCredentials;
      }
      if (responseType != null) {
        xhr[dartx.responseType] = responseType;
      }
      if (mimeType != null) {
        xhr[dartx.overrideMimeType](mimeType);
      }
      if (requestHeaders != null) {
        requestHeaders[dartx.forEach](dart.fn((header, value) => {
          xhr[dartx.setRequestHeader](header, value);
        }, dart.void, [core.String, core.String]));
      }
      if (onProgress != null) {
        xhr[dartx.onProgress].listen(onProgress);
      }
      xhr[dartx.onLoad].listen(dart.fn(e => {
        let accepted = dart.notNull(xhr[dartx.status]) >= 200 && dart.notNull(xhr[dartx.status]) < 300;
        let fileUri = xhr[dartx.status] == 0;
        let notModified = xhr[dartx.status] == 304;
        let unknownRedirect = dart.notNull(xhr[dartx.status]) > 307 && dart.notNull(xhr[dartx.status]) < 400;
        if (accepted || fileUri || notModified || unknownRedirect) {
          completer.complete(xhr);
        } else {
          completer.completeError(e);
        }
      }, dart.void, [html$.ProgressEvent]));
      xhr[dartx.onError].listen(dart.bind(completer, 'completeError'));
      if (sendData != null) {
        xhr[dartx.send](sendData);
      } else {
        xhr[dartx.send]();
      }
      return completer.future;
    }
    static get supportsProgressEvent() {
      let xhr = html$.HttpRequest.new();
      return "onprogress" in xhr;
    }
    static get supportsCrossOrigin() {
      let xhr = html$.HttpRequest.new();
      return "withCredentials" in xhr;
    }
    static get supportsLoadEndEvent() {
      let xhr = html$.HttpRequest.new();
      return "onloadend" in xhr;
    }
    static get supportsOverrideMimeType() {
      let xhr = html$.HttpRequest.new();
      return "overrideMimeType" in xhr;
    }
    static requestCrossOrigin(url, opts) {
      let method = opts && 'method' in opts ? opts.method : null;
      let sendData = opts && 'sendData' in opts ? opts.sendData : null;
      if (dart.notNull(html$.HttpRequest.supportsCrossOrigin)) {
        return html$.HttpRequest.request(url, {method: method, sendData: sendData}).then(core.String)(dart.fn(xhr => xhr[dartx.responseText], core.String, [html$.HttpRequest]));
      }
      let completer = async.Completer$(core.String).new();
      if (method == null) {
        method = 'GET';
      }
      let xhr = new XDomainRequest();
      xhr.open(method, url);
      xhr.onload = _js_helper.convertDartClosureToJS(dart.functionType(dart.dynamic, [dart.dynamic]))(dart.fn(e => {
        let response = xhr.responseText;
        completer.complete(response);
      }), 1);
      xhr.onerror = _js_helper.convertDartClosureToJS(dart.functionType(dart.dynamic, [dart.dynamic]))(dart.fn(e => {
        completer.completeError(e);
      }), 1);
      xhr.onprogress = {};
      xhr.ontimeout = {};
      xhr.timeout = Number.MAX_VALUE;
      if (sendData != null) {
        xhr.send(sendData);
      } else {
        xhr.send();
      }
      return completer.future;
    }
    get [dartx.responseHeaders]() {
      let headers = dart.map({}, core.String, core.String);
      let headersString = this[dartx.getAllResponseHeaders]();
      if (headersString == null) {
        return headers;
      }
      let headersList = headersString[dartx.split]('\r\n');
      for (let header of headersList) {
        if (dart.notNull(header[dartx.isEmpty])) {
          continue;
        }
        let splitIdx = header[dartx.indexOf](': ');
        if (splitIdx == -1) {
          continue;
        }
        let key = header[dartx.substring](0, splitIdx)[dartx.toLowerCase]();
        let value = header[dartx.substring](dart.notNull(splitIdx) + 2);
        if (dart.notNull(headers[dartx.containsKey](key))) {
          headers[dartx.set](key, `${headers[dartx.get](key)}, ${value}`);
        } else {
          headers[dartx.set](key, value);
        }
      }
      return headers;
    }
    [dartx.open](method, url, opts) {
      return this.open(method, url, opts);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.HttpRequest._create_1();
    }
    static _create_1() {
      return new XMLHttpRequest();
    }
    get [dartx.readyState]() {
      return this.readyState;
    }
    get [dartx.response]() {
      return html$._convertNativeToDart_XHR_Response(this[_get_response]);
    }
    get [_get_response]() {
      return this.response;
    }
    get [dartx.responseText]() {
      return this.responseText;
    }
    get [dartx.responseType]() {
      return this.responseType;
    }
    set [dartx.responseType](value) {
      this.responseType = value;
    }
    get [dartx.responseUrl]() {
      return this.responseURL;
    }
    get [dartx.responseXml]() {
      return this.responseXML;
    }
    get [dartx.status]() {
      return this.status;
    }
    get [dartx.statusText]() {
      return this.statusText;
    }
    get [dartx.timeout]() {
      return this.timeout;
    }
    set [dartx.timeout](value) {
      this.timeout = value;
    }
    get [dartx.upload]() {
      return this.upload;
    }
    get [dartx.withCredentials]() {
      return this.withCredentials;
    }
    set [dartx.withCredentials](value) {
      this.withCredentials = value;
    }
    [dartx.abort]() {
      return this.abort();
    }
    [dartx.getAllResponseHeaders]() {
      return this.getAllResponseHeaders();
    }
    [dartx.getResponseHeader](name) {
      return this.getResponseHeader(name);
    }
    [dartx.overrideMimeType](mime) {
      return this.overrideMimeType(mime);
    }
    [dartx.send](body_OR_data) {
      return this.send(body_OR_data);
    }
    [dartx.setRequestHeader](name, value) {
      return this.setRequestHeader(name, value);
    }
    get [dartx.onReadyStateChange]() {
      return html$.HttpRequest.readyStateChangeEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.HttpRequest, {
    constructors: () => ({
      _: [html$.HttpRequest, []],
      new: [html$.HttpRequest, []]
    }),
    methods: () => ({
      [dartx.open]: [dart.void, [core.String, core.String], {async: core.bool, user: core.String, password: core.String}],
      [dartx.abort]: [dart.void, []],
      [dartx.getAllResponseHeaders]: [core.String, []],
      [dartx.getResponseHeader]: [core.String, [core.String]],
      [dartx.overrideMimeType]: [dart.void, [core.String]],
      [dartx.send]: [dart.void, [], [dart.dynamic]],
      [dartx.setRequestHeader]: [dart.void, [core.String, core.String]]
    }),
    statics: () => ({
      getString: [async.Future$(core.String), [core.String], {withCredentials: core.bool, onProgress: dart.functionType(dart.void, [html$.ProgressEvent])}],
      postFormData: [async.Future$(html$.HttpRequest), [core.String, core.Map$(core.String, core.String)], {withCredentials: core.bool, responseType: core.String, requestHeaders: core.Map$(core.String, core.String), onProgress: dart.functionType(dart.void, [html$.ProgressEvent])}],
      request: [async.Future$(html$.HttpRequest), [core.String], {method: core.String, withCredentials: core.bool, responseType: core.String, mimeType: core.String, requestHeaders: core.Map$(core.String, core.String), sendData: dart.dynamic, onProgress: dart.functionType(dart.void, [html$.ProgressEvent])}],
      requestCrossOrigin: [async.Future$(core.String), [core.String], {method: core.String, sendData: core.String}],
      _create_1: [html$.HttpRequest, []]
    }),
    names: ['getString', 'postFormData', 'request', 'requestCrossOrigin', '_create_1']
  });
  html$.HttpRequest[dart.metadata] = () => [dart.const(new _metadata.DomName('XMLHttpRequest')), dart.const(new _js_helper.Native("XMLHttpRequest"))];
  html$.HttpRequest.DONE = 4;
  html$.HttpRequest.HEADERS_RECEIVED = 2;
  html$.HttpRequest.LOADING = 3;
  html$.HttpRequest.OPENED = 1;
  html$.HttpRequest.UNSENT = 0;
  dart.defineLazy(html$.HttpRequest, {
    get readyStateChangeEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.ProgressEvent))('readystatechange'));
    }
  });
  dart.registerExtension(dart.global.XMLHttpRequest, html$.HttpRequest);
  html$.HttpRequestUpload = class HttpRequestUpload extends html$.HttpRequestEventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$.HttpRequestUpload, {
    constructors: () => ({_: [html$.HttpRequestUpload, []]})
  });
  html$.HttpRequestUpload[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('XMLHttpRequestUpload')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("XMLHttpRequestUpload"))];
  dart.registerExtension(dart.global.XMLHttpRequestUpload, html$.HttpRequestUpload);
  const _get_contentWindow = Symbol('_get_contentWindow');
  dart.defineExtensionNames([
    'contentWindow',
    'allowFullscreen',
    'height',
    'name',
    'sandbox',
    'src',
    'srcdoc',
    'width'
  ]);
  html$.IFrameElement = class IFrameElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("iframe"), html$.IFrameElement);
    }
    created() {
      this[dartx.allowFullscreen] = null;
      this[_get_contentWindow] = null;
      this[dartx.height] = null;
      this[dartx.name] = null;
      this[dartx.sandbox] = null;
      this[dartx.src] = null;
      this[dartx.srcdoc] = null;
      this[dartx.width] = null;
      super.created();
    }
    get [dartx.allowFullscreen]() {
      return this.allowFullscreen;
    }
    set [dartx.allowFullscreen](value) {
      this.allowFullscreen = value;
    }
    get [dartx.contentWindow]() {
      return html$._convertNativeToDart_Window(this[_get_contentWindow]);
    }
    get [_get_contentWindow]() {
      return this.contentWindow;
    }
    get [dartx.height]() {
      return this.height;
    }
    set [dartx.height](value) {
      this.height = value;
    }
    get [dartx.name]() {
      return this.name;
    }
    set [dartx.name](value) {
      this.name = value;
    }
    get [dartx.sandbox]() {
      return this.sandbox;
    }
    get [dartx.src]() {
      return this.src;
    }
    set [dartx.src](value) {
      this.src = value;
    }
    get [dartx.srcdoc]() {
      return this.srcdoc;
    }
    set [dartx.srcdoc](value) {
      this.srcdoc = value;
    }
    get [dartx.width]() {
      return this.width;
    }
    set [dartx.width](value) {
      this.width = value;
    }
  };
  dart.defineNamedConstructor(html$.IFrameElement, 'created');
  dart.setSignature(html$.IFrameElement, {
    constructors: () => ({
      _: [html$.IFrameElement, []],
      new: [html$.IFrameElement, []],
      created: [html$.IFrameElement, []]
    })
  });
  html$.IFrameElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLIFrameElement')), dart.const(new _js_helper.Native("HTMLIFrameElement"))];
  dart.registerExtension(dart.global.HTMLIFrameElement, html$.IFrameElement);
  dart.defineExtensionNames([
    'height',
    'width'
  ]);
  html$.ImageBitmap = class ImageBitmap extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.width]() {
      return this.width;
    }
  };
  dart.setSignature(html$.ImageBitmap, {
    constructors: () => ({_: [html$.ImageBitmap, []]})
  });
  html$.ImageBitmap[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ImageBitmap')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("ImageBitmap"))];
  dart.registerExtension(dart.global.ImageBitmap, html$.ImageBitmap);
  dart.defineExtensionNames([
    'data',
    'height',
    'width'
  ]);
  html$.ImageData = class ImageData extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(data_OR_sw, sh_OR_sw, sh) {
      if (sh === void 0) sh = null;
      if (typeof sh_OR_sw == 'number' && typeof data_OR_sw == 'number' && sh == null) {
        return html$.ImageData._create_1(data_OR_sw, sh_OR_sw);
      }
      if (typeof sh_OR_sw == 'number' && dart.is(data_OR_sw, typed_data.Uint8ClampedList) && sh == null) {
        return html$.ImageData._create_2(data_OR_sw, sh_OR_sw);
      }
      if (typeof sh == 'number' && typeof sh_OR_sw == 'number' && dart.is(data_OR_sw, typed_data.Uint8ClampedList)) {
        return html$.ImageData._create_3(data_OR_sw, sh_OR_sw, sh);
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    static _create_1(data_OR_sw, sh_OR_sw) {
      return new ImageData(data_OR_sw, sh_OR_sw);
    }
    static _create_2(data_OR_sw, sh_OR_sw) {
      return new ImageData(data_OR_sw, sh_OR_sw);
    }
    static _create_3(data_OR_sw, sh_OR_sw, sh) {
      return new ImageData(data_OR_sw, sh_OR_sw, sh);
    }
    get [dartx.data]() {
      return this.data;
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.width]() {
      return this.width;
    }
  };
  dart.setSignature(html$.ImageData, {
    constructors: () => ({
      _: [html$.ImageData, []],
      new: [html$.ImageData, [dart.dynamic, core.int], [core.int]]
    }),
    statics: () => ({
      _create_1: [html$.ImageData, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.ImageData, [dart.dynamic, dart.dynamic]],
      _create_3: [html$.ImageData, [dart.dynamic, dart.dynamic, dart.dynamic]]
    }),
    names: ['_create_1', '_create_2', '_create_3']
  });
  html$.ImageData[dart.metadata] = () => [dart.const(new _metadata.DomName('ImageData')), dart.const(new _js_helper.Native("ImageData"))];
  dart.registerExtension(dart.global.ImageData, html$.ImageData);
  dart.defineExtensionNames([
    'alt',
    'complete',
    'crossOrigin',
    'currentSrc',
    'height',
    'isMap',
    'naturalHeight',
    'naturalWidth',
    'sizes',
    'src',
    'srcset',
    'useMap',
    'width'
  ]);
  html$.ImageElement = class ImageElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(opts) {
      let src = opts && 'src' in opts ? opts.src : null;
      let width = opts && 'width' in opts ? opts.width : null;
      let height = opts && 'height' in opts ? opts.height : null;
      let e = dart.as(html$.document[dartx.createElement]("img"), html$.ImageElement);
      if (src != null) e[dartx.src] = src;
      if (width != null) e[dartx.width] = width;
      if (height != null) e[dartx.height] = height;
      return e;
    }
    created() {
      this[dartx.alt] = null;
      this[dartx.complete] = null;
      this[dartx.crossOrigin] = null;
      this[dartx.currentSrc] = null;
      this[dartx.height] = null;
      this[dartx.isMap] = null;
      this[dartx.naturalHeight] = null;
      this[dartx.naturalWidth] = null;
      this[dartx.sizes] = null;
      this[dartx.src] = null;
      this[dartx.srcset] = null;
      this[dartx.useMap] = null;
      this[dartx.width] = null;
      super.created();
    }
    get [dartx.alt]() {
      return this.alt;
    }
    set [dartx.alt](value) {
      this.alt = value;
    }
    get [dartx.complete]() {
      return this.complete;
    }
    get [dartx.crossOrigin]() {
      return this.crossOrigin;
    }
    set [dartx.crossOrigin](value) {
      this.crossOrigin = value;
    }
    get [dartx.currentSrc]() {
      return this.currentSrc;
    }
    get [dartx.height]() {
      return this.height;
    }
    set [dartx.height](value) {
      this.height = value;
    }
    get [dartx.isMap]() {
      return this.isMap;
    }
    set [dartx.isMap](value) {
      this.isMap = value;
    }
    get [dartx.naturalHeight]() {
      return this.naturalHeight;
    }
    get [dartx.naturalWidth]() {
      return this.naturalWidth;
    }
    get [dartx.sizes]() {
      return this.sizes;
    }
    set [dartx.sizes](value) {
      this.sizes = value;
    }
    get [dartx.src]() {
      return this.src;
    }
    set [dartx.src](value) {
      this.src = value;
    }
    get [dartx.srcset]() {
      return this.srcset;
    }
    set [dartx.srcset](value) {
      this.srcset = value;
    }
    get [dartx.useMap]() {
      return this.useMap;
    }
    set [dartx.useMap](value) {
      this.useMap = value;
    }
    get [dartx.width]() {
      return this.width;
    }
    set [dartx.width](value) {
      this.width = value;
    }
  };
  dart.defineNamedConstructor(html$.ImageElement, 'created');
  html$.ImageElement[dart.implements] = () => [html$.CanvasImageSource];
  dart.setSignature(html$.ImageElement, {
    constructors: () => ({
      _: [html$.ImageElement, []],
      new: [html$.ImageElement, [], {src: core.String, width: core.int, height: core.int}],
      created: [html$.ImageElement, []]
    })
  });
  html$.ImageElement[dart.metadata] = () => [dart.const(new _metadata.DomName('HTMLImageElement')), dart.const(new _js_helper.Native("HTMLImageElement"))];
  dart.registerExtension(dart.global.HTMLImageElement, html$.ImageElement);
  dart.defineExtensionNames([
    'inspect'
  ]);
  html$.InjectedScriptHost = class InjectedScriptHost extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.inspect](objectId, hints) {
      return this.inspect(objectId, hints);
    }
  };
  dart.setSignature(html$.InjectedScriptHost, {
    constructors: () => ({_: [html$.InjectedScriptHost, []]}),
    methods: () => ({[dartx.inspect]: [dart.void, [core.Object, core.Object]]})
  });
  html$.InjectedScriptHost[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('InjectedScriptHost')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("InjectedScriptHost"))];
  dart.registerExtension(dart.global.InjectedScriptHost, html$.InjectedScriptHost);
  dart.defineExtensionNames([
    'firesTouchEvents'
  ]);
  html$.InputDevice = class InputDevice extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(deviceInitDict) {
      if (deviceInitDict === void 0) deviceInitDict = null;
      if (deviceInitDict != null) {
        let deviceInitDict_1 = html_common.convertDartToNative_Dictionary(deviceInitDict);
        return html$.InputDevice._create_1(deviceInitDict_1);
      }
      return html$.InputDevice._create_2();
    }
    static _create_1(deviceInitDict) {
      return new InputDevice(deviceInitDict);
    }
    static _create_2() {
      return new InputDevice();
    }
    get [dartx.firesTouchEvents]() {
      return this.firesTouchEvents;
    }
  };
  dart.setSignature(html$.InputDevice, {
    constructors: () => ({
      _: [html$.InputDevice, []],
      new: [html$.InputDevice, [], [core.Map]]
    }),
    statics: () => ({
      _create_1: [html$.InputDevice, [dart.dynamic]],
      _create_2: [html$.InputDevice, []]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.InputDevice[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('InputDevice')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("InputDevice"))];
  dart.registerExtension(dart.global.InputDevice, html$.InputDevice);
  const _get_valueAsDate = Symbol('_get_valueAsDate');
  const _set_valueAsDate = Symbol('_set_valueAsDate');
  dart.defineExtensionNames([
    'valueAsDate',
    'valueAsDate',
    'checkValidity',
    'reportValidity',
    'select',
    'setCustomValidity',
    'setRangeText',
    'setSelectionRange',
    'stepDown',
    'stepUp',
    'accept',
    'alt',
    'autocapitalize',
    'autocomplete',
    'autofocus',
    'capture',
    'checked',
    'defaultChecked',
    'defaultValue',
    'dirName',
    'disabled',
    'files',
    'form',
    'formAction',
    'formEnctype',
    'formMethod',
    'formNoValidate',
    'formTarget',
    'height',
    'incremental',
    'indeterminate',
    'inputMode',
    'labels',
    'list',
    'max',
    'maxLength',
    'min',
    'minLength',
    'multiple',
    'name',
    'pattern',
    'placeholder',
    'readOnly',
    'required',
    'selectionDirection',
    'selectionEnd',
    'selectionStart',
    'size',
    'src',
    'step',
    'type',
    'validationMessage',
    'validity',
    'value',
    'valueAsNumber',
    'entries',
    'directory',
    'width',
    'willValidate'
  ]);
  html$.InputElement = class InputElement extends html$.HtmlElement {
    static new(opts) {
      let type = opts && 'type' in opts ? opts.type : null;
      let e = dart.as(html$.document[dartx.createElement]("input"), html$.InputElement);
      if (type != null) {
        try {
          e[dartx.type] = type;
        } catch (_) {
        }

      }
      return e;
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      this[dartx.accept] = null;
      this[dartx.alt] = null;
      this[dartx.autocapitalize] = null;
      this[dartx.autocomplete] = null;
      this[dartx.autofocus] = null;
      this[dartx.capture] = null;
      this[dartx.checked] = null;
      this[dartx.defaultChecked] = null;
      this[dartx.defaultValue] = null;
      this[dartx.dirName] = null;
      this[dartx.disabled] = null;
      this[dartx.files] = null;
      this[dartx.form] = null;
      this[dartx.formAction] = null;
      this[dartx.formEnctype] = null;
      this[dartx.formMethod] = null;
      this[dartx.formNoValidate] = null;
      this[dartx.formTarget] = null;
      this[dartx.height] = null;
      this[dartx.incremental] = null;
      this[dartx.indeterminate] = null;
      this[dartx.inputMode] = null;
      this[dartx.labels] = null;
      this[dartx.list] = null;
      this[dartx.max] = null;
      this[dartx.maxLength] = null;
      this[dartx.min] = null;
      this[dartx.minLength] = null;
      this[dartx.multiple] = null;
      this[dartx.name] = null;
      this[dartx.pattern] = null;
      this[dartx.placeholder] = null;
      this[dartx.readOnly] = null;
      this[dartx.required] = null;
      this[dartx.selectionDirection] = null;
      this[dartx.selectionEnd] = null;
      this[dartx.selectionStart] = null;
      this[dartx.size] = null;
      this[dartx.src] = null;
      this[dartx.step] = null;
      this[dartx.type] = null;
      this[dartx.validationMessage] = null;
      this[dartx.validity] = null;
      this[dartx.value] = null;
      this[_get_valueAsDate] = null;
      this[dartx.valueAsNumber] = null;
      this[dartx.entries] = null;
      this[dartx.directory] = null;
      this[dartx.width] = null;
      this[dartx.willValidate] = null;
      super.created();
    }
    get [dartx.accept]() {
      return this.accept;
    }
    set [dartx.accept](value) {
      this.accept = value;
    }
    get [dartx.alt]() {
      return this.alt;
    }
    set [dartx.alt](value) {
      this.alt = value;
    }
    get [dartx.autocapitalize]() {
      return this.autocapitalize;
    }
    set [dartx.autocapitalize](value) {
      this.autocapitalize = value;
    }
    get [dartx.autocomplete]() {
      return this.autocomplete;
    }
    set [dartx.autocomplete](value) {
      this.autocomplete = value;
    }
    get [dartx.autofocus]() {
      return this.autofocus;
    }
    set [dartx.autofocus](value) {
      this.autofocus = value;
    }
    get [dartx.capture]() {
      return this.capture;
    }
    set [dartx.capture](value) {
      this.capture = value;
    }
    get [dartx.checked]() {
      return this.checked;
    }
    set [dartx.checked](value) {
      this.checked = value;
    }
    get [dartx.defaultChecked]() {
      return this.defaultChecked;
    }
    set [dartx.defaultChecked](value) {
      this.defaultChecked = value;
    }
    get [dartx.defaultValue]() {
      return this.defaultValue;
    }
    set [dartx.defaultValue](value) {
      this.defaultValue = value;
    }
    get [dartx.dirName]() {
      return this.dirName;
    }
    set [dartx.dirName](value) {
      this.dirName = value;
    }
    get [dartx.disabled]() {
      return this.disabled;
    }
    set [dartx.disabled](value) {
      this.disabled = value;
    }
    get [dartx.files]() {
      return this.files;
    }
    set [dartx.files](value) {
      this.files = value;
    }
    get [dartx.form]() {
      return this.form;
    }
    get [dartx.formAction]() {
      return this.formAction;
    }
    set [dartx.formAction](value) {
      this.formAction = value;
    }
    get [dartx.formEnctype]() {
      return this.formEnctype;
    }
    set [dartx.formEnctype](value) {
      this.formEnctype = value;
    }
    get [dartx.formMethod]() {
      return this.formMethod;
    }
    set [dartx.formMethod](value) {
      this.formMethod = value;
    }
    get [dartx.formNoValidate]() {
      return this.formNoValidate;
    }
    set [dartx.formNoValidate](value) {
      this.formNoValidate = value;
    }
    get [dartx.formTarget]() {
      return this.formTarget;
    }
    set [dartx.formTarget](value) {
      this.formTarget = value;
    }
    get [dartx.height]() {
      return this.height;
    }
    set [dartx.height](value) {
      this.height = value;
    }
    get [dartx.incremental]() {
      return this.incremental;
    }
    set [dartx.incremental](value) {
      this.incremental = value;
    }
    get [dartx.indeterminate]() {
      return this.indeterminate;
    }
    set [dartx.indeterminate](value) {
      this.indeterminate = value;
    }
    get [dartx.inputMode]() {
      return this.inputMode;
    }
    set [dartx.inputMode](value) {
      this.inputMode = value;
    }
    get [dartx.labels]() {
      return this.labels;
    }
    get [dartx.list]() {
      return this.list;
    }
    get [dartx.max]() {
      return this.max;
    }
    set [dartx.max](value) {
      this.max = value;
    }
    get [dartx.maxLength]() {
      return this.maxLength;
    }
    set [dartx.maxLength](value) {
      this.maxLength = value;
    }
    get [dartx.min]() {
      return this.min;
    }
    set [dartx.min](value) {
      this.min = value;
    }
    get [dartx.minLength]() {
      return this.minLength;
    }
    set [dartx.minLength](value) {
      this.minLength = value;
    }
    get [dartx.multiple]() {
      return this.multiple;
    }
    set [dartx.multiple](value) {
      this.multiple = value;
    }
    get [dartx.name]() {
      return this.name;
    }
    set [dartx.name](value) {
      this.name = value;
    }
    get [dartx.pattern]() {
      return this.pattern;
    }
    set [dartx.pattern](value) {
      this.pattern = value;
    }
    get [dartx.placeholder]() {
      return this.placeholder;
    }
    set [dartx.placeholder](value) {
      this.placeholder = value;
    }
    get [dartx.readOnly]() {
      return this.readOnly;
    }
    set [dartx.readOnly](value) {
      this.readOnly = value;
    }
    get [dartx.required]() {
      return this.required;
    }
    set [dartx.required](value) {
      this.required = value;
    }
    get [dartx.selectionDirection]() {
      return this.selectionDirection;
    }
    set [dartx.selectionDirection](value) {
      this.selectionDirection = value;
    }
    get [dartx.selectionEnd]() {
      return this.selectionEnd;
    }
    set [dartx.selectionEnd](value) {
      this.selectionEnd = value;
    }
    get [dartx.selectionStart]() {
      return this.selectionStart;
    }
    set [dartx.selectionStart](value) {
      this.selectionStart = value;
    }
    get [dartx.size]() {
      return this.size;
    }
    set [dartx.size](value) {
      this.size = value;
    }
    get [dartx.src]() {
      return this.src;
    }
    set [dartx.src](value) {
      this.src = value;
    }
    get [dartx.step]() {
      return this.step;
    }
    set [dartx.step](value) {
      this.step = value;
    }
    get [dartx.type]() {
      return this.type;
    }
    set [dartx.type](value) {
      this.type = value;
    }
    get [dartx.validationMessage]() {
      return this.validationMessage;
    }
    get [dartx.validity]() {
      return this.validity;
    }
    get [dartx.value]() {
      return this.value;
    }
    set [dartx.value](value) {
      this.value = value;
    }
    get [dartx.valueAsDate]() {
      return html_common.convertNativeToDart_DateTime(this[_get_valueAsDate]);
    }
    get [_get_valueAsDate]() {
      return this.valueAsDate;
    }
    set [dartx.valueAsDate](value) {
      this[_set_valueAsDate] = html_common.convertDartToNative_DateTime(value);
    }
    set [_set_valueAsDate](value) {
      this.valueAsDate = value;
    }
    get [dartx.valueAsNumber]() {
      return this.valueAsNumber;
    }
    set [dartx.valueAsNumber](value) {
      this.valueAsNumber = value;
    }
    get [dartx.entries]() {
      return this.webkitEntries;
    }
    get [dartx.directory]() {
      return this.webkitdirectory;
    }
    set [dartx.directory](value) {
      this.webkitdirectory = value;
    }
    get [dartx.width]() {
      return this.width;
    }
    set [dartx.width](value) {
      this.width = value;
    }
    get [dartx.willValidate]() {
      return this.willValidate;
    }
    [dartx.checkValidity]() {
      return this.checkValidity();
    }
    [dartx.reportValidity]() {
      return this.reportValidity();
    }
    [dartx.select]() {
      return this.select();
    }
    [dartx.setCustomValidity](error) {
      return this.setCustomValidity(error);
    }
    [dartx.setRangeText](replacement, opts) {
      return this.setRangeText(replacement, opts);
    }
    [dartx.setSelectionRange](start, end, direction) {
      return this.setSelectionRange(start, end, direction);
    }
    [dartx.stepDown](n) {
      return this.stepDown(n);
    }
    [dartx.stepUp](n) {
      return this.stepUp(n);
    }
  };
  dart.defineNamedConstructor(html$.InputElement, 'created');
  html$.InputElement[dart.implements] = () => [html$.HiddenInputElement, html$.SearchInputElement, html$.TextInputElement, html$.UrlInputElement, html$.TelephoneInputElement, html$.EmailInputElement, html$.PasswordInputElement, html$.DateInputElement, html$.MonthInputElement, html$.WeekInputElement, html$.TimeInputElement, html$.LocalDateTimeInputElement, html$.NumberInputElement, html$.RangeInputElement, html$.CheckboxInputElement, html$.RadioButtonInputElement, html$.FileUploadInputElement, html$.SubmitButtonInputElement, html$.ImageButtonInputElement, html$.ResetButtonInputElement, html$.ButtonInputElement];
  dart.setSignature(html$.InputElement, {
    constructors: () => ({
      new: [html$.InputElement, [], {type: core.String}],
      _: [html$.InputElement, []],
      created: [html$.InputElement, []]
    }),
    methods: () => ({
      [dartx.checkValidity]: [core.bool, []],
      [dartx.reportValidity]: [core.bool, []],
      [dartx.select]: [dart.void, []],
      [dartx.setCustomValidity]: [dart.void, [core.String]],
      [dartx.setRangeText]: [dart.void, [core.String], {start: core.int, end: core.int, selectionMode: core.String}],
      [dartx.setSelectionRange]: [dart.void, [core.int, core.int], [core.String]],
      [dartx.stepDown]: [dart.void, [], [core.int]],
      [dartx.stepUp]: [dart.void, [], [core.int]]
    })
  });
  html$.InputElement[dart.metadata] = () => [dart.const(new _metadata.DomName('HTMLInputElement')), dart.const(new _js_helper.Native("HTMLInputElement"))];
  dart.registerExtension(dart.global.HTMLInputElement, html$.InputElement);
  dart.defineExtensionNames([
    'autofocus',
    'disabled',
    'incremental',
    'indeterminate',
    'name',
    'value'
  ]);
  html$.InputElementBase = class InputElementBase extends core.Object {
    InputElementBase() {
      this[dartx.autofocus] = null;
      this[dartx.disabled] = null;
      this[dartx.incremental] = null;
      this[dartx.indeterminate] = null;
      this[dartx.name] = null;
      this[dartx.value] = null;
    }
  };
  html$.InputElementBase[dart.implements] = () => [html$.Element];
  dart.setSignature(html$.InputElementBase, {});
  dart.defineExtensionMembers(html$.InputElementBase, [
    'autofocus',
    'autofocus',
    'disabled',
    'disabled',
    'incremental',
    'incremental',
    'indeterminate',
    'indeterminate',
    'name',
    'name',
    'value',
    'value'
  ]);
  html$.HiddenInputElement = class HiddenInputElement extends core.Object {
    static new() {
      return html$.InputElement.new({type: 'hidden'});
    }
  };
  html$.HiddenInputElement[dart.implements] = () => [html$.InputElementBase];
  dart.setSignature(html$.HiddenInputElement, {
    constructors: () => ({new: [html$.HiddenInputElement, []]})
  });
  dart.defineExtensionNames([
    'autocomplete',
    'maxLength',
    'pattern',
    'placeholder',
    'readOnly',
    'required',
    'size',
    'selectionDirection',
    'selectionEnd',
    'selectionStart'
  ]);
  html$.TextInputElementBase = class TextInputElementBase extends core.Object {
    TextInputElementBase() {
      this[dartx.autocomplete] = null;
      this[dartx.maxLength] = null;
      this[dartx.pattern] = null;
      this[dartx.placeholder] = null;
      this[dartx.readOnly] = null;
      this[dartx.required] = null;
      this[dartx.size] = null;
      this[dartx.selectionDirection] = null;
      this[dartx.selectionEnd] = null;
      this[dartx.selectionStart] = null;
    }
  };
  html$.TextInputElementBase[dart.implements] = () => [html$.InputElementBase];
  dart.setSignature(html$.TextInputElementBase, {});
  dart.defineExtensionMembers(html$.TextInputElementBase, [
    'autocomplete',
    'autocomplete',
    'maxLength',
    'maxLength',
    'pattern',
    'pattern',
    'placeholder',
    'placeholder',
    'readOnly',
    'readOnly',
    'required',
    'required',
    'size',
    'size',
    'selectionDirection',
    'selectionDirection',
    'selectionEnd',
    'selectionEnd',
    'selectionStart',
    'selectionStart'
  ]);
  dart.defineExtensionNames([
    'dirName'
  ]);
  html$.SearchInputElement = class SearchInputElement extends core.Object {
    static new() {
      return html$.InputElement.new({type: 'search'});
    }
    static get supported() {
      return html$.InputElement.new({type: 'search'})[dartx.type] == 'search';
    }
  };
  html$.SearchInputElement[dart.implements] = () => [html$.TextInputElementBase];
  dart.setSignature(html$.SearchInputElement, {
    constructors: () => ({new: [html$.SearchInputElement, []]})
  });
  dart.defineExtensionMembers(html$.SearchInputElement, ['dirName', 'dirName']);
  html$.SearchInputElement[dart.metadata] = () => [dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI))];
  dart.defineExtensionNames([
    'dirName'
  ]);
  html$.TextInputElement = class TextInputElement extends core.Object {
    static new() {
      return html$.InputElement.new({type: 'text'});
    }
  };
  html$.TextInputElement[dart.implements] = () => [html$.TextInputElementBase];
  dart.setSignature(html$.TextInputElement, {
    constructors: () => ({new: [html$.TextInputElement, []]})
  });
  dart.defineExtensionMembers(html$.TextInputElement, ['dirName', 'dirName']);
  html$.UrlInputElement = class UrlInputElement extends core.Object {
    static new() {
      return html$.InputElement.new({type: 'url'});
    }
    static get supported() {
      return html$.InputElement.new({type: 'url'})[dartx.type] == 'url';
    }
  };
  html$.UrlInputElement[dart.implements] = () => [html$.TextInputElementBase];
  dart.setSignature(html$.UrlInputElement, {
    constructors: () => ({new: [html$.UrlInputElement, []]})
  });
  html$.UrlInputElement[dart.metadata] = () => [dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI))];
  html$.TelephoneInputElement = class TelephoneInputElement extends core.Object {
    static new() {
      return html$.InputElement.new({type: 'tel'});
    }
    static get supported() {
      return html$.InputElement.new({type: 'tel'})[dartx.type] == 'tel';
    }
  };
  html$.TelephoneInputElement[dart.implements] = () => [html$.TextInputElementBase];
  dart.setSignature(html$.TelephoneInputElement, {
    constructors: () => ({new: [html$.TelephoneInputElement, []]})
  });
  html$.TelephoneInputElement[dart.metadata] = () => [dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI))];
  dart.defineExtensionNames([
    'autocomplete',
    'autofocus',
    'maxLength',
    'multiple',
    'pattern',
    'placeholder',
    'readOnly',
    'required',
    'size'
  ]);
  html$.EmailInputElement = class EmailInputElement extends core.Object {
    static new() {
      return html$.InputElement.new({type: 'email'});
    }
    static get supported() {
      return html$.InputElement.new({type: 'email'})[dartx.type] == 'email';
    }
  };
  html$.EmailInputElement[dart.implements] = () => [html$.TextInputElementBase];
  dart.setSignature(html$.EmailInputElement, {
    constructors: () => ({new: [html$.EmailInputElement, []]})
  });
  dart.defineExtensionMembers(html$.EmailInputElement, [
    'autocomplete',
    'autocomplete',
    'autofocus',
    'autofocus',
    'maxLength',
    'maxLength',
    'multiple',
    'multiple',
    'pattern',
    'pattern',
    'placeholder',
    'placeholder',
    'readOnly',
    'readOnly',
    'required',
    'required',
    'size',
    'size'
  ]);
  html$.EmailInputElement[dart.metadata] = () => [dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI))];
  html$.PasswordInputElement = class PasswordInputElement extends core.Object {
    static new() {
      return html$.InputElement.new({type: 'password'});
    }
  };
  html$.PasswordInputElement[dart.implements] = () => [html$.TextInputElementBase];
  dart.setSignature(html$.PasswordInputElement, {
    constructors: () => ({new: [html$.PasswordInputElement, []]})
  });
  dart.defineExtensionNames([
    'max',
    'min',
    'step',
    'valueAsNumber'
  ]);
  html$.RangeInputElementBase = class RangeInputElementBase extends core.Object {
    RangeInputElementBase() {
      this[dartx.max] = null;
      this[dartx.min] = null;
      this[dartx.step] = null;
      this[dartx.valueAsNumber] = null;
    }
  };
  html$.RangeInputElementBase[dart.implements] = () => [html$.InputElementBase];
  dart.setSignature(html$.RangeInputElementBase, {});
  dart.defineExtensionMembers(html$.RangeInputElementBase, [
    'max',
    'max',
    'min',
    'min',
    'step',
    'step',
    'valueAsNumber',
    'valueAsNumber'
  ]);
  dart.defineExtensionNames([
    'valueAsDate',
    'readOnly',
    'required'
  ]);
  html$.DateInputElement = class DateInputElement extends core.Object {
    static new() {
      return html$.InputElement.new({type: 'date'});
    }
    static get supported() {
      return html$.InputElement.new({type: 'date'})[dartx.type] == 'date';
    }
  };
  html$.DateInputElement[dart.implements] = () => [html$.RangeInputElementBase];
  dart.setSignature(html$.DateInputElement, {
    constructors: () => ({new: [html$.DateInputElement, []]})
  });
  dart.defineExtensionMembers(html$.DateInputElement, [
    'valueAsDate',
    'valueAsDate',
    'readOnly',
    'readOnly',
    'required',
    'required'
  ]);
  html$.DateInputElement[dart.metadata] = () => [dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME, '25')), dart.const(new _metadata.Experimental())];
  dart.defineExtensionNames([
    'valueAsDate',
    'readOnly',
    'required'
  ]);
  html$.MonthInputElement = class MonthInputElement extends core.Object {
    static new() {
      return html$.InputElement.new({type: 'month'});
    }
    static get supported() {
      return html$.InputElement.new({type: 'month'})[dartx.type] == 'month';
    }
  };
  html$.MonthInputElement[dart.implements] = () => [html$.RangeInputElementBase];
  dart.setSignature(html$.MonthInputElement, {
    constructors: () => ({new: [html$.MonthInputElement, []]})
  });
  dart.defineExtensionMembers(html$.MonthInputElement, [
    'valueAsDate',
    'valueAsDate',
    'readOnly',
    'readOnly',
    'required',
    'required'
  ]);
  html$.MonthInputElement[dart.metadata] = () => [dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME, '25')), dart.const(new _metadata.Experimental())];
  dart.defineExtensionNames([
    'valueAsDate',
    'readOnly',
    'required'
  ]);
  html$.WeekInputElement = class WeekInputElement extends core.Object {
    static new() {
      return html$.InputElement.new({type: 'week'});
    }
    static get supported() {
      return html$.InputElement.new({type: 'week'})[dartx.type] == 'week';
    }
  };
  html$.WeekInputElement[dart.implements] = () => [html$.RangeInputElementBase];
  dart.setSignature(html$.WeekInputElement, {
    constructors: () => ({new: [html$.WeekInputElement, []]})
  });
  dart.defineExtensionMembers(html$.WeekInputElement, [
    'valueAsDate',
    'valueAsDate',
    'readOnly',
    'readOnly',
    'required',
    'required'
  ]);
  html$.WeekInputElement[dart.metadata] = () => [dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME, '25')), dart.const(new _metadata.Experimental())];
  dart.defineExtensionNames([
    'valueAsDate',
    'readOnly',
    'required'
  ]);
  html$.TimeInputElement = class TimeInputElement extends core.Object {
    static new() {
      return html$.InputElement.new({type: 'time'});
    }
    static get supported() {
      return html$.InputElement.new({type: 'time'})[dartx.type] == 'time';
    }
  };
  html$.TimeInputElement[dart.implements] = () => [html$.RangeInputElementBase];
  dart.setSignature(html$.TimeInputElement, {
    constructors: () => ({new: [html$.TimeInputElement, []]})
  });
  dart.defineExtensionMembers(html$.TimeInputElement, [
    'valueAsDate',
    'valueAsDate',
    'readOnly',
    'readOnly',
    'required',
    'required'
  ]);
  html$.TimeInputElement[dart.metadata] = () => [dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.Experimental())];
  dart.defineExtensionNames([
    'readOnly',
    'required'
  ]);
  html$.LocalDateTimeInputElement = class LocalDateTimeInputElement extends core.Object {
    static new() {
      return html$.InputElement.new({type: 'datetime-local'});
    }
    static get supported() {
      return html$.InputElement.new({type: 'datetime-local'})[dartx.type] == 'datetime-local';
    }
  };
  html$.LocalDateTimeInputElement[dart.implements] = () => [html$.RangeInputElementBase];
  dart.setSignature(html$.LocalDateTimeInputElement, {
    constructors: () => ({new: [html$.LocalDateTimeInputElement, []]})
  });
  dart.defineExtensionMembers(html$.LocalDateTimeInputElement, ['readOnly', 'readOnly', 'required', 'required']);
  html$.LocalDateTimeInputElement[dart.metadata] = () => [dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME, '25')), dart.const(new _metadata.Experimental())];
  dart.defineExtensionNames([
    'placeholder',
    'readOnly',
    'required'
  ]);
  html$.NumberInputElement = class NumberInputElement extends core.Object {
    static new() {
      return html$.InputElement.new({type: 'number'});
    }
    static get supported() {
      return html$.InputElement.new({type: 'number'})[dartx.type] == 'number';
    }
  };
  html$.NumberInputElement[dart.implements] = () => [html$.RangeInputElementBase];
  dart.setSignature(html$.NumberInputElement, {
    constructors: () => ({new: [html$.NumberInputElement, []]})
  });
  dart.defineExtensionMembers(html$.NumberInputElement, [
    'placeholder',
    'placeholder',
    'readOnly',
    'readOnly',
    'required',
    'required'
  ]);
  html$.NumberInputElement[dart.metadata] = () => [dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Experimental())];
  html$.RangeInputElement = class RangeInputElement extends core.Object {
    static new() {
      return html$.InputElement.new({type: 'range'});
    }
    static get supported() {
      return html$.InputElement.new({type: 'range'})[dartx.type] == 'range';
    }
  };
  html$.RangeInputElement[dart.implements] = () => [html$.RangeInputElementBase];
  dart.setSignature(html$.RangeInputElement, {
    constructors: () => ({new: [html$.RangeInputElement, []]})
  });
  html$.RangeInputElement[dart.metadata] = () => [dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.Experimental())];
  dart.defineExtensionNames([
    'checked',
    'required'
  ]);
  html$.CheckboxInputElement = class CheckboxInputElement extends core.Object {
    static new() {
      return html$.InputElement.new({type: 'checkbox'});
    }
  };
  html$.CheckboxInputElement[dart.implements] = () => [html$.InputElementBase];
  dart.setSignature(html$.CheckboxInputElement, {
    constructors: () => ({new: [html$.CheckboxInputElement, []]})
  });
  dart.defineExtensionMembers(html$.CheckboxInputElement, ['checked', 'checked', 'required', 'required']);
  dart.defineExtensionNames([
    'checked',
    'required'
  ]);
  html$.RadioButtonInputElement = class RadioButtonInputElement extends core.Object {
    static new() {
      return html$.InputElement.new({type: 'radio'});
    }
  };
  html$.RadioButtonInputElement[dart.implements] = () => [html$.InputElementBase];
  dart.setSignature(html$.RadioButtonInputElement, {
    constructors: () => ({new: [html$.RadioButtonInputElement, []]})
  });
  dart.defineExtensionMembers(html$.RadioButtonInputElement, ['checked', 'checked', 'required', 'required']);
  dart.defineExtensionNames([
    'accept',
    'multiple',
    'required',
    'files'
  ]);
  html$.FileUploadInputElement = class FileUploadInputElement extends core.Object {
    static new() {
      return html$.InputElement.new({type: 'file'});
    }
  };
  html$.FileUploadInputElement[dart.implements] = () => [html$.InputElementBase];
  dart.setSignature(html$.FileUploadInputElement, {
    constructors: () => ({new: [html$.FileUploadInputElement, []]})
  });
  dart.defineExtensionMembers(html$.FileUploadInputElement, [
    'accept',
    'accept',
    'multiple',
    'multiple',
    'required',
    'required',
    'files',
    'files'
  ]);
  dart.defineExtensionNames([
    'formAction',
    'formEnctype',
    'formMethod',
    'formNoValidate',
    'formTarget'
  ]);
  html$.SubmitButtonInputElement = class SubmitButtonInputElement extends core.Object {
    static new() {
      return html$.InputElement.new({type: 'submit'});
    }
  };
  html$.SubmitButtonInputElement[dart.implements] = () => [html$.InputElementBase];
  dart.setSignature(html$.SubmitButtonInputElement, {
    constructors: () => ({new: [html$.SubmitButtonInputElement, []]})
  });
  dart.defineExtensionMembers(html$.SubmitButtonInputElement, [
    'formAction',
    'formAction',
    'formEnctype',
    'formEnctype',
    'formMethod',
    'formMethod',
    'formNoValidate',
    'formNoValidate',
    'formTarget',
    'formTarget'
  ]);
  dart.defineExtensionNames([
    'alt',
    'formAction',
    'formEnctype',
    'formMethod',
    'formNoValidate',
    'formTarget',
    'height',
    'src',
    'width'
  ]);
  html$.ImageButtonInputElement = class ImageButtonInputElement extends core.Object {
    static new() {
      return html$.InputElement.new({type: 'image'});
    }
  };
  html$.ImageButtonInputElement[dart.implements] = () => [html$.InputElementBase];
  dart.setSignature(html$.ImageButtonInputElement, {
    constructors: () => ({new: [html$.ImageButtonInputElement, []]})
  });
  dart.defineExtensionMembers(html$.ImageButtonInputElement, [
    'alt',
    'alt',
    'formAction',
    'formAction',
    'formEnctype',
    'formEnctype',
    'formMethod',
    'formMethod',
    'formNoValidate',
    'formNoValidate',
    'formTarget',
    'formTarget',
    'height',
    'height',
    'src',
    'src',
    'width',
    'width'
  ]);
  html$.ResetButtonInputElement = class ResetButtonInputElement extends core.Object {
    static new() {
      return html$.InputElement.new({type: 'reset'});
    }
  };
  html$.ResetButtonInputElement[dart.implements] = () => [html$.InputElementBase];
  dart.setSignature(html$.ResetButtonInputElement, {
    constructors: () => ({new: [html$.ResetButtonInputElement, []]})
  });
  html$.ButtonInputElement = class ButtonInputElement extends core.Object {
    static new() {
      return html$.InputElement.new({type: 'button'});
    }
  };
  html$.ButtonInputElement[dart.implements] = () => [html$.InputElementBase];
  dart.setSignature(html$.ButtonInputElement, {
    constructors: () => ({new: [html$.ButtonInputElement, []]})
  });
  const _initKeyboardEvent = Symbol('_initKeyboardEvent');
  const _keyIdentifier = Symbol('_keyIdentifier');
  dart.defineExtensionNames([
    'keyCode',
    'charCode',
    'which',
    'getModifierState',
    'altKey',
    'code',
    'ctrlKey',
    'key',
    'keyLocation',
    'location',
    'metaKey',
    'repeat',
    'shiftKey'
  ]);
  html$.KeyboardEvent = class KeyboardEvent extends html$.UIEvent {
    static new(type, opts) {
      let view = opts && 'view' in opts ? opts.view : null;
      let canBubble = opts && 'canBubble' in opts ? opts.canBubble : true;
      let cancelable = opts && 'cancelable' in opts ? opts.cancelable : true;
      let keyLocation = opts && 'keyLocation' in opts ? opts.keyLocation : 1;
      let ctrlKey = opts && 'ctrlKey' in opts ? opts.ctrlKey : false;
      let altKey = opts && 'altKey' in opts ? opts.altKey : false;
      let shiftKey = opts && 'shiftKey' in opts ? opts.shiftKey : false;
      let metaKey = opts && 'metaKey' in opts ? opts.metaKey : false;
      if (view == null) {
        view = html$.window;
      }
      let e = dart.as(html$.document[_createEvent]("KeyboardEvent"), html$.KeyboardEvent);
      e[_initKeyboardEvent](type, canBubble, cancelable, view, "", keyLocation, ctrlKey, altKey, shiftKey, metaKey);
      return e;
    }
    [_initKeyboardEvent](type, canBubble, cancelable, view, keyIdentifier, keyLocation, ctrlKey, altKey, shiftKey, metaKey) {
      if (typeof this.initKeyEvent == "function") {
        this.initKeyEvent(type, canBubble, cancelable, view, ctrlKey, altKey, shiftKey, metaKey, 0, 0);
      } else {
        this.initKeyboardEvent(type, canBubble, cancelable, view, keyIdentifier, keyLocation, ctrlKey, altKey, shiftKey, metaKey);
      }
    }
    get [dartx.keyCode]() {
      return this[_keyCode];
    }
    get [dartx.charCode]() {
      return this[_charCode];
    }
    get [dartx.which]() {
      return this[_which];
    }
    static _(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.KeyboardEvent._create_1(type, eventInitDict_1);
      }
      return html$.KeyboardEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new KeyboardEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new KeyboardEvent(type);
    }
    get [dartx.altKey]() {
      return this.altKey;
    }
    get [dartx.code]() {
      return this.code;
    }
    get [dartx.ctrlKey]() {
      return this.ctrlKey;
    }
    get [dartx.key]() {
      return this.key;
    }
    get [_keyIdentifier]() {
      return this.keyIdentifier;
    }
    get [dartx.keyLocation]() {
      return this.keyLocation;
    }
    get [dartx.location]() {
      return this.location;
    }
    get [dartx.metaKey]() {
      return this.metaKey;
    }
    get [dartx.repeat]() {
      return this.repeat;
    }
    get [dartx.shiftKey]() {
      return this.shiftKey;
    }
    [dartx.getModifierState](keyArg) {
      return this.getModifierState(keyArg);
    }
  };
  dart.setSignature(html$.KeyboardEvent, {
    constructors: () => ({
      new: [html$.KeyboardEvent, [core.String], {view: html$.Window, canBubble: core.bool, cancelable: core.bool, keyLocation: core.int, ctrlKey: core.bool, altKey: core.bool, shiftKey: core.bool, metaKey: core.bool}],
      _: [html$.KeyboardEvent, [core.String], [core.Map]]
    }),
    methods: () => ({
      [_initKeyboardEvent]: [dart.void, [core.String, core.bool, core.bool, html$.Window, core.String, core.int, core.bool, core.bool, core.bool, core.bool]],
      [dartx.getModifierState]: [core.bool, [core.String]]
    }),
    statics: () => ({
      _create_1: [html$.KeyboardEvent, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.KeyboardEvent, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.KeyboardEvent[dart.metadata] = () => [dart.const(new _metadata.DomName('KeyboardEvent')), dart.const(new _js_helper.Native("KeyboardEvent"))];
  html$.KeyboardEvent.DOM_KEY_LOCATION_LEFT = 1;
  html$.KeyboardEvent.DOM_KEY_LOCATION_NUMPAD = 3;
  html$.KeyboardEvent.DOM_KEY_LOCATION_RIGHT = 2;
  html$.KeyboardEvent.DOM_KEY_LOCATION_STANDARD = 0;
  dart.registerExtension(dart.global.KeyboardEvent, html$.KeyboardEvent);
  html$.KeyframeEffect = class KeyframeEffect extends html$.AnimationEffectReadOnly {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(target, keyframes, timing) {
      if (timing === void 0) timing = null;
      if (dart.is(keyframes, core.List$(core.Map)) && (dart.is(target, html$.Element) || target == null) && timing == null) {
        return html$.KeyframeEffect._create_1(target, keyframes);
      }
      if (typeof timing == 'number' && dart.is(keyframes, core.List$(core.Map)) && (dart.is(target, html$.Element) || target == null)) {
        return html$.KeyframeEffect._create_2(target, keyframes, timing);
      }
      if (dart.is(timing, core.Map) && dart.is(keyframes, core.List$(core.Map)) && (dart.is(target, html$.Element) || target == null)) {
        let timing_1 = html_common.convertDartToNative_Dictionary(timing);
        return html$.KeyframeEffect._create_3(target, keyframes, timing_1);
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    static _create_1(target, keyframes) {
      return new KeyframeEffect(target, keyframes);
    }
    static _create_2(target, keyframes, timing) {
      return new KeyframeEffect(target, keyframes, timing);
    }
    static _create_3(target, keyframes, timing) {
      return new KeyframeEffect(target, keyframes, timing);
    }
  };
  dart.setSignature(html$.KeyframeEffect, {
    constructors: () => ({
      _: [html$.KeyframeEffect, []],
      new: [html$.KeyframeEffect, [html$.Element, core.List$(core.Map)], [dart.dynamic]]
    }),
    statics: () => ({
      _create_1: [html$.KeyframeEffect, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.KeyframeEffect, [dart.dynamic, dart.dynamic, dart.dynamic]],
      _create_3: [html$.KeyframeEffect, [dart.dynamic, dart.dynamic, dart.dynamic]]
    }),
    names: ['_create_1', '_create_2', '_create_3']
  });
  html$.KeyframeEffect[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('KeyframeEffect')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("KeyframeEffect"))];
  dart.registerExtension(dart.global.KeyframeEffect, html$.KeyframeEffect);
  dart.defineExtensionNames([
    'checkValidity',
    'reportValidity',
    'setCustomValidity',
    'autofocus',
    'challenge',
    'disabled',
    'form',
    'keytype',
    'labels',
    'name',
    'type',
    'validationMessage',
    'validity',
    'willValidate'
  ]);
  html$.KeygenElement = class KeygenElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("keygen"), html$.KeygenElement);
    }
    created() {
      this[dartx.autofocus] = null;
      this[dartx.challenge] = null;
      this[dartx.disabled] = null;
      this[dartx.form] = null;
      this[dartx.keytype] = null;
      this[dartx.labels] = null;
      this[dartx.name] = null;
      this[dartx.type] = null;
      this[dartx.validationMessage] = null;
      this[dartx.validity] = null;
      this[dartx.willValidate] = null;
      super.created();
    }
    static get supported() {
      return dart.notNull(html$.Element.isTagSupported('keygen')) && dart.is(html$.Element.tag('keygen'), html$.KeygenElement);
    }
    get [dartx.autofocus]() {
      return this.autofocus;
    }
    set [dartx.autofocus](value) {
      this.autofocus = value;
    }
    get [dartx.challenge]() {
      return this.challenge;
    }
    set [dartx.challenge](value) {
      this.challenge = value;
    }
    get [dartx.disabled]() {
      return this.disabled;
    }
    set [dartx.disabled](value) {
      this.disabled = value;
    }
    get [dartx.form]() {
      return this.form;
    }
    get [dartx.keytype]() {
      return this.keytype;
    }
    set [dartx.keytype](value) {
      this.keytype = value;
    }
    get [dartx.labels]() {
      return this.labels;
    }
    get [dartx.name]() {
      return this.name;
    }
    set [dartx.name](value) {
      this.name = value;
    }
    get [dartx.type]() {
      return this.type;
    }
    get [dartx.validationMessage]() {
      return this.validationMessage;
    }
    get [dartx.validity]() {
      return this.validity;
    }
    get [dartx.willValidate]() {
      return this.willValidate;
    }
    [dartx.checkValidity]() {
      return this.checkValidity();
    }
    [dartx.reportValidity]() {
      return this.reportValidity();
    }
    [dartx.setCustomValidity](error) {
      return this.setCustomValidity(error);
    }
  };
  dart.defineNamedConstructor(html$.KeygenElement, 'created');
  dart.setSignature(html$.KeygenElement, {
    constructors: () => ({
      _: [html$.KeygenElement, []],
      new: [html$.KeygenElement, []],
      created: [html$.KeygenElement, []]
    }),
    methods: () => ({
      [dartx.checkValidity]: [core.bool, []],
      [dartx.reportValidity]: [core.bool, []],
      [dartx.setCustomValidity]: [dart.void, [core.String]]
    })
  });
  html$.KeygenElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLKeygenElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("HTMLKeygenElement"))];
  dart.registerExtension(dart.global.HTMLKeygenElement, html$.KeygenElement);
  dart.defineExtensionNames([
    'value'
  ]);
  html$.LIElement = class LIElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("li"), html$.LIElement);
    }
    created() {
      this[dartx.value] = null;
      super.created();
    }
    get [dartx.value]() {
      return this.value;
    }
    set [dartx.value](value) {
      this.value = value;
    }
  };
  dart.defineNamedConstructor(html$.LIElement, 'created');
  dart.setSignature(html$.LIElement, {
    constructors: () => ({
      _: [html$.LIElement, []],
      new: [html$.LIElement, []],
      created: [html$.LIElement, []]
    })
  });
  html$.LIElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLLIElement')), dart.const(new _js_helper.Native("HTMLLIElement"))];
  dart.registerExtension(dart.global.HTMLLIElement, html$.LIElement);
  dart.defineExtensionNames([
    'control',
    'form',
    'htmlFor'
  ]);
  html$.LabelElement = class LabelElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("label"), html$.LabelElement);
    }
    created() {
      this[dartx.control] = null;
      this[dartx.form] = null;
      this[dartx.htmlFor] = null;
      super.created();
    }
    get [dartx.control]() {
      return this.control;
    }
    get [dartx.form]() {
      return this.form;
    }
    get [dartx.htmlFor]() {
      return this.htmlFor;
    }
    set [dartx.htmlFor](value) {
      this.htmlFor = value;
    }
  };
  dart.defineNamedConstructor(html$.LabelElement, 'created');
  dart.setSignature(html$.LabelElement, {
    constructors: () => ({
      _: [html$.LabelElement, []],
      new: [html$.LabelElement, []],
      created: [html$.LabelElement, []]
    })
  });
  html$.LabelElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLLabelElement')), dart.const(new _js_helper.Native("HTMLLabelElement"))];
  dart.registerExtension(dart.global.HTMLLabelElement, html$.LabelElement);
  dart.defineExtensionNames([
    'form'
  ]);
  html$.LegendElement = class LegendElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("legend"), html$.LegendElement);
    }
    created() {
      this[dartx.form] = null;
      super.created();
    }
    get [dartx.form]() {
      return this.form;
    }
  };
  dart.defineNamedConstructor(html$.LegendElement, 'created');
  dart.setSignature(html$.LegendElement, {
    constructors: () => ({
      _: [html$.LegendElement, []],
      new: [html$.LegendElement, []],
      created: [html$.LegendElement, []]
    })
  });
  html$.LegendElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLLegendElement')), dart.const(new _js_helper.Native("HTMLLegendElement"))];
  dart.registerExtension(dart.global.HTMLLegendElement, html$.LegendElement);
  dart.defineExtensionNames([
    'supportsImport',
    'crossOrigin',
    'disabled',
    'href',
    'hreflang',
    'import',
    'integrity',
    'media',
    'rel',
    'sheet',
    'sizes',
    'type'
  ]);
  html$.LinkElement = class LinkElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("link"), html$.LinkElement);
    }
    created() {
      this[dartx.crossOrigin] = null;
      this[dartx.disabled] = null;
      this[dartx.href] = null;
      this[dartx.hreflang] = null;
      this[dartx.import] = null;
      this[dartx.integrity] = null;
      this[dartx.media] = null;
      this[dartx.rel] = null;
      this[dartx.sheet] = null;
      this[dartx.sizes] = null;
      this[dartx.type] = null;
      super.created();
    }
    get [dartx.crossOrigin]() {
      return this.crossOrigin;
    }
    set [dartx.crossOrigin](value) {
      this.crossOrigin = value;
    }
    get [dartx.disabled]() {
      return this.disabled;
    }
    set [dartx.disabled](value) {
      this.disabled = value;
    }
    get [dartx.href]() {
      return this.href;
    }
    set [dartx.href](value) {
      this.href = value;
    }
    get [dartx.hreflang]() {
      return this.hreflang;
    }
    set [dartx.hreflang](value) {
      this.hreflang = value;
    }
    get [dartx.import]() {
      return this.import;
    }
    get [dartx.integrity]() {
      return this.integrity;
    }
    set [dartx.integrity](value) {
      this.integrity = value;
    }
    get [dartx.media]() {
      return this.media;
    }
    set [dartx.media](value) {
      this.media = value;
    }
    get [dartx.rel]() {
      return this.rel;
    }
    set [dartx.rel](value) {
      this.rel = value;
    }
    get [dartx.sheet]() {
      return this.sheet;
    }
    get [dartx.sizes]() {
      return this.sizes;
    }
    get [dartx.type]() {
      return this.type;
    }
    set [dartx.type](value) {
      this.type = value;
    }
    get [dartx.supportsImport]() {
      return "import" in this;
    }
  };
  dart.defineNamedConstructor(html$.LinkElement, 'created');
  dart.setSignature(html$.LinkElement, {
    constructors: () => ({
      _: [html$.LinkElement, []],
      new: [html$.LinkElement, []],
      created: [html$.LinkElement, []]
    })
  });
  html$.LinkElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLLinkElement')), dart.const(new _js_helper.Native("HTMLLinkElement"))];
  dart.registerExtension(dart.global.HTMLLinkElement, html$.LinkElement);
  dart.defineExtensionNames([
    'assign',
    'reload',
    'replace',
    'origin',
    'toString',
    'ancestorOrigins',
    'hash',
    'host',
    'hostname',
    'href',
    'pathname',
    'port',
    'protocol',
    'search'
  ]);
  html$.Location = class Location extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.ancestorOrigins]() {
      return this.ancestorOrigins;
    }
    get [dartx.hash]() {
      return this.hash;
    }
    set [dartx.hash](value) {
      this.hash = value;
    }
    get [dartx.host]() {
      return this.host;
    }
    set [dartx.host](value) {
      this.host = value;
    }
    get [dartx.hostname]() {
      return this.hostname;
    }
    set [dartx.hostname](value) {
      this.hostname = value;
    }
    get [dartx.href]() {
      return this.href;
    }
    set [dartx.href](value) {
      this.href = value;
    }
    get [dartx.pathname]() {
      return this.pathname;
    }
    set [dartx.pathname](value) {
      this.pathname = value;
    }
    get [dartx.port]() {
      return this.port;
    }
    set [dartx.port](value) {
      this.port = value;
    }
    get [dartx.protocol]() {
      return this.protocol;
    }
    set [dartx.protocol](value) {
      this.protocol = value;
    }
    get [dartx.search]() {
      return this.search;
    }
    set [dartx.search](value) {
      this.search = value;
    }
    [dartx.assign](url) {
      return this.assign(url);
    }
    [dartx.reload]() {
      return this.reload();
    }
    [dartx.replace](url) {
      return this.replace(url);
    }
    get [dartx.origin]() {
      if ("origin" in this) {
        return this.origin;
      }
      return `${this[dartx.protocol]}//${this[dartx.host]}`;
    }
    [dartx.toString]() {
      return String(this);
    }
  };
  html$.Location[dart.implements] = () => [html$.LocationBase];
  dart.setSignature(html$.Location, {
    constructors: () => ({_: [html$.Location, []]}),
    methods: () => ({
      [dartx.assign]: [dart.void, [], [core.String]],
      [dartx.reload]: [dart.void, []],
      [dartx.replace]: [dart.void, [core.String]]
    })
  });
  html$.Location[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Location')), dart.const(new _js_helper.Native("Location"))];
  dart.registerExtension(dart.global.Location, html$.Location);
  dart.defineExtensionNames([
    'areas',
    'name'
  ]);
  html$.MapElement = class MapElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("map"), html$.MapElement);
    }
    created() {
      this[dartx.areas] = null;
      this[dartx.name] = null;
      super.created();
    }
    get [dartx.areas]() {
      return this.areas;
    }
    get [dartx.name]() {
      return this.name;
    }
    set [dartx.name](value) {
      this.name = value;
    }
  };
  dart.defineNamedConstructor(html$.MapElement, 'created');
  dart.setSignature(html$.MapElement, {
    constructors: () => ({
      _: [html$.MapElement, []],
      new: [html$.MapElement, []],
      created: [html$.MapElement, []]
    })
  });
  html$.MapElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLMapElement')), dart.const(new _js_helper.Native("HTMLMapElement"))];
  dart.registerExtension(dart.global.HTMLMapElement, html$.MapElement);
  dart.defineExtensionNames([
    'pause',
    'play',
    'unpause',
    'buffered',
    'currentTime',
    'defaultPlaybackRate',
    'duration',
    'muted',
    'paused',
    'playbackRate',
    'playbackState',
    'played',
    'seekable',
    'volume'
  ]);
  html$.MediaController = class MediaController extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.MediaController._create_1();
    }
    static _create_1() {
      return new MediaController();
    }
    get [dartx.buffered]() {
      return this.buffered;
    }
    get [dartx.currentTime]() {
      return this.currentTime;
    }
    set [dartx.currentTime](value) {
      this.currentTime = value;
    }
    get [dartx.defaultPlaybackRate]() {
      return this.defaultPlaybackRate;
    }
    set [dartx.defaultPlaybackRate](value) {
      this.defaultPlaybackRate = value;
    }
    get [dartx.duration]() {
      return this.duration;
    }
    get [dartx.muted]() {
      return this.muted;
    }
    set [dartx.muted](value) {
      this.muted = value;
    }
    get [dartx.paused]() {
      return this.paused;
    }
    get [dartx.playbackRate]() {
      return this.playbackRate;
    }
    set [dartx.playbackRate](value) {
      this.playbackRate = value;
    }
    get [dartx.playbackState]() {
      return this.playbackState;
    }
    get [dartx.played]() {
      return this.played;
    }
    get [dartx.seekable]() {
      return this.seekable;
    }
    get [dartx.volume]() {
      return this.volume;
    }
    set [dartx.volume](value) {
      this.volume = value;
    }
    [dartx.pause]() {
      return this.pause();
    }
    [dartx.play]() {
      return this.play();
    }
    [dartx.unpause]() {
      return this.unpause();
    }
  };
  dart.setSignature(html$.MediaController, {
    constructors: () => ({
      _: [html$.MediaController, []],
      new: [html$.MediaController, []]
    }),
    methods: () => ({
      [dartx.pause]: [dart.void, []],
      [dartx.play]: [dart.void, []],
      [dartx.unpause]: [dart.void, []]
    }),
    statics: () => ({_create_1: [html$.MediaController, []]}),
    names: ['_create_1']
  });
  html$.MediaController[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MediaController')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MediaController"))];
  dart.registerExtension(dart.global.MediaController, html$.MediaController);
  dart.defineExtensionNames([
    'deviceId',
    'groupId',
    'kind',
    'label'
  ]);
  html$.MediaDeviceInfo = class MediaDeviceInfo extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.deviceId]() {
      return this.deviceId;
    }
    get [dartx.groupId]() {
      return this.groupId;
    }
    get [dartx.kind]() {
      return this.kind;
    }
    get [dartx.label]() {
      return this.label;
    }
  };
  dart.setSignature(html$.MediaDeviceInfo, {
    constructors: () => ({_: [html$.MediaDeviceInfo, []]})
  });
  html$.MediaDeviceInfo[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MediaDeviceInfo')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MediaDeviceInfo"))];
  dart.registerExtension(dart.global.MediaDeviceInfo, html$.MediaDeviceInfo);
  const _getUserMedia_1 = Symbol('_getUserMedia_1');
  dart.defineExtensionNames([
    'enumerateDevices',
    'getUserMedia'
  ]);
  html$.MediaDevices = class MediaDevices extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.enumerateDevices]() {
      return this.enumerateDevices();
    }
    [dartx.getUserMedia](options) {
      let options_1 = html_common.convertDartToNative_Dictionary(options);
      return this[_getUserMedia_1](options_1);
    }
    [_getUserMedia_1](options) {
      return this.getUserMedia(options);
    }
  };
  dart.setSignature(html$.MediaDevices, {
    constructors: () => ({_: [html$.MediaDevices, []]}),
    methods: () => ({
      [dartx.enumerateDevices]: [async.Future, []],
      [dartx.getUserMedia]: [async.Future, [core.Map]],
      [_getUserMedia_1]: [async.Future, [dart.dynamic]]
    })
  });
  html$.MediaDevices[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MediaDevices')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MediaDevices"))];
  dart.registerExtension(dart.global.MediaDevices, html$.MediaDevices);
  dart.defineExtensionNames([
    'initData',
    'initDataType'
  ]);
  html$.MediaEncryptedEvent = class MediaEncryptedEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.MediaEncryptedEvent._create_1(type, eventInitDict_1);
      }
      return html$.MediaEncryptedEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new MediaEncryptedEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new MediaEncryptedEvent(type);
    }
    get [dartx.initData]() {
      return this.initData;
    }
    get [dartx.initDataType]() {
      return this.initDataType;
    }
  };
  dart.setSignature(html$.MediaEncryptedEvent, {
    constructors: () => ({
      _: [html$.MediaEncryptedEvent, []],
      new: [html$.MediaEncryptedEvent, [core.String], [core.Map]]
    }),
    statics: () => ({
      _create_1: [html$.MediaEncryptedEvent, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.MediaEncryptedEvent, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.MediaEncryptedEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MediaEncryptedEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MediaEncryptedEvent"))];
  dart.registerExtension(dart.global.MediaEncryptedEvent, html$.MediaEncryptedEvent);
  dart.defineExtensionNames([
    'code'
  ]);
  html$.MediaError = class MediaError extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.code]() {
      return this.code;
    }
  };
  dart.setSignature(html$.MediaError, {
    constructors: () => ({_: [html$.MediaError, []]})
  });
  html$.MediaError[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MediaError')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("MediaError"))];
  html$.MediaError.MEDIA_ERR_ABORTED = 1;
  html$.MediaError.MEDIA_ERR_DECODE = 3;
  html$.MediaError.MEDIA_ERR_NETWORK = 2;
  html$.MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED = 4;
  dart.registerExtension(dart.global.MediaError, html$.MediaError);
  dart.defineExtensionNames([
    'code',
    'systemCode'
  ]);
  html$.MediaKeyError = class MediaKeyError extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.code]() {
      return this.code;
    }
    get [dartx.systemCode]() {
      return this.systemCode;
    }
  };
  dart.setSignature(html$.MediaKeyError, {
    constructors: () => ({_: [html$.MediaKeyError, []]})
  });
  html$.MediaKeyError[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MediaKeyError')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MediaKeyError"))];
  html$.MediaKeyError.MEDIA_KEYERR_CLIENT = 2;
  html$.MediaKeyError.MEDIA_KEYERR_DOMAIN = 6;
  html$.MediaKeyError.MEDIA_KEYERR_HARDWARECHANGE = 5;
  html$.MediaKeyError.MEDIA_KEYERR_OUTPUT = 4;
  html$.MediaKeyError.MEDIA_KEYERR_SERVICE = 3;
  html$.MediaKeyError.MEDIA_KEYERR_UNKNOWN = 1;
  dart.registerExtension(dart.global.MediaKeyError, html$.MediaKeyError);
  dart.defineExtensionNames([
    'defaultUrl',
    'errorCode',
    'initData',
    'keySystem',
    'message',
    'sessionId',
    'systemCode'
  ]);
  html$.MediaKeyEvent = class MediaKeyEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.MediaKeyEvent._create_1(type, eventInitDict_1);
      }
      return html$.MediaKeyEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new MediaKeyEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new MediaKeyEvent(type);
    }
    get [dartx.defaultUrl]() {
      return this.defaultURL;
    }
    get [dartx.errorCode]() {
      return this.errorCode;
    }
    get [dartx.initData]() {
      return this.initData;
    }
    get [dartx.keySystem]() {
      return this.keySystem;
    }
    get [dartx.message]() {
      return this.message;
    }
    get [dartx.sessionId]() {
      return this.sessionId;
    }
    get [dartx.systemCode]() {
      return this.systemCode;
    }
  };
  dart.setSignature(html$.MediaKeyEvent, {
    constructors: () => ({
      _: [html$.MediaKeyEvent, []],
      new: [html$.MediaKeyEvent, [core.String], [core.Map]]
    }),
    statics: () => ({
      _create_1: [html$.MediaKeyEvent, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.MediaKeyEvent, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.MediaKeyEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MediaKeyEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MediaKeyEvent"))];
  dart.registerExtension(dart.global.MediaKeyEvent, html$.MediaKeyEvent);
  dart.defineExtensionNames([
    'message',
    'messageType'
  ]);
  html$.MediaKeyMessageEvent = class MediaKeyMessageEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.MediaKeyMessageEvent._create_1(type, eventInitDict_1);
      }
      return html$.MediaKeyMessageEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new MediaKeyMessageEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new MediaKeyMessageEvent(type);
    }
    get [dartx.message]() {
      return this.message;
    }
    get [dartx.messageType]() {
      return this.messageType;
    }
  };
  dart.setSignature(html$.MediaKeyMessageEvent, {
    constructors: () => ({
      _: [html$.MediaKeyMessageEvent, []],
      new: [html$.MediaKeyMessageEvent, [core.String], [core.Map]]
    }),
    statics: () => ({
      _create_1: [html$.MediaKeyMessageEvent, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.MediaKeyMessageEvent, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.MediaKeyMessageEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MediaKeyMessageEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MediaKeyMessageEvent"))];
  dart.registerExtension(dart.global.MediaKeyMessageEvent, html$.MediaKeyMessageEvent);
  const _update$ = Symbol('_update');
  dart.defineExtensionNames([
    'close',
    'generateRequest',
    'load',
    'remove',
    'closed',
    'expiration',
    'keyStatuses',
    'sessionId'
  ]);
  html$.MediaKeySession = class MediaKeySession extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.closed]() {
      return this.closed;
    }
    get [dartx.expiration]() {
      return this.expiration;
    }
    get [dartx.keyStatuses]() {
      return this.keyStatuses;
    }
    get [dartx.sessionId]() {
      return this.sessionId;
    }
    [dartx.close]() {
      return this.close();
    }
    [dartx.generateRequest](initDataType, initData) {
      return this.generateRequest(initDataType, initData);
    }
    [dartx.load](sessionId) {
      return this.load(sessionId);
    }
    [dartx.remove]() {
      return this.remove();
    }
    [_update$](response) {
      return this.update(response);
    }
  };
  dart.setSignature(html$.MediaKeySession, {
    constructors: () => ({_: [html$.MediaKeySession, []]}),
    methods: () => ({
      [dartx.close]: [async.Future, []],
      [dartx.generateRequest]: [async.Future, [core.String, dart.dynamic]],
      [dartx.load]: [async.Future, [core.String]],
      [dartx.remove]: [async.Future, []],
      [_update$]: [async.Future, [dart.dynamic]]
    })
  });
  html$.MediaKeySession[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MediaKeySession')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MediaKeySession"))];
  dart.registerExtension(dart.global.MediaKeySession, html$.MediaKeySession);
  dart.defineExtensionNames([
    'size'
  ]);
  html$.MediaKeyStatusMap = class MediaKeyStatusMap extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.size]() {
      return this.size;
    }
  };
  dart.setSignature(html$.MediaKeyStatusMap, {
    constructors: () => ({_: [html$.MediaKeyStatusMap, []]})
  });
  html$.MediaKeyStatusMap[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MediaKeyStatusMap')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MediaKeyStatusMap"))];
  dart.registerExtension(dart.global.MediaKeyStatusMap, html$.MediaKeyStatusMap);
  const _getConfiguration_1 = Symbol('_getConfiguration_1');
  dart.defineExtensionNames([
    'createMediaKeys',
    'getConfiguration',
    'keySystem'
  ]);
  html$.MediaKeySystemAccess = class MediaKeySystemAccess extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.keySystem]() {
      return this.keySystem;
    }
    [dartx.createMediaKeys]() {
      return this.createMediaKeys();
    }
    [dartx.getConfiguration]() {
      return html_common.convertNativeToDart_Dictionary(this[_getConfiguration_1]());
    }
    [_getConfiguration_1]() {
      return this.getConfiguration();
    }
  };
  dart.setSignature(html$.MediaKeySystemAccess, {
    constructors: () => ({_: [html$.MediaKeySystemAccess, []]}),
    methods: () => ({
      [dartx.createMediaKeys]: [async.Future, []],
      [dartx.getConfiguration]: [core.Map, []],
      [_getConfiguration_1]: [dart.dynamic, []]
    })
  });
  html$.MediaKeySystemAccess[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MediaKeySystemAccess')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MediaKeySystemAccess"))];
  dart.registerExtension(dart.global.MediaKeySystemAccess, html$.MediaKeySystemAccess);
  const _createSession = Symbol('_createSession');
  dart.defineExtensionNames([
    'setServerCertificate'
  ]);
  html$.MediaKeys = class MediaKeys extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [_createSession](sessionType) {
      return this.createSession(sessionType);
    }
    [dartx.setServerCertificate](serverCertificate) {
      return this.setServerCertificate(serverCertificate);
    }
  };
  dart.setSignature(html$.MediaKeys, {
    constructors: () => ({_: [html$.MediaKeys, []]}),
    methods: () => ({
      [_createSession]: [html$.MediaKeySession, [], [core.String]],
      [dartx.setServerCertificate]: [async.Future, [dart.dynamic]]
    })
  });
  html$.MediaKeys[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MediaKeys')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MediaKeys"))];
  dart.registerExtension(dart.global.MediaKeys, html$.MediaKeys);
  dart.defineExtensionNames([
    'appendMedium',
    'deleteMedium',
    'item',
    'length',
    'mediaText'
  ]);
  html$.MediaList = class MediaList extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    get [dartx.mediaText]() {
      return this.mediaText;
    }
    set [dartx.mediaText](value) {
      this.mediaText = value;
    }
    [dartx.appendMedium](medium) {
      return this.appendMedium(medium);
    }
    [dartx.deleteMedium](medium) {
      return this.deleteMedium(medium);
    }
    [dartx.item](index) {
      return this.item(index);
    }
  };
  dart.setSignature(html$.MediaList, {
    constructors: () => ({_: [html$.MediaList, []]}),
    methods: () => ({
      [dartx.appendMedium]: [dart.void, [core.String]],
      [dartx.deleteMedium]: [dart.void, [core.String]],
      [dartx.item]: [core.String, [core.int]]
    })
  });
  html$.MediaList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MediaList')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("MediaList"))];
  dart.registerExtension(dart.global.MediaList, html$.MediaList);
  dart.defineExtensionNames([
    'addListener',
    'removeListener',
    'onChange',
    'matches',
    'media'
  ]);
  html$.MediaQueryList = class MediaQueryList extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.matches]() {
      return this.matches;
    }
    get [dartx.media]() {
      return this.media;
    }
    [dartx.addListener](listener) {
      return this.addListener(listener);
    }
    [dartx.removeListener](listener) {
      return this.removeListener(listener);
    }
    get [dartx.onChange]() {
      return html$.MediaQueryList.changeEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.MediaQueryList, {
    constructors: () => ({_: [html$.MediaQueryList, []]}),
    methods: () => ({
      [dartx.addListener]: [dart.void, [html$.EventListener]],
      [dartx.removeListener]: [dart.void, [html$.EventListener]]
    })
  });
  html$.MediaQueryList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MediaQueryList')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("MediaQueryList"))];
  dart.defineLazy(html$.MediaQueryList, {
    get changeEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('change'));
    }
  });
  dart.registerExtension(dart.global.MediaQueryList, html$.MediaQueryList);
  dart.defineExtensionNames([
    'matches',
    'media'
  ]);
  html$.MediaQueryListEvent = class MediaQueryListEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.MediaQueryListEvent._create_1(type, eventInitDict_1);
      }
      return html$.MediaQueryListEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new MediaQueryListEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new MediaQueryListEvent(type);
    }
    get [dartx.matches]() {
      return this.matches;
    }
    get [dartx.media]() {
      return this.media;
    }
  };
  dart.setSignature(html$.MediaQueryListEvent, {
    constructors: () => ({
      _: [html$.MediaQueryListEvent, []],
      new: [html$.MediaQueryListEvent, [core.String], [core.Map]]
    }),
    statics: () => ({
      _create_1: [html$.MediaQueryListEvent, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.MediaQueryListEvent, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.MediaQueryListEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MediaQueryListEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MediaQueryListEvent"))];
  dart.registerExtension(dart.global.MediaQueryListEvent, html$.MediaQueryListEvent);
  dart.defineExtensionNames([
    'activate',
    'deactivate'
  ]);
  html$.MediaSession = class MediaSession extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.MediaSession._create_1();
    }
    static _create_1() {
      return new MediaSession();
    }
    [dartx.activate]() {
      return this.activate();
    }
    [dartx.deactivate]() {
      return this.deactivate();
    }
  };
  dart.setSignature(html$.MediaSession, {
    constructors: () => ({
      _: [html$.MediaSession, []],
      new: [html$.MediaSession, []]
    }),
    methods: () => ({
      [dartx.activate]: [dart.void, []],
      [dartx.deactivate]: [dart.void, []]
    }),
    statics: () => ({_create_1: [html$.MediaSession, []]}),
    names: ['_create_1']
  });
  html$.MediaSession[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MediaSession')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MediaSession"))];
  dart.registerExtension(dart.global.MediaSession, html$.MediaSession);
  dart.defineExtensionNames([
    'addSourceBuffer',
    'endOfStream',
    'removeSourceBuffer',
    'activeSourceBuffers',
    'duration',
    'readyState',
    'sourceBuffers'
  ]);
  html$.MediaSource = class MediaSource extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.MediaSource._create_1();
    }
    static _create_1() {
      return new MediaSource();
    }
    static get supported() {
      return !!window.MediaSource;
    }
    get [dartx.activeSourceBuffers]() {
      return this.activeSourceBuffers;
    }
    get [dartx.duration]() {
      return this.duration;
    }
    set [dartx.duration](value) {
      this.duration = value;
    }
    get [dartx.readyState]() {
      return this.readyState;
    }
    get [dartx.sourceBuffers]() {
      return this.sourceBuffers;
    }
    [dartx.addSourceBuffer](type) {
      return this.addSourceBuffer(type);
    }
    [dartx.endOfStream](error) {
      return this.endOfStream(error);
    }
    [dartx.removeSourceBuffer](buffer) {
      return this.removeSourceBuffer(buffer);
    }
  };
  dart.setSignature(html$.MediaSource, {
    constructors: () => ({
      _: [html$.MediaSource, []],
      new: [html$.MediaSource, []]
    }),
    methods: () => ({
      [dartx.addSourceBuffer]: [html$.SourceBuffer, [core.String]],
      [dartx.endOfStream]: [dart.void, [], [core.String]],
      [dartx.removeSourceBuffer]: [dart.void, [html$.SourceBuffer]]
    }),
    statics: () => ({
      _create_1: [html$.MediaSource, []],
      isTypeSupported: [core.bool, [core.String]]
    }),
    names: ['_create_1', 'isTypeSupported']
  });
  html$.MediaSource[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MediaSource')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '11')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MediaSource"))];
  dart.registerExtension(dart.global.MediaSource, html$.MediaSource);
  dart.defineExtensionNames([
    'addTrack',
    'clone',
    'getAudioTracks',
    'getTrackById',
    'getTracks',
    'getVideoTracks',
    'removeTrack',
    'stop',
    'onAddTrack',
    'onEnded',
    'onRemoveTrack',
    'active',
    'ended',
    'id',
    'label'
  ]);
  html$.MediaStream = class MediaStream extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(stream_OR_tracks) {
      if (stream_OR_tracks === void 0) stream_OR_tracks = null;
      if (stream_OR_tracks == null) {
        return html$.MediaStream._create_1();
      }
      if (dart.is(stream_OR_tracks, html$.MediaStream) || stream_OR_tracks == null) {
        return html$.MediaStream._create_2(stream_OR_tracks);
      }
      if (dart.is(stream_OR_tracks, core.List$(html$.MediaStreamTrack)) || stream_OR_tracks == null) {
        return html$.MediaStream._create_3(stream_OR_tracks);
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    static _create_1() {
      return new MediaStream();
    }
    static _create_2(stream_OR_tracks) {
      return new MediaStream(stream_OR_tracks);
    }
    static _create_3(stream_OR_tracks) {
      return new MediaStream(stream_OR_tracks);
    }
    get [dartx.active]() {
      return this.active;
    }
    get [dartx.ended]() {
      return this.ended;
    }
    get [dartx.id]() {
      return this.id;
    }
    get [dartx.label]() {
      return this.label;
    }
    [dartx.addTrack](track) {
      return this.addTrack(track);
    }
    [dartx.clone]() {
      return this.clone();
    }
    [dartx.getAudioTracks]() {
      return this.getAudioTracks();
    }
    [dartx.getTrackById](trackId) {
      return this.getTrackById(trackId);
    }
    [dartx.getTracks]() {
      return this.getTracks();
    }
    [dartx.getVideoTracks]() {
      return this.getVideoTracks();
    }
    [dartx.removeTrack](track) {
      return this.removeTrack(track);
    }
    [dartx.stop]() {
      return this.stop();
    }
    get [dartx.onAddTrack]() {
      return html$.MediaStream.addTrackEvent.forTarget(this);
    }
    get [dartx.onEnded]() {
      return html$.MediaStream.endedEvent.forTarget(this);
    }
    get [dartx.onRemoveTrack]() {
      return html$.MediaStream.removeTrackEvent.forTarget(this);
    }
    static get supported() {
      return !!(html$.window[dartx.navigator].getUserMedia || html$.window[dartx.navigator].webkitGetUserMedia || html$.window[dartx.navigator].mozGetUserMedia || html$.window[dartx.navigator].msGetUserMedia);
    }
  };
  dart.setSignature(html$.MediaStream, {
    constructors: () => ({
      _: [html$.MediaStream, []],
      new: [html$.MediaStream, [], [dart.dynamic]]
    }),
    methods: () => ({
      [dartx.addTrack]: [dart.void, [html$.MediaStreamTrack]],
      [dartx.clone]: [html$.MediaStream, []],
      [dartx.getAudioTracks]: [core.List$(html$.MediaStreamTrack), []],
      [dartx.getTrackById]: [html$.MediaStreamTrack, [core.String]],
      [dartx.getTracks]: [core.List$(html$.MediaStreamTrack), []],
      [dartx.getVideoTracks]: [core.List$(html$.MediaStreamTrack), []],
      [dartx.removeTrack]: [dart.void, [html$.MediaStreamTrack]],
      [dartx.stop]: [dart.void, []]
    }),
    statics: () => ({
      _create_1: [html$.MediaStream, []],
      _create_2: [html$.MediaStream, [dart.dynamic]],
      _create_3: [html$.MediaStream, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2', '_create_3']
  });
  html$.MediaStream[dart.metadata] = () => [dart.const(new _metadata.DomName('MediaStream')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MediaStream"))];
  dart.defineLazy(html$.MediaStream, {
    get addTrackEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('addtrack'));
    },
    get endedEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('ended'));
    },
    get removeTrackEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('removetrack'));
    }
  });
  dart.registerExtension(dart.global.MediaStream, html$.MediaStream);
  dart.defineExtensionNames([
    'stream'
  ]);
  html$.MediaStreamEvent = class MediaStreamEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.MediaStreamEvent._create_1(type, eventInitDict_1);
      }
      return html$.MediaStreamEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new MediaStreamEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new MediaStreamEvent(type);
    }
    static get supported() {
      return html_common.Device.isEventTypeSupported('MediaStreamEvent');
    }
    get [dartx.stream]() {
      return this.stream;
    }
  };
  dart.setSignature(html$.MediaStreamEvent, {
    constructors: () => ({
      _: [html$.MediaStreamEvent, []],
      new: [html$.MediaStreamEvent, [core.String], [core.Map]]
    }),
    statics: () => ({
      _create_1: [html$.MediaStreamEvent, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.MediaStreamEvent, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.MediaStreamEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MediaStreamEvent')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MediaStreamEvent"))];
  dart.registerExtension(dart.global.MediaStreamEvent, html$.MediaStreamEvent);
  dart.defineExtensionNames([
    'clone',
    'stop',
    'onEnded',
    'onMute',
    'onUnmute',
    'enabled',
    'id',
    'kind',
    'label',
    'muted',
    'readyState'
  ]);
  html$.MediaStreamTrack = class MediaStreamTrack extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.enabled]() {
      return this.enabled;
    }
    set [dartx.enabled](value) {
      this.enabled = value;
    }
    get [dartx.id]() {
      return this.id;
    }
    get [dartx.kind]() {
      return this.kind;
    }
    get [dartx.label]() {
      return this.label;
    }
    get [dartx.muted]() {
      return this.muted;
    }
    get [dartx.readyState]() {
      return this.readyState;
    }
    [dartx.clone]() {
      return this.clone();
    }
    static getSources() {
      let completer = async.Completer$(core.List$(html$.SourceInfo)).new();
      html$.MediaStreamTrack._getSources(dart.fn(value => {
        completer.complete(value);
      }, dart.void, [core.List$(html$.SourceInfo)]));
      return completer.future;
    }
    [dartx.stop]() {
      return this.stop();
    }
    get [dartx.onEnded]() {
      return html$.MediaStreamTrack.endedEvent.forTarget(this);
    }
    get [dartx.onMute]() {
      return html$.MediaStreamTrack.muteEvent.forTarget(this);
    }
    get [dartx.onUnmute]() {
      return html$.MediaStreamTrack.unmuteEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.MediaStreamTrack, {
    constructors: () => ({_: [html$.MediaStreamTrack, []]}),
    methods: () => ({
      [dartx.clone]: [html$.MediaStreamTrack, []],
      [dartx.stop]: [dart.void, []]
    }),
    statics: () => ({
      _getSources: [dart.void, [html$.MediaStreamTrackSourcesCallback]],
      getSources: [async.Future$(core.List$(html$.SourceInfo)), []]
    }),
    names: ['_getSources', 'getSources']
  });
  html$.MediaStreamTrack[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MediaStreamTrack')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MediaStreamTrack"))];
  dart.defineLazy(html$.MediaStreamTrack, {
    get endedEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('ended'));
    },
    get muteEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('mute'));
    },
    get unmuteEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('unmute'));
    }
  });
  dart.registerExtension(dart.global.MediaStreamTrack, html$.MediaStreamTrack);
  dart.defineExtensionNames([
    'track'
  ]);
  html$.MediaStreamTrackEvent = class MediaStreamTrackEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static get supported() {
      return html_common.Device.isEventTypeSupported('MediaStreamTrackEvent');
    }
    get [dartx.track]() {
      return this.track;
    }
  };
  dart.setSignature(html$.MediaStreamTrackEvent, {
    constructors: () => ({_: [html$.MediaStreamTrackEvent, []]})
  });
  html$.MediaStreamTrackEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MediaStreamTrackEvent')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MediaStreamTrackEvent"))];
  dart.registerExtension(dart.global.MediaStreamTrackEvent, html$.MediaStreamTrackEvent);
  html$.MediaStreamTrackSourcesCallback = dart.typedef('MediaStreamTrackSourcesCallback', () => dart.functionType(dart.void, [core.List$(html$.SourceInfo)]));
  dart.defineExtensionNames([
    'jsHeapSizeLimit',
    'totalJSHeapSize',
    'usedJSHeapSize'
  ]);
  html$.MemoryInfo = class MemoryInfo extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.jsHeapSizeLimit]() {
      return this.jsHeapSizeLimit;
    }
    get [dartx.totalJSHeapSize]() {
      return this.totalJSHeapSize;
    }
    get [dartx.usedJSHeapSize]() {
      return this.usedJSHeapSize;
    }
  };
  dart.setSignature(html$.MemoryInfo, {
    constructors: () => ({_: [html$.MemoryInfo, []]})
  });
  html$.MemoryInfo[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MemoryInfo')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MemoryInfo"))];
  dart.registerExtension(dart.global.MemoryInfo, html$.MemoryInfo);
  dart.defineExtensionNames([
    'label',
    'type'
  ]);
  html$.MenuElement = class MenuElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("menu"), html$.MenuElement);
    }
    created() {
      this[dartx.label] = null;
      this[dartx.type] = null;
      super.created();
    }
    get [dartx.label]() {
      return this.label;
    }
    set [dartx.label](value) {
      this.label = value;
    }
    get [dartx.type]() {
      return this.type;
    }
    set [dartx.type](value) {
      this.type = value;
    }
  };
  dart.defineNamedConstructor(html$.MenuElement, 'created');
  dart.setSignature(html$.MenuElement, {
    constructors: () => ({
      _: [html$.MenuElement, []],
      new: [html$.MenuElement, []],
      created: [html$.MenuElement, []]
    })
  });
  html$.MenuElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLMenuElement')), dart.const(new _js_helper.Native("HTMLMenuElement"))];
  dart.registerExtension(dart.global.HTMLMenuElement, html$.MenuElement);
  dart.defineExtensionNames([
    'checked',
    'defaultValue',
    'disabled',
    'icon',
    'label',
    'radiogroup',
    'type'
  ]);
  html$.MenuItemElement = class MenuItemElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      this[dartx.checked] = null;
      this[dartx.defaultValue] = null;
      this[dartx.disabled] = null;
      this[dartx.icon] = null;
      this[dartx.label] = null;
      this[dartx.radiogroup] = null;
      this[dartx.type] = null;
      super.created();
    }
    get [dartx.checked]() {
      return this.checked;
    }
    set [dartx.checked](value) {
      this.checked = value;
    }
    get [dartx.defaultValue]() {
      return this.default;
    }
    set [dartx.defaultValue](value) {
      this.default = value;
    }
    get [dartx.disabled]() {
      return this.disabled;
    }
    set [dartx.disabled](value) {
      this.disabled = value;
    }
    get [dartx.icon]() {
      return this.icon;
    }
    set [dartx.icon](value) {
      this.icon = value;
    }
    get [dartx.label]() {
      return this.label;
    }
    set [dartx.label](value) {
      this.label = value;
    }
    get [dartx.radiogroup]() {
      return this.radiogroup;
    }
    set [dartx.radiogroup](value) {
      this.radiogroup = value;
    }
    get [dartx.type]() {
      return this.type;
    }
    set [dartx.type](value) {
      this.type = value;
    }
  };
  dart.defineNamedConstructor(html$.MenuItemElement, 'created');
  dart.setSignature(html$.MenuItemElement, {
    constructors: () => ({
      _: [html$.MenuItemElement, []],
      created: [html$.MenuItemElement, []]
    })
  });
  html$.MenuItemElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLMenuItemElement')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("HTMLMenuItemElement"))];
  dart.registerExtension(dart.global.HTMLMenuItemElement, html$.MenuItemElement);
  dart.defineExtensionNames([
    'port1',
    'port2'
  ]);
  html$.MessageChannel = class MessageChannel extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.port1]() {
      return this.port1;
    }
    get [dartx.port2]() {
      return this.port2;
    }
  };
  dart.setSignature(html$.MessageChannel, {
    constructors: () => ({_: [html$.MessageChannel, []]})
  });
  html$.MessageChannel[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MessageChannel')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("MessageChannel"))];
  dart.registerExtension(dart.global.MessageChannel, html$.MessageChannel);
  const _initMessageEvent = Symbol('_initMessageEvent');
  const _get_data = Symbol('_get_data');
  const _get_source = Symbol('_get_source');
  dart.defineExtensionNames([
    'data',
    'source',
    'lastEventId',
    'origin'
  ]);
  html$.MessageEvent = class MessageEvent extends html$.Event {
    static new(type, opts) {
      let canBubble = opts && 'canBubble' in opts ? opts.canBubble : false;
      let cancelable = opts && 'cancelable' in opts ? opts.cancelable : false;
      let data = opts && 'data' in opts ? opts.data : null;
      let origin = opts && 'origin' in opts ? opts.origin : null;
      let lastEventId = opts && 'lastEventId' in opts ? opts.lastEventId : null;
      let source = opts && 'source' in opts ? opts.source : null;
      let messagePorts = opts && 'messagePorts' in opts ? opts.messagePorts : null;
      if (source == null) {
        source = html$.window;
      }
      if (!dart.notNull(html_common.Device.isIE)) {
        return new MessageEvent(type, {bubbles: canBubble, cancelable: cancelable, data: data, origin: origin, lastEventId: lastEventId, source: source, ports: messagePorts});
      }
      let event = dart.as(html$.document[_createEvent]("MessageEvent"), html$.MessageEvent);
      event[_initMessageEvent](type, canBubble, cancelable, data, origin, lastEventId, source, messagePorts);
      return event;
    }
    get [dartx.data]() {
      return html_common.convertNativeToDart_SerializedScriptValue(this[_get_data]);
    }
    get [_get_data]() {
      return this.data;
    }
    static _(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.MessageEvent._create_1(type, eventInitDict_1);
      }
      return html$.MessageEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new MessageEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new MessageEvent(type);
    }
    get [dartx.lastEventId]() {
      return this.lastEventId;
    }
    get [dartx.origin]() {
      return this.origin;
    }
    get [dartx.source]() {
      return html$._convertNativeToDart_EventTarget(this[_get_source]);
    }
    get [_get_source]() {
      return this.source;
    }
    [_initMessageEvent](typeArg, canBubbleArg, cancelableArg, dataArg, originArg, lastEventIdArg, sourceArg, portsArg) {
      return this.initMessageEvent(typeArg, canBubbleArg, cancelableArg, dataArg, originArg, lastEventIdArg, sourceArg, portsArg);
    }
  };
  dart.setSignature(html$.MessageEvent, {
    constructors: () => ({
      new: [html$.MessageEvent, [core.String], {canBubble: core.bool, cancelable: core.bool, data: core.Object, origin: core.String, lastEventId: core.String, source: html$.Window, messagePorts: core.List$(html$.MessagePort)}],
      _: [html$.MessageEvent, [core.String], [core.Map]]
    }),
    methods: () => ({[_initMessageEvent]: [dart.void, [core.String, core.bool, core.bool, core.Object, core.String, core.String, html$.Window, core.List$(html$.MessagePort)]]}),
    statics: () => ({
      _create_1: [html$.MessageEvent, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.MessageEvent, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.MessageEvent[dart.metadata] = () => [dart.const(new _metadata.DomName('MessageEvent')), dart.const(new _js_helper.Native("MessageEvent"))];
  dart.registerExtension(dart.global.MessageEvent, html$.MessageEvent);
  dart.defineExtensionNames([
    'close',
    'postMessage',
    'start',
    'onMessage'
  ]);
  html$.MessagePort = class MessagePort extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.close]() {
      return this.close();
    }
    [dartx.postMessage](message, transfer) {
      if (transfer === void 0) transfer = null;
      if (transfer != null) {
        let message_1 = html_common.convertDartToNative_SerializedScriptValue(message);
        this[_postMessage_1](message_1, transfer);
        return;
      }
      let message_1 = html_common.convertDartToNative_SerializedScriptValue(message);
      this[_postMessage_2](message_1);
      return;
    }
    [_postMessage_1](message, transfer) {
      return this.postMessage(message, transfer);
    }
    [_postMessage_2](message) {
      return this.postMessage(message);
    }
    [dartx.start]() {
      return this.start();
    }
    get [dartx.onMessage]() {
      return html$.MessagePort.messageEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.MessagePort, {
    constructors: () => ({_: [html$.MessagePort, []]}),
    methods: () => ({
      [dartx.close]: [dart.void, []],
      [dartx.postMessage]: [dart.void, [dart.dynamic], [core.List$(html$.MessagePort)]],
      [_postMessage_1]: [dart.void, [dart.dynamic, core.List$(html$.MessagePort)]],
      [_postMessage_2]: [dart.void, [dart.dynamic]],
      [dartx.start]: [dart.void, []]
    })
  });
  html$.MessagePort[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MessagePort')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("MessagePort"))];
  dart.defineLazy(html$.MessagePort, {
    get messageEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MessageEvent))('message'));
    }
  });
  dart.registerExtension(dart.global.MessagePort, html$.MessagePort);
  dart.defineExtensionNames([
    'content',
    'httpEquiv',
    'name'
  ]);
  html$.MetaElement = class MetaElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("meta"), html$.MetaElement);
    }
    created() {
      this[dartx.content] = null;
      this[dartx.httpEquiv] = null;
      this[dartx.name] = null;
      super.created();
    }
    get [dartx.content]() {
      return this.content;
    }
    set [dartx.content](value) {
      this.content = value;
    }
    get [dartx.httpEquiv]() {
      return this.httpEquiv;
    }
    set [dartx.httpEquiv](value) {
      this.httpEquiv = value;
    }
    get [dartx.name]() {
      return this.name;
    }
    set [dartx.name](value) {
      this.name = value;
    }
  };
  dart.defineNamedConstructor(html$.MetaElement, 'created');
  dart.setSignature(html$.MetaElement, {
    constructors: () => ({
      _: [html$.MetaElement, []],
      new: [html$.MetaElement, []],
      created: [html$.MetaElement, []]
    })
  });
  html$.MetaElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLMetaElement')), dart.const(new _js_helper.Native("HTMLMetaElement"))];
  dart.registerExtension(dart.global.HTMLMetaElement, html$.MetaElement);
  const _get_modificationTime = Symbol('_get_modificationTime');
  dart.defineExtensionNames([
    'modificationTime',
    'size'
  ]);
  html$.Metadata = class Metadata extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.modificationTime]() {
      return html_common.convertNativeToDart_DateTime(this[_get_modificationTime]);
    }
    get [_get_modificationTime]() {
      return this.modificationTime;
    }
    get [dartx.size]() {
      return this.size;
    }
  };
  dart.setSignature(html$.Metadata, {
    constructors: () => ({_: [html$.Metadata, []]})
  });
  html$.Metadata[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Metadata')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("Metadata"))];
  dart.registerExtension(dart.global.Metadata, html$.Metadata);
  html$.MetadataCallback = dart.typedef('MetadataCallback', () => dart.functionType(dart.void, [html$.Metadata]));
  dart.defineExtensionNames([
    'high',
    'labels',
    'low',
    'max',
    'min',
    'optimum',
    'value'
  ]);
  html$.MeterElement = class MeterElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("meter"), html$.MeterElement);
    }
    created() {
      this[dartx.high] = null;
      this[dartx.labels] = null;
      this[dartx.low] = null;
      this[dartx.max] = null;
      this[dartx.min] = null;
      this[dartx.optimum] = null;
      this[dartx.value] = null;
      super.created();
    }
    static get supported() {
      return html$.Element.isTagSupported('meter');
    }
    get [dartx.high]() {
      return this.high;
    }
    set [dartx.high](value) {
      this.high = value;
    }
    get [dartx.labels]() {
      return this.labels;
    }
    get [dartx.low]() {
      return this.low;
    }
    set [dartx.low](value) {
      this.low = value;
    }
    get [dartx.max]() {
      return this.max;
    }
    set [dartx.max](value) {
      this.max = value;
    }
    get [dartx.min]() {
      return this.min;
    }
    set [dartx.min](value) {
      this.min = value;
    }
    get [dartx.optimum]() {
      return this.optimum;
    }
    set [dartx.optimum](value) {
      this.optimum = value;
    }
    get [dartx.value]() {
      return this.value;
    }
    set [dartx.value](value) {
      this.value = value;
    }
  };
  dart.defineNamedConstructor(html$.MeterElement, 'created');
  dart.setSignature(html$.MeterElement, {
    constructors: () => ({
      _: [html$.MeterElement, []],
      new: [html$.MeterElement, []],
      created: [html$.MeterElement, []]
    })
  });
  html$.MeterElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLMeterElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("HTMLMeterElement"))];
  dart.registerExtension(dart.global.HTMLMeterElement, html$.MeterElement);
  dart.defineExtensionNames([
    'inputs',
    'outputs',
    'sysexEnabled'
  ]);
  html$.MidiAccess = class MidiAccess extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.inputs]() {
      return this.inputs;
    }
    get [dartx.outputs]() {
      return this.outputs;
    }
    get [dartx.sysexEnabled]() {
      return this.sysexEnabled;
    }
  };
  dart.setSignature(html$.MidiAccess, {
    constructors: () => ({_: [html$.MidiAccess, []]})
  });
  html$.MidiAccess[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MIDIAccess')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MIDIAccess"))];
  dart.registerExtension(dart.global.MIDIAccess, html$.MidiAccess);
  dart.defineExtensionNames([
    'port'
  ]);
  html$.MidiConnectionEvent = class MidiConnectionEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.MidiConnectionEvent._create_1(type, eventInitDict_1);
      }
      return html$.MidiConnectionEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new MIDIConnectionEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new MIDIConnectionEvent(type);
    }
    get [dartx.port]() {
      return this.port;
    }
  };
  dart.setSignature(html$.MidiConnectionEvent, {
    constructors: () => ({
      _: [html$.MidiConnectionEvent, []],
      new: [html$.MidiConnectionEvent, [core.String], [core.Map]]
    }),
    statics: () => ({
      _create_1: [html$.MidiConnectionEvent, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.MidiConnectionEvent, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.MidiConnectionEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MIDIConnectionEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MIDIConnectionEvent"))];
  dart.registerExtension(dart.global.MIDIConnectionEvent, html$.MidiConnectionEvent);
  dart.defineExtensionNames([
    'close',
    'open',
    'connection',
    'id',
    'manufacturer',
    'name',
    'state',
    'type',
    'version'
  ]);
  html$.MidiPort = class MidiPort extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.connection]() {
      return this.connection;
    }
    get [dartx.id]() {
      return this.id;
    }
    get [dartx.manufacturer]() {
      return this.manufacturer;
    }
    get [dartx.name]() {
      return this.name;
    }
    get [dartx.state]() {
      return this.state;
    }
    get [dartx.type]() {
      return this.type;
    }
    get [dartx.version]() {
      return this.version;
    }
    [dartx.close]() {
      return this.close();
    }
    [dartx.open]() {
      return this.open();
    }
  };
  dart.setSignature(html$.MidiPort, {
    constructors: () => ({_: [html$.MidiPort, []]}),
    methods: () => ({
      [dartx.close]: [async.Future, []],
      [dartx.open]: [async.Future, []]
    })
  });
  html$.MidiPort[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MIDIPort')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MIDIPort"))];
  dart.registerExtension(dart.global.MIDIPort, html$.MidiPort);
  dart.defineExtensionNames([
    'onMidiMessage'
  ]);
  html$.MidiInput = class MidiInput extends html$.MidiPort {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.onMidiMessage]() {
      return html$.MidiInput.midiMessageEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.MidiInput, {
    constructors: () => ({_: [html$.MidiInput, []]})
  });
  html$.MidiInput[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MIDIInput')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MIDIInput"))];
  dart.defineLazy(html$.MidiInput, {
    get midiMessageEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MidiMessageEvent))('midimessage'));
    }
  });
  dart.registerExtension(dart.global.MIDIInput, html$.MidiInput);
  dart.defineExtensionNames([
    'size'
  ]);
  html$.MidiInputMap = class MidiInputMap extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.size]() {
      return this.size;
    }
  };
  dart.setSignature(html$.MidiInputMap, {
    constructors: () => ({_: [html$.MidiInputMap, []]})
  });
  html$.MidiInputMap[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MIDIInputMap')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MIDIInputMap"))];
  dart.registerExtension(dart.global.MIDIInputMap, html$.MidiInputMap);
  dart.defineExtensionNames([
    'data',
    'receivedTime'
  ]);
  html$.MidiMessageEvent = class MidiMessageEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.MidiMessageEvent._create_1(type, eventInitDict_1);
      }
      return html$.MidiMessageEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new MIDIMessageEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new MIDIMessageEvent(type);
    }
    get [dartx.data]() {
      return this.data;
    }
    get [dartx.receivedTime]() {
      return this.receivedTime;
    }
  };
  dart.setSignature(html$.MidiMessageEvent, {
    constructors: () => ({
      _: [html$.MidiMessageEvent, []],
      new: [html$.MidiMessageEvent, [core.String], [core.Map]]
    }),
    statics: () => ({
      _create_1: [html$.MidiMessageEvent, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.MidiMessageEvent, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.MidiMessageEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MIDIMessageEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MIDIMessageEvent"))];
  dart.registerExtension(dart.global.MIDIMessageEvent, html$.MidiMessageEvent);
  dart.defineExtensionNames([
    'send'
  ]);
  html$.MidiOutput = class MidiOutput extends html$.MidiPort {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.send](data, timestamp) {
      return this.send(data, timestamp);
    }
  };
  dart.setSignature(html$.MidiOutput, {
    constructors: () => ({_: [html$.MidiOutput, []]}),
    methods: () => ({[dartx.send]: [dart.void, [typed_data.Uint8List], [core.num]]})
  });
  html$.MidiOutput[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MIDIOutput')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MIDIOutput"))];
  dart.registerExtension(dart.global.MIDIOutput, html$.MidiOutput);
  dart.defineExtensionNames([
    'size'
  ]);
  html$.MidiOutputMap = class MidiOutputMap extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.size]() {
      return this.size;
    }
  };
  dart.setSignature(html$.MidiOutputMap, {
    constructors: () => ({_: [html$.MidiOutputMap, []]})
  });
  html$.MidiOutputMap[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MIDIOutputMap')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MIDIOutputMap"))];
  dart.registerExtension(dart.global.MIDIOutputMap, html$.MidiOutputMap);
  dart.defineExtensionNames([
    'description',
    'enabledPlugin',
    'suffixes',
    'type'
  ]);
  html$.MimeType = class MimeType extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.description]() {
      return this.description;
    }
    get [dartx.enabledPlugin]() {
      return this.enabledPlugin;
    }
    get [dartx.suffixes]() {
      return this.suffixes;
    }
    get [dartx.type]() {
      return this.type;
    }
  };
  dart.setSignature(html$.MimeType, {
    constructors: () => ({_: [html$.MimeType, []]})
  });
  html$.MimeType[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MimeType')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MimeType"))];
  dart.registerExtension(dart.global.MimeType, html$.MimeType);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'item',
    'namedItem'
  ]);
  html$.MimeTypeArray = class MimeTypeArray extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(html$.MimeType), html$.ImmutableListMixin$(html$.MimeType)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return this[index];
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return this[0];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return this[dart.notNull(len) - 1];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return this[0];
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [dartx.item](index) {
      return this.item(index);
    }
    [dartx.namedItem](name) {
      return this.namedItem(name);
    }
  };
  html$.MimeTypeArray[dart.implements] = () => [_js_helper.JavaScriptIndexingBehavior, core.List$(html$.MimeType)];
  dart.setSignature(html$.MimeTypeArray, {
    constructors: () => ({_: [html$.MimeTypeArray, []]}),
    methods: () => ({
      [dartx.get]: [html$.MimeType, [core.int]],
      [dartx.set]: [dart.void, [core.int, html$.MimeType]],
      [dartx.elementAt]: [html$.MimeType, [core.int]],
      [dartx.item]: [html$.MimeType, [core.int]],
      [dartx.namedItem]: [html$.MimeType, [core.String]]
    })
  });
  html$.MimeTypeArray[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MimeTypeArray')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MimeTypeArray"))];
  dart.registerExtension(dart.global.MimeTypeArray, html$.MimeTypeArray);
  dart.defineExtensionNames([
    'cite',
    'dateTime'
  ]);
  html$.ModElement = class ModElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      this[dartx.cite] = null;
      this[dartx.dateTime] = null;
      super.created();
    }
    get [dartx.cite]() {
      return this.cite;
    }
    set [dartx.cite](value) {
      this.cite = value;
    }
    get [dartx.dateTime]() {
      return this.dateTime;
    }
    set [dartx.dateTime](value) {
      this.dateTime = value;
    }
  };
  dart.defineNamedConstructor(html$.ModElement, 'created');
  dart.setSignature(html$.ModElement, {
    constructors: () => ({
      _: [html$.ModElement, []],
      created: [html$.ModElement, []]
    })
  });
  html$.ModElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLModElement')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("HTMLModElement"))];
  dart.registerExtension(dart.global.HTMLModElement, html$.ModElement);
  const _initMouseEvent = Symbol('_initMouseEvent');
  const _clientX = Symbol('_clientX');
  const _clientY = Symbol('_clientY');
  const _layerX = Symbol('_layerX');
  const _layerY = Symbol('_layerY');
  const _movementX = Symbol('_movementX');
  const _movementY = Symbol('_movementY');
  const _pageX = Symbol('_pageX');
  const _pageY = Symbol('_pageY');
  const _screenX = Symbol('_screenX');
  const _screenY = Symbol('_screenY');
  const _webkitMovementX = Symbol('_webkitMovementX');
  const _webkitMovementY = Symbol('_webkitMovementY');
  const _initMouseEvent_1 = Symbol('_initMouseEvent_1');
  dart.defineExtensionNames([
    'relatedTarget',
    'client',
    'movement',
    'offset',
    'screen',
    'layer',
    'page',
    'altKey',
    'button',
    'buttons',
    'ctrlKey',
    'dataTransfer',
    'fromElement',
    'metaKey',
    'region',
    'shiftKey',
    'toElement'
  ]);
  html$.MouseEvent = class MouseEvent extends html$.UIEvent {
    static new(type, opts) {
      let view = opts && 'view' in opts ? opts.view : null;
      let detail = opts && 'detail' in opts ? opts.detail : 0;
      let screenX = opts && 'screenX' in opts ? opts.screenX : 0;
      let screenY = opts && 'screenY' in opts ? opts.screenY : 0;
      let clientX = opts && 'clientX' in opts ? opts.clientX : 0;
      let clientY = opts && 'clientY' in opts ? opts.clientY : 0;
      let button = opts && 'button' in opts ? opts.button : 0;
      let canBubble = opts && 'canBubble' in opts ? opts.canBubble : true;
      let cancelable = opts && 'cancelable' in opts ? opts.cancelable : true;
      let ctrlKey = opts && 'ctrlKey' in opts ? opts.ctrlKey : false;
      let altKey = opts && 'altKey' in opts ? opts.altKey : false;
      let shiftKey = opts && 'shiftKey' in opts ? opts.shiftKey : false;
      let metaKey = opts && 'metaKey' in opts ? opts.metaKey : false;
      let relatedTarget = opts && 'relatedTarget' in opts ? opts.relatedTarget : null;
      if (view == null) {
        view = html$.window;
      }
      let event = dart.as(html$.document[_createEvent]('MouseEvent'), html$.MouseEvent);
      event[_initMouseEvent](type, canBubble, cancelable, view, detail, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey, button, relatedTarget);
      return event;
    }
    static _(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.MouseEvent._create_1(type, eventInitDict_1);
      }
      return html$.MouseEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new MouseEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new MouseEvent(type);
    }
    get [dartx.altKey]() {
      return this.altKey;
    }
    get [dartx.button]() {
      return this.button;
    }
    get [dartx.buttons]() {
      return this.buttons;
    }
    get [_clientX]() {
      return this.clientX;
    }
    get [_clientY]() {
      return this.clientY;
    }
    get [dartx.ctrlKey]() {
      return this.ctrlKey;
    }
    get [dartx.dataTransfer]() {
      return this.dataTransfer;
    }
    get [dartx.fromElement]() {
      return this.fromElement;
    }
    get [_layerX]() {
      return this.layerX;
    }
    get [_layerY]() {
      return this.layerY;
    }
    get [dartx.metaKey]() {
      return this.metaKey;
    }
    get [_movementX]() {
      return this.movementX;
    }
    get [_movementY]() {
      return this.movementY;
    }
    get [_pageX]() {
      return this.pageX;
    }
    get [_pageY]() {
      return this.pageY;
    }
    get [dartx.region]() {
      return this.region;
    }
    get [dartx.relatedTarget]() {
      return html$._convertNativeToDart_EventTarget(this[_get_relatedTarget]);
    }
    get [_get_relatedTarget]() {
      return this.relatedTarget;
    }
    get [_screenX]() {
      return this.screenX;
    }
    get [_screenY]() {
      return this.screenY;
    }
    get [dartx.shiftKey]() {
      return this.shiftKey;
    }
    get [dartx.toElement]() {
      return this.toElement;
    }
    get [_webkitMovementX]() {
      return this.webkitMovementX;
    }
    get [_webkitMovementY]() {
      return this.webkitMovementY;
    }
    [_initMouseEvent](type, bubbles, cancelable, view, detail, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey, button, relatedTarget) {
      let relatedTarget_1 = html$._convertDartToNative_EventTarget(relatedTarget);
      this[_initMouseEvent_1](type, bubbles, cancelable, view, detail, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey, button, relatedTarget_1);
      return;
    }
    [_initMouseEvent_1](type, bubbles, cancelable, view, detail, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey, button, relatedTarget) {
      return this.initMouseEvent(type, bubbles, cancelable, view, detail, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey, button, relatedTarget);
    }
    get [dartx.client]() {
      return new (math.Point$(core.num))(this[_clientX], this[_clientY]);
    }
    get [dartx.movement]() {
      return new (math.Point$(core.num))(this[_webkitMovementX], this[_webkitMovementY]);
    }
    get [dartx.offset]() {
      if (!!this.offsetX) {
        let x = this.offsetX;
        let y = this.offsetY;
        return new (math.Point$(core.num))(x, y);
      } else {
        if (!dart.is(this[dartx.target], html$.Element)) {
          dart.throw(new core.UnsupportedError('offsetX is only supported on elements'));
        }
        let target = dart.as(this[dartx.target], html$.Element);
        let point = this[dartx.client]['-'](target[dartx.getBoundingClientRect]()[dartx.topLeft]);
        return new (math.Point$(core.num))(point.x[dartx.toInt](), point.y[dartx.toInt]());
      }
    }
    get [dartx.screen]() {
      return new (math.Point$(core.num))(this[_screenX], this[_screenY]);
    }
    get [dartx.layer]() {
      return new (math.Point$(core.num))(this[_layerX], this[_layerY]);
    }
    get [dartx.page]() {
      return new (math.Point$(core.num))(this[_pageX], this[_pageY]);
    }
  };
  dart.setSignature(html$.MouseEvent, {
    constructors: () => ({
      new: [html$.MouseEvent, [core.String], {view: html$.Window, detail: core.int, screenX: core.int, screenY: core.int, clientX: core.int, clientY: core.int, button: core.int, canBubble: core.bool, cancelable: core.bool, ctrlKey: core.bool, altKey: core.bool, shiftKey: core.bool, metaKey: core.bool, relatedTarget: html$.EventTarget}],
      _: [html$.MouseEvent, [core.String], [core.Map]]
    }),
    methods: () => ({
      [_initMouseEvent]: [dart.void, [core.String, core.bool, core.bool, html$.Window, core.int, core.int, core.int, core.int, core.int, core.bool, core.bool, core.bool, core.bool, core.int, html$.EventTarget]],
      [_initMouseEvent_1]: [dart.void, [dart.dynamic, dart.dynamic, dart.dynamic, html$.Window, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]]
    }),
    statics: () => ({
      _create_1: [html$.MouseEvent, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.MouseEvent, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.MouseEvent[dart.metadata] = () => [dart.const(new _metadata.DomName('MouseEvent')), dart.const(new _js_helper.Native("MouseEvent,DragEvent"))];
  dart.registerExtension(dart.global.MouseEvent, html$.MouseEvent);
  html$.MutationCallback = dart.typedef('MutationCallback', () => dart.functionType(dart.void, [core.List$(html$.MutationRecord), html$.MutationObserver]));
  const _observe_1 = Symbol('_observe_1');
  const _observe = Symbol('_observe');
  const _call = Symbol('_call');
  dart.defineExtensionNames([
    'disconnect',
    'takeRecords',
    'observe'
  ]);
  html$.MutationObserver = class MutationObserver extends _interceptors.Interceptor {
    [dartx.disconnect]() {
      return this.disconnect();
    }
    [_observe](target, options) {
      let options_1 = html_common.convertDartToNative_Dictionary(options);
      this[_observe_1](target, options_1);
      return;
    }
    [_observe_1](target, options) {
      return this.observe(target, options);
    }
    [dartx.takeRecords]() {
      return this.takeRecords();
    }
    static get supported() {
      return !!(window.MutationObserver || window.WebKitMutationObserver);
    }
    [dartx.observe](target, opts) {
      let childList = opts && 'childList' in opts ? opts.childList : null;
      let attributes = opts && 'attributes' in opts ? opts.attributes : null;
      let characterData = opts && 'characterData' in opts ? opts.characterData : null;
      let subtree = opts && 'subtree' in opts ? opts.subtree : null;
      let attributeOldValue = opts && 'attributeOldValue' in opts ? opts.attributeOldValue : null;
      let characterDataOldValue = opts && 'characterDataOldValue' in opts ? opts.characterDataOldValue : null;
      let attributeFilter = opts && 'attributeFilter' in opts ? opts.attributeFilter : null;
      let parsedOptions = html$.MutationObserver._createDict();
      function override(key, value) {
        if (value != null) html$.MutationObserver._add(parsedOptions, dart.as(key, core.String), value);
      }
      dart.fn(override);
      override('childList', childList);
      override('attributes', attributes);
      override('characterData', characterData);
      override('subtree', subtree);
      override('attributeOldValue', attributeOldValue);
      override('characterDataOldValue', characterDataOldValue);
      if (attributeFilter != null) {
        override('attributeFilter', html$.MutationObserver._fixupList(attributeFilter));
      }
      this[_call](target, parsedOptions);
    }
    static _createDict() {
      return {};
    }
    static _add(m, key, value) {
      m[key] = value;
    }
    static _fixupList(list) {
      return list;
    }
    [_call](target, options) {
      return this.observe(target, options);
    }
    static new(callback) {
      0;
      return new (window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver)(_js_helper.convertDartClosureToJS(html$._wrapZoneBinaryCallback)(html$._wrapBinaryZone(dart.dynamic, dart.dynamic, dart.dynamic)(callback), 2));
    }
  };
  dart.setSignature(html$.MutationObserver, {
    constructors: () => ({new: [html$.MutationObserver, [html$.MutationCallback]]}),
    methods: () => ({
      [dartx.disconnect]: [dart.void, []],
      [_observe]: [dart.void, [html$.Node, core.Map]],
      [_observe_1]: [dart.void, [html$.Node, dart.dynamic]],
      [dartx.takeRecords]: [core.List$(html$.MutationRecord), []],
      [dartx.observe]: [dart.void, [html$.Node], {childList: core.bool, attributes: core.bool, characterData: core.bool, subtree: core.bool, attributeOldValue: core.bool, characterDataOldValue: core.bool, attributeFilter: core.List$(core.String)}],
      [_call]: [dart.void, [dart.dynamic, dart.dynamic]]
    }),
    statics: () => ({
      _createDict: [dart.dynamic, []],
      _add: [dart.dynamic, [dart.dynamic, core.String, dart.dynamic]],
      _fixupList: [dart.dynamic, [dart.dynamic]]
    }),
    names: ['_createDict', '_add', '_fixupList']
  });
  html$.MutationObserver[dart.metadata] = () => [dart.const(new _metadata.DomName('MutationObserver')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MutationObserver,WebKitMutationObserver"))];
  html$.MutationObserver._boolKeys = dart.const(dart.map({childList: true, attributes: true, characterData: true, subtree: true, attributeOldValue: true, characterDataOldValue: true}));
  dart.registerExtension(dart.global.MutationObserver, html$.MutationObserver);
  dart.defineExtensionNames([
    'addedNodes',
    'attributeName',
    'attributeNamespace',
    'nextSibling',
    'oldValue',
    'previousSibling',
    'removedNodes',
    'target',
    'type'
  ]);
  html$.MutationRecord = class MutationRecord extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.addedNodes]() {
      return this.addedNodes;
    }
    get [dartx.attributeName]() {
      return this.attributeName;
    }
    get [dartx.attributeNamespace]() {
      return this.attributeNamespace;
    }
    get [dartx.nextSibling]() {
      return this.nextSibling;
    }
    get [dartx.oldValue]() {
      return this.oldValue;
    }
    get [dartx.previousSibling]() {
      return this.previousSibling;
    }
    get [dartx.removedNodes]() {
      return this.removedNodes;
    }
    get [dartx.target]() {
      return this.target;
    }
    get [dartx.type]() {
      return this.type;
    }
  };
  dart.setSignature(html$.MutationRecord, {
    constructors: () => ({_: [html$.MutationRecord, []]})
  });
  html$.MutationRecord[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MutationRecord')), dart.const(new _js_helper.Native("MutationRecord"))];
  dart.registerExtension(dart.global.MutationRecord, html$.MutationRecord);
  const _ensureGetUserMedia = Symbol('_ensureGetUserMedia');
  const _getUserMedia = Symbol('_getUserMedia');
  const _requestMidiAccess_1 = Symbol('_requestMidiAccess_1');
  const _requestMidiAccess_2 = Symbol('_requestMidiAccess_2');
  dart.defineExtensionNames([
    'language',
    'getUserMedia',
    'getBattery',
    'getGamepads',
    'getVRDevices',
    'registerProtocolHandler',
    'requestMidiAccess',
    'requestMediaKeySystemAccess',
    'sendBeacon',
    'getStorageUpdates',
    'bluetooth',
    'connection',
    'credentials',
    'doNotTrack',
    'geolocation',
    'maxTouchPoints',
    'mediaDevices',
    'mimeTypes',
    'permissions',
    'presentation',
    'productSub',
    'serviceWorker',
    'services',
    'storageQuota',
    'vendor',
    'vendorSub',
    'persistentStorage',
    'temporaryStorage',
    'hardwareConcurrency',
    'appCodeName',
    'appName',
    'appVersion',
    'dartEnabled',
    'platform',
    'product',
    'userAgent',
    'languages',
    'onLine',
    'cookieEnabled'
  ]);
  html$.Navigator = class Navigator extends _interceptors.Interceptor {
    get [dartx.language]() {
      return this.language || this.userLanguage;
    }
    [dartx.getUserMedia](opts) {
      let audio = opts && 'audio' in opts ? opts.audio : false;
      let video = opts && 'video' in opts ? opts.video : false;
      let completer = async.Completer$(html$.MediaStream).new();
      let options = dart.map({audio: audio, video: video});
      this[_ensureGetUserMedia]();
      this[_getUserMedia](html_common.convertDartToNative_SerializedScriptValue(options), dart.fn(stream => {
        completer.complete(stream);
      }, dart.void, [html$.MediaStream]), dart.fn(error => {
        completer.completeError(error);
      }, dart.void, [html$.NavigatorUserMediaError]));
      return completer.future;
    }
    [_ensureGetUserMedia]() {
      if (!this.getUserMedia) {
        this.getUserMedia = this.getUserMedia || this.webkitGetUserMedia || this.mozGetUserMedia || this.msGetUserMedia;
      }
    }
    [_getUserMedia](options, success, error) {
      return this.getUserMedia(options, success, error);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.bluetooth]() {
      return this.bluetooth;
    }
    get [dartx.connection]() {
      return this.connection;
    }
    get [dartx.credentials]() {
      return this.credentials;
    }
    get [dartx.doNotTrack]() {
      return this.doNotTrack;
    }
    get [dartx.geolocation]() {
      return this.geolocation;
    }
    get [dartx.maxTouchPoints]() {
      return this.maxTouchPoints;
    }
    get [dartx.mediaDevices]() {
      return this.mediaDevices;
    }
    get [dartx.mimeTypes]() {
      return this.mimeTypes;
    }
    get [dartx.permissions]() {
      return this.permissions;
    }
    get [dartx.presentation]() {
      return this.presentation;
    }
    get [dartx.productSub]() {
      return this.productSub;
    }
    get [dartx.serviceWorker]() {
      return this.serviceWorker;
    }
    get [dartx.services]() {
      return this.services;
    }
    get [dartx.storageQuota]() {
      return this.storageQuota;
    }
    get [dartx.vendor]() {
      return this.vendor;
    }
    get [dartx.vendorSub]() {
      return this.vendorSub;
    }
    get [dartx.persistentStorage]() {
      return this.webkitPersistentStorage;
    }
    get [dartx.temporaryStorage]() {
      return this.webkitTemporaryStorage;
    }
    [dartx.getBattery]() {
      return this.getBattery();
    }
    [dartx.getGamepads]() {
      return this.getGamepads();
    }
    [dartx.getVRDevices]() {
      return this.getVRDevices();
    }
    [dartx.registerProtocolHandler](scheme, url, title) {
      return this.registerProtocolHandler(scheme, url, title);
    }
    [dartx.requestMidiAccess](options) {
      if (options === void 0) options = null;
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        return this[_requestMidiAccess_1](options_1);
      }
      return this[_requestMidiAccess_2]();
    }
    [_requestMidiAccess_1](options) {
      return this.requestMIDIAccess(options);
    }
    [_requestMidiAccess_2]() {
      return this.requestMIDIAccess();
    }
    [dartx.requestMediaKeySystemAccess](keySystem, supportedConfigurations) {
      return this.requestMediaKeySystemAccess(keySystem, supportedConfigurations);
    }
    [dartx.sendBeacon](url, data) {
      return this.sendBeacon(url, data);
    }
    get [dartx.hardwareConcurrency]() {
      return this.hardwareConcurrency;
    }
    get [dartx.appCodeName]() {
      return this.appCodeName;
    }
    get [dartx.appName]() {
      return this.appName;
    }
    get [dartx.appVersion]() {
      return this.appVersion;
    }
    get [dartx.dartEnabled]() {
      return this.dartEnabled;
    }
    get [dartx.platform]() {
      return this.platform;
    }
    get [dartx.product]() {
      return this.product;
    }
    get [dartx.userAgent]() {
      return this.userAgent;
    }
    get [dartx.languages]() {
      return this.languages;
    }
    get [dartx.onLine]() {
      return this.onLine;
    }
    get [dartx.cookieEnabled]() {
      return this.cookieEnabled;
    }
    [dartx.getStorageUpdates]() {
      return this.getStorageUpdates();
    }
  };
  html$.Navigator[dart.implements] = () => [html$.NavigatorStorageUtils, html$.NavigatorCpu, html$.NavigatorLanguage, html$.NavigatorOnLine, html$.NavigatorID];
  dart.setSignature(html$.Navigator, {
    constructors: () => ({_: [html$.Navigator, []]}),
    methods: () => ({
      [dartx.getUserMedia]: [async.Future$(html$.MediaStream), [], {audio: dart.dynamic, video: dart.dynamic}],
      [_ensureGetUserMedia]: [dart.dynamic, []],
      [_getUserMedia]: [dart.void, [dart.dynamic, html$._NavigatorUserMediaSuccessCallback, html$._NavigatorUserMediaErrorCallback]],
      [dartx.getBattery]: [async.Future, []],
      [dartx.getGamepads]: [core.List$(html$.Gamepad), []],
      [dartx.getVRDevices]: [async.Future, []],
      [dartx.registerProtocolHandler]: [dart.void, [core.String, core.String, core.String]],
      [dartx.requestMidiAccess]: [async.Future, [], [core.Map]],
      [_requestMidiAccess_1]: [async.Future, [dart.dynamic]],
      [_requestMidiAccess_2]: [async.Future, []],
      [dartx.requestMediaKeySystemAccess]: [async.Future, [core.String, core.List$(core.Map)]],
      [dartx.sendBeacon]: [core.bool, [core.String, core.Object]],
      [dartx.getStorageUpdates]: [dart.void, []]
    })
  });
  html$.Navigator[dart.metadata] = () => [dart.const(new _metadata.DomName('Navigator')), dart.const(new _js_helper.Native("Navigator"))];
  dart.registerExtension(dart.global.Navigator, html$.Navigator);
  dart.defineExtensionNames([
    'hardwareConcurrency'
  ]);
  html$.NavigatorCpu = class NavigatorCpu extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$.NavigatorCpu, {
    constructors: () => ({_: [html$.NavigatorCpu, []]})
  });
  dart.defineExtensionMembers(html$.NavigatorCpu, ['hardwareConcurrency']);
  html$.NavigatorCpu[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('NavigatorCPU')), dart.const(new _metadata.Experimental())];
  dart.defineExtensionNames([
    'appCodeName',
    'appName',
    'appVersion',
    'dartEnabled',
    'platform',
    'product',
    'userAgent'
  ]);
  html$.NavigatorID = class NavigatorID extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$.NavigatorID, {
    constructors: () => ({_: [html$.NavigatorID, []]})
  });
  dart.defineExtensionMembers(html$.NavigatorID, [
    'appCodeName',
    'appName',
    'appVersion',
    'dartEnabled',
    'platform',
    'product',
    'userAgent'
  ]);
  html$.NavigatorID[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('NavigatorID')), dart.const(new _metadata.Experimental())];
  dart.defineExtensionNames([
    'language',
    'languages'
  ]);
  html$.NavigatorLanguage = class NavigatorLanguage extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$.NavigatorLanguage, {
    constructors: () => ({_: [html$.NavigatorLanguage, []]})
  });
  dart.defineExtensionMembers(html$.NavigatorLanguage, ['language', 'languages']);
  html$.NavigatorLanguage[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('NavigatorLanguage')), dart.const(new _metadata.Experimental())];
  dart.defineExtensionNames([
    'onLine'
  ]);
  html$.NavigatorOnLine = class NavigatorOnLine extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$.NavigatorOnLine, {
    constructors: () => ({_: [html$.NavigatorOnLine, []]})
  });
  dart.defineExtensionMembers(html$.NavigatorOnLine, ['onLine']);
  html$.NavigatorOnLine[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('NavigatorOnLine')), dart.const(new _metadata.Experimental())];
  dart.defineExtensionNames([
    'getStorageUpdates',
    'cookieEnabled'
  ]);
  html$.NavigatorStorageUtils = class NavigatorStorageUtils extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.cookieEnabled]() {
      return this.cookieEnabled;
    }
    [dartx.getStorageUpdates]() {
      return this.getStorageUpdates();
    }
  };
  dart.setSignature(html$.NavigatorStorageUtils, {
    constructors: () => ({_: [html$.NavigatorStorageUtils, []]}),
    methods: () => ({[dartx.getStorageUpdates]: [dart.void, []]})
  });
  html$.NavigatorStorageUtils[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('NavigatorStorageUtils')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("NavigatorStorageUtils"))];
  dart.registerExtension(dart.global.NavigatorStorageUtils, html$.NavigatorStorageUtils);
  dart.defineExtensionNames([
    'constraintName',
    'message',
    'name'
  ]);
  html$.NavigatorUserMediaError = class NavigatorUserMediaError extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.constraintName]() {
      return this.constraintName;
    }
    get [dartx.message]() {
      return this.message;
    }
    get [dartx.name]() {
      return this.name;
    }
  };
  dart.setSignature(html$.NavigatorUserMediaError, {
    constructors: () => ({_: [html$.NavigatorUserMediaError, []]})
  });
  html$.NavigatorUserMediaError[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('NavigatorUserMediaError')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("NavigatorUserMediaError"))];
  dart.registerExtension(dart.global.NavigatorUserMediaError, html$.NavigatorUserMediaError);
  html$._NavigatorUserMediaErrorCallback = dart.typedef('_NavigatorUserMediaErrorCallback', () => dart.functionType(dart.void, [html$.NavigatorUserMediaError]));
  html$._NavigatorUserMediaSuccessCallback = dart.typedef('_NavigatorUserMediaSuccessCallback', () => dart.functionType(dart.void, [html$.MediaStream]));
  dart.defineExtensionNames([
    'type'
  ]);
  html$.NetworkInformation = class NetworkInformation extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.type]() {
      return this.type;
    }
  };
  dart.setSignature(html$.NetworkInformation, {
    constructors: () => ({_: [html$.NetworkInformation, []]})
  });
  html$.NetworkInformation[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('NetworkInformation')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("NetworkInformation"))];
  dart.registerExtension(dart.global.NetworkInformation, html$.NetworkInformation);
  html$._ChildNodeListLazy = class _ChildNodeListLazy extends collection.ListBase$(html$.Node) {
    _ChildNodeListLazy(this$) {
      this[_this] = this$;
    }
    get first() {
      let result = this[_this].firstChild;
      if (result == null) dart.throw(new core.StateError("No elements"));
      return result;
    }
    get last() {
      let result = this[_this].lastChild;
      if (result == null) dart.throw(new core.StateError("No elements"));
      return result;
    }
    get single() {
      let l = this.length;
      if (l == 0) dart.throw(new core.StateError("No elements"));
      if (dart.notNull(l) > 1) dart.throw(new core.StateError("More than one element"));
      return this[_this].firstChild;
    }
    add(value) {
      this[_this][dartx.append](value);
    }
    addAll(iterable) {
      if (dart.is(iterable, html$._ChildNodeListLazy)) {
        let otherList = iterable;
        if (!core.identical(otherList[_this], this[_this])) {
          for (let i = 0, len = otherList.length; i < dart.notNull(len); ++i) {
            this[_this][dartx.append](otherList[_this][dartx.firstChild]);
          }
        }
        return;
      }
      for (let node of iterable) {
        this[_this][dartx.append](node);
      }
    }
    insert(index, node) {
      if (dart.notNull(index) < 0 || dart.notNull(index) > dart.notNull(this.length)) {
        dart.throw(new core.RangeError.range(index, 0, this.length));
      }
      if (index == this.length) {
        this[_this][dartx.append](node);
      } else {
        this[_this][dartx.insertBefore](node, this.get(index));
      }
    }
    insertAll(index, iterable) {
      if (index == this.length) {
        this.addAll(iterable);
      } else {
        let item = this.get(index);
        this[_this][dartx.insertAllBefore](iterable, item);
      }
    }
    setAll(index, iterable) {
      dart.throw(new core.UnsupportedError("Cannot setAll on Node list"));
    }
    removeLast() {
      let result = this.last;
      if (result != null) {
        this[_this][_removeChild](result);
      }
      return result;
    }
    removeAt(index) {
      let result = this.get(index);
      if (result != null) {
        this[_this][_removeChild](result);
      }
      return result;
    }
    remove(object) {
      if (!dart.is(object, html$.Node)) return false;
      let node = dart.as(object, html$.Node);
      if (!core.identical(this[_this], node[dartx.parentNode])) return false;
      this[_this][_removeChild](node);
      return true;
    }
    [_filter$](test, removeMatching) {
      let child = this[_this][dartx.firstChild];
      while (child != null) {
        let nextChild = child[dartx.nextNode];
        if (test(child) == removeMatching) {
          this[_this][_removeChild](child);
        }
        child = nextChild;
      }
    }
    removeWhere(test) {
      this[_filter$](test, true);
    }
    retainWhere(test) {
      this[_filter$](test, false);
    }
    clear() {
      this[_this][_clearChildren]();
    }
    set(index, value) {
      this[_this][_replaceChild](value, this.get(index));
      return value;
    }
    get iterator() {
      return this[_this][dartx.childNodes][dartx.iterator];
    }
    sort(compare) {
      if (compare === void 0) compare = null;
      dart.throw(new core.UnsupportedError("Cannot sort Node list"));
    }
    shuffle(random) {
      if (random === void 0) random = null;
      dart.throw(new core.UnsupportedError("Cannot shuffle Node list"));
    }
    setRange(start, end, iterable, skipCount) {
      if (skipCount === void 0) skipCount = 0;
      dart.throw(new core.UnsupportedError("Cannot setRange on Node list"));
    }
    fillRange(start, end, fill) {
      if (fill === void 0) fill = null;
      dart.throw(new core.UnsupportedError("Cannot fillRange on Node list"));
    }
    get length() {
      return this[_this][dartx.childNodes][dartx.length];
    }
    set length(value) {
      dart.throw(new core.UnsupportedError("Cannot set length on immutable List."));
    }
    get(index) {
      return this[_this][dartx.childNodes][dartx.get](index);
    }
    get rawList() {
      return this[_this][dartx.childNodes];
    }
  };
  html$._ChildNodeListLazy[dart.implements] = () => [html_common.NodeListWrapper];
  dart.setSignature(html$._ChildNodeListLazy, {
    constructors: () => ({_ChildNodeListLazy: [html$._ChildNodeListLazy, [html$.Node]]}),
    methods: () => ({
      add: [dart.void, [html$.Node]],
      addAll: [dart.void, [core.Iterable$(html$.Node)]],
      insert: [dart.void, [core.int, html$.Node]],
      insertAll: [dart.void, [core.int, core.Iterable$(html$.Node)]],
      setAll: [dart.void, [core.int, core.Iterable$(html$.Node)]],
      removeLast: [html$.Node, []],
      removeAt: [html$.Node, [core.int]],
      [_filter$]: [dart.void, [dart.functionType(core.bool, [html$.Node]), core.bool]],
      removeWhere: [dart.void, [dart.functionType(core.bool, [html$.Node])]],
      retainWhere: [dart.void, [dart.functionType(core.bool, [html$.Node])]],
      set: [dart.void, [core.int, html$.Node]],
      sort: [dart.void, [], [core.Comparator$(html$.Node)]],
      setRange: [dart.void, [core.int, core.int, core.Iterable$(html$.Node)], [core.int]],
      fillRange: [dart.void, [core.int, core.int], [html$.Node]],
      get: [html$.Node, [core.int]]
    })
  });
  dart.defineExtensionMembers(html$._ChildNodeListLazy, [
    'add',
    'addAll',
    'insert',
    'insertAll',
    'setAll',
    'removeLast',
    'removeAt',
    'remove',
    'removeWhere',
    'retainWhere',
    'clear',
    'set',
    'sort',
    'shuffle',
    'setRange',
    'fillRange',
    'get',
    'first',
    'last',
    'single',
    'iterator',
    'length',
    'length'
  ]);
  html$.NodeFilter = class NodeFilter extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$.NodeFilter, {
    constructors: () => ({_: [html$.NodeFilter, []]})
  });
  html$.NodeFilter[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('NodeFilter')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("NodeFilter"))];
  html$.NodeFilter.FILTER_ACCEPT = 1;
  html$.NodeFilter.FILTER_REJECT = 2;
  html$.NodeFilter.FILTER_SKIP = 3;
  html$.NodeFilter.SHOW_ALL = 4294967295;
  html$.NodeFilter.SHOW_COMMENT = 128;
  html$.NodeFilter.SHOW_DOCUMENT = 256;
  html$.NodeFilter.SHOW_DOCUMENT_FRAGMENT = 1024;
  html$.NodeFilter.SHOW_DOCUMENT_TYPE = 512;
  html$.NodeFilter.SHOW_ELEMENT = 1;
  html$.NodeFilter.SHOW_PROCESSING_INSTRUCTION = 64;
  html$.NodeFilter.SHOW_TEXT = 4;
  dart.registerExtension(dart.global.NodeFilter, html$.NodeFilter);
  dart.defineExtensionNames([
    'detach',
    'nextNode',
    'previousNode',
    'pointerBeforeReferenceNode',
    'referenceNode',
    'root',
    'whatToShow'
  ]);
  html$.NodeIterator = class NodeIterator extends _interceptors.Interceptor {
    static new(root, whatToShow) {
      return html$.document[_createNodeIterator](root, whatToShow, null);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.pointerBeforeReferenceNode]() {
      return this.pointerBeforeReferenceNode;
    }
    get [dartx.referenceNode]() {
      return this.referenceNode;
    }
    get [dartx.root]() {
      return this.root;
    }
    get [dartx.whatToShow]() {
      return this.whatToShow;
    }
    [dartx.detach]() {
      return this.detach();
    }
    [dartx.nextNode]() {
      return this.nextNode();
    }
    [dartx.previousNode]() {
      return this.previousNode();
    }
  };
  dart.setSignature(html$.NodeIterator, {
    constructors: () => ({
      new: [html$.NodeIterator, [html$.Node, core.int]],
      _: [html$.NodeIterator, []]
    }),
    methods: () => ({
      [dartx.detach]: [dart.void, []],
      [dartx.nextNode]: [html$.Node, []],
      [dartx.previousNode]: [html$.Node, []]
    })
  });
  html$.NodeIterator[dart.metadata] = () => [dart.const(new _metadata.DomName('NodeIterator')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("NodeIterator"))];
  dart.registerExtension(dart.global.NodeIterator, html$.NodeIterator);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt'
  ]);
  html$.NodeList = class NodeList extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(html$.Node), html$.ImmutableListMixin$(html$.Node)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return this[index];
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return this[0];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return this[dart.notNull(len) - 1];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return this[0];
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [_item](index) {
      return this.item(index);
    }
  };
  html$.NodeList[dart.implements] = () => [_js_helper.JavaScriptIndexingBehavior, core.List$(html$.Node)];
  dart.setSignature(html$.NodeList, {
    constructors: () => ({_: [html$.NodeList, []]}),
    methods: () => ({
      [dartx.get]: [html$.Node, [core.int]],
      [dartx.set]: [dart.void, [core.int, html$.Node]],
      [dartx.elementAt]: [html$.Node, [core.int]],
      [_item]: [html$.Node, [core.int]]
    })
  });
  html$.NodeList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('NodeList')), dart.const(new _js_helper.Native("NodeList,RadioNodeList"))];
  dart.registerExtension(dart.global.NodeList, html$.NodeList);
  dart.defineExtensionNames([
    'nextElementSibling',
    'previousElementSibling'
  ]);
  html$.NonDocumentTypeChildNode = class NonDocumentTypeChildNode extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.nextElementSibling]() {
      return this.nextElementSibling;
    }
    get [dartx.previousElementSibling]() {
      return this.previousElementSibling;
    }
  };
  dart.setSignature(html$.NonDocumentTypeChildNode, {
    constructors: () => ({_: [html$.NonDocumentTypeChildNode, []]})
  });
  html$.NonDocumentTypeChildNode[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('NonDocumentTypeChildNode')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("NonDocumentTypeChildNode"))];
  dart.registerExtension(dart.global.NonDocumentTypeChildNode, html$.NonDocumentTypeChildNode);
  dart.defineExtensionNames([
    'getElementById'
  ]);
  html$.NonElementParentNode = class NonElementParentNode extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.getElementById](elementId) {
      return this.getElementById(elementId);
    }
  };
  dart.setSignature(html$.NonElementParentNode, {
    constructors: () => ({_: [html$.NonElementParentNode, []]}),
    methods: () => ({[dartx.getElementById]: [html$.Element, [core.String]]})
  });
  html$.NonElementParentNode[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('NonElementParentNode')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("NonElementParentNode"))];
  dart.registerExtension(dart.global.NonElementParentNode, html$.NonElementParentNode);
  dart.defineExtensionNames([
    'close',
    'onClick',
    'onClose',
    'onError',
    'onShow',
    'body',
    'data',
    'dir',
    'icon',
    'lang',
    'permission',
    'silent',
    'tag',
    'title',
    'vibrate'
  ]);
  html$.Notification = class Notification extends html$.EventTarget {
    static new(title, opts) {
      let dir = opts && 'dir' in opts ? opts.dir : null;
      let body = opts && 'body' in opts ? opts.body : null;
      let lang = opts && 'lang' in opts ? opts.lang : null;
      let tag = opts && 'tag' in opts ? opts.tag : null;
      let icon = opts && 'icon' in opts ? opts.icon : null;
      let parsedOptions = dart.map();
      if (dir != null) parsedOptions[dartx.set]('dir', dir);
      if (body != null) parsedOptions[dartx.set]('body', body);
      if (lang != null) parsedOptions[dartx.set]('lang', lang);
      if (tag != null) parsedOptions[dartx.set]('tag', tag);
      if (icon != null) parsedOptions[dartx.set]('icon', icon);
      return html$.Notification._factoryNotification(title, parsedOptions);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static _factoryNotification(title, options) {
      if (options === void 0) options = null;
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        return html$.Notification._create_1(title, options_1);
      }
      return html$.Notification._create_2(title);
    }
    static _create_1(title, options) {
      return new Notification(title, options);
    }
    static _create_2(title) {
      return new Notification(title);
    }
    static get supported() {
      return !!window.Notification;
    }
    get [dartx.body]() {
      return this.body;
    }
    get [dartx.data]() {
      return this.data;
    }
    get [dartx.dir]() {
      return this.dir;
    }
    get [dartx.icon]() {
      return this.icon;
    }
    get [dartx.lang]() {
      return this.lang;
    }
    get [dartx.permission]() {
      return this.permission;
    }
    get [dartx.silent]() {
      return this.silent;
    }
    get [dartx.tag]() {
      return this.tag;
    }
    get [dartx.title]() {
      return this.title;
    }
    get [dartx.vibrate]() {
      return this.vibrate;
    }
    [dartx.close]() {
      return this.close();
    }
    static requestPermission() {
      let completer = async.Completer$(core.String).new();
      html$.Notification._requestPermission(dart.fn(value => {
        completer.complete(value);
      }, dart.void, [core.String]));
      return completer.future;
    }
    get [dartx.onClick]() {
      return html$.Notification.clickEvent.forTarget(this);
    }
    get [dartx.onClose]() {
      return html$.Notification.closeEvent.forTarget(this);
    }
    get [dartx.onError]() {
      return html$.Notification.errorEvent.forTarget(this);
    }
    get [dartx.onShow]() {
      return html$.Notification.showEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.Notification, {
    constructors: () => ({
      new: [html$.Notification, [core.String], {dir: core.String, body: core.String, lang: core.String, tag: core.String, icon: core.String}],
      _: [html$.Notification, []]
    }),
    methods: () => ({[dartx.close]: [dart.void, []]}),
    statics: () => ({
      _factoryNotification: [html$.Notification, [core.String], [core.Map]],
      _create_1: [html$.Notification, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.Notification, [dart.dynamic]],
      _requestPermission: [dart.void, [], [html$._NotificationPermissionCallback]],
      requestPermission: [async.Future$(core.String), []]
    }),
    names: ['_factoryNotification', '_create_1', '_create_2', '_requestPermission', 'requestPermission']
  });
  html$.Notification[dart.metadata] = () => [dart.const(new _metadata.DomName('Notification')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("Notification"))];
  dart.defineLazy(html$.Notification, {
    get clickEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('click'));
    },
    get closeEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('close'));
    },
    get errorEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('error'));
    },
    get showEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('show'));
    }
  });
  dart.registerExtension(dart.global.Notification, html$.Notification);
  dart.defineExtensionNames([
    'notification'
  ]);
  html$.NotificationEvent = class NotificationEvent extends html$.ExtendableEvent {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.NotificationEvent._create_1(type, eventInitDict_1);
      }
      return html$.NotificationEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new NotificationEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new NotificationEvent(type);
    }
    get [dartx.notification]() {
      return this.notification;
    }
  };
  dart.setSignature(html$.NotificationEvent, {
    constructors: () => ({
      _: [html$.NotificationEvent, []],
      new: [html$.NotificationEvent, [core.String], [core.Map]]
    }),
    statics: () => ({
      _create_1: [html$.NotificationEvent, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.NotificationEvent, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.NotificationEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('NotificationEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("NotificationEvent"))];
  dart.registerExtension(dart.global.NotificationEvent, html$.NotificationEvent);
  html$._NotificationPermissionCallback = dart.typedef('_NotificationPermissionCallback', () => dart.functionType(dart.void, [core.String]));
  dart.defineExtensionNames([
    'reversed',
    'start',
    'type'
  ]);
  html$.OListElement = class OListElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("ol"), html$.OListElement);
    }
    created() {
      this[dartx.reversed] = null;
      this[dartx.start] = null;
      this[dartx.type] = null;
      super.created();
    }
    get [dartx.reversed]() {
      return this.reversed;
    }
    set [dartx.reversed](value) {
      this.reversed = value;
    }
    get [dartx.start]() {
      return this.start;
    }
    set [dartx.start](value) {
      this.start = value;
    }
    get [dartx.type]() {
      return this.type;
    }
    set [dartx.type](value) {
      this.type = value;
    }
  };
  dart.defineNamedConstructor(html$.OListElement, 'created');
  dart.setSignature(html$.OListElement, {
    constructors: () => ({
      _: [html$.OListElement, []],
      new: [html$.OListElement, []],
      created: [html$.OListElement, []]
    })
  });
  html$.OListElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLOListElement')), dart.const(new _js_helper.Native("HTMLOListElement"))];
  dart.registerExtension(dart.global.HTMLOListElement, html$.OListElement);
  dart.defineExtensionNames([
    'checkValidity',
    'reportValidity',
    'setCustomValidity',
    'data',
    'form',
    'height',
    'name',
    'type',
    'useMap',
    'validationMessage',
    'validity',
    'width',
    'willValidate'
  ]);
  html$.ObjectElement = class ObjectElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("object"), html$.ObjectElement);
    }
    created() {
      this[dartx.data] = null;
      this[dartx.form] = null;
      this[dartx.height] = null;
      this[dartx.name] = null;
      this[dartx.type] = null;
      this[dartx.useMap] = null;
      this[dartx.validationMessage] = null;
      this[dartx.validity] = null;
      this[dartx.width] = null;
      this[dartx.willValidate] = null;
      super.created();
    }
    static get supported() {
      return html$.Element.isTagSupported('object');
    }
    get [dartx.data]() {
      return this.data;
    }
    set [dartx.data](value) {
      this.data = value;
    }
    get [dartx.form]() {
      return this.form;
    }
    get [dartx.height]() {
      return this.height;
    }
    set [dartx.height](value) {
      this.height = value;
    }
    get [dartx.name]() {
      return this.name;
    }
    set [dartx.name](value) {
      this.name = value;
    }
    get [dartx.type]() {
      return this.type;
    }
    set [dartx.type](value) {
      this.type = value;
    }
    get [dartx.useMap]() {
      return this.useMap;
    }
    set [dartx.useMap](value) {
      this.useMap = value;
    }
    get [dartx.validationMessage]() {
      return this.validationMessage;
    }
    get [dartx.validity]() {
      return this.validity;
    }
    get [dartx.width]() {
      return this.width;
    }
    set [dartx.width](value) {
      this.width = value;
    }
    get [dartx.willValidate]() {
      return this.willValidate;
    }
    [__getter__](index_OR_name) {
      return this.__getter__(index_OR_name);
    }
    [__setter__](index_OR_name, value) {
      return this.__setter__(index_OR_name, value);
    }
    [dartx.checkValidity]() {
      return this.checkValidity();
    }
    [dartx.reportValidity]() {
      return this.reportValidity();
    }
    [dartx.setCustomValidity](error) {
      return this.setCustomValidity(error);
    }
  };
  dart.defineNamedConstructor(html$.ObjectElement, 'created');
  dart.setSignature(html$.ObjectElement, {
    constructors: () => ({
      _: [html$.ObjectElement, []],
      new: [html$.ObjectElement, []],
      created: [html$.ObjectElement, []]
    }),
    methods: () => ({
      [__getter__]: [core.bool, [dart.dynamic]],
      [__setter__]: [dart.void, [dart.dynamic, html$.Node]],
      [dartx.checkValidity]: [core.bool, []],
      [dartx.reportValidity]: [core.bool, []],
      [dartx.setCustomValidity]: [dart.void, [core.String]]
    })
  });
  html$.ObjectElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLObjectElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("HTMLObjectElement"))];
  dart.registerExtension(dart.global.HTMLObjectElement, html$.ObjectElement);
  dart.defineExtensionNames([
    'disabled',
    'label'
  ]);
  html$.OptGroupElement = class OptGroupElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("optgroup"), html$.OptGroupElement);
    }
    created() {
      this[dartx.disabled] = null;
      this[dartx.label] = null;
      super.created();
    }
    get [dartx.disabled]() {
      return this.disabled;
    }
    set [dartx.disabled](value) {
      this.disabled = value;
    }
    get [dartx.label]() {
      return this.label;
    }
    set [dartx.label](value) {
      this.label = value;
    }
  };
  dart.defineNamedConstructor(html$.OptGroupElement, 'created');
  dart.setSignature(html$.OptGroupElement, {
    constructors: () => ({
      _: [html$.OptGroupElement, []],
      new: [html$.OptGroupElement, []],
      created: [html$.OptGroupElement, []]
    })
  });
  html$.OptGroupElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLOptGroupElement')), dart.const(new _js_helper.Native("HTMLOptGroupElement"))];
  dart.registerExtension(dart.global.HTMLOptGroupElement, html$.OptGroupElement);
  dart.defineExtensionNames([
    'defaultSelected',
    'disabled',
    'form',
    'index',
    'label',
    'selected',
    'value'
  ]);
  html$.OptionElement = class OptionElement extends html$.HtmlElement {
    static new(opts) {
      let data = opts && 'data' in opts ? opts.data : '';
      let value = opts && 'value' in opts ? opts.value : '';
      let selected = opts && 'selected' in opts ? opts.selected : false;
      return html$.OptionElement._(data, value, null, selected);
    }
    static _(data, value, defaultSelected, selected) {
      if (data === void 0) data = null;
      if (value === void 0) value = null;
      if (defaultSelected === void 0) defaultSelected = null;
      if (selected === void 0) selected = null;
      if (selected != null) {
        return html$.OptionElement._create_1(data, value, defaultSelected, selected);
      }
      if (defaultSelected != null) {
        return html$.OptionElement._create_2(data, value, defaultSelected);
      }
      if (value != null) {
        return html$.OptionElement._create_3(data, value);
      }
      if (data != null) {
        return html$.OptionElement._create_4(data);
      }
      return html$.OptionElement._create_5();
    }
    static _create_1(data, value, defaultSelected, selected) {
      return new Option(data, value, defaultSelected, selected);
    }
    static _create_2(data, value, defaultSelected) {
      return new Option(data, value, defaultSelected);
    }
    static _create_3(data, value) {
      return new Option(data, value);
    }
    static _create_4(data) {
      return new Option(data);
    }
    static _create_5() {
      return new Option();
    }
    created() {
      this[dartx.defaultSelected] = null;
      this[dartx.disabled] = null;
      this[dartx.form] = null;
      this[dartx.index] = null;
      this[dartx.label] = null;
      this[dartx.selected] = null;
      this[dartx.value] = null;
      super.created();
    }
    get [dartx.defaultSelected]() {
      return this.defaultSelected;
    }
    set [dartx.defaultSelected](value) {
      this.defaultSelected = value;
    }
    get [dartx.disabled]() {
      return this.disabled;
    }
    set [dartx.disabled](value) {
      this.disabled = value;
    }
    get [dartx.form]() {
      return this.form;
    }
    get [dartx.index]() {
      return this.index;
    }
    get [dartx.label]() {
      return this.label;
    }
    set [dartx.label](value) {
      this.label = value;
    }
    get [dartx.selected]() {
      return this.selected;
    }
    set [dartx.selected](value) {
      this.selected = value;
    }
    get [dartx.value]() {
      return this.value;
    }
    set [dartx.value](value) {
      this.value = value;
    }
  };
  dart.defineNamedConstructor(html$.OptionElement, 'created');
  dart.setSignature(html$.OptionElement, {
    constructors: () => ({
      new: [html$.OptionElement, [], {data: core.String, value: core.String, selected: core.bool}],
      _: [html$.OptionElement, [], [core.String, core.String, core.bool, core.bool]],
      created: [html$.OptionElement, []]
    }),
    statics: () => ({
      _create_1: [html$.OptionElement, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]],
      _create_2: [html$.OptionElement, [dart.dynamic, dart.dynamic, dart.dynamic]],
      _create_3: [html$.OptionElement, [dart.dynamic, dart.dynamic]],
      _create_4: [html$.OptionElement, [dart.dynamic]],
      _create_5: [html$.OptionElement, []]
    }),
    names: ['_create_1', '_create_2', '_create_3', '_create_4', '_create_5']
  });
  html$.OptionElement[dart.metadata] = () => [dart.const(new _metadata.DomName('HTMLOptionElement')), dart.const(new _js_helper.Native("HTMLOptionElement"))];
  dart.registerExtension(dart.global.HTMLOptionElement, html$.OptionElement);
  dart.defineExtensionNames([
    'checkValidity',
    'reportValidity',
    'setCustomValidity',
    'defaultValue',
    'form',
    'htmlFor',
    'labels',
    'name',
    'type',
    'validationMessage',
    'validity',
    'value',
    'willValidate'
  ]);
  html$.OutputElement = class OutputElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("output"), html$.OutputElement);
    }
    created() {
      this[dartx.defaultValue] = null;
      this[dartx.form] = null;
      this[dartx.htmlFor] = null;
      this[dartx.labels] = null;
      this[dartx.name] = null;
      this[dartx.type] = null;
      this[dartx.validationMessage] = null;
      this[dartx.validity] = null;
      this[dartx.value] = null;
      this[dartx.willValidate] = null;
      super.created();
    }
    static get supported() {
      return html$.Element.isTagSupported('output');
    }
    get [dartx.defaultValue]() {
      return this.defaultValue;
    }
    set [dartx.defaultValue](value) {
      this.defaultValue = value;
    }
    get [dartx.form]() {
      return this.form;
    }
    get [dartx.htmlFor]() {
      return this.htmlFor;
    }
    get [dartx.labels]() {
      return this.labels;
    }
    get [dartx.name]() {
      return this.name;
    }
    set [dartx.name](value) {
      this.name = value;
    }
    get [dartx.type]() {
      return this.type;
    }
    get [dartx.validationMessage]() {
      return this.validationMessage;
    }
    get [dartx.validity]() {
      return this.validity;
    }
    get [dartx.value]() {
      return this.value;
    }
    set [dartx.value](value) {
      this.value = value;
    }
    get [dartx.willValidate]() {
      return this.willValidate;
    }
    [dartx.checkValidity]() {
      return this.checkValidity();
    }
    [dartx.reportValidity]() {
      return this.reportValidity();
    }
    [dartx.setCustomValidity](error) {
      return this.setCustomValidity(error);
    }
  };
  dart.defineNamedConstructor(html$.OutputElement, 'created');
  dart.setSignature(html$.OutputElement, {
    constructors: () => ({
      _: [html$.OutputElement, []],
      new: [html$.OutputElement, []],
      created: [html$.OutputElement, []]
    }),
    methods: () => ({
      [dartx.checkValidity]: [core.bool, []],
      [dartx.reportValidity]: [core.bool, []],
      [dartx.setCustomValidity]: [dart.void, [core.String]]
    })
  });
  html$.OutputElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLOutputElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _js_helper.Native("HTMLOutputElement"))];
  dart.registerExtension(dart.global.HTMLOutputElement, html$.OutputElement);
  dart.defineExtensionNames([
    'persisted'
  ]);
  html$.PageTransitionEvent = class PageTransitionEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.PageTransitionEvent._create_1(type, eventInitDict_1);
      }
      return html$.PageTransitionEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new PageTransitionEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new PageTransitionEvent(type);
    }
    get [dartx.persisted]() {
      return this.persisted;
    }
  };
  dart.setSignature(html$.PageTransitionEvent, {
    constructors: () => ({
      _: [html$.PageTransitionEvent, []],
      new: [html$.PageTransitionEvent, [core.String], [core.Map]]
    }),
    statics: () => ({
      _create_1: [html$.PageTransitionEvent, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.PageTransitionEvent, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.PageTransitionEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('PageTransitionEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("PageTransitionEvent"))];
  dart.registerExtension(dart.global.PageTransitionEvent, html$.PageTransitionEvent);
  html$.ParagraphElement = class ParagraphElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("p"), html$.ParagraphElement);
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(html$.ParagraphElement, 'created');
  dart.setSignature(html$.ParagraphElement, {
    constructors: () => ({
      _: [html$.ParagraphElement, []],
      new: [html$.ParagraphElement, []],
      created: [html$.ParagraphElement, []]
    })
  });
  html$.ParagraphElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLParagraphElement')), dart.const(new _js_helper.Native("HTMLParagraphElement"))];
  dart.registerExtension(dart.global.HTMLParagraphElement, html$.ParagraphElement);
  dart.defineExtensionNames([
    'name',
    'value'
  ]);
  html$.ParamElement = class ParamElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("param"), html$.ParamElement);
    }
    created() {
      this[dartx.name] = null;
      this[dartx.value] = null;
      super.created();
    }
    get [dartx.name]() {
      return this.name;
    }
    set [dartx.name](value) {
      this.name = value;
    }
    get [dartx.value]() {
      return this.value;
    }
    set [dartx.value](value) {
      this.value = value;
    }
  };
  dart.defineNamedConstructor(html$.ParamElement, 'created');
  dart.setSignature(html$.ParamElement, {
    constructors: () => ({
      _: [html$.ParamElement, []],
      new: [html$.ParamElement, []],
      created: [html$.ParamElement, []]
    })
  });
  html$.ParamElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLParamElement')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("HTMLParamElement"))];
  dart.registerExtension(dart.global.HTMLParamElement, html$.ParamElement);
  html$.ParentNode = class ParentNode extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$.ParentNode, {
    constructors: () => ({_: [html$.ParentNode, []]})
  });
  html$.ParentNode[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ParentNode')), dart.const(new _metadata.Experimental())];
  dart.defineExtensionNames([
    'formData',
    'password'
  ]);
  html$.PasswordCredential = class PasswordCredential extends html$.Credential {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(id, password, name, iconURL) {
      if (name === void 0) name = null;
      if (iconURL === void 0) iconURL = null;
      if (iconURL != null) {
        return html$.PasswordCredential._create_1(id, password, name, iconURL);
      }
      if (name != null) {
        return html$.PasswordCredential._create_2(id, password, name);
      }
      return html$.PasswordCredential._create_3(id, password);
    }
    static _create_1(id, password, name, iconURL) {
      return new PasswordCredential(id, password, name, iconURL);
    }
    static _create_2(id, password, name) {
      return new PasswordCredential(id, password, name);
    }
    static _create_3(id, password) {
      return new PasswordCredential(id, password);
    }
    get [dartx.formData]() {
      return this.formData;
    }
    get [dartx.password]() {
      return this.password;
    }
  };
  dart.setSignature(html$.PasswordCredential, {
    constructors: () => ({
      _: [html$.PasswordCredential, []],
      new: [html$.PasswordCredential, [core.String, core.String], [core.String, core.String]]
    }),
    statics: () => ({
      _create_1: [html$.PasswordCredential, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]],
      _create_2: [html$.PasswordCredential, [dart.dynamic, dart.dynamic, dart.dynamic]],
      _create_3: [html$.PasswordCredential, [dart.dynamic, dart.dynamic]]
    }),
    names: ['_create_1', '_create_2', '_create_3']
  });
  html$.PasswordCredential[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('PasswordCredential')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("PasswordCredential"))];
  dart.registerExtension(dart.global.PasswordCredential, html$.PasswordCredential);
  dart.defineExtensionNames([
    'addPath',
    'arc',
    'arcTo',
    'bezierCurveTo',
    'closePath',
    'ellipse',
    'lineTo',
    'moveTo',
    'quadraticCurveTo',
    'rect'
  ]);
  html$.Path2D = class Path2D extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(path_OR_text) {
      if (path_OR_text === void 0) path_OR_text = null;
      if (path_OR_text == null) {
        return html$.Path2D._create_1();
      }
      if (dart.is(path_OR_text, html$.Path2D) || path_OR_text == null) {
        return html$.Path2D._create_2(path_OR_text);
      }
      if (typeof path_OR_text == 'string' || path_OR_text == null) {
        return html$.Path2D._create_3(path_OR_text);
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    static _create_1() {
      return new Path2D();
    }
    static _create_2(path_OR_text) {
      return new Path2D(path_OR_text);
    }
    static _create_3(path_OR_text) {
      return new Path2D(path_OR_text);
    }
    [dartx.addPath](path, transform) {
      return this.addPath(path, transform);
    }
    [dartx.arc](x, y, radius, startAngle, endAngle, anticlockwise) {
      return this.arc(x, y, radius, startAngle, endAngle, anticlockwise);
    }
    [dartx.arcTo](x1, y1, x2, y2, radius) {
      return this.arcTo(x1, y1, x2, y2, radius);
    }
    [dartx.bezierCurveTo](cp1x, cp1y, cp2x, cp2y, x, y) {
      return this.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    }
    [dartx.closePath]() {
      return this.closePath();
    }
    [dartx.ellipse](x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {
      return this.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise);
    }
    [dartx.lineTo](x, y) {
      return this.lineTo(x, y);
    }
    [dartx.moveTo](x, y) {
      return this.moveTo(x, y);
    }
    [dartx.quadraticCurveTo](cpx, cpy, x, y) {
      return this.quadraticCurveTo(cpx, cpy, x, y);
    }
    [dartx.rect](x, y, width, height) {
      return this.rect(x, y, width, height);
    }
  };
  html$.Path2D[dart.implements] = () => [html$._CanvasPathMethods];
  dart.setSignature(html$.Path2D, {
    constructors: () => ({
      _: [html$.Path2D, []],
      new: [html$.Path2D, [], [dart.dynamic]]
    }),
    methods: () => ({
      [dartx.addPath]: [dart.void, [html$.Path2D], [svg$.Matrix]],
      [dartx.arc]: [dart.void, [core.num, core.num, core.num, core.num, core.num, core.bool]],
      [dartx.arcTo]: [dart.void, [core.num, core.num, core.num, core.num, core.num]],
      [dartx.bezierCurveTo]: [dart.void, [core.num, core.num, core.num, core.num, core.num, core.num]],
      [dartx.closePath]: [dart.void, []],
      [dartx.ellipse]: [dart.void, [core.num, core.num, core.num, core.num, core.num, core.num, core.num, core.bool]],
      [dartx.lineTo]: [dart.void, [core.num, core.num]],
      [dartx.moveTo]: [dart.void, [core.num, core.num]],
      [dartx.quadraticCurveTo]: [dart.void, [core.num, core.num, core.num, core.num]],
      [dartx.rect]: [dart.void, [core.num, core.num, core.num, core.num]]
    }),
    statics: () => ({
      _create_1: [html$.Path2D, []],
      _create_2: [html$.Path2D, [dart.dynamic]],
      _create_3: [html$.Path2D, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2', '_create_3']
  });
  html$.Path2D[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Path2D')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("Path2D"))];
  dart.registerExtension(dart.global.Path2D, html$.Path2D);
  dart.defineExtensionNames([
    'clearFrameTimings',
    'clearMarks',
    'clearMeasures',
    'getEntries',
    'getEntriesByName',
    'getEntriesByType',
    'mark',
    'measure',
    'now',
    'setFrameTimingBufferSize',
    'clearResourceTimings',
    'setResourceTimingBufferSize',
    'onResourceTimingBufferFull',
    'memory',
    'navigation',
    'timing'
  ]);
  html$.Performance = class Performance extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static get supported() {
      return !!window.performance;
    }
    get [dartx.memory]() {
      return this.memory;
    }
    get [dartx.navigation]() {
      return this.navigation;
    }
    get [dartx.timing]() {
      return this.timing;
    }
    [dartx.clearFrameTimings]() {
      return this.clearFrameTimings();
    }
    [dartx.clearMarks](markName) {
      return this.clearMarks(markName);
    }
    [dartx.clearMeasures](measureName) {
      return this.clearMeasures(measureName);
    }
    [dartx.getEntries]() {
      return this.getEntries();
    }
    [dartx.getEntriesByName](name, entryType) {
      return this.getEntriesByName(name, entryType);
    }
    [dartx.getEntriesByType](entryType) {
      return this.getEntriesByType(entryType);
    }
    [dartx.mark](markName) {
      return this.mark(markName);
    }
    [dartx.measure](measureName, startMark, endMark) {
      return this.measure(measureName, startMark, endMark);
    }
    [dartx.now]() {
      return this.now();
    }
    [dartx.setFrameTimingBufferSize](maxSize) {
      return this.setFrameTimingBufferSize(maxSize);
    }
    [dartx.clearResourceTimings]() {
      return this.webkitClearResourceTimings();
    }
    [dartx.setResourceTimingBufferSize](maxSize) {
      return this.webkitSetResourceTimingBufferSize(maxSize);
    }
    get [dartx.onResourceTimingBufferFull]() {
      return html$.Performance.resourceTimingBufferFullEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.Performance, {
    constructors: () => ({_: [html$.Performance, []]}),
    methods: () => ({
      [dartx.clearFrameTimings]: [dart.void, []],
      [dartx.clearMarks]: [dart.void, [core.String]],
      [dartx.clearMeasures]: [dart.void, [core.String]],
      [dartx.getEntries]: [core.List$(html$.PerformanceEntry), []],
      [dartx.getEntriesByName]: [core.List$(html$.PerformanceEntry), [core.String, core.String]],
      [dartx.getEntriesByType]: [core.List$(html$.PerformanceEntry), [core.String]],
      [dartx.mark]: [dart.void, [core.String]],
      [dartx.measure]: [dart.void, [core.String, core.String, core.String]],
      [dartx.now]: [core.double, []],
      [dartx.setFrameTimingBufferSize]: [dart.void, [core.int]],
      [dartx.clearResourceTimings]: [dart.void, []],
      [dartx.setResourceTimingBufferSize]: [dart.void, [core.int]]
    })
  });
  html$.Performance[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Performance')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE)), dart.const(new _js_helper.Native("Performance"))];
  dart.defineLazy(html$.Performance, {
    get resourceTimingBufferFullEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('webkitresourcetimingbufferfull'));
    }
  });
  dart.registerExtension(dart.global.Performance, html$.Performance);
  dart.defineExtensionNames([
    'duration',
    'entryType',
    'name',
    'startTime'
  ]);
  html$.PerformanceEntry = class PerformanceEntry extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.duration]() {
      return this.duration;
    }
    get [dartx.entryType]() {
      return this.entryType;
    }
    get [dartx.name]() {
      return this.name;
    }
    get [dartx.startTime]() {
      return this.startTime;
    }
  };
  dart.setSignature(html$.PerformanceEntry, {
    constructors: () => ({_: [html$.PerformanceEntry, []]})
  });
  html$.PerformanceEntry[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('PerformanceEntry')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("PerformanceEntry"))];
  dart.registerExtension(dart.global.PerformanceEntry, html$.PerformanceEntry);
  dart.defineExtensionNames([
    'sourceFrame'
  ]);
  html$.PerformanceCompositeTiming = class PerformanceCompositeTiming extends html$.PerformanceEntry {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.sourceFrame]() {
      return this.sourceFrame;
    }
  };
  dart.setSignature(html$.PerformanceCompositeTiming, {
    constructors: () => ({_: [html$.PerformanceCompositeTiming, []]})
  });
  html$.PerformanceCompositeTiming[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('PerformanceCompositeTiming')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("PerformanceCompositeTiming"))];
  dart.registerExtension(dart.global.PerformanceCompositeTiming, html$.PerformanceCompositeTiming);
  html$.PerformanceMark = class PerformanceMark extends html$.PerformanceEntry {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$.PerformanceMark, {
    constructors: () => ({_: [html$.PerformanceMark, []]})
  });
  html$.PerformanceMark[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('PerformanceMark')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("PerformanceMark"))];
  dart.registerExtension(dart.global.PerformanceMark, html$.PerformanceMark);
  html$.PerformanceMeasure = class PerformanceMeasure extends html$.PerformanceEntry {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$.PerformanceMeasure, {
    constructors: () => ({_: [html$.PerformanceMeasure, []]})
  });
  html$.PerformanceMeasure[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('PerformanceMeasure')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("PerformanceMeasure"))];
  dart.registerExtension(dart.global.PerformanceMeasure, html$.PerformanceMeasure);
  dart.defineExtensionNames([
    'redirectCount',
    'type'
  ]);
  html$.PerformanceNavigation = class PerformanceNavigation extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.redirectCount]() {
      return this.redirectCount;
    }
    get [dartx.type]() {
      return this.type;
    }
  };
  dart.setSignature(html$.PerformanceNavigation, {
    constructors: () => ({_: [html$.PerformanceNavigation, []]})
  });
  html$.PerformanceNavigation[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('PerformanceNavigation')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("PerformanceNavigation"))];
  html$.PerformanceNavigation.TYPE_BACK_FORWARD = 2;
  html$.PerformanceNavigation.TYPE_NAVIGATE = 0;
  html$.PerformanceNavigation.TYPE_RELOAD = 1;
  html$.PerformanceNavigation.TYPE_RESERVED = 255;
  dart.registerExtension(dart.global.PerformanceNavigation, html$.PerformanceNavigation);
  dart.defineExtensionNames([
    'sourceFrame'
  ]);
  html$.PerformanceRenderTiming = class PerformanceRenderTiming extends html$.PerformanceEntry {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.sourceFrame]() {
      return this.sourceFrame;
    }
  };
  dart.setSignature(html$.PerformanceRenderTiming, {
    constructors: () => ({_: [html$.PerformanceRenderTiming, []]})
  });
  html$.PerformanceRenderTiming[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('PerformanceRenderTiming')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("PerformanceRenderTiming"))];
  dart.registerExtension(dart.global.PerformanceRenderTiming, html$.PerformanceRenderTiming);
  dart.defineExtensionNames([
    'connectEnd',
    'connectStart',
    'domainLookupEnd',
    'domainLookupStart',
    'fetchStart',
    'initiatorType',
    'redirectEnd',
    'redirectStart',
    'requestStart',
    'responseEnd',
    'responseStart',
    'secureConnectionStart',
    'workerStart'
  ]);
  html$.PerformanceResourceTiming = class PerformanceResourceTiming extends html$.PerformanceEntry {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.connectEnd]() {
      return this.connectEnd;
    }
    get [dartx.connectStart]() {
      return this.connectStart;
    }
    get [dartx.domainLookupEnd]() {
      return this.domainLookupEnd;
    }
    get [dartx.domainLookupStart]() {
      return this.domainLookupStart;
    }
    get [dartx.fetchStart]() {
      return this.fetchStart;
    }
    get [dartx.initiatorType]() {
      return this.initiatorType;
    }
    get [dartx.redirectEnd]() {
      return this.redirectEnd;
    }
    get [dartx.redirectStart]() {
      return this.redirectStart;
    }
    get [dartx.requestStart]() {
      return this.requestStart;
    }
    get [dartx.responseEnd]() {
      return this.responseEnd;
    }
    get [dartx.responseStart]() {
      return this.responseStart;
    }
    get [dartx.secureConnectionStart]() {
      return this.secureConnectionStart;
    }
    get [dartx.workerStart]() {
      return this.workerStart;
    }
  };
  dart.setSignature(html$.PerformanceResourceTiming, {
    constructors: () => ({_: [html$.PerformanceResourceTiming, []]})
  });
  html$.PerformanceResourceTiming[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('PerformanceResourceTiming')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("PerformanceResourceTiming"))];
  dart.registerExtension(dart.global.PerformanceResourceTiming, html$.PerformanceResourceTiming);
  dart.defineExtensionNames([
    'connectEnd',
    'connectStart',
    'domComplete',
    'domContentLoadedEventEnd',
    'domContentLoadedEventStart',
    'domInteractive',
    'domLoading',
    'domainLookupEnd',
    'domainLookupStart',
    'fetchStart',
    'loadEventEnd',
    'loadEventStart',
    'navigationStart',
    'redirectEnd',
    'redirectStart',
    'requestStart',
    'responseEnd',
    'responseStart',
    'secureConnectionStart',
    'unloadEventEnd',
    'unloadEventStart'
  ]);
  html$.PerformanceTiming = class PerformanceTiming extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.connectEnd]() {
      return this.connectEnd;
    }
    get [dartx.connectStart]() {
      return this.connectStart;
    }
    get [dartx.domComplete]() {
      return this.domComplete;
    }
    get [dartx.domContentLoadedEventEnd]() {
      return this.domContentLoadedEventEnd;
    }
    get [dartx.domContentLoadedEventStart]() {
      return this.domContentLoadedEventStart;
    }
    get [dartx.domInteractive]() {
      return this.domInteractive;
    }
    get [dartx.domLoading]() {
      return this.domLoading;
    }
    get [dartx.domainLookupEnd]() {
      return this.domainLookupEnd;
    }
    get [dartx.domainLookupStart]() {
      return this.domainLookupStart;
    }
    get [dartx.fetchStart]() {
      return this.fetchStart;
    }
    get [dartx.loadEventEnd]() {
      return this.loadEventEnd;
    }
    get [dartx.loadEventStart]() {
      return this.loadEventStart;
    }
    get [dartx.navigationStart]() {
      return this.navigationStart;
    }
    get [dartx.redirectEnd]() {
      return this.redirectEnd;
    }
    get [dartx.redirectStart]() {
      return this.redirectStart;
    }
    get [dartx.requestStart]() {
      return this.requestStart;
    }
    get [dartx.responseEnd]() {
      return this.responseEnd;
    }
    get [dartx.responseStart]() {
      return this.responseStart;
    }
    get [dartx.secureConnectionStart]() {
      return this.secureConnectionStart;
    }
    get [dartx.unloadEventEnd]() {
      return this.unloadEventEnd;
    }
    get [dartx.unloadEventStart]() {
      return this.unloadEventStart;
    }
  };
  dart.setSignature(html$.PerformanceTiming, {
    constructors: () => ({_: [html$.PerformanceTiming, []]})
  });
  html$.PerformanceTiming[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('PerformanceTiming')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("PerformanceTiming"))];
  dart.registerExtension(dart.global.PerformanceTiming, html$.PerformanceTiming);
  dart.defineExtensionNames([
    'registration'
  ]);
  html$.PeriodicSyncEvent = class PeriodicSyncEvent extends html$.ExtendableEvent {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, init) {
      let init_1 = html_common.convertDartToNative_Dictionary(init);
      return html$.PeriodicSyncEvent._create_1(type, init_1);
    }
    static _create_1(type, init) {
      return new PeriodicSyncEvent(type, init);
    }
    get [dartx.registration]() {
      return this.registration;
    }
  };
  dart.setSignature(html$.PeriodicSyncEvent, {
    constructors: () => ({
      _: [html$.PeriodicSyncEvent, []],
      new: [html$.PeriodicSyncEvent, [core.String, core.Map]]
    }),
    statics: () => ({_create_1: [html$.PeriodicSyncEvent, [dart.dynamic, dart.dynamic]]}),
    names: ['_create_1']
  });
  html$.PeriodicSyncEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('PeriodicSyncEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("PeriodicSyncEvent"))];
  dart.registerExtension(dart.global.PeriodicSyncEvent, html$.PeriodicSyncEvent);
  const _register_1 = Symbol('_register_1');
  const _register_2 = Symbol('_register_2');
  dart.defineExtensionNames([
    'getRegistration',
    'getRegistrations',
    'permissionState',
    'register',
    'minPossiblePeriod'
  ]);
  html$.PeriodicSyncManager = class PeriodicSyncManager extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.minPossiblePeriod]() {
      return this.minPossiblePeriod;
    }
    [dartx.getRegistration](tag) {
      return this.getRegistration(tag);
    }
    [dartx.getRegistrations]() {
      return this.getRegistrations();
    }
    [dartx.permissionState]() {
      return this.permissionState();
    }
    [dartx.register](options) {
      if (options === void 0) options = null;
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        return this[_register_1](options_1);
      }
      return this[_register_2]();
    }
    [_register_1](options) {
      return this.register(options);
    }
    [_register_2]() {
      return this.register();
    }
  };
  dart.setSignature(html$.PeriodicSyncManager, {
    constructors: () => ({_: [html$.PeriodicSyncManager, []]}),
    methods: () => ({
      [dartx.getRegistration]: [async.Future, [core.String]],
      [dartx.getRegistrations]: [async.Future, []],
      [dartx.permissionState]: [async.Future, []],
      [dartx.register]: [async.Future, [], [core.Map]],
      [_register_1]: [async.Future, [dart.dynamic]],
      [_register_2]: [async.Future, []]
    })
  });
  html$.PeriodicSyncManager[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('PeriodicSyncManager')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("PeriodicSyncManager"))];
  dart.registerExtension(dart.global.PeriodicSyncManager, html$.PeriodicSyncManager);
  dart.defineExtensionNames([
    'unregister',
    'minPeriod',
    'networkState',
    'powerState',
    'tag'
  ]);
  html$.PeriodicSyncRegistration = class PeriodicSyncRegistration extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.minPeriod]() {
      return this.minPeriod;
    }
    get [dartx.networkState]() {
      return this.networkState;
    }
    get [dartx.powerState]() {
      return this.powerState;
    }
    get [dartx.tag]() {
      return this.tag;
    }
    [dartx.unregister]() {
      return this.unregister();
    }
  };
  dart.setSignature(html$.PeriodicSyncRegistration, {
    constructors: () => ({_: [html$.PeriodicSyncRegistration, []]}),
    methods: () => ({[dartx.unregister]: [async.Future, []]})
  });
  html$.PeriodicSyncRegistration[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('PeriodicSyncRegistration')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("PeriodicSyncRegistration"))];
  dart.registerExtension(dart.global.PeriodicSyncRegistration, html$.PeriodicSyncRegistration);
  dart.defineExtensionNames([
    'onChange',
    'state',
    'status'
  ]);
  html$.PermissionStatus = class PermissionStatus extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.state]() {
      return this.state;
    }
    get [dartx.status]() {
      return this.status;
    }
    get [dartx.onChange]() {
      return html$.PermissionStatus.changeEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.PermissionStatus, {
    constructors: () => ({_: [html$.PermissionStatus, []]})
  });
  html$.PermissionStatus[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('PermissionStatus')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("PermissionStatus"))];
  dart.defineLazy(html$.PermissionStatus, {
    get changeEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('change'));
    }
  });
  dart.registerExtension(dart.global.PermissionStatus, html$.PermissionStatus);
  dart.defineExtensionNames([
    'query'
  ]);
  html$.Permissions = class Permissions extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.query](permission) {
      return this.query(permission);
    }
  };
  dart.setSignature(html$.Permissions, {
    constructors: () => ({_: [html$.Permissions, []]}),
    methods: () => ({[dartx.query]: [async.Future, [core.Object]]})
  });
  html$.Permissions[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Permissions')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("Permissions"))];
  dart.registerExtension(dart.global.Permissions, html$.Permissions);
  html$.PictureElement = class PictureElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(html$.PictureElement, 'created');
  dart.setSignature(html$.PictureElement, {
    constructors: () => ({
      _: [html$.PictureElement, []],
      created: [html$.PictureElement, []]
    })
  });
  html$.PictureElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLPictureElement')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("HTMLPictureElement"))];
  dart.registerExtension(dart.global.HTMLPictureElement, html$.PictureElement);
  dart.defineExtensionNames([
    'item',
    'namedItem',
    'description',
    'filename',
    'length',
    'name'
  ]);
  html$.Plugin = class Plugin extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.description]() {
      return this.description;
    }
    get [dartx.filename]() {
      return this.filename;
    }
    get [dartx.length]() {
      return this.length;
    }
    get [dartx.name]() {
      return this.name;
    }
    [dartx.item](index) {
      return this.item(index);
    }
    [dartx.namedItem](name) {
      return this.namedItem(name);
    }
  };
  dart.setSignature(html$.Plugin, {
    constructors: () => ({_: [html$.Plugin, []]}),
    methods: () => ({
      [dartx.item]: [html$.MimeType, [core.int]],
      [dartx.namedItem]: [html$.MimeType, [core.String]]
    })
  });
  html$.Plugin[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Plugin')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("Plugin"))];
  dart.registerExtension(dart.global.Plugin, html$.Plugin);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'item',
    'namedItem',
    'refresh'
  ]);
  html$.PluginArray = class PluginArray extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(html$.Plugin), html$.ImmutableListMixin$(html$.Plugin)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return this[index];
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return this[0];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return this[dart.notNull(len) - 1];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return this[0];
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [dartx.item](index) {
      return this.item(index);
    }
    [dartx.namedItem](name) {
      return this.namedItem(name);
    }
    [dartx.refresh](reload) {
      return this.refresh(reload);
    }
  };
  html$.PluginArray[dart.implements] = () => [_js_helper.JavaScriptIndexingBehavior, core.List$(html$.Plugin)];
  dart.setSignature(html$.PluginArray, {
    constructors: () => ({_: [html$.PluginArray, []]}),
    methods: () => ({
      [dartx.get]: [html$.Plugin, [core.int]],
      [dartx.set]: [dart.void, [core.int, html$.Plugin]],
      [dartx.elementAt]: [html$.Plugin, [core.int]],
      [dartx.item]: [html$.Plugin, [core.int]],
      [dartx.namedItem]: [html$.Plugin, [core.String]],
      [dartx.refresh]: [dart.void, [core.bool]]
    })
  });
  html$.PluginArray[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('PluginArray')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("PluginArray"))];
  dart.registerExtension(dart.global.PluginArray, html$.PluginArray);
  dart.defineExtensionNames([
    'createdCallback',
    'closeable',
    'message'
  ]);
  html$.PluginPlaceholderElement = class PluginPlaceholderElement extends html$.DivElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      this[dartx.closeable] = null;
      this[dartx.message] = null;
      super.created();
    }
    get [dartx.closeable]() {
      return this.closeable;
    }
    set [dartx.closeable](value) {
      this.closeable = value;
    }
    get [dartx.message]() {
      return this.message;
    }
    set [dartx.message](value) {
      this.message = value;
    }
    [dartx.createdCallback]() {
      return this.createdCallback();
    }
  };
  dart.defineNamedConstructor(html$.PluginPlaceholderElement, 'created');
  dart.setSignature(html$.PluginPlaceholderElement, {
    constructors: () => ({
      _: [html$.PluginPlaceholderElement, []],
      created: [html$.PluginPlaceholderElement, []]
    }),
    methods: () => ({[dartx.createdCallback]: [dart.void, []]})
  });
  html$.PluginPlaceholderElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('PluginPlaceholderElement')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("PluginPlaceholderElement"))];
  dart.registerExtension(dart.global.PluginPlaceholderElement, html$.PluginPlaceholderElement);
  dart.defineExtensionNames([
    'height',
    'isPrimary',
    'pointerId',
    'pointerType',
    'pressure',
    'tiltX',
    'tiltY',
    'width'
  ]);
  html$.PointerEvent = class PointerEvent extends html$.MouseEvent {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.PointerEvent._create_1(type, eventInitDict_1);
      }
      return html$.PointerEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new PointerEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new PointerEvent(type);
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.isPrimary]() {
      return this.isPrimary;
    }
    get [dartx.pointerId]() {
      return this.pointerId;
    }
    get [dartx.pointerType]() {
      return this.pointerType;
    }
    get [dartx.pressure]() {
      return this.pressure;
    }
    get [dartx.tiltX]() {
      return this.tiltX;
    }
    get [dartx.tiltY]() {
      return this.tiltY;
    }
    get [dartx.width]() {
      return this.width;
    }
  };
  dart.setSignature(html$.PointerEvent, {
    constructors: () => ({
      _: [html$.PointerEvent, []],
      new: [html$.PointerEvent, [core.String], [core.Map]]
    }),
    statics: () => ({
      _create_1: [html$.PointerEvent, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.PointerEvent, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.PointerEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('PointerEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("PointerEvent"))];
  dart.registerExtension(dart.global.PointerEvent, html$.PointerEvent);
  dart.defineExtensionNames([
    'state'
  ]);
  html$.PopStateEvent = class PopStateEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.PopStateEvent._create_1(type, eventInitDict_1);
      }
      return html$.PopStateEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new PopStateEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new PopStateEvent(type);
    }
    get [dartx.state]() {
      return html_common.convertNativeToDart_SerializedScriptValue(this[_get_state]);
    }
    get [_get_state]() {
      return this.state;
    }
  };
  dart.setSignature(html$.PopStateEvent, {
    constructors: () => ({
      _: [html$.PopStateEvent, []],
      new: [html$.PopStateEvent, [core.String], [core.Map]]
    }),
    statics: () => ({
      _create_1: [html$.PopStateEvent, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.PopStateEvent, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.PopStateEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('PopStateEvent')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _js_helper.Native("PopStateEvent"))];
  dart.registerExtension(dart.global.PopStateEvent, html$.PopStateEvent);
  html$._PositionCallback = dart.typedef('_PositionCallback', () => dart.functionType(dart.void, [html$.Geoposition]));
  dart.defineExtensionNames([
    'code',
    'message'
  ]);
  html$.PositionError = class PositionError extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.code]() {
      return this.code;
    }
    get [dartx.message]() {
      return this.message;
    }
  };
  dart.setSignature(html$.PositionError, {
    constructors: () => ({_: [html$.PositionError, []]})
  });
  html$.PositionError[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('PositionError')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("PositionError"))];
  html$.PositionError.PERMISSION_DENIED = 1;
  html$.PositionError.POSITION_UNAVAILABLE = 2;
  html$.PositionError.TIMEOUT = 3;
  dart.registerExtension(dart.global.PositionError, html$.PositionError);
  html$._PositionErrorCallback = dart.typedef('_PositionErrorCallback', () => dart.functionType(dart.void, [html$.PositionError]));
  dart.defineExtensionNames([
    'getImmediateState',
    'getState',
    'resetSensor'
  ]);
  html$.PositionSensorVRDevice = class PositionSensorVRDevice extends html$.VRDevice {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.getImmediateState]() {
      return this.getImmediateState();
    }
    [dartx.getState]() {
      return this.getState();
    }
    [dartx.resetSensor]() {
      return this.resetSensor();
    }
  };
  dart.setSignature(html$.PositionSensorVRDevice, {
    constructors: () => ({_: [html$.PositionSensorVRDevice, []]}),
    methods: () => ({
      [dartx.getImmediateState]: [html$.VRPositionState, []],
      [dartx.getState]: [html$.VRPositionState, []],
      [dartx.resetSensor]: [dart.void, []]
    })
  });
  html$.PositionSensorVRDevice[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('PositionSensorVRDevice')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("PositionSensorVRDevice"))];
  dart.registerExtension(dart.global.PositionSensorVRDevice, html$.PositionSensorVRDevice);
  html$.PreElement = class PreElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("pre"), html$.PreElement);
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(html$.PreElement, 'created');
  dart.setSignature(html$.PreElement, {
    constructors: () => ({
      _: [html$.PreElement, []],
      new: [html$.PreElement, []],
      created: [html$.PreElement, []]
    })
  });
  html$.PreElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLPreElement')), dart.const(new _js_helper.Native("HTMLPreElement"))];
  dart.registerExtension(dart.global.HTMLPreElement, html$.PreElement);
  dart.defineExtensionNames([
    'getAvailability',
    'joinSession',
    'startSession',
    'session'
  ]);
  html$.Presentation = class Presentation extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.session]() {
      return this.session;
    }
    [dartx.getAvailability](url) {
      return this.getAvailability(url);
    }
    [dartx.joinSession](url, presentationId) {
      return this.joinSession(url, presentationId);
    }
    [dartx.startSession](url) {
      return this.startSession(url);
    }
  };
  dart.setSignature(html$.Presentation, {
    constructors: () => ({_: [html$.Presentation, []]}),
    methods: () => ({
      [dartx.getAvailability]: [async.Future, [core.String]],
      [dartx.joinSession]: [async.Future, [core.String, core.String]],
      [dartx.startSession]: [async.Future, [core.String]]
    })
  });
  html$.Presentation[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Presentation')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("Presentation"))];
  dart.registerExtension(dart.global.Presentation, html$.Presentation);
  dart.defineExtensionNames([
    'onChange',
    'value'
  ]);
  html$.PresentationAvailability = class PresentationAvailability extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.value]() {
      return this.value;
    }
    get [dartx.onChange]() {
      return html$.PresentationAvailability.changeEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.PresentationAvailability, {
    constructors: () => ({_: [html$.PresentationAvailability, []]})
  });
  html$.PresentationAvailability[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('PresentationAvailability')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("PresentationAvailability"))];
  dart.defineLazy(html$.PresentationAvailability, {
    get changeEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('change'));
    }
  });
  dart.registerExtension(dart.global.PresentationAvailability, html$.PresentationAvailability);
  dart.defineExtensionNames([
    'close',
    'send',
    'onMessage',
    'binaryType',
    'id',
    'state'
  ]);
  html$.PresentationSession = class PresentationSession extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.binaryType]() {
      return this.binaryType;
    }
    set [dartx.binaryType](value) {
      this.binaryType = value;
    }
    get [dartx.id]() {
      return this.id;
    }
    get [dartx.state]() {
      return this.state;
    }
    [dartx.close]() {
      return this.close();
    }
    [dartx.send](data_OR_message) {
      return this.send(data_OR_message);
    }
    get [dartx.onMessage]() {
      return html$.PresentationSession.messageEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.PresentationSession, {
    constructors: () => ({_: [html$.PresentationSession, []]}),
    methods: () => ({
      [dartx.close]: [dart.void, []],
      [dartx.send]: [dart.void, [dart.dynamic]]
    })
  });
  html$.PresentationSession[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('PresentationSession')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("PresentationSession"))];
  dart.defineLazy(html$.PresentationSession, {
    get messageEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MessageEvent))('message'));
    }
  });
  dart.registerExtension(dart.global.PresentationSession, html$.PresentationSession);
  dart.defineExtensionNames([
    'sheet',
    'target'
  ]);
  html$.ProcessingInstruction = class ProcessingInstruction extends html$.CharacterData {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.sheet]() {
      return this.sheet;
    }
    get [dartx.target]() {
      return this.target;
    }
  };
  dart.setSignature(html$.ProcessingInstruction, {
    constructors: () => ({_: [html$.ProcessingInstruction, []]})
  });
  html$.ProcessingInstruction[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ProcessingInstruction')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("ProcessingInstruction"))];
  dart.registerExtension(dart.global.ProcessingInstruction, html$.ProcessingInstruction);
  dart.defineExtensionNames([
    'labels',
    'max',
    'position',
    'value'
  ]);
  html$.ProgressElement = class ProgressElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("progress"), html$.ProgressElement);
    }
    created() {
      this[dartx.labels] = null;
      this[dartx.max] = null;
      this[dartx.position] = null;
      this[dartx.value] = null;
      super.created();
    }
    static get supported() {
      return html$.Element.isTagSupported('progress');
    }
    get [dartx.labels]() {
      return this.labels;
    }
    get [dartx.max]() {
      return this.max;
    }
    set [dartx.max](value) {
      this.max = value;
    }
    get [dartx.position]() {
      return this.position;
    }
    get [dartx.value]() {
      return this.value;
    }
    set [dartx.value](value) {
      this.value = value;
    }
  };
  dart.defineNamedConstructor(html$.ProgressElement, 'created');
  dart.setSignature(html$.ProgressElement, {
    constructors: () => ({
      _: [html$.ProgressElement, []],
      new: [html$.ProgressElement, []],
      created: [html$.ProgressElement, []]
    })
  });
  html$.ProgressElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLProgressElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _js_helper.Native("HTMLProgressElement"))];
  dart.registerExtension(dart.global.HTMLProgressElement, html$.ProgressElement);
  dart.defineExtensionNames([
    'lengthComputable',
    'loaded',
    'total'
  ]);
  html$.ProgressEvent = class ProgressEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.ProgressEvent._create_1(type, eventInitDict_1);
      }
      return html$.ProgressEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new ProgressEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new ProgressEvent(type);
    }
    get [dartx.lengthComputable]() {
      return this.lengthComputable;
    }
    get [dartx.loaded]() {
      return this.loaded;
    }
    get [dartx.total]() {
      return this.total;
    }
  };
  dart.setSignature(html$.ProgressEvent, {
    constructors: () => ({
      _: [html$.ProgressEvent, []],
      new: [html$.ProgressEvent, [core.String], [core.Map]]
    }),
    statics: () => ({
      _create_1: [html$.ProgressEvent, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.ProgressEvent, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.ProgressEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ProgressEvent')), dart.const(new _js_helper.Native("ProgressEvent"))];
  dart.registerExtension(dart.global.ProgressEvent, html$.ProgressEvent);
  dart.defineExtensionNames([
    'promise',
    'reason'
  ]);
  html$.PromiseRejectionEvent = class PromiseRejectionEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.PromiseRejectionEvent._create_1(type, eventInitDict_1);
      }
      return html$.PromiseRejectionEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new PromiseRejectionEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new PromiseRejectionEvent(type);
    }
    get [dartx.promise]() {
      return this.promise;
    }
    get [dartx.reason]() {
      return this.reason;
    }
  };
  dart.setSignature(html$.PromiseRejectionEvent, {
    constructors: () => ({
      _: [html$.PromiseRejectionEvent, []],
      new: [html$.PromiseRejectionEvent, [core.String], [core.Map]]
    }),
    statics: () => ({
      _create_1: [html$.PromiseRejectionEvent, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.PromiseRejectionEvent, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.PromiseRejectionEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('PromiseRejectionEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("PromiseRejectionEvent"))];
  dart.registerExtension(dart.global.PromiseRejectionEvent, html$.PromiseRejectionEvent);
  dart.defineExtensionNames([
    'data'
  ]);
  html$.PushEvent = class PushEvent extends html$.ExtendableEvent {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.PushEvent._create_1(type, eventInitDict_1);
      }
      return html$.PushEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new PushEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new PushEvent(type);
    }
    get [dartx.data]() {
      return this.data;
    }
  };
  dart.setSignature(html$.PushEvent, {
    constructors: () => ({
      _: [html$.PushEvent, []],
      new: [html$.PushEvent, [core.String], [core.Map]]
    }),
    statics: () => ({
      _create_1: [html$.PushEvent, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.PushEvent, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.PushEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('PushEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("PushEvent"))];
  dart.registerExtension(dart.global.PushEvent, html$.PushEvent);
  const _permissionState_1 = Symbol('_permissionState_1');
  const _permissionState_2 = Symbol('_permissionState_2');
  const _subscribe_1 = Symbol('_subscribe_1');
  const _subscribe_2 = Symbol('_subscribe_2');
  dart.defineExtensionNames([
    'getSubscription',
    'permissionState',
    'subscribe'
  ]);
  html$.PushManager = class PushManager extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.getSubscription]() {
      return this.getSubscription();
    }
    [dartx.permissionState](options) {
      if (options === void 0) options = null;
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        return this[_permissionState_1](options_1);
      }
      return this[_permissionState_2]();
    }
    [_permissionState_1](options) {
      return this.permissionState(options);
    }
    [_permissionState_2]() {
      return this.permissionState();
    }
    [dartx.subscribe](options) {
      if (options === void 0) options = null;
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        return this[_subscribe_1](options_1);
      }
      return this[_subscribe_2]();
    }
    [_subscribe_1](options) {
      return this.subscribe(options);
    }
    [_subscribe_2]() {
      return this.subscribe();
    }
  };
  dart.setSignature(html$.PushManager, {
    constructors: () => ({_: [html$.PushManager, []]}),
    methods: () => ({
      [dartx.getSubscription]: [async.Future, []],
      [dartx.permissionState]: [async.Future, [], [core.Map]],
      [_permissionState_1]: [async.Future, [dart.dynamic]],
      [_permissionState_2]: [async.Future, []],
      [dartx.subscribe]: [async.Future, [], [core.Map]],
      [_subscribe_1]: [async.Future, [dart.dynamic]],
      [_subscribe_2]: [async.Future, []]
    })
  });
  html$.PushManager[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('PushManager')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("PushManager"))];
  dart.registerExtension(dart.global.PushManager, html$.PushManager);
  dart.defineExtensionNames([
    'arrayBuffer',
    'blob',
    'json',
    'text'
  ]);
  html$.PushMessageData = class PushMessageData extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(message) {
      return html$.PushMessageData._create_1(message);
    }
    static _create_1(message) {
      return new PushMessageData(message);
    }
    [dartx.arrayBuffer]() {
      return this.arrayBuffer();
    }
    [dartx.blob]() {
      return this.blob();
    }
    [dartx.json]() {
      return this.json();
    }
    [dartx.text]() {
      return this.text();
    }
  };
  dart.setSignature(html$.PushMessageData, {
    constructors: () => ({
      _: [html$.PushMessageData, []],
      new: [html$.PushMessageData, [core.String]]
    }),
    methods: () => ({
      [dartx.arrayBuffer]: [typed_data.ByteBuffer, []],
      [dartx.blob]: [html$.Blob, []],
      [dartx.json]: [core.Object, []],
      [dartx.text]: [core.String, []]
    }),
    statics: () => ({_create_1: [html$.PushMessageData, [dart.dynamic]]}),
    names: ['_create_1']
  });
  html$.PushMessageData[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('PushMessageData')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("PushMessageData"))];
  dart.registerExtension(dart.global.PushMessageData, html$.PushMessageData);
  dart.defineExtensionNames([
    'unsubscribe',
    'endpoint'
  ]);
  html$.PushSubscription = class PushSubscription extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.endpoint]() {
      return this.endpoint;
    }
    [dartx.unsubscribe]() {
      return this.unsubscribe();
    }
  };
  dart.setSignature(html$.PushSubscription, {
    constructors: () => ({_: [html$.PushSubscription, []]}),
    methods: () => ({[dartx.unsubscribe]: [async.Future, []]})
  });
  html$.PushSubscription[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('PushSubscription')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("PushSubscription"))];
  dart.registerExtension(dart.global.PushSubscription, html$.PushSubscription);
  dart.defineExtensionNames([
    'cite'
  ]);
  html$.QuoteElement = class QuoteElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("q"), html$.QuoteElement);
    }
    created() {
      this[dartx.cite] = null;
      super.created();
    }
    get [dartx.cite]() {
      return this.cite;
    }
    set [dartx.cite](value) {
      this.cite = value;
    }
  };
  dart.defineNamedConstructor(html$.QuoteElement, 'created');
  dart.setSignature(html$.QuoteElement, {
    constructors: () => ({
      _: [html$.QuoteElement, []],
      new: [html$.QuoteElement, []],
      created: [html$.QuoteElement, []]
    })
  });
  html$.QuoteElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLQuoteElement')), dart.const(new _js_helper.Native("HTMLQuoteElement"))];
  dart.registerExtension(dart.global.HTMLQuoteElement, html$.QuoteElement);
  html$._RtcErrorCallback = dart.typedef('_RtcErrorCallback', () => dart.functionType(dart.void, [core.String]));
  html$._RtcSessionDescriptionCallback = dart.typedef('_RtcSessionDescriptionCallback', () => dart.functionType(dart.void, [html$.RtcSessionDescription]));
  html$.RtcStatsCallback = dart.typedef('RtcStatsCallback', () => dart.functionType(dart.void, [html$.RtcStatsResponse]));
  dart.defineExtensionNames([
    'cloneContents',
    'cloneRange',
    'collapse',
    'compareBoundaryPoints',
    'comparePoint',
    'createContextualFragment',
    'deleteContents',
    'detach',
    'expand',
    'extractContents',
    'getBoundingClientRect',
    'getClientRects',
    'insertNode',
    'isPointInRange',
    'selectNode',
    'selectNodeContents',
    'setEnd',
    'setEndAfter',
    'setEndBefore',
    'setStart',
    'setStartAfter',
    'setStartBefore',
    'surroundContents',
    'collapsed',
    'commonAncestorContainer',
    'endContainer',
    'endOffset',
    'startContainer',
    'startOffset'
  ]);
  html$.Range = class Range extends _interceptors.Interceptor {
    static new() {
      return html$.document[dartx.createRange]();
    }
    static fromPoint(point) {
      return html$.document[_caretRangeFromPoint](dart.asInt(point.x), dart.asInt(point.y));
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.collapsed]() {
      return this.collapsed;
    }
    get [dartx.commonAncestorContainer]() {
      return this.commonAncestorContainer;
    }
    get [dartx.endContainer]() {
      return this.endContainer;
    }
    get [dartx.endOffset]() {
      return this.endOffset;
    }
    get [dartx.startContainer]() {
      return this.startContainer;
    }
    get [dartx.startOffset]() {
      return this.startOffset;
    }
    [dartx.cloneContents]() {
      return this.cloneContents();
    }
    [dartx.cloneRange]() {
      return this.cloneRange();
    }
    [dartx.collapse](toStart) {
      return this.collapse(toStart);
    }
    [dartx.compareBoundaryPoints](how, sourceRange) {
      return this.compareBoundaryPoints(how, sourceRange);
    }
    [dartx.comparePoint](node, offset) {
      return this.comparePoint(node, offset);
    }
    [dartx.createContextualFragment](fragment) {
      return this.createContextualFragment(fragment);
    }
    [dartx.deleteContents]() {
      return this.deleteContents();
    }
    [dartx.detach]() {
      return this.detach();
    }
    [dartx.expand](unit) {
      return this.expand(unit);
    }
    [dartx.extractContents]() {
      return this.extractContents();
    }
    [dartx.getBoundingClientRect]() {
      return this.getBoundingClientRect();
    }
    [dartx.getClientRects]() {
      return this.getClientRects();
    }
    [dartx.insertNode](node) {
      return this.insertNode(node);
    }
    [dartx.isPointInRange](node, offset) {
      return this.isPointInRange(node, offset);
    }
    [dartx.selectNode](node) {
      return this.selectNode(node);
    }
    [dartx.selectNodeContents](node) {
      return this.selectNodeContents(node);
    }
    [dartx.setEnd](node, offset) {
      return this.setEnd(node, offset);
    }
    [dartx.setEndAfter](node) {
      return this.setEndAfter(node);
    }
    [dartx.setEndBefore](node) {
      return this.setEndBefore(node);
    }
    [dartx.setStart](node, offset) {
      return this.setStart(node, offset);
    }
    [dartx.setStartAfter](node) {
      return this.setStartAfter(node);
    }
    [dartx.setStartBefore](node) {
      return this.setStartBefore(node);
    }
    [dartx.surroundContents](newParent) {
      return this.surroundContents(newParent);
    }
    static get supportsCreateContextualFragment() {
      return "createContextualFragment" in window.Range.prototype;
    }
  };
  dart.setSignature(html$.Range, {
    constructors: () => ({
      new: [html$.Range, []],
      fromPoint: [html$.Range, [math.Point$(core.num)]],
      _: [html$.Range, []]
    }),
    methods: () => ({
      [dartx.cloneContents]: [html$.DocumentFragment, []],
      [dartx.cloneRange]: [html$.Range, []],
      [dartx.collapse]: [dart.void, [], [core.bool]],
      [dartx.compareBoundaryPoints]: [core.int, [core.int, html$.Range]],
      [dartx.comparePoint]: [core.int, [html$.Node, core.int]],
      [dartx.createContextualFragment]: [html$.DocumentFragment, [core.String]],
      [dartx.deleteContents]: [dart.void, []],
      [dartx.detach]: [dart.void, []],
      [dartx.expand]: [dart.void, [core.String]],
      [dartx.extractContents]: [html$.DocumentFragment, []],
      [dartx.getBoundingClientRect]: [math.Rectangle$(core.num), []],
      [dartx.getClientRects]: [core.List$(math.Rectangle$(core.num)), []],
      [dartx.insertNode]: [dart.void, [html$.Node]],
      [dartx.isPointInRange]: [core.bool, [html$.Node, core.int]],
      [dartx.selectNode]: [dart.void, [html$.Node]],
      [dartx.selectNodeContents]: [dart.void, [html$.Node]],
      [dartx.setEnd]: [dart.void, [html$.Node, core.int]],
      [dartx.setEndAfter]: [dart.void, [html$.Node]],
      [dartx.setEndBefore]: [dart.void, [html$.Node]],
      [dartx.setStart]: [dart.void, [html$.Node, core.int]],
      [dartx.setStartAfter]: [dart.void, [html$.Node]],
      [dartx.setStartBefore]: [dart.void, [html$.Node]],
      [dartx.surroundContents]: [dart.void, [html$.Node]]
    })
  });
  html$.Range[dart.metadata] = () => [dart.const(new _metadata.DomName('Range')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("Range"))];
  html$.Range.END_TO_END = 2;
  html$.Range.END_TO_START = 3;
  html$.Range.START_TO_END = 1;
  html$.Range.START_TO_START = 0;
  dart.registerExtension(dart.global.Range, html$.Range);
  dart.defineExtensionNames([
    'cancel',
    'getReader'
  ]);
  html$.ReadableByteStream = class ReadableByteStream extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.cancel](reason) {
      return this.cancel(reason);
    }
    [dartx.getReader]() {
      return this.getReader();
    }
  };
  dart.setSignature(html$.ReadableByteStream, {
    constructors: () => ({_: [html$.ReadableByteStream, []]}),
    methods: () => ({
      [dartx.cancel]: [async.Future, [], [core.Object]],
      [dartx.getReader]: [html$.ReadableByteStreamReader, []]
    })
  });
  html$.ReadableByteStream[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ReadableByteStream')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("ReadableByteStream"))];
  dart.registerExtension(dart.global.ReadableByteStream, html$.ReadableByteStream);
  dart.defineExtensionNames([
    'cancel',
    'read',
    'releaseLock',
    'closed'
  ]);
  html$.ReadableByteStreamReader = class ReadableByteStreamReader extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.closed]() {
      return this.closed;
    }
    [dartx.cancel](reason) {
      return this.cancel(reason);
    }
    [dartx.read]() {
      return this.read();
    }
    [dartx.releaseLock]() {
      return this.releaseLock();
    }
  };
  dart.setSignature(html$.ReadableByteStreamReader, {
    constructors: () => ({_: [html$.ReadableByteStreamReader, []]}),
    methods: () => ({
      [dartx.cancel]: [async.Future, [], [core.Object]],
      [dartx.read]: [async.Future, []],
      [dartx.releaseLock]: [dart.void, []]
    })
  });
  html$.ReadableByteStreamReader[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ReadableByteStreamReader')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("ReadableByteStreamReader"))];
  dart.registerExtension(dart.global.ReadableByteStreamReader, html$.ReadableByteStreamReader);
  dart.defineExtensionNames([
    'cancel',
    'getReader'
  ]);
  html$.ReadableStream = class ReadableStream extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.cancel](reason) {
      return this.cancel(reason);
    }
    [dartx.getReader]() {
      return this.getReader();
    }
  };
  dart.setSignature(html$.ReadableStream, {
    constructors: () => ({_: [html$.ReadableStream, []]}),
    methods: () => ({
      [dartx.cancel]: [async.Future, [], [core.Object]],
      [dartx.getReader]: [html$.ReadableStreamReader, []]
    })
  });
  html$.ReadableStream[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ReadableStream')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("ReadableStream"))];
  dart.registerExtension(dart.global.ReadableStream, html$.ReadableStream);
  dart.defineExtensionNames([
    'cancel',
    'read',
    'releaseLock',
    'closed'
  ]);
  html$.ReadableStreamReader = class ReadableStreamReader extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.closed]() {
      return this.closed;
    }
    [dartx.cancel](reason) {
      return this.cancel(reason);
    }
    [dartx.read]() {
      return this.read();
    }
    [dartx.releaseLock]() {
      return this.releaseLock();
    }
  };
  dart.setSignature(html$.ReadableStreamReader, {
    constructors: () => ({_: [html$.ReadableStreamReader, []]}),
    methods: () => ({
      [dartx.cancel]: [async.Future, [], [core.Object]],
      [dartx.read]: [async.Future, []],
      [dartx.releaseLock]: [dart.void, []]
    })
  });
  html$.ReadableStreamReader[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ReadableStreamReader')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("ReadableStreamReader"))];
  dart.registerExtension(dart.global.ReadableStreamReader, html$.ReadableStreamReader);
  dart.defineExtensionNames([
    'relatedTarget'
  ]);
  html$.RelatedEvent = class RelatedEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.RelatedEvent._create_1(type, eventInitDict_1);
      }
      return html$.RelatedEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new RelatedEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new RelatedEvent(type);
    }
    get [dartx.relatedTarget]() {
      return html$._convertNativeToDart_EventTarget(this[_get_relatedTarget]);
    }
    get [_get_relatedTarget]() {
      return this.relatedTarget;
    }
  };
  dart.setSignature(html$.RelatedEvent, {
    constructors: () => ({
      _: [html$.RelatedEvent, []],
      new: [html$.RelatedEvent, [core.String], [core.Map]]
    }),
    statics: () => ({
      _create_1: [html$.RelatedEvent, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.RelatedEvent, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.RelatedEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('RelatedEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("RelatedEvent"))];
  dart.registerExtension(dart.global.RelatedEvent, html$.RelatedEvent);
  html$.RequestAnimationFrameCallback = dart.typedef('RequestAnimationFrameCallback', () => dart.functionType(dart.void, [core.num]));
  dart.defineExtensionNames([
    'url'
  ]);
  html$.ResourceProgressEvent = class ResourceProgressEvent extends html$.ProgressEvent {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.url]() {
      return this.url;
    }
  };
  dart.setSignature(html$.ResourceProgressEvent, {
    constructors: () => ({_: [html$.ResourceProgressEvent, []]})
  });
  html$.ResourceProgressEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ResourceProgressEvent')), core.deprecated, dart.const(new _js_helper.Native("ResourceProgressEvent"))];
  dart.registerExtension(dart.global.ResourceProgressEvent, html$.ResourceProgressEvent);
  dart.defineExtensionNames([
    'close',
    'send',
    'sendBlob',
    'sendByteBuffer',
    'sendString',
    'sendTypedData',
    'onClose',
    'onError',
    'onMessage',
    'onOpen',
    'binaryType',
    'bufferedAmount',
    'id',
    'label',
    'maxRetransmitTime',
    'maxRetransmits',
    'negotiated',
    'ordered',
    'protocol',
    'readyState',
    'reliable'
  ]);
  html$.RtcDataChannel = class RtcDataChannel extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.binaryType]() {
      return this.binaryType;
    }
    set [dartx.binaryType](value) {
      this.binaryType = value;
    }
    get [dartx.bufferedAmount]() {
      return this.bufferedAmount;
    }
    get [dartx.id]() {
      return this.id;
    }
    get [dartx.label]() {
      return this.label;
    }
    get [dartx.maxRetransmitTime]() {
      return this.maxRetransmitTime;
    }
    get [dartx.maxRetransmits]() {
      return this.maxRetransmits;
    }
    get [dartx.negotiated]() {
      return this.negotiated;
    }
    get [dartx.ordered]() {
      return this.ordered;
    }
    get [dartx.protocol]() {
      return this.protocol;
    }
    get [dartx.readyState]() {
      return this.readyState;
    }
    get [dartx.reliable]() {
      return this.reliable;
    }
    [dartx.close]() {
      return this.close();
    }
    [dartx.send](data) {
      return this.send(data);
    }
    [dartx.sendBlob](data) {
      return this.send(data);
    }
    [dartx.sendByteBuffer](data) {
      return this.send(data);
    }
    [dartx.sendString](data) {
      return this.send(data);
    }
    [dartx.sendTypedData](data) {
      return this.send(data);
    }
    get [dartx.onClose]() {
      return html$.RtcDataChannel.closeEvent.forTarget(this);
    }
    get [dartx.onError]() {
      return html$.RtcDataChannel.errorEvent.forTarget(this);
    }
    get [dartx.onMessage]() {
      return html$.RtcDataChannel.messageEvent.forTarget(this);
    }
    get [dartx.onOpen]() {
      return html$.RtcDataChannel.openEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.RtcDataChannel, {
    constructors: () => ({_: [html$.RtcDataChannel, []]}),
    methods: () => ({
      [dartx.close]: [dart.void, []],
      [dartx.send]: [dart.void, [dart.dynamic]],
      [dartx.sendBlob]: [dart.void, [html$.Blob]],
      [dartx.sendByteBuffer]: [dart.void, [typed_data.ByteBuffer]],
      [dartx.sendString]: [dart.void, [core.String]],
      [dartx.sendTypedData]: [dart.void, [typed_data.TypedData]]
    })
  });
  html$.RtcDataChannel[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('RTCDataChannel')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("RTCDataChannel,DataChannel"))];
  dart.defineLazy(html$.RtcDataChannel, {
    get closeEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('close'));
    },
    get errorEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('error'));
    },
    get messageEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MessageEvent))('message'));
    },
    get openEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('open'));
    }
  });
  dart.registerExtension(dart.global.RTCDataChannel, html$.RtcDataChannel);
  dart.defineExtensionNames([
    'channel'
  ]);
  html$.RtcDataChannelEvent = class RtcDataChannelEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.channel]() {
      return this.channel;
    }
  };
  dart.setSignature(html$.RtcDataChannelEvent, {
    constructors: () => ({_: [html$.RtcDataChannelEvent, []]})
  });
  html$.RtcDataChannelEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('RTCDataChannelEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("RTCDataChannelEvent"))];
  dart.registerExtension(dart.global.RTCDataChannelEvent, html$.RtcDataChannelEvent);
  dart.defineExtensionNames([
    'insertDtmf',
    'onToneChange',
    'canInsertDtmf',
    'duration',
    'interToneGap',
    'toneBuffer',
    'track'
  ]);
  html$.RtcDtmfSender = class RtcDtmfSender extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.canInsertDtmf]() {
      return this.canInsertDTMF;
    }
    get [dartx.duration]() {
      return this.duration;
    }
    get [dartx.interToneGap]() {
      return this.interToneGap;
    }
    get [dartx.toneBuffer]() {
      return this.toneBuffer;
    }
    get [dartx.track]() {
      return this.track;
    }
    [dartx.insertDtmf](tones, duration, interToneGap) {
      return this.insertDTMF(tones, duration, interToneGap);
    }
    get [dartx.onToneChange]() {
      return html$.RtcDtmfSender.toneChangeEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.RtcDtmfSender, {
    constructors: () => ({_: [html$.RtcDtmfSender, []]}),
    methods: () => ({[dartx.insertDtmf]: [dart.void, [core.String], [core.int, core.int]]})
  });
  html$.RtcDtmfSender[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('RTCDTMFSender')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("RTCDTMFSender"))];
  dart.defineLazy(html$.RtcDtmfSender, {
    get toneChangeEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.RtcDtmfToneChangeEvent))('tonechange'));
    }
  });
  dart.registerExtension(dart.global.RTCDTMFSender, html$.RtcDtmfSender);
  dart.defineExtensionNames([
    'tone'
  ]);
  html$.RtcDtmfToneChangeEvent = class RtcDtmfToneChangeEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
      return html$.RtcDtmfToneChangeEvent._create_1(type, eventInitDict_1);
    }
    static _create_1(type, eventInitDict) {
      return new RTCDTMFToneChangeEvent(type, eventInitDict);
    }
    get [dartx.tone]() {
      return this.tone;
    }
  };
  dart.setSignature(html$.RtcDtmfToneChangeEvent, {
    constructors: () => ({
      _: [html$.RtcDtmfToneChangeEvent, []],
      new: [html$.RtcDtmfToneChangeEvent, [core.String, core.Map]]
    }),
    statics: () => ({_create_1: [html$.RtcDtmfToneChangeEvent, [dart.dynamic, dart.dynamic]]}),
    names: ['_create_1']
  });
  html$.RtcDtmfToneChangeEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('RTCDTMFToneChangeEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("RTCDTMFToneChangeEvent"))];
  dart.registerExtension(dart.global.RTCDTMFToneChangeEvent, html$.RtcDtmfToneChangeEvent);
  dart.defineExtensionNames([
    'candidate',
    'sdpMLineIndex',
    'sdpMid'
  ]);
  html$.RtcIceCandidate = class RtcIceCandidate extends _interceptors.Interceptor {
    static new(dictionary) {
      let constructorName = window[dart.notNull(html_common.Device.isFirefox) ? `${html_common.Device.propertyPrefix}RTCIceCandidate` : 'RTCIceCandidate'];
      return new constructorName(html_common.convertDartToNative_SerializedScriptValue(dictionary));
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.candidate]() {
      return this.candidate;
    }
    set [dartx.candidate](value) {
      this.candidate = value;
    }
    get [dartx.sdpMLineIndex]() {
      return this.sdpMLineIndex;
    }
    set [dartx.sdpMLineIndex](value) {
      this.sdpMLineIndex = value;
    }
    get [dartx.sdpMid]() {
      return this.sdpMid;
    }
    set [dartx.sdpMid](value) {
      this.sdpMid = value;
    }
  };
  dart.setSignature(html$.RtcIceCandidate, {
    constructors: () => ({
      new: [html$.RtcIceCandidate, [core.Map]],
      _: [html$.RtcIceCandidate, []]
    })
  });
  html$.RtcIceCandidate[dart.metadata] = () => [dart.const(new _metadata.DomName('RTCIceCandidate')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("RTCIceCandidate,mozRTCIceCandidate"))];
  dart.registerExtension(dart.global.RTCIceCandidate, html$.RtcIceCandidate);
  dart.defineExtensionNames([
    'candidate'
  ]);
  html$.RtcIceCandidateEvent = class RtcIceCandidateEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.candidate]() {
      return this.candidate;
    }
  };
  dart.setSignature(html$.RtcIceCandidateEvent, {
    constructors: () => ({_: [html$.RtcIceCandidateEvent, []]})
  });
  html$.RtcIceCandidateEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('RTCIceCandidateEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("RTCIceCandidateEvent,RTCPeerConnectionIceEvent"))];
  dart.registerExtension(dart.global.RTCIceCandidateEvent, html$.RtcIceCandidateEvent);
  const _createOffer = Symbol('_createOffer');
  const _createAnswer = Symbol('_createAnswer');
  const _getStats = Symbol('_getStats');
  const _addStream_1 = Symbol('_addStream_1');
  const _addStream_2 = Symbol('_addStream_2');
  const _createAnswer_1 = Symbol('_createAnswer_1');
  const _createAnswer_2 = Symbol('_createAnswer_2');
  const _createDataChannel_1 = Symbol('_createDataChannel_1');
  const _createDataChannel_2 = Symbol('_createDataChannel_2');
  const _createOffer_1 = Symbol('_createOffer_1');
  const _createOffer_2 = Symbol('_createOffer_2');
  const _setLocalDescription = Symbol('_setLocalDescription');
  const _setRemoteDescription = Symbol('_setRemoteDescription');
  const _updateIce_1 = Symbol('_updateIce_1');
  const _updateIce_2 = Symbol('_updateIce_2');
  const _updateIce_3 = Symbol('_updateIce_3');
  dart.defineExtensionNames([
    'createOffer',
    'createAnswer',
    'getStats',
    'addIceCandidate',
    'addStream',
    'close',
    'createDtmfSender',
    'createDataChannel',
    'getLocalStreams',
    'getRemoteStreams',
    'getStreamById',
    'removeStream',
    'setLocalDescription',
    'setRemoteDescription',
    'updateIce',
    'onAddStream',
    'onDataChannel',
    'onIceCandidate',
    'onIceConnectionStateChange',
    'onNegotiationNeeded',
    'onRemoveStream',
    'onSignalingStateChange',
    'iceConnectionState',
    'iceGatheringState',
    'localDescription',
    'remoteDescription',
    'signalingState'
  ]);
  html$.RtcPeerConnection = class RtcPeerConnection extends html$.EventTarget {
    static new(rtcIceServers, mediaConstraints) {
      if (mediaConstraints === void 0) mediaConstraints = null;
      let constructorName = window[`${html_common.Device.propertyPrefix}RTCPeerConnection`];
      if (mediaConstraints != null) {
        return new constructorName(html_common.convertDartToNative_SerializedScriptValue(rtcIceServers), html_common.convertDartToNative_SerializedScriptValue(mediaConstraints));
      } else {
        return new constructorName(html_common.convertDartToNative_SerializedScriptValue(rtcIceServers));
      }
    }
    static get supported() {
      try {
        html$.RtcPeerConnection.new(dart.map({iceServers: dart.list([dart.map({url: "stun:localhost"})], core.Map$(core.String, core.String))}));
        return true;
      } catch (_) {
        return false;
      }

      return false;
    }
    [dartx.createOffer](mediaConstraints) {
      if (mediaConstraints === void 0) mediaConstraints = null;
      let completer = async.Completer$(html$.RtcSessionDescription).new();
      this[_createOffer](dart.fn(value => {
        completer.complete(value);
      }, dart.void, [html$.RtcSessionDescription]), dart.fn(error => {
        completer.completeError(error);
      }, dart.void, [core.String]), mediaConstraints);
      return completer.future;
    }
    [dartx.createAnswer](mediaConstraints) {
      if (mediaConstraints === void 0) mediaConstraints = null;
      let completer = async.Completer$(html$.RtcSessionDescription).new();
      this[_createAnswer](dart.fn(value => {
        completer.complete(value);
      }, dart.void, [html$.RtcSessionDescription]), dart.fn(error => {
        completer.completeError(error);
      }, dart.void, [core.String]), mediaConstraints);
      return completer.future;
    }
    [dartx.getStats](selector) {
      let completer = async.Completer$(html$.RtcStatsResponse).new();
      this[_getStats](dart.fn(value => {
        completer.complete(value);
      }, dart.void, [html$.RtcStatsResponse]), selector);
      return completer.future;
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.iceConnectionState]() {
      return this.iceConnectionState;
    }
    get [dartx.iceGatheringState]() {
      return this.iceGatheringState;
    }
    get [dartx.localDescription]() {
      return this.localDescription;
    }
    get [dartx.remoteDescription]() {
      return this.remoteDescription;
    }
    get [dartx.signalingState]() {
      return this.signalingState;
    }
    [dartx.addIceCandidate](candidate, successCallback, failureCallback) {
      return this.addIceCandidate(candidate, successCallback, failureCallback);
    }
    [dartx.addStream](stream, mediaConstraints) {
      if (mediaConstraints === void 0) mediaConstraints = null;
      if (mediaConstraints != null) {
        let mediaConstraints_1 = html_common.convertDartToNative_Dictionary(mediaConstraints);
        this[_addStream_1](stream, mediaConstraints_1);
        return;
      }
      this[_addStream_2](stream);
      return;
    }
    [_addStream_1](stream, mediaConstraints) {
      return this.addStream(stream, mediaConstraints);
    }
    [_addStream_2](stream) {
      return this.addStream(stream);
    }
    [dartx.close]() {
      return this.close();
    }
    [_createAnswer](successCallback, failureCallback, mediaConstraints) {
      if (failureCallback === void 0) failureCallback = null;
      if (mediaConstraints === void 0) mediaConstraints = null;
      if (mediaConstraints != null) {
        let mediaConstraints_1 = html_common.convertDartToNative_Dictionary(mediaConstraints);
        this[_createAnswer_1](successCallback, failureCallback, mediaConstraints_1);
        return;
      }
      this[_createAnswer_2](successCallback, failureCallback);
      return;
    }
    [_createAnswer_1](successCallback, failureCallback, mediaConstraints) {
      return this.createAnswer(successCallback, failureCallback, mediaConstraints);
    }
    [_createAnswer_2](successCallback, failureCallback) {
      return this.createAnswer(successCallback, failureCallback);
    }
    [dartx.createDtmfSender](track) {
      return this.createDTMFSender(track);
    }
    [dartx.createDataChannel](label, options) {
      if (options === void 0) options = null;
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        return this[_createDataChannel_1](label, options_1);
      }
      return this[_createDataChannel_2](label);
    }
    [_createDataChannel_1](label, options) {
      return this.createDataChannel(label, options);
    }
    [_createDataChannel_2](label) {
      return this.createDataChannel(label);
    }
    [_createOffer](successCallback, failureCallback, rtcOfferOptions) {
      if (failureCallback === void 0) failureCallback = null;
      if (rtcOfferOptions === void 0) rtcOfferOptions = null;
      if (rtcOfferOptions != null) {
        let rtcOfferOptions_1 = html_common.convertDartToNative_Dictionary(rtcOfferOptions);
        this[_createOffer_1](successCallback, failureCallback, rtcOfferOptions_1);
        return;
      }
      this[_createOffer_2](successCallback, failureCallback);
      return;
    }
    [_createOffer_1](successCallback, failureCallback, rtcOfferOptions) {
      return this.createOffer(successCallback, failureCallback, rtcOfferOptions);
    }
    [_createOffer_2](successCallback, failureCallback) {
      return this.createOffer(successCallback, failureCallback);
    }
    [dartx.getLocalStreams]() {
      return this.getLocalStreams();
    }
    [dartx.getRemoteStreams]() {
      return this.getRemoteStreams();
    }
    [_getStats](successCallback, selector) {
      return this.getStats(successCallback, selector);
    }
    [dartx.getStreamById](streamId) {
      return this.getStreamById(streamId);
    }
    [dartx.removeStream](stream) {
      return this.removeStream(stream);
    }
    [_setLocalDescription](description, successCallback, failureCallback) {
      return this.setLocalDescription(description, successCallback, failureCallback);
    }
    [dartx.setLocalDescription](description) {
      let completer = async.Completer.new();
      this[_setLocalDescription](description, dart.fn(() => {
        completer.complete();
      }, dart.void, []), dart.fn(error => {
        completer.completeError(error);
      }, dart.void, [core.String]));
      return completer.future;
    }
    [_setRemoteDescription](description, successCallback, failureCallback) {
      return this.setRemoteDescription(description, successCallback, failureCallback);
    }
    [dartx.setRemoteDescription](description) {
      let completer = async.Completer.new();
      this[_setRemoteDescription](description, dart.fn(() => {
        completer.complete();
      }, dart.void, []), dart.fn(error => {
        completer.completeError(error);
      }, dart.void, [core.String]));
      return completer.future;
    }
    [dartx.updateIce](configuration, mediaConstraints) {
      if (configuration === void 0) configuration = null;
      if (mediaConstraints === void 0) mediaConstraints = null;
      if (mediaConstraints != null) {
        let configuration_1 = html_common.convertDartToNative_Dictionary(configuration);
        let mediaConstraints_2 = html_common.convertDartToNative_Dictionary(mediaConstraints);
        this[_updateIce_1](configuration_1, mediaConstraints_2);
        return;
      }
      if (configuration != null) {
        let configuration_1 = html_common.convertDartToNative_Dictionary(configuration);
        this[_updateIce_2](configuration_1);
        return;
      }
      this[_updateIce_3]();
      return;
    }
    [_updateIce_1](configuration, mediaConstraints) {
      return this.updateIce(configuration, mediaConstraints);
    }
    [_updateIce_2](configuration) {
      return this.updateIce(configuration);
    }
    [_updateIce_3]() {
      return this.updateIce();
    }
    get [dartx.onAddStream]() {
      return html$.RtcPeerConnection.addStreamEvent.forTarget(this);
    }
    get [dartx.onDataChannel]() {
      return html$.RtcPeerConnection.dataChannelEvent.forTarget(this);
    }
    get [dartx.onIceCandidate]() {
      return html$.RtcPeerConnection.iceCandidateEvent.forTarget(this);
    }
    get [dartx.onIceConnectionStateChange]() {
      return html$.RtcPeerConnection.iceConnectionStateChangeEvent.forTarget(this);
    }
    get [dartx.onNegotiationNeeded]() {
      return html$.RtcPeerConnection.negotiationNeededEvent.forTarget(this);
    }
    get [dartx.onRemoveStream]() {
      return html$.RtcPeerConnection.removeStreamEvent.forTarget(this);
    }
    get [dartx.onSignalingStateChange]() {
      return html$.RtcPeerConnection.signalingStateChangeEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.RtcPeerConnection, {
    constructors: () => ({
      new: [html$.RtcPeerConnection, [core.Map], [core.Map]],
      _: [html$.RtcPeerConnection, []]
    }),
    methods: () => ({
      [dartx.createOffer]: [async.Future$(html$.RtcSessionDescription), [], [core.Map]],
      [dartx.createAnswer]: [async.Future$(html$.RtcSessionDescription), [], [core.Map]],
      [dartx.getStats]: [async.Future$(html$.RtcStatsResponse), [html$.MediaStreamTrack]],
      [dartx.addIceCandidate]: [dart.void, [html$.RtcIceCandidate, html$.VoidCallback, html$._RtcErrorCallback]],
      [dartx.addStream]: [dart.void, [html$.MediaStream], [core.Map]],
      [_addStream_1]: [dart.void, [html$.MediaStream, dart.dynamic]],
      [_addStream_2]: [dart.void, [html$.MediaStream]],
      [dartx.close]: [dart.void, []],
      [_createAnswer]: [dart.void, [html$._RtcSessionDescriptionCallback], [html$._RtcErrorCallback, core.Map]],
      [_createAnswer_1]: [dart.void, [html$._RtcSessionDescriptionCallback, html$._RtcErrorCallback, dart.dynamic]],
      [_createAnswer_2]: [dart.void, [html$._RtcSessionDescriptionCallback, html$._RtcErrorCallback]],
      [dartx.createDtmfSender]: [html$.RtcDtmfSender, [html$.MediaStreamTrack]],
      [dartx.createDataChannel]: [html$.RtcDataChannel, [core.String], [core.Map]],
      [_createDataChannel_1]: [html$.RtcDataChannel, [dart.dynamic, dart.dynamic]],
      [_createDataChannel_2]: [html$.RtcDataChannel, [dart.dynamic]],
      [_createOffer]: [dart.void, [html$._RtcSessionDescriptionCallback], [html$._RtcErrorCallback, core.Map]],
      [_createOffer_1]: [dart.void, [html$._RtcSessionDescriptionCallback, html$._RtcErrorCallback, dart.dynamic]],
      [_createOffer_2]: [dart.void, [html$._RtcSessionDescriptionCallback, html$._RtcErrorCallback]],
      [dartx.getLocalStreams]: [core.List$(html$.MediaStream), []],
      [dartx.getRemoteStreams]: [core.List$(html$.MediaStream), []],
      [_getStats]: [dart.void, [html$.RtcStatsCallback, html$.MediaStreamTrack]],
      [dartx.getStreamById]: [html$.MediaStream, [core.String]],
      [dartx.removeStream]: [dart.void, [html$.MediaStream]],
      [_setLocalDescription]: [dart.void, [html$.RtcSessionDescription], [html$.VoidCallback, html$._RtcErrorCallback]],
      [dartx.setLocalDescription]: [async.Future, [html$.RtcSessionDescription]],
      [_setRemoteDescription]: [dart.void, [html$.RtcSessionDescription], [html$.VoidCallback, html$._RtcErrorCallback]],
      [dartx.setRemoteDescription]: [async.Future, [html$.RtcSessionDescription]],
      [dartx.updateIce]: [dart.void, [], [core.Map, core.Map]],
      [_updateIce_1]: [dart.void, [dart.dynamic, dart.dynamic]],
      [_updateIce_2]: [dart.void, [dart.dynamic]],
      [_updateIce_3]: [dart.void, []]
    })
  });
  html$.RtcPeerConnection[dart.metadata] = () => [dart.const(new _metadata.DomName('RTCPeerConnection')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("RTCPeerConnection,mozRTCPeerConnection"))];
  dart.defineLazy(html$.RtcPeerConnection, {
    get addStreamEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MediaStreamEvent))('addstream'));
    },
    get dataChannelEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.RtcDataChannelEvent))('datachannel'));
    },
    get iceCandidateEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.RtcIceCandidateEvent))('icecandidate'));
    },
    get iceConnectionStateChangeEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('iceconnectionstatechange'));
    },
    get negotiationNeededEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('negotiationneeded'));
    },
    get removeStreamEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MediaStreamEvent))('removestream'));
    },
    get signalingStateChangeEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('signalingstatechange'));
    }
  });
  dart.registerExtension(dart.global.RTCPeerConnection, html$.RtcPeerConnection);
  dart.defineExtensionNames([
    'sdp',
    'type'
  ]);
  html$.RtcSessionDescription = class RtcSessionDescription extends _interceptors.Interceptor {
    static new(dictionary) {
      let constructorName = window[dart.notNull(html_common.Device.isFirefox) ? `${html_common.Device.propertyPrefix}RTCSessionDescription` : 'RTCSessionDescription'];
      return new constructorName(html_common.convertDartToNative_SerializedScriptValue(dictionary));
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.sdp]() {
      return this.sdp;
    }
    set [dartx.sdp](value) {
      this.sdp = value;
    }
    get [dartx.type]() {
      return this.type;
    }
    set [dartx.type](value) {
      this.type = value;
    }
  };
  dart.setSignature(html$.RtcSessionDescription, {
    constructors: () => ({
      new: [html$.RtcSessionDescription, [core.Map]],
      _: [html$.RtcSessionDescription, []]
    })
  });
  html$.RtcSessionDescription[dart.metadata] = () => [dart.const(new _metadata.DomName('RTCSessionDescription')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("RTCSessionDescription,mozRTCSessionDescription"))];
  dart.registerExtension(dart.global.RTCSessionDescription, html$.RtcSessionDescription);
  const _get_timestamp = Symbol('_get_timestamp');
  dart.defineExtensionNames([
    'timestamp',
    'names',
    'stat',
    'id',
    'type'
  ]);
  html$.RtcStatsReport = class RtcStatsReport extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.id]() {
      return this.id;
    }
    get [dartx.timestamp]() {
      return html_common.convertNativeToDart_DateTime(this[_get_timestamp]);
    }
    get [_get_timestamp]() {
      return this.timestamp;
    }
    get [dartx.type]() {
      return this.type;
    }
    [dartx.names]() {
      return this.names();
    }
    [dartx.stat](name) {
      return this.stat(name);
    }
  };
  dart.setSignature(html$.RtcStatsReport, {
    constructors: () => ({_: [html$.RtcStatsReport, []]}),
    methods: () => ({
      [dartx.names]: [core.List$(core.String), []],
      [dartx.stat]: [core.String, [core.String]]
    })
  });
  html$.RtcStatsReport[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('RTCStatsReport')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("RTCStatsReport"))];
  dart.registerExtension(dart.global.RTCStatsReport, html$.RtcStatsReport);
  dart.defineExtensionNames([
    'namedItem',
    'result'
  ]);
  html$.RtcStatsResponse = class RtcStatsResponse extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.namedItem](name) {
      return this.namedItem(name);
    }
    [dartx.result]() {
      return this.result();
    }
  };
  dart.setSignature(html$.RtcStatsResponse, {
    constructors: () => ({_: [html$.RtcStatsResponse, []]}),
    methods: () => ({
      [dartx.namedItem]: [html$.RtcStatsReport, [core.String]],
      [dartx.result]: [core.List$(html$.RtcStatsReport), []]
    })
  });
  html$.RtcStatsResponse[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('RTCStatsResponse')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("RTCStatsResponse"))];
  dart.registerExtension(dart.global.RTCStatsResponse, html$.RtcStatsResponse);
  const _availLeft = Symbol('_availLeft');
  const _availTop = Symbol('_availTop');
  const _availWidth = Symbol('_availWidth');
  const _availHeight = Symbol('_availHeight');
  dart.defineExtensionNames([
    'available',
    'colorDepth',
    'height',
    'orientation',
    'pixelDepth',
    'width'
  ]);
  html$.Screen = class Screen extends _interceptors.Interceptor {
    get [dartx.available]() {
      return new (math.Rectangle$(core.num))(this[_availLeft], this[_availTop], this[_availWidth], this[_availHeight]);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [_availHeight]() {
      return this.availHeight;
    }
    get [_availLeft]() {
      return this.availLeft;
    }
    get [_availTop]() {
      return this.availTop;
    }
    get [_availWidth]() {
      return this.availWidth;
    }
    get [dartx.colorDepth]() {
      return this.colorDepth;
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.orientation]() {
      return this.orientation;
    }
    get [dartx.pixelDepth]() {
      return this.pixelDepth;
    }
    get [dartx.width]() {
      return this.width;
    }
  };
  dart.setSignature(html$.Screen, {
    constructors: () => ({_: [html$.Screen, []]})
  });
  html$.Screen[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Screen')), dart.const(new _js_helper.Native("Screen"))];
  dart.registerExtension(dart.global.Screen, html$.Screen);
  dart.defineExtensionNames([
    'lock',
    'unlock',
    'onChange',
    'angle',
    'type'
  ]);
  html$.ScreenOrientation = class ScreenOrientation extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.angle]() {
      return this.angle;
    }
    get [dartx.type]() {
      return this.type;
    }
    [dartx.lock](orientation) {
      return this.lock(orientation);
    }
    [dartx.unlock]() {
      return this.unlock();
    }
    get [dartx.onChange]() {
      return html$.ScreenOrientation.changeEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.ScreenOrientation, {
    constructors: () => ({_: [html$.ScreenOrientation, []]}),
    methods: () => ({
      [dartx.lock]: [async.Future, [core.String]],
      [dartx.unlock]: [dart.void, []]
    })
  });
  html$.ScreenOrientation[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ScreenOrientation')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("ScreenOrientation"))];
  dart.defineLazy(html$.ScreenOrientation, {
    get changeEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('change'));
    }
  });
  dart.registerExtension(dart.global.ScreenOrientation, html$.ScreenOrientation);
  dart.defineExtensionNames([
    'async',
    'charset',
    'crossOrigin',
    'defer',
    'integrity',
    'nonce',
    'src',
    'type'
  ]);
  html$.ScriptElement = class ScriptElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("script"), html$.ScriptElement);
    }
    created() {
      this[dartx.async] = null;
      this[dartx.charset] = null;
      this[dartx.crossOrigin] = null;
      this[dartx.defer] = null;
      this[dartx.integrity] = null;
      this[dartx.nonce] = null;
      this[dartx.src] = null;
      this[dartx.type] = null;
      super.created();
    }
    get [dartx.async]() {
      return this.async;
    }
    set [dartx.async](value) {
      this.async = value;
    }
    get [dartx.charset]() {
      return this.charset;
    }
    set [dartx.charset](value) {
      this.charset = value;
    }
    get [dartx.crossOrigin]() {
      return this.crossOrigin;
    }
    set [dartx.crossOrigin](value) {
      this.crossOrigin = value;
    }
    get [dartx.defer]() {
      return this.defer;
    }
    set [dartx.defer](value) {
      this.defer = value;
    }
    get [dartx.integrity]() {
      return this.integrity;
    }
    set [dartx.integrity](value) {
      this.integrity = value;
    }
    get [dartx.nonce]() {
      return this.nonce;
    }
    set [dartx.nonce](value) {
      this.nonce = value;
    }
    get [dartx.src]() {
      return this.src;
    }
    set [dartx.src](value) {
      this.src = value;
    }
    get [dartx.type]() {
      return this.type;
    }
    set [dartx.type](value) {
      this.type = value;
    }
  };
  dart.defineNamedConstructor(html$.ScriptElement, 'created');
  dart.setSignature(html$.ScriptElement, {
    constructors: () => ({
      _: [html$.ScriptElement, []],
      new: [html$.ScriptElement, []],
      created: [html$.ScriptElement, []]
    })
  });
  html$.ScriptElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLScriptElement')), dart.const(new _js_helper.Native("HTMLScriptElement"))];
  dart.registerExtension(dart.global.HTMLScriptElement, html$.ScriptElement);
  dart.defineExtensionNames([
    'consumeDelta',
    'deltaGranularity',
    'deltaX',
    'deltaY',
    'fromUserInput',
    'inInertialPhase',
    'isBeginning',
    'isEnding',
    'shouldPropagate',
    'velocityX',
    'velocityY'
  ]);
  html$.ScrollState = class ScrollState extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(deltaX, deltaY, deltaGranularity, velocityX, velocityY, inInertialPhase, isBeginning, isEnding) {
      if (deltaX === void 0) deltaX = null;
      if (deltaY === void 0) deltaY = null;
      if (deltaGranularity === void 0) deltaGranularity = null;
      if (velocityX === void 0) velocityX = null;
      if (velocityY === void 0) velocityY = null;
      if (inInertialPhase === void 0) inInertialPhase = null;
      if (isBeginning === void 0) isBeginning = null;
      if (isEnding === void 0) isEnding = null;
      if (isEnding != null) {
        return html$.ScrollState._create_1(deltaX, deltaY, deltaGranularity, velocityX, velocityY, inInertialPhase, isBeginning, isEnding);
      }
      if (isBeginning != null) {
        return html$.ScrollState._create_2(deltaX, deltaY, deltaGranularity, velocityX, velocityY, inInertialPhase, isBeginning);
      }
      if (inInertialPhase != null) {
        return html$.ScrollState._create_3(deltaX, deltaY, deltaGranularity, velocityX, velocityY, inInertialPhase);
      }
      if (velocityY != null) {
        return html$.ScrollState._create_4(deltaX, deltaY, deltaGranularity, velocityX, velocityY);
      }
      if (velocityX != null) {
        return html$.ScrollState._create_5(deltaX, deltaY, deltaGranularity, velocityX);
      }
      if (deltaGranularity != null) {
        return html$.ScrollState._create_6(deltaX, deltaY, deltaGranularity);
      }
      if (deltaY != null) {
        return html$.ScrollState._create_7(deltaX, deltaY);
      }
      if (deltaX != null) {
        return html$.ScrollState._create_8(deltaX);
      }
      return html$.ScrollState._create_9();
    }
    static _create_1(deltaX, deltaY, deltaGranularity, velocityX, velocityY, inInertialPhase, isBeginning, isEnding) {
      return new ScrollState(deltaX, deltaY, deltaGranularity, velocityX, velocityY, inInertialPhase, isBeginning, isEnding);
    }
    static _create_2(deltaX, deltaY, deltaGranularity, velocityX, velocityY, inInertialPhase, isBeginning) {
      return new ScrollState(deltaX, deltaY, deltaGranularity, velocityX, velocityY, inInertialPhase, isBeginning);
    }
    static _create_3(deltaX, deltaY, deltaGranularity, velocityX, velocityY, inInertialPhase) {
      return new ScrollState(deltaX, deltaY, deltaGranularity, velocityX, velocityY, inInertialPhase);
    }
    static _create_4(deltaX, deltaY, deltaGranularity, velocityX, velocityY) {
      return new ScrollState(deltaX, deltaY, deltaGranularity, velocityX, velocityY);
    }
    static _create_5(deltaX, deltaY, deltaGranularity, velocityX) {
      return new ScrollState(deltaX, deltaY, deltaGranularity, velocityX);
    }
    static _create_6(deltaX, deltaY, deltaGranularity) {
      return new ScrollState(deltaX, deltaY, deltaGranularity);
    }
    static _create_7(deltaX, deltaY) {
      return new ScrollState(deltaX, deltaY);
    }
    static _create_8(deltaX) {
      return new ScrollState(deltaX);
    }
    static _create_9() {
      return new ScrollState();
    }
    get [dartx.deltaGranularity]() {
      return this.deltaGranularity;
    }
    get [dartx.deltaX]() {
      return this.deltaX;
    }
    get [dartx.deltaY]() {
      return this.deltaY;
    }
    get [dartx.fromUserInput]() {
      return this.fromUserInput;
    }
    get [dartx.inInertialPhase]() {
      return this.inInertialPhase;
    }
    get [dartx.isBeginning]() {
      return this.isBeginning;
    }
    get [dartx.isEnding]() {
      return this.isEnding;
    }
    get [dartx.shouldPropagate]() {
      return this.shouldPropagate;
    }
    get [dartx.velocityX]() {
      return this.velocityX;
    }
    get [dartx.velocityY]() {
      return this.velocityY;
    }
    [dartx.consumeDelta](x, y) {
      return this.consumeDelta(x, y);
    }
  };
  dart.setSignature(html$.ScrollState, {
    constructors: () => ({
      _: [html$.ScrollState, []],
      new: [html$.ScrollState, [], [core.num, core.num, core.num, core.num, core.num, core.bool, core.bool, core.bool]]
    }),
    methods: () => ({[dartx.consumeDelta]: [dart.void, [core.num, core.num]]}),
    statics: () => ({
      _create_1: [html$.ScrollState, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]],
      _create_2: [html$.ScrollState, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]],
      _create_3: [html$.ScrollState, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]],
      _create_4: [html$.ScrollState, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]],
      _create_5: [html$.ScrollState, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]],
      _create_6: [html$.ScrollState, [dart.dynamic, dart.dynamic, dart.dynamic]],
      _create_7: [html$.ScrollState, [dart.dynamic, dart.dynamic]],
      _create_8: [html$.ScrollState, [dart.dynamic]],
      _create_9: [html$.ScrollState, []]
    }),
    names: ['_create_1', '_create_2', '_create_3', '_create_4', '_create_5', '_create_6', '_create_7', '_create_8', '_create_9']
  });
  html$.ScrollState[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ScrollState')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("ScrollState"))];
  dart.registerExtension(dart.global.ScrollState, html$.ScrollState);
  dart.defineExtensionNames([
    'blockedUri',
    'columnNumber',
    'documentUri',
    'effectiveDirective',
    'lineNumber',
    'originalPolicy',
    'referrer',
    'sourceFile',
    'statusCode',
    'violatedDirective'
  ]);
  html$.SecurityPolicyViolationEvent = class SecurityPolicyViolationEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.SecurityPolicyViolationEvent._create_1(type, eventInitDict_1);
      }
      return html$.SecurityPolicyViolationEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new SecurityPolicyViolationEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new SecurityPolicyViolationEvent(type);
    }
    get [dartx.blockedUri]() {
      return this.blockedURI;
    }
    get [dartx.columnNumber]() {
      return this.columnNumber;
    }
    get [dartx.documentUri]() {
      return this.documentURI;
    }
    get [dartx.effectiveDirective]() {
      return this.effectiveDirective;
    }
    get [dartx.lineNumber]() {
      return this.lineNumber;
    }
    get [dartx.originalPolicy]() {
      return this.originalPolicy;
    }
    get [dartx.referrer]() {
      return this.referrer;
    }
    get [dartx.sourceFile]() {
      return this.sourceFile;
    }
    get [dartx.statusCode]() {
      return this.statusCode;
    }
    get [dartx.violatedDirective]() {
      return this.violatedDirective;
    }
  };
  dart.setSignature(html$.SecurityPolicyViolationEvent, {
    constructors: () => ({
      _: [html$.SecurityPolicyViolationEvent, []],
      new: [html$.SecurityPolicyViolationEvent, [core.String], [core.Map]]
    }),
    statics: () => ({
      _create_1: [html$.SecurityPolicyViolationEvent, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.SecurityPolicyViolationEvent, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.SecurityPolicyViolationEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SecurityPolicyViolationEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("SecurityPolicyViolationEvent"))];
  dart.registerExtension(dart.global.SecurityPolicyViolationEvent, html$.SecurityPolicyViolationEvent);
  dart.defineExtensionNames([
    'add',
    'checkValidity',
    'item',
    'namedItem',
    'reportValidity',
    'setCustomValidity',
    'options',
    'selectedOptions',
    'autofocus',
    'disabled',
    'form',
    'labels',
    'length',
    'multiple',
    'name',
    'required',
    'selectedIndex',
    'size',
    'type',
    'validationMessage',
    'validity',
    'value',
    'willValidate'
  ]);
  html$.SelectElement = class SelectElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("select"), html$.SelectElement);
    }
    created() {
      this[dartx.autofocus] = null;
      this[dartx.disabled] = null;
      this[dartx.form] = null;
      this[dartx.labels] = null;
      this[dartx.length] = null;
      this[dartx.multiple] = null;
      this[dartx.name] = null;
      this[dartx.required] = null;
      this[dartx.selectedIndex] = null;
      this[dartx.size] = null;
      this[dartx.type] = null;
      this[dartx.validationMessage] = null;
      this[dartx.validity] = null;
      this[dartx.value] = null;
      this[dartx.willValidate] = null;
      super.created();
    }
    get [dartx.autofocus]() {
      return this.autofocus;
    }
    set [dartx.autofocus](value) {
      this.autofocus = value;
    }
    get [dartx.disabled]() {
      return this.disabled;
    }
    set [dartx.disabled](value) {
      this.disabled = value;
    }
    get [dartx.form]() {
      return this.form;
    }
    get [dartx.labels]() {
      return this.labels;
    }
    get [dartx.length]() {
      return this.length;
    }
    set [dartx.length](value) {
      this.length = value;
    }
    get [dartx.multiple]() {
      return this.multiple;
    }
    set [dartx.multiple](value) {
      this.multiple = value;
    }
    get [dartx.name]() {
      return this.name;
    }
    set [dartx.name](value) {
      this.name = value;
    }
    get [dartx.required]() {
      return this.required;
    }
    set [dartx.required](value) {
      this.required = value;
    }
    get [dartx.selectedIndex]() {
      return this.selectedIndex;
    }
    set [dartx.selectedIndex](value) {
      this.selectedIndex = value;
    }
    get [dartx.size]() {
      return this.size;
    }
    set [dartx.size](value) {
      this.size = value;
    }
    get [dartx.type]() {
      return this.type;
    }
    get [dartx.validationMessage]() {
      return this.validationMessage;
    }
    get [dartx.validity]() {
      return this.validity;
    }
    get [dartx.value]() {
      return this.value;
    }
    set [dartx.value](value) {
      this.value = value;
    }
    get [dartx.willValidate]() {
      return this.willValidate;
    }
    [__setter__](index, option) {
      return this.__setter__(index, option);
    }
    [dartx.add](element, before) {
      return this.add(element, before);
    }
    [dartx.checkValidity]() {
      return this.checkValidity();
    }
    [dartx.item](index) {
      return this.item(index);
    }
    [dartx.namedItem](name) {
      return this.namedItem(name);
    }
    [dartx.reportValidity]() {
      return this.reportValidity();
    }
    [dartx.setCustomValidity](error) {
      return this.setCustomValidity(error);
    }
    get [dartx.options]() {
      let options = core.List$(html$.OptionElement).from(this[dartx.querySelectorAll](html$.Element)('option'));
      return new (collection.UnmodifiableListView$(html$.OptionElement))(options);
    }
    get [dartx.selectedOptions]() {
      if (dart.notNull(this[dartx.multiple])) {
        let options = this[dartx.options][dartx.where](dart.fn(o => o[dartx.selected], core.bool, [html$.OptionElement]))[dartx.toList]();
        return new (collection.UnmodifiableListView$(html$.OptionElement))(options);
      } else {
        return dart.list([this[dartx.options][dartx.get](this[dartx.selectedIndex])], html$.OptionElement);
      }
    }
  };
  dart.defineNamedConstructor(html$.SelectElement, 'created');
  dart.setSignature(html$.SelectElement, {
    constructors: () => ({
      _: [html$.SelectElement, []],
      new: [html$.SelectElement, []],
      created: [html$.SelectElement, []]
    }),
    methods: () => ({
      [__setter__]: [dart.void, [core.int, html$.OptionElement]],
      [dartx.add]: [dart.void, [core.Object, core.Object]],
      [dartx.checkValidity]: [core.bool, []],
      [dartx.item]: [html$.Element, [core.int]],
      [dartx.namedItem]: [html$.OptionElement, [core.String]],
      [dartx.reportValidity]: [core.bool, []],
      [dartx.setCustomValidity]: [dart.void, [core.String]]
    })
  });
  html$.SelectElement[dart.metadata] = () => [dart.const(new _metadata.DomName('HTMLSelectElement')), dart.const(new _js_helper.Native("HTMLSelectElement"))];
  dart.registerExtension(dart.global.HTMLSelectElement, html$.SelectElement);
  dart.defineExtensionNames([
    'addRange',
    'collapse',
    'collapseToEnd',
    'collapseToStart',
    'containsNode',
    'deleteFromDocument',
    'empty',
    'extend',
    'getRangeAt',
    'modify',
    'removeAllRanges',
    'selectAllChildren',
    'setBaseAndExtent',
    'setPosition',
    'anchorNode',
    'anchorOffset',
    'baseNode',
    'baseOffset',
    'extentNode',
    'extentOffset',
    'focusNode',
    'focusOffset',
    'isCollapsed',
    'rangeCount',
    'type'
  ]);
  html$.Selection = class Selection extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.anchorNode]() {
      return this.anchorNode;
    }
    get [dartx.anchorOffset]() {
      return this.anchorOffset;
    }
    get [dartx.baseNode]() {
      return this.baseNode;
    }
    get [dartx.baseOffset]() {
      return this.baseOffset;
    }
    get [dartx.extentNode]() {
      return this.extentNode;
    }
    get [dartx.extentOffset]() {
      return this.extentOffset;
    }
    get [dartx.focusNode]() {
      return this.focusNode;
    }
    get [dartx.focusOffset]() {
      return this.focusOffset;
    }
    get [dartx.isCollapsed]() {
      return this.isCollapsed;
    }
    get [dartx.rangeCount]() {
      return this.rangeCount;
    }
    get [dartx.type]() {
      return this.type;
    }
    [dartx.addRange](range) {
      return this.addRange(range);
    }
    [dartx.collapse](node, offset) {
      return this.collapse(node, offset);
    }
    [dartx.collapseToEnd]() {
      return this.collapseToEnd();
    }
    [dartx.collapseToStart]() {
      return this.collapseToStart();
    }
    [dartx.containsNode](node, allowPartialContainment) {
      return this.containsNode(node, allowPartialContainment);
    }
    [dartx.deleteFromDocument]() {
      return this.deleteFromDocument();
    }
    [dartx.empty]() {
      return this.empty();
    }
    [dartx.extend](node, offset) {
      return this.extend(node, offset);
    }
    [dartx.getRangeAt](index) {
      return this.getRangeAt(index);
    }
    [dartx.modify](alter, direction, granularity) {
      return this.modify(alter, direction, granularity);
    }
    [dartx.removeAllRanges]() {
      return this.removeAllRanges();
    }
    [dartx.selectAllChildren](node) {
      return this.selectAllChildren(node);
    }
    [dartx.setBaseAndExtent](baseNode, baseOffset, extentNode, extentOffset) {
      return this.setBaseAndExtent(baseNode, baseOffset, extentNode, extentOffset);
    }
    [dartx.setPosition](node, offset) {
      return this.setPosition(node, offset);
    }
  };
  dart.setSignature(html$.Selection, {
    constructors: () => ({_: [html$.Selection, []]}),
    methods: () => ({
      [dartx.addRange]: [dart.void, [html$.Range]],
      [dartx.collapse]: [dart.void, [html$.Node], [core.int]],
      [dartx.collapseToEnd]: [dart.void, []],
      [dartx.collapseToStart]: [dart.void, []],
      [dartx.containsNode]: [core.bool, [html$.Node, core.bool]],
      [dartx.deleteFromDocument]: [dart.void, []],
      [dartx.empty]: [dart.void, []],
      [dartx.extend]: [dart.void, [html$.Node], [core.int]],
      [dartx.getRangeAt]: [html$.Range, [core.int]],
      [dartx.modify]: [dart.void, [core.String, core.String, core.String]],
      [dartx.removeAllRanges]: [dart.void, []],
      [dartx.selectAllChildren]: [dart.void, [html$.Node]],
      [dartx.setBaseAndExtent]: [dart.void, [html$.Node, core.int, html$.Node, core.int]],
      [dartx.setPosition]: [dart.void, [html$.Node], [core.int]]
    })
  });
  html$.Selection[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Selection')), dart.const(new _js_helper.Native("Selection"))];
  dart.registerExtension(dart.global.Selection, html$.Selection);
  dart.defineExtensionNames([
    'close',
    'postMessage',
    'data',
    'name',
    'targetUrl'
  ]);
  html$.ServicePort = class ServicePort extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.data]() {
      return this.data;
    }
    get [dartx.name]() {
      return this.name;
    }
    get [dartx.targetUrl]() {
      return this.targetURL;
    }
    [dartx.close]() {
      return this.close();
    }
    [dartx.postMessage](message, transfer) {
      if (transfer === void 0) transfer = null;
      if (transfer != null) {
        let message_1 = html_common.convertDartToNative_SerializedScriptValue(message);
        this[_postMessage_1](message_1, transfer);
        return;
      }
      let message_1 = html_common.convertDartToNative_SerializedScriptValue(message);
      this[_postMessage_2](message_1);
      return;
    }
    [_postMessage_1](message, transfer) {
      return this.postMessage(message, transfer);
    }
    [_postMessage_2](message) {
      return this.postMessage(message);
    }
  };
  dart.setSignature(html$.ServicePort, {
    constructors: () => ({_: [html$.ServicePort, []]}),
    methods: () => ({
      [dartx.close]: [dart.void, []],
      [dartx.postMessage]: [dart.void, [dart.dynamic], [core.List$(html$.MessagePort)]],
      [_postMessage_1]: [dart.void, [dart.dynamic, core.List$(html$.MessagePort)]],
      [_postMessage_2]: [dart.void, [dart.dynamic]]
    })
  });
  html$.ServicePort[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ServicePort')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("ServicePort"))];
  dart.registerExtension(dart.global.ServicePort, html$.ServicePort);
  const _connect_1 = Symbol('_connect_1');
  const _connect_2 = Symbol('_connect_2');
  dart.defineExtensionNames([
    'connect',
    'match',
    'matchAll',
    'onMessage'
  ]);
  html$.ServicePortCollection = class ServicePortCollection extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.connect](url, options) {
      if (options === void 0) options = null;
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        return this[_connect_1](url, options_1);
      }
      return this[_connect_2](url);
    }
    [_connect_1](url, options) {
      return this.connect(url, options);
    }
    [_connect_2](url) {
      return this.connect(url);
    }
    [dartx.match](options) {
      let options_1 = html_common.convertDartToNative_Dictionary(options);
      return this[_match_1](options_1);
    }
    [_match_1](options) {
      return this.match(options);
    }
    [dartx.matchAll](options) {
      if (options === void 0) options = null;
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        return this[_matchAll_1](options_1);
      }
      return this[_matchAll_2]();
    }
    [_matchAll_1](options) {
      return this.matchAll(options);
    }
    [_matchAll_2]() {
      return this.matchAll();
    }
    get [dartx.onMessage]() {
      return html$.ServicePortCollection.messageEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.ServicePortCollection, {
    constructors: () => ({_: [html$.ServicePortCollection, []]}),
    methods: () => ({
      [dartx.connect]: [async.Future, [core.String], [core.Map]],
      [_connect_1]: [async.Future, [dart.dynamic, dart.dynamic]],
      [_connect_2]: [async.Future, [dart.dynamic]],
      [dartx.match]: [async.Future, [core.Map]],
      [_match_1]: [async.Future, [dart.dynamic]],
      [dartx.matchAll]: [async.Future, [], [core.Map]],
      [_matchAll_1]: [async.Future, [dart.dynamic]],
      [_matchAll_2]: [async.Future, []]
    })
  });
  html$.ServicePortCollection[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ServicePortCollection')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("ServicePortCollection"))];
  dart.defineLazy(html$.ServicePortCollection, {
    get messageEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MessageEvent))('message'));
    }
  });
  dart.registerExtension(dart.global.ServicePortCollection, html$.ServicePortCollection);
  dart.defineExtensionNames([
    'respondWith',
    'origin',
    'targetUrl'
  ]);
  html$.ServicePortConnectEvent = class ServicePortConnectEvent extends html$.ExtendableEvent {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.ServicePortConnectEvent._create_1(type, eventInitDict_1);
      }
      return html$.ServicePortConnectEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new ServicePortConnectEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new ServicePortConnectEvent(type);
    }
    get [dartx.origin]() {
      return this.origin;
    }
    get [dartx.targetUrl]() {
      return this.targetURL;
    }
    [dartx.respondWith](response) {
      return this.respondWith(response);
    }
  };
  dart.setSignature(html$.ServicePortConnectEvent, {
    constructors: () => ({
      _: [html$.ServicePortConnectEvent, []],
      new: [html$.ServicePortConnectEvent, [core.String], [core.Map]]
    }),
    methods: () => ({[dartx.respondWith]: [async.Future, [async.Future]]}),
    statics: () => ({
      _create_1: [html$.ServicePortConnectEvent, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.ServicePortConnectEvent, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.ServicePortConnectEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ServicePortConnectEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("ServicePortConnectEvent"))];
  dart.registerExtension(dart.global.ServicePortConnectEvent, html$.ServicePortConnectEvent);
  dart.defineExtensionNames([
    'getRegistration',
    'getRegistrations',
    'register',
    'onMessage',
    'controller',
    'ready'
  ]);
  html$.ServiceWorkerContainer = class ServiceWorkerContainer extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.controller]() {
      return this.controller;
    }
    get [dartx.ready]() {
      return this.ready;
    }
    [dartx.getRegistration](documentURL) {
      return this.getRegistration(documentURL);
    }
    [dartx.getRegistrations]() {
      return this.getRegistrations();
    }
    [dartx.register](url, options) {
      if (options === void 0) options = null;
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        return this[_register_1](url, options_1);
      }
      return this[_register_2](url);
    }
    [_register_1](url, options) {
      return this.register(url, options);
    }
    [_register_2](url) {
      return this.register(url);
    }
    get [dartx.onMessage]() {
      return html$.ServiceWorkerContainer.messageEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.ServiceWorkerContainer, {
    constructors: () => ({_: [html$.ServiceWorkerContainer, []]}),
    methods: () => ({
      [dartx.getRegistration]: [async.Future, [], [core.String]],
      [dartx.getRegistrations]: [async.Future, []],
      [dartx.register]: [async.Future, [core.String], [core.Map]],
      [_register_1]: [async.Future, [dart.dynamic, dart.dynamic]],
      [_register_2]: [async.Future, [dart.dynamic]]
    })
  });
  html$.ServiceWorkerContainer[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ServiceWorkerContainer')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("ServiceWorkerContainer"))];
  dart.defineLazy(html$.ServiceWorkerContainer, {
    get messageEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MessageEvent))('message'));
    }
  });
  dart.registerExtension(dart.global.ServiceWorkerContainer, html$.ServiceWorkerContainer);
  dart.defineExtensionNames([
    'skipWaiting',
    'onMessage',
    'clients',
    'ports',
    'registration'
  ]);
  html$.ServiceWorkerGlobalScope = class ServiceWorkerGlobalScope extends html$.WorkerGlobalScope {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.clients]() {
      return this.clients;
    }
    get [dartx.ports]() {
      return this.ports;
    }
    get [dartx.registration]() {
      return this.registration;
    }
    [dartx.skipWaiting]() {
      return this.skipWaiting();
    }
    get [dartx.onMessage]() {
      return html$.ServiceWorkerGlobalScope.messageEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.ServiceWorkerGlobalScope, {
    constructors: () => ({_: [html$.ServiceWorkerGlobalScope, []]}),
    methods: () => ({[dartx.skipWaiting]: [async.Future, []]})
  });
  html$.ServiceWorkerGlobalScope[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ServiceWorkerGlobalScope')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("ServiceWorkerGlobalScope"))];
  dart.defineLazy(html$.ServiceWorkerGlobalScope, {
    get messageEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MessageEvent))('message'));
    }
  });
  dart.registerExtension(dart.global.ServiceWorkerGlobalScope, html$.ServiceWorkerGlobalScope);
  dart.defineExtensionNames([
    'data',
    'lastEventId',
    'origin',
    'ports',
    'source'
  ]);
  html$.ServiceWorkerMessageEvent = class ServiceWorkerMessageEvent extends html$.Event {
    get [dartx.data]() {
      return html_common.convertNativeToDart_SerializedScriptValue(this[_get_data]);
    }
    get [_get_data]() {
      return this.data;
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.ServiceWorkerMessageEvent._create_1(type, eventInitDict_1);
      }
      return html$.ServiceWorkerMessageEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new ServiceWorkerMessageEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new ServiceWorkerMessageEvent(type);
    }
    get [dartx.lastEventId]() {
      return this.lastEventId;
    }
    get [dartx.origin]() {
      return this.origin;
    }
    get [dartx.ports]() {
      return this.ports;
    }
    get [dartx.source]() {
      return this.source;
    }
  };
  dart.setSignature(html$.ServiceWorkerMessageEvent, {
    constructors: () => ({
      _: [html$.ServiceWorkerMessageEvent, []],
      new: [html$.ServiceWorkerMessageEvent, [core.String], [core.Map]]
    }),
    statics: () => ({
      _create_1: [html$.ServiceWorkerMessageEvent, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.ServiceWorkerMessageEvent, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.ServiceWorkerMessageEvent[dart.metadata] = () => [dart.const(new _metadata.DomName('ServiceWorkerMessageEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("ServiceWorkerMessageEvent"))];
  dart.registerExtension(dart.global.ServiceWorkerMessageEvent, html$.ServiceWorkerMessageEvent);
  const _getNotifications_1 = Symbol('_getNotifications_1');
  const _getNotifications_2 = Symbol('_getNotifications_2');
  const _showNotification_1 = Symbol('_showNotification_1');
  const _showNotification_2 = Symbol('_showNotification_2');
  dart.defineExtensionNames([
    'getNotifications',
    'showNotification',
    'unregister',
    'update',
    'active',
    'geofencing',
    'installing',
    'periodicSync',
    'pushManager',
    'scope',
    'sync',
    'waiting'
  ]);
  html$.ServiceWorkerRegistration = class ServiceWorkerRegistration extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.active]() {
      return this.active;
    }
    get [dartx.geofencing]() {
      return this.geofencing;
    }
    get [dartx.installing]() {
      return this.installing;
    }
    get [dartx.periodicSync]() {
      return this.periodicSync;
    }
    get [dartx.pushManager]() {
      return this.pushManager;
    }
    get [dartx.scope]() {
      return this.scope;
    }
    get [dartx.sync]() {
      return this.sync;
    }
    get [dartx.waiting]() {
      return this.waiting;
    }
    [dartx.getNotifications](filter) {
      if (filter === void 0) filter = null;
      if (filter != null) {
        let filter_1 = html_common.convertDartToNative_Dictionary(filter);
        return this[_getNotifications_1](filter_1);
      }
      return this[_getNotifications_2]();
    }
    [_getNotifications_1](filter) {
      return this.getNotifications(filter);
    }
    [_getNotifications_2]() {
      return this.getNotifications();
    }
    [dartx.showNotification](title, options) {
      if (options === void 0) options = null;
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        return this[_showNotification_1](title, options_1);
      }
      return this[_showNotification_2](title);
    }
    [_showNotification_1](title, options) {
      return this.showNotification(title, options);
    }
    [_showNotification_2](title) {
      return this.showNotification(title);
    }
    [dartx.unregister]() {
      return this.unregister();
    }
    [dartx.update]() {
      return this.update();
    }
  };
  dart.setSignature(html$.ServiceWorkerRegistration, {
    constructors: () => ({_: [html$.ServiceWorkerRegistration, []]}),
    methods: () => ({
      [dartx.getNotifications]: [async.Future, [], [core.Map]],
      [_getNotifications_1]: [async.Future, [dart.dynamic]],
      [_getNotifications_2]: [async.Future, []],
      [dartx.showNotification]: [async.Future, [core.String], [core.Map]],
      [_showNotification_1]: [async.Future, [dart.dynamic, dart.dynamic]],
      [_showNotification_2]: [async.Future, [dart.dynamic]],
      [dartx.unregister]: [async.Future, []],
      [dartx.update]: [dart.void, []]
    })
  });
  html$.ServiceWorkerRegistration[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ServiceWorkerRegistration')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("ServiceWorkerRegistration"))];
  dart.registerExtension(dart.global.ServiceWorkerRegistration, html$.ServiceWorkerRegistration);
  dart.defineExtensionNames([
    'getDistributedNodes'
  ]);
  html$.ShadowElement = class ShadowElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("shadow"), html$.ShadowElement);
    }
    created() {
      super.created();
    }
    static get supported() {
      return html$.Element.isTagSupported('shadow');
    }
    [dartx.getDistributedNodes]() {
      return this.getDistributedNodes();
    }
  };
  dart.defineNamedConstructor(html$.ShadowElement, 'created');
  dart.setSignature(html$.ShadowElement, {
    constructors: () => ({
      _: [html$.ShadowElement, []],
      new: [html$.ShadowElement, []],
      created: [html$.ShadowElement, []]
    }),
    methods: () => ({[dartx.getDistributedNodes]: [core.List$(html$.Node), []]})
  });
  html$.ShadowElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLShadowElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME, '26')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("HTMLShadowElement"))];
  dart.registerExtension(dart.global.HTMLShadowElement, html$.ShadowElement);
  dart.defineExtensionNames([
    'clone',
    'elementFromPoint',
    'elementsFromPoint',
    'getSelection',
    'resetStyleInheritance',
    'resetStyleInheritance',
    'applyAuthorStyles',
    'applyAuthorStyles',
    'activeElement',
    'delegatesFocus',
    'host',
    'innerHtml',
    'olderShadowRoot',
    'styleSheets'
  ]);
  html$.ShadowRoot = class ShadowRoot extends html$.DocumentFragment {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.activeElement]() {
      return this.activeElement;
    }
    get [dartx.delegatesFocus]() {
      return this.delegatesFocus;
    }
    get [dartx.host]() {
      return this.host;
    }
    get [dartx.innerHtml]() {
      return this.innerHTML;
    }
    set [dartx.innerHtml](value) {
      this.innerHTML = value;
    }
    get [dartx.olderShadowRoot]() {
      return this.olderShadowRoot;
    }
    get [dartx.styleSheets]() {
      return this.styleSheets;
    }
    [dartx.clone](deep) {
      return this.cloneNode(deep);
    }
    [dartx.elementFromPoint](x, y) {
      return this.elementFromPoint(x, y);
    }
    [dartx.elementsFromPoint](x, y) {
      return this.elementsFromPoint(x, y);
    }
    [dartx.getSelection]() {
      return this.getSelection();
    }
    static get supported() {
      return !!(Element.prototype.createShadowRoot || Element.prototype.webkitCreateShadowRoot);
    }
    static _shadowRootDeprecationReport() {
      if (!dart.notNull(html$.ShadowRoot._shadowRootDeprecationReported)) {
        html$.window[dartx.console].warn('ShadowRoot.resetStyleInheritance and ShadowRoot.applyAuthorStyles now deprecated in dart:html.\nPlease remove them from your code.\n');
        html$.ShadowRoot._shadowRootDeprecationReported = true;
      }
    }
    get [dartx.resetStyleInheritance]() {
      html$.ShadowRoot._shadowRootDeprecationReport();
      return false;
    }
    set [dartx.resetStyleInheritance](value) {
      html$.ShadowRoot._shadowRootDeprecationReport();
    }
    get [dartx.applyAuthorStyles]() {
      html$.ShadowRoot._shadowRootDeprecationReport();
      return false;
    }
    set [dartx.applyAuthorStyles](value) {
      html$.ShadowRoot._shadowRootDeprecationReport();
    }
  };
  const innerHtml = Symbol(html$.ShadowRoot.name + "." + dartx.innerHtml.toString());
  dart.setSignature(html$.ShadowRoot, {
    constructors: () => ({_: [html$.ShadowRoot, []]}),
    methods: () => ({
      [dartx.elementFromPoint]: [html$.Element, [core.int, core.int]],
      [dartx.elementsFromPoint]: [core.List$(html$.Element), [core.int, core.int]],
      [dartx.getSelection]: [html$.Selection, []]
    }),
    statics: () => ({_shadowRootDeprecationReport: [dart.void, []]}),
    names: ['_shadowRootDeprecationReport']
  });
  html$.ShadowRoot[dart.metadata] = () => [dart.const(new _metadata.DomName('ShadowRoot')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME, '26')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("ShadowRoot"))];
  html$.ShadowRoot._shadowRootDeprecationReported = false;
  dart.registerExtension(dart.global.ShadowRoot, html$.ShadowRoot);
  dart.defineExtensionNames([
    'byteLength'
  ]);
  html$.SharedArrayBuffer = class SharedArrayBuffer extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.byteLength]() {
      return this.byteLength;
    }
  };
  dart.setSignature(html$.SharedArrayBuffer, {
    constructors: () => ({_: [html$.SharedArrayBuffer, []]})
  });
  html$.SharedArrayBuffer[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SharedArrayBuffer')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("SharedArrayBuffer"))];
  dart.registerExtension(dart.global.SharedArrayBuffer, html$.SharedArrayBuffer);
  dart.defineExtensionNames([
    'onError',
    'port',
    'workerStart'
  ]);
  html$.SharedWorker = class SharedWorker extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(scriptURL, name) {
      if (name === void 0) name = null;
      if (name != null) {
        return html$.SharedWorker._create_1(scriptURL, name);
      }
      return html$.SharedWorker._create_2(scriptURL);
    }
    static _create_1(scriptURL, name) {
      return new SharedWorker(scriptURL, name);
    }
    static _create_2(scriptURL) {
      return new SharedWorker(scriptURL);
    }
    get [dartx.port]() {
      return this.port;
    }
    get [dartx.workerStart]() {
      return this.workerStart;
    }
    get [dartx.onError]() {
      return html$.SharedWorker.errorEvent.forTarget(this);
    }
  };
  html$.SharedWorker[dart.implements] = () => [html$.AbstractWorker];
  dart.setSignature(html$.SharedWorker, {
    constructors: () => ({
      _: [html$.SharedWorker, []],
      new: [html$.SharedWorker, [core.String], [core.String]]
    }),
    statics: () => ({
      _create_1: [html$.SharedWorker, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.SharedWorker, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.SharedWorker[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SharedWorker')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("SharedWorker"))];
  dart.defineLazy(html$.SharedWorker, {
    get errorEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('error'));
    }
  });
  dart.registerExtension(dart.global.SharedWorker, html$.SharedWorker);
  dart.defineExtensionNames([
    'onConnect',
    'name'
  ]);
  html$.SharedWorkerGlobalScope = class SharedWorkerGlobalScope extends html$.WorkerGlobalScope {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.name]() {
      return this.name;
    }
    get [dartx.onConnect]() {
      return html$.SharedWorkerGlobalScope.connectEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.SharedWorkerGlobalScope, {
    constructors: () => ({_: [html$.SharedWorkerGlobalScope, []]})
  });
  html$.SharedWorkerGlobalScope[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SharedWorkerGlobalScope')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("SharedWorkerGlobalScope"))];
  dart.defineLazy(html$.SharedWorkerGlobalScope, {
    get connectEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('connect'));
    }
  });
  dart.registerExtension(dart.global.SharedWorkerGlobalScope, html$.SharedWorkerGlobalScope);
  dart.defineExtensionNames([
    'abort',
    'appendBuffer',
    'appendStream',
    'appendTypedData',
    'remove',
    'appendWindowEnd',
    'appendWindowStart',
    'buffered',
    'mode',
    'timestampOffset',
    'trackDefaults',
    'updating'
  ]);
  html$.SourceBuffer = class SourceBuffer extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.appendWindowEnd]() {
      return this.appendWindowEnd;
    }
    set [dartx.appendWindowEnd](value) {
      this.appendWindowEnd = value;
    }
    get [dartx.appendWindowStart]() {
      return this.appendWindowStart;
    }
    set [dartx.appendWindowStart](value) {
      this.appendWindowStart = value;
    }
    get [dartx.buffered]() {
      return this.buffered;
    }
    get [dartx.mode]() {
      return this.mode;
    }
    set [dartx.mode](value) {
      this.mode = value;
    }
    get [dartx.timestampOffset]() {
      return this.timestampOffset;
    }
    set [dartx.timestampOffset](value) {
      this.timestampOffset = value;
    }
    get [dartx.trackDefaults]() {
      return this.trackDefaults;
    }
    set [dartx.trackDefaults](value) {
      this.trackDefaults = value;
    }
    get [dartx.updating]() {
      return this.updating;
    }
    [dartx.abort]() {
      return this.abort();
    }
    [dartx.appendBuffer](data) {
      return this.appendBuffer(data);
    }
    [dartx.appendStream](stream, maxSize) {
      return this.appendStream(stream, maxSize);
    }
    [dartx.appendTypedData](data) {
      return this.appendBuffer(data);
    }
    [dartx.remove](start, end) {
      return this.remove(start, end);
    }
  };
  dart.setSignature(html$.SourceBuffer, {
    constructors: () => ({_: [html$.SourceBuffer, []]}),
    methods: () => ({
      [dartx.abort]: [dart.void, []],
      [dartx.appendBuffer]: [dart.void, [typed_data.ByteBuffer]],
      [dartx.appendStream]: [dart.void, [html$.FileStream], [core.int]],
      [dartx.appendTypedData]: [dart.void, [typed_data.TypedData]],
      [dartx.remove]: [dart.void, [core.num, core.num]]
    })
  });
  html$.SourceBuffer[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SourceBuffer')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("SourceBuffer"))];
  dart.registerExtension(dart.global.SourceBuffer, html$.SourceBuffer);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'item'
  ]);
  html$.SourceBufferList = class SourceBufferList extends dart.mixin(html$.EventTarget, collection.ListMixin$(html$.SourceBuffer), html$.ImmutableListMixin$(html$.SourceBuffer)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return this[index];
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return this[0];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return this[dart.notNull(len) - 1];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return this[0];
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [dartx.item](index) {
      return this.item(index);
    }
  };
  html$.SourceBufferList[dart.implements] = () => [_js_helper.JavaScriptIndexingBehavior, core.List$(html$.SourceBuffer)];
  dart.setSignature(html$.SourceBufferList, {
    constructors: () => ({_: [html$.SourceBufferList, []]}),
    methods: () => ({
      [dartx.get]: [html$.SourceBuffer, [core.int]],
      [dartx.set]: [dart.void, [core.int, html$.SourceBuffer]],
      [dartx.elementAt]: [html$.SourceBuffer, [core.int]],
      [dartx.item]: [html$.SourceBuffer, [core.int]]
    })
  });
  html$.SourceBufferList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SourceBufferList')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("SourceBufferList"))];
  dart.registerExtension(dart.global.SourceBufferList, html$.SourceBufferList);
  dart.defineExtensionNames([
    'media',
    'sizes',
    'src',
    'srcset',
    'type'
  ]);
  html$.SourceElement = class SourceElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("source"), html$.SourceElement);
    }
    created() {
      this[dartx.media] = null;
      this[dartx.sizes] = null;
      this[dartx.src] = null;
      this[dartx.srcset] = null;
      this[dartx.type] = null;
      super.created();
    }
    get [dartx.media]() {
      return this.media;
    }
    set [dartx.media](value) {
      this.media = value;
    }
    get [dartx.sizes]() {
      return this.sizes;
    }
    set [dartx.sizes](value) {
      this.sizes = value;
    }
    get [dartx.src]() {
      return this.src;
    }
    set [dartx.src](value) {
      this.src = value;
    }
    get [dartx.srcset]() {
      return this.srcset;
    }
    set [dartx.srcset](value) {
      this.srcset = value;
    }
    get [dartx.type]() {
      return this.type;
    }
    set [dartx.type](value) {
      this.type = value;
    }
  };
  dart.defineNamedConstructor(html$.SourceElement, 'created');
  dart.setSignature(html$.SourceElement, {
    constructors: () => ({
      _: [html$.SourceElement, []],
      new: [html$.SourceElement, []],
      created: [html$.SourceElement, []]
    })
  });
  html$.SourceElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLSourceElement')), dart.const(new _js_helper.Native("HTMLSourceElement"))];
  dart.registerExtension(dart.global.HTMLSourceElement, html$.SourceElement);
  dart.defineExtensionNames([
    'facing',
    'id',
    'kind',
    'label'
  ]);
  html$.SourceInfo = class SourceInfo extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.facing]() {
      return this.facing;
    }
    get [dartx.id]() {
      return this.id;
    }
    get [dartx.kind]() {
      return this.kind;
    }
    get [dartx.label]() {
      return this.label;
    }
  };
  dart.setSignature(html$.SourceInfo, {
    constructors: () => ({_: [html$.SourceInfo, []]})
  });
  html$.SourceInfo[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SourceInfo')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("SourceInfo"))];
  dart.registerExtension(dart.global.SourceInfo, html$.SourceInfo);
  html$.SpanElement = class SpanElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("span"), html$.SpanElement);
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(html$.SpanElement, 'created');
  dart.setSignature(html$.SpanElement, {
    constructors: () => ({
      _: [html$.SpanElement, []],
      new: [html$.SpanElement, []],
      created: [html$.SpanElement, []]
    })
  });
  html$.SpanElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLSpanElement')), dart.const(new _js_helper.Native("HTMLSpanElement"))];
  dart.registerExtension(dart.global.HTMLSpanElement, html$.SpanElement);
  dart.defineExtensionNames([
    'src',
    'weight'
  ]);
  html$.SpeechGrammar = class SpeechGrammar extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.SpeechGrammar._create_1();
    }
    static _create_1() {
      return new SpeechGrammar();
    }
    get [dartx.src]() {
      return this.src;
    }
    set [dartx.src](value) {
      this.src = value;
    }
    get [dartx.weight]() {
      return this.weight;
    }
    set [dartx.weight](value) {
      this.weight = value;
    }
  };
  dart.setSignature(html$.SpeechGrammar, {
    constructors: () => ({
      _: [html$.SpeechGrammar, []],
      new: [html$.SpeechGrammar, []]
    }),
    statics: () => ({_create_1: [html$.SpeechGrammar, []]}),
    names: ['_create_1']
  });
  html$.SpeechGrammar[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SpeechGrammar')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("SpeechGrammar"))];
  dart.registerExtension(dart.global.SpeechGrammar, html$.SpeechGrammar);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'addFromString',
    'addFromUri',
    'item'
  ]);
  html$.SpeechGrammarList = class SpeechGrammarList extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(html$.SpeechGrammar), html$.ImmutableListMixin$(html$.SpeechGrammar)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.SpeechGrammarList._create_1();
    }
    static _create_1() {
      return new SpeechGrammarList();
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return this[index];
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return this[0];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return this[dart.notNull(len) - 1];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return this[0];
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [dartx.addFromString](string, weight) {
      return this.addFromString(string, weight);
    }
    [dartx.addFromUri](src, weight) {
      return this.addFromUri(src, weight);
    }
    [dartx.item](index) {
      return this.item(index);
    }
  };
  html$.SpeechGrammarList[dart.implements] = () => [_js_helper.JavaScriptIndexingBehavior, core.List$(html$.SpeechGrammar)];
  dart.setSignature(html$.SpeechGrammarList, {
    constructors: () => ({
      _: [html$.SpeechGrammarList, []],
      new: [html$.SpeechGrammarList, []]
    }),
    methods: () => ({
      [dartx.get]: [html$.SpeechGrammar, [core.int]],
      [dartx.set]: [dart.void, [core.int, html$.SpeechGrammar]],
      [dartx.elementAt]: [html$.SpeechGrammar, [core.int]],
      [dartx.addFromString]: [dart.void, [core.String], [core.num]],
      [dartx.addFromUri]: [dart.void, [core.String], [core.num]],
      [dartx.item]: [html$.SpeechGrammar, [core.int]]
    }),
    statics: () => ({_create_1: [html$.SpeechGrammarList, []]}),
    names: ['_create_1']
  });
  html$.SpeechGrammarList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SpeechGrammarList')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("SpeechGrammarList"))];
  dart.registerExtension(dart.global.SpeechGrammarList, html$.SpeechGrammarList);
  dart.defineExtensionNames([
    'abort',
    'start',
    'stop',
    'onAudioEnd',
    'onAudioStart',
    'onEnd',
    'onError',
    'onNoMatch',
    'onResult',
    'onSoundEnd',
    'onSoundStart',
    'onSpeechEnd',
    'onSpeechStart',
    'onStart',
    'audioTrack',
    'continuous',
    'grammars',
    'interimResults',
    'lang',
    'maxAlternatives',
    'serviceUri'
  ]);
  html$.SpeechRecognition = class SpeechRecognition extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static get supported() {
      return !!(window.SpeechRecognition || window.webkitSpeechRecognition);
    }
    get [dartx.audioTrack]() {
      return this.audioTrack;
    }
    set [dartx.audioTrack](value) {
      this.audioTrack = value;
    }
    get [dartx.continuous]() {
      return this.continuous;
    }
    set [dartx.continuous](value) {
      this.continuous = value;
    }
    get [dartx.grammars]() {
      return this.grammars;
    }
    set [dartx.grammars](value) {
      this.grammars = value;
    }
    get [dartx.interimResults]() {
      return this.interimResults;
    }
    set [dartx.interimResults](value) {
      this.interimResults = value;
    }
    get [dartx.lang]() {
      return this.lang;
    }
    set [dartx.lang](value) {
      this.lang = value;
    }
    get [dartx.maxAlternatives]() {
      return this.maxAlternatives;
    }
    set [dartx.maxAlternatives](value) {
      this.maxAlternatives = value;
    }
    get [dartx.serviceUri]() {
      return this.serviceURI;
    }
    set [dartx.serviceUri](value) {
      this.serviceURI = value;
    }
    [dartx.abort]() {
      return this.abort();
    }
    [dartx.start]() {
      return this.start();
    }
    [dartx.stop]() {
      return this.stop();
    }
    get [dartx.onAudioEnd]() {
      return html$.SpeechRecognition.audioEndEvent.forTarget(this);
    }
    get [dartx.onAudioStart]() {
      return html$.SpeechRecognition.audioStartEvent.forTarget(this);
    }
    get [dartx.onEnd]() {
      return html$.SpeechRecognition.endEvent.forTarget(this);
    }
    get [dartx.onError]() {
      return html$.SpeechRecognition.errorEvent.forTarget(this);
    }
    get [dartx.onNoMatch]() {
      return html$.SpeechRecognition.noMatchEvent.forTarget(this);
    }
    get [dartx.onResult]() {
      return html$.SpeechRecognition.resultEvent.forTarget(this);
    }
    get [dartx.onSoundEnd]() {
      return html$.SpeechRecognition.soundEndEvent.forTarget(this);
    }
    get [dartx.onSoundStart]() {
      return html$.SpeechRecognition.soundStartEvent.forTarget(this);
    }
    get [dartx.onSpeechEnd]() {
      return html$.SpeechRecognition.speechEndEvent.forTarget(this);
    }
    get [dartx.onSpeechStart]() {
      return html$.SpeechRecognition.speechStartEvent.forTarget(this);
    }
    get [dartx.onStart]() {
      return html$.SpeechRecognition.startEvent.forTarget(this);
    }
    static new() {
      return new (window.SpeechRecognition || window.webkitSpeechRecognition)();
    }
  };
  dart.setSignature(html$.SpeechRecognition, {
    constructors: () => ({
      _: [html$.SpeechRecognition, []],
      new: [html$.SpeechRecognition, []]
    }),
    methods: () => ({
      [dartx.abort]: [dart.void, []],
      [dartx.start]: [dart.void, []],
      [dartx.stop]: [dart.void, []]
    })
  });
  html$.SpeechRecognition[dart.metadata] = () => [dart.const(new _metadata.DomName('SpeechRecognition')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME, '25')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("SpeechRecognition"))];
  dart.defineLazy(html$.SpeechRecognition, {
    get audioEndEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('audioend'));
    },
    get audioStartEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('audiostart'));
    },
    get endEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('end'));
    },
    get errorEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.SpeechRecognitionError))('error'));
    },
    get noMatchEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.SpeechRecognitionEvent))('nomatch'));
    },
    get resultEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.SpeechRecognitionEvent))('result'));
    },
    get soundEndEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('soundend'));
    },
    get soundStartEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('soundstart'));
    },
    get speechEndEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('speechend'));
    },
    get speechStartEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('speechstart'));
    },
    get startEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('start'));
    }
  });
  dart.registerExtension(dart.global.SpeechRecognition, html$.SpeechRecognition);
  dart.defineExtensionNames([
    'confidence',
    'transcript'
  ]);
  html$.SpeechRecognitionAlternative = class SpeechRecognitionAlternative extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.confidence]() {
      return this.confidence;
    }
    get [dartx.transcript]() {
      return this.transcript;
    }
  };
  dart.setSignature(html$.SpeechRecognitionAlternative, {
    constructors: () => ({_: [html$.SpeechRecognitionAlternative, []]})
  });
  html$.SpeechRecognitionAlternative[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SpeechRecognitionAlternative')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME, '25')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("SpeechRecognitionAlternative"))];
  dart.registerExtension(dart.global.SpeechRecognitionAlternative, html$.SpeechRecognitionAlternative);
  dart.defineExtensionNames([
    'error',
    'message'
  ]);
  html$.SpeechRecognitionError = class SpeechRecognitionError extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, initDict) {
      if (initDict === void 0) initDict = null;
      if (initDict != null) {
        let initDict_1 = html_common.convertDartToNative_Dictionary(initDict);
        return html$.SpeechRecognitionError._create_1(type, initDict_1);
      }
      return html$.SpeechRecognitionError._create_2(type);
    }
    static _create_1(type, initDict) {
      return new SpeechRecognitionError(type, initDict);
    }
    static _create_2(type) {
      return new SpeechRecognitionError(type);
    }
    get [dartx.error]() {
      return this.error;
    }
    get [dartx.message]() {
      return this.message;
    }
  };
  dart.setSignature(html$.SpeechRecognitionError, {
    constructors: () => ({
      _: [html$.SpeechRecognitionError, []],
      new: [html$.SpeechRecognitionError, [core.String], [core.Map]]
    }),
    statics: () => ({
      _create_1: [html$.SpeechRecognitionError, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.SpeechRecognitionError, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.SpeechRecognitionError[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SpeechRecognitionError')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME, '25')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("SpeechRecognitionError"))];
  dart.registerExtension(dart.global.SpeechRecognitionError, html$.SpeechRecognitionError);
  dart.defineExtensionNames([
    'emma',
    'interpretation',
    'resultIndex',
    'results'
  ]);
  html$.SpeechRecognitionEvent = class SpeechRecognitionEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, initDict) {
      if (initDict === void 0) initDict = null;
      if (initDict != null) {
        let initDict_1 = html_common.convertDartToNative_Dictionary(initDict);
        return html$.SpeechRecognitionEvent._create_1(type, initDict_1);
      }
      return html$.SpeechRecognitionEvent._create_2(type);
    }
    static _create_1(type, initDict) {
      return new SpeechRecognitionEvent(type, initDict);
    }
    static _create_2(type) {
      return new SpeechRecognitionEvent(type);
    }
    get [dartx.emma]() {
      return this.emma;
    }
    get [dartx.interpretation]() {
      return this.interpretation;
    }
    get [dartx.resultIndex]() {
      return this.resultIndex;
    }
    get [dartx.results]() {
      return this.results;
    }
  };
  dart.setSignature(html$.SpeechRecognitionEvent, {
    constructors: () => ({
      _: [html$.SpeechRecognitionEvent, []],
      new: [html$.SpeechRecognitionEvent, [core.String], [core.Map]]
    }),
    statics: () => ({
      _create_1: [html$.SpeechRecognitionEvent, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.SpeechRecognitionEvent, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.SpeechRecognitionEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SpeechRecognitionEvent')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME, '25')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("SpeechRecognitionEvent"))];
  dart.registerExtension(dart.global.SpeechRecognitionEvent, html$.SpeechRecognitionEvent);
  dart.defineExtensionNames([
    'item',
    'isFinal',
    'length'
  ]);
  html$.SpeechRecognitionResult = class SpeechRecognitionResult extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.isFinal]() {
      return this.isFinal;
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.item](index) {
      return this.item(index);
    }
  };
  dart.setSignature(html$.SpeechRecognitionResult, {
    constructors: () => ({_: [html$.SpeechRecognitionResult, []]}),
    methods: () => ({[dartx.item]: [html$.SpeechRecognitionAlternative, [core.int]]})
  });
  html$.SpeechRecognitionResult[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SpeechRecognitionResult')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME, '25')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("SpeechRecognitionResult"))];
  dart.registerExtension(dart.global.SpeechRecognitionResult, html$.SpeechRecognitionResult);
  dart.defineExtensionNames([
    'cancel',
    'getVoices',
    'pause',
    'resume',
    'speak',
    'paused',
    'pending',
    'speaking'
  ]);
  html$.SpeechSynthesis = class SpeechSynthesis extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.paused]() {
      return this.paused;
    }
    get [dartx.pending]() {
      return this.pending;
    }
    get [dartx.speaking]() {
      return this.speaking;
    }
    [dartx.cancel]() {
      return this.cancel();
    }
    [dartx.getVoices]() {
      return this.getVoices();
    }
    [dartx.pause]() {
      return this.pause();
    }
    [dartx.resume]() {
      return this.resume();
    }
    [dartx.speak](utterance) {
      return this.speak(utterance);
    }
  };
  dart.setSignature(html$.SpeechSynthesis, {
    constructors: () => ({_: [html$.SpeechSynthesis, []]}),
    methods: () => ({
      [dartx.cancel]: [dart.void, []],
      [dartx.getVoices]: [core.List$(html$.SpeechSynthesisVoice), []],
      [dartx.pause]: [dart.void, []],
      [dartx.resume]: [dart.void, []],
      [dartx.speak]: [dart.void, [html$.SpeechSynthesisUtterance]]
    })
  });
  html$.SpeechSynthesis[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SpeechSynthesis')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("SpeechSynthesis"))];
  dart.registerExtension(dart.global.SpeechSynthesis, html$.SpeechSynthesis);
  dart.defineExtensionNames([
    'charIndex',
    'elapsedTime',
    'name',
    'utterance'
  ]);
  html$.SpeechSynthesisEvent = class SpeechSynthesisEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.charIndex]() {
      return this.charIndex;
    }
    get [dartx.elapsedTime]() {
      return this.elapsedTime;
    }
    get [dartx.name]() {
      return this.name;
    }
    get [dartx.utterance]() {
      return this.utterance;
    }
  };
  dart.setSignature(html$.SpeechSynthesisEvent, {
    constructors: () => ({_: [html$.SpeechSynthesisEvent, []]})
  });
  html$.SpeechSynthesisEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SpeechSynthesisEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("SpeechSynthesisEvent"))];
  dart.registerExtension(dart.global.SpeechSynthesisEvent, html$.SpeechSynthesisEvent);
  dart.defineExtensionNames([
    'onBoundary',
    'onEnd',
    'onError',
    'onMark',
    'onPause',
    'onResume',
    'onStart',
    'lang',
    'pitch',
    'rate',
    'text',
    'voice',
    'volume'
  ]);
  html$.SpeechSynthesisUtterance = class SpeechSynthesisUtterance extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(text) {
      if (text === void 0) text = null;
      if (text != null) {
        return html$.SpeechSynthesisUtterance._create_1(text);
      }
      return html$.SpeechSynthesisUtterance._create_2();
    }
    static _create_1(text) {
      return new SpeechSynthesisUtterance(text);
    }
    static _create_2() {
      return new SpeechSynthesisUtterance();
    }
    get [dartx.lang]() {
      return this.lang;
    }
    set [dartx.lang](value) {
      this.lang = value;
    }
    get [dartx.pitch]() {
      return this.pitch;
    }
    set [dartx.pitch](value) {
      this.pitch = value;
    }
    get [dartx.rate]() {
      return this.rate;
    }
    set [dartx.rate](value) {
      this.rate = value;
    }
    get [dartx.text]() {
      return this.text;
    }
    set [dartx.text](value) {
      this.text = value;
    }
    get [dartx.voice]() {
      return this.voice;
    }
    set [dartx.voice](value) {
      this.voice = value;
    }
    get [dartx.volume]() {
      return this.volume;
    }
    set [dartx.volume](value) {
      this.volume = value;
    }
    get [dartx.onBoundary]() {
      return html$.SpeechSynthesisUtterance.boundaryEvent.forTarget(this);
    }
    get [dartx.onEnd]() {
      return html$.SpeechSynthesisUtterance.endEvent.forTarget(this);
    }
    get [dartx.onError]() {
      return html$.SpeechSynthesisUtterance.errorEvent.forTarget(this);
    }
    get [dartx.onMark]() {
      return html$.SpeechSynthesisUtterance.markEvent.forTarget(this);
    }
    get [dartx.onPause]() {
      return html$.SpeechSynthesisUtterance.pauseEvent.forTarget(this);
    }
    get [dartx.onResume]() {
      return html$.SpeechSynthesisUtterance.resumeEvent.forTarget(this);
    }
    get [dartx.onStart]() {
      return html$.SpeechSynthesisUtterance.startEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.SpeechSynthesisUtterance, {
    constructors: () => ({
      _: [html$.SpeechSynthesisUtterance, []],
      new: [html$.SpeechSynthesisUtterance, [], [core.String]]
    }),
    statics: () => ({
      _create_1: [html$.SpeechSynthesisUtterance, [dart.dynamic]],
      _create_2: [html$.SpeechSynthesisUtterance, []]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.SpeechSynthesisUtterance[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SpeechSynthesisUtterance')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("SpeechSynthesisUtterance"))];
  dart.defineLazy(html$.SpeechSynthesisUtterance, {
    get boundaryEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.SpeechSynthesisEvent))('boundary'));
    },
    get endEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.SpeechSynthesisEvent))('end'));
    },
    get errorEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('error'));
    },
    get markEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.SpeechSynthesisEvent))('mark'));
    },
    get pauseEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('pause'));
    },
    get resumeEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.SpeechSynthesisEvent))('resume'));
    },
    get startEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.SpeechSynthesisEvent))('start'));
    }
  });
  dart.registerExtension(dart.global.SpeechSynthesisUtterance, html$.SpeechSynthesisUtterance);
  dart.defineExtensionNames([
    'defaultValue',
    'lang',
    'localService',
    'name',
    'voiceUri'
  ]);
  html$.SpeechSynthesisVoice = class SpeechSynthesisVoice extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.defaultValue]() {
      return this.default;
    }
    get [dartx.lang]() {
      return this.lang;
    }
    get [dartx.localService]() {
      return this.localService;
    }
    get [dartx.name]() {
      return this.name;
    }
    get [dartx.voiceUri]() {
      return this.voiceURI;
    }
  };
  dart.setSignature(html$.SpeechSynthesisVoice, {
    constructors: () => ({_: [html$.SpeechSynthesisVoice, []]})
  });
  html$.SpeechSynthesisVoice[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SpeechSynthesisVoice')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("SpeechSynthesisVoice"))];
  dart.registerExtension(dart.global.SpeechSynthesisVoice, html$.SpeechSynthesisVoice);
  dart.defineExtensionNames([
    'name'
  ]);
  html$.StashedMessagePort = class StashedMessagePort extends html$.MessagePort {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.name]() {
      return this.name;
    }
  };
  dart.setSignature(html$.StashedMessagePort, {
    constructors: () => ({_: [html$.StashedMessagePort, []]})
  });
  html$.StashedMessagePort[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('StashedMessagePort')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("StashedMessagePort"))];
  dart.registerExtension(dart.global.StashedMessagePort, html$.StashedMessagePort);
  dart.defineExtensionNames([
    'add',
    'onMessage'
  ]);
  html$.StashedPortCollection = class StashedPortCollection extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.add](name, port) {
      return this.add(name, port);
    }
    get [dartx.onMessage]() {
      return html$.StashedPortCollection.messageEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.StashedPortCollection, {
    constructors: () => ({_: [html$.StashedPortCollection, []]}),
    methods: () => ({[dartx.add]: [html$.StashedMessagePort, [core.String, html$.MessagePort]]})
  });
  html$.StashedPortCollection[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('StashedPortCollection')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("StashedPortCollection"))];
  dart.defineLazy(html$.StashedPortCollection, {
    get messageEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MessageEvent))('message'));
    }
  });
  dart.registerExtension(dart.global.StashedPortCollection, html$.StashedPortCollection);
  const _getItem = Symbol('_getItem');
  const _setItem = Symbol('_setItem');
  const _removeItem = Symbol('_removeItem');
  const _key$ = Symbol('_key');
  const _length$2 = Symbol('_length');
  const __delete__ = Symbol('__delete__');
  dart.defineExtensionNames([
    'addAll',
    'containsValue',
    'containsKey',
    'get',
    'set',
    'putIfAbsent',
    'remove',
    'clear',
    'forEach',
    'keys',
    'values',
    'length',
    'isEmpty',
    'isNotEmpty'
  ]);
  html$.Storage = class Storage extends _interceptors.Interceptor {
    [dartx.addAll](other) {
      other[dartx.forEach](dart.fn((k, v) => {
        this[dartx.set](k, v);
      }, dart.void, [core.String, core.String]));
    }
    [dartx.containsValue](value) {
      return this[dartx.values][dartx.any](dart.fn(e => dart.equals(e, value), core.bool, [core.String]));
    }
    [dartx.containsKey](key) {
      return this[_getItem](dart.as(key, core.String)) != null;
    }
    [dartx.get](key) {
      return this[_getItem](dart.as(key, core.String));
    }
    [dartx.set](key, value) {
      this[_setItem](key, value);
      return value;
    }
    [dartx.putIfAbsent](key, ifAbsent) {
      if (!dart.notNull(this[dartx.containsKey](key))) this[dartx.set](key, ifAbsent());
      return this[dartx.get](key);
    }
    [dartx.remove](key) {
      let value = this[dartx.get](key);
      this[_removeItem](dart.as(key, core.String));
      return value;
    }
    [dartx.clear]() {
      return this[_clear$1]();
    }
    [dartx.forEach](f) {
      for (let i = 0; true; i++) {
        let key = this[_key$](i);
        if (key == null) return;
        f(key, this[dartx.get](key));
      }
    }
    get [dartx.keys]() {
      let keys = dart.list([], core.String);
      this[dartx.forEach](dart.fn((k, v) => keys[dartx.add](k), dart.void, [core.String, core.String]));
      return keys;
    }
    get [dartx.values]() {
      let values = dart.list([], core.String);
      this[dartx.forEach](dart.fn((k, v) => values[dartx.add](v), dart.void, [core.String, core.String]));
      return values;
    }
    get [dartx.length]() {
      return this[_length$2];
    }
    get [dartx.isEmpty]() {
      return this[_key$](0) == null;
    }
    get [dartx.isNotEmpty]() {
      return !dart.notNull(this[dartx.isEmpty]);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [_length$2]() {
      return this.length;
    }
    [__delete__](index_OR_name) {
      return this.__delete__(index_OR_name);
    }
    [__getter__](index_OR_name) {
      return this.__getter__(index_OR_name);
    }
    [__setter__](index_OR_name, value) {
      return this.__setter__(index_OR_name, value);
    }
    [_clear$1]() {
      return this.clear();
    }
    [_getItem](key) {
      return this.getItem(key);
    }
    [_key$](index) {
      return this.key(index);
    }
    [_removeItem](key) {
      return this.removeItem(key);
    }
    [_setItem](key, data) {
      return this.setItem(key, data);
    }
  };
  html$.Storage[dart.implements] = () => [core.Map$(core.String, core.String)];
  dart.setSignature(html$.Storage, {
    constructors: () => ({_: [html$.Storage, []]}),
    methods: () => ({
      [dartx.addAll]: [dart.void, [core.Map$(core.String, core.String)]],
      [dartx.containsValue]: [core.bool, [core.Object]],
      [dartx.containsKey]: [core.bool, [core.Object]],
      [dartx.get]: [core.String, [core.Object]],
      [dartx.set]: [dart.void, [core.String, core.String]],
      [dartx.putIfAbsent]: [core.String, [core.String, dart.functionType(core.String, [])]],
      [dartx.remove]: [core.String, [core.Object]],
      [dartx.clear]: [dart.void, []],
      [dartx.forEach]: [dart.void, [dart.functionType(dart.void, [core.String, core.String])]],
      [__delete__]: [core.bool, [dart.dynamic]],
      [__getter__]: [core.String, [dart.dynamic]],
      [__setter__]: [dart.void, [dart.dynamic, core.String]],
      [_clear$1]: [dart.void, []],
      [_getItem]: [core.String, [core.String]],
      [_key$]: [core.String, [core.int]],
      [_removeItem]: [dart.void, [core.String]],
      [_setItem]: [dart.void, [core.String, core.String]]
    })
  });
  html$.Storage[dart.metadata] = () => [dart.const(new _metadata.DomName('Storage')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("Storage"))];
  dart.registerExtension(dart.global.Storage, html$.Storage);
  html$.StorageErrorCallback = dart.typedef('StorageErrorCallback', () => dart.functionType(dart.void, [html$.DomError]));
  const _initStorageEvent = Symbol('_initStorageEvent');
  dart.defineExtensionNames([
    'key',
    'newValue',
    'oldValue',
    'storageArea',
    'url'
  ]);
  html$.StorageEvent = class StorageEvent extends html$.Event {
    static new(type, opts) {
      let canBubble = opts && 'canBubble' in opts ? opts.canBubble : false;
      let cancelable = opts && 'cancelable' in opts ? opts.cancelable : false;
      let key = opts && 'key' in opts ? opts.key : null;
      let oldValue = opts && 'oldValue' in opts ? opts.oldValue : null;
      let newValue = opts && 'newValue' in opts ? opts.newValue : null;
      let url = opts && 'url' in opts ? opts.url : null;
      let storageArea = opts && 'storageArea' in opts ? opts.storageArea : null;
      let e = dart.as(html$.document[_createEvent]("StorageEvent"), html$.StorageEvent);
      e[_initStorageEvent](type, canBubble, cancelable, key, oldValue, newValue, url, storageArea);
      return e;
    }
    static _(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.StorageEvent._create_1(type, eventInitDict_1);
      }
      return html$.StorageEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new StorageEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new StorageEvent(type);
    }
    get [dartx.key]() {
      return this.key;
    }
    get [dartx.newValue]() {
      return this.newValue;
    }
    get [dartx.oldValue]() {
      return this.oldValue;
    }
    get [dartx.storageArea]() {
      return this.storageArea;
    }
    get [dartx.url]() {
      return this.url;
    }
    [_initStorageEvent](typeArg, canBubbleArg, cancelableArg, keyArg, oldValueArg, newValueArg, urlArg, storageAreaArg) {
      return this.initStorageEvent(typeArg, canBubbleArg, cancelableArg, keyArg, oldValueArg, newValueArg, urlArg, storageAreaArg);
    }
  };
  dart.setSignature(html$.StorageEvent, {
    constructors: () => ({
      new: [html$.StorageEvent, [core.String], {canBubble: core.bool, cancelable: core.bool, key: core.String, oldValue: core.String, newValue: core.String, url: core.String, storageArea: html$.Storage}],
      _: [html$.StorageEvent, [core.String], [core.Map]]
    }),
    methods: () => ({[_initStorageEvent]: [dart.void, [core.String, core.bool, core.bool, core.String, core.String, core.String, core.String, html$.Storage]]}),
    statics: () => ({
      _create_1: [html$.StorageEvent, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.StorageEvent, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.StorageEvent[dart.metadata] = () => [dart.const(new _metadata.DomName('StorageEvent')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("StorageEvent"))];
  dart.registerExtension(dart.global.StorageEvent, html$.StorageEvent);
  dart.defineExtensionNames([
    'quota',
    'usage'
  ]);
  html$.StorageInfo = class StorageInfo extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.quota]() {
      return this.quota;
    }
    get [dartx.usage]() {
      return this.usage;
    }
  };
  dart.setSignature(html$.StorageInfo, {
    constructors: () => ({_: [html$.StorageInfo, []]})
  });
  html$.StorageInfo[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('StorageInfo')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("StorageInfo"))];
  dart.registerExtension(dart.global.StorageInfo, html$.StorageInfo);
  dart.defineExtensionNames([
    'queryInfo',
    'requestPersistentQuota',
    'supportedTypes'
  ]);
  html$.StorageQuota = class StorageQuota extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.supportedTypes]() {
      return this.supportedTypes;
    }
    [dartx.queryInfo](type) {
      return this.queryInfo(type);
    }
    [dartx.requestPersistentQuota](newQuota) {
      return this.requestPersistentQuota(newQuota);
    }
  };
  dart.setSignature(html$.StorageQuota, {
    constructors: () => ({_: [html$.StorageQuota, []]}),
    methods: () => ({
      [dartx.queryInfo]: [async.Future, [core.String]],
      [dartx.requestPersistentQuota]: [async.Future, [core.int]]
    })
  });
  html$.StorageQuota[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('StorageQuota')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("StorageQuota"))];
  dart.registerExtension(dart.global.StorageQuota, html$.StorageQuota);
  html$.StorageQuotaCallback = dart.typedef('StorageQuotaCallback', () => dart.functionType(dart.void, [core.int]));
  html$.StorageUsageCallback = dart.typedef('StorageUsageCallback', () => dart.functionType(dart.void, [core.int, core.int]));
  html$._StringCallback = dart.typedef('_StringCallback', () => dart.functionType(dart.void, [core.String]));
  dart.defineExtensionNames([
    'disabled',
    'media',
    'sheet',
    'type'
  ]);
  html$.StyleElement = class StyleElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("style"), html$.StyleElement);
    }
    created() {
      this[dartx.disabled] = null;
      this[dartx.media] = null;
      this[dartx.sheet] = null;
      this[dartx.type] = null;
      super.created();
    }
    get [dartx.disabled]() {
      return this.disabled;
    }
    set [dartx.disabled](value) {
      this.disabled = value;
    }
    get [dartx.media]() {
      return this.media;
    }
    set [dartx.media](value) {
      this.media = value;
    }
    get [dartx.sheet]() {
      return this.sheet;
    }
    get [dartx.type]() {
      return this.type;
    }
    set [dartx.type](value) {
      this.type = value;
    }
  };
  dart.defineNamedConstructor(html$.StyleElement, 'created');
  dart.setSignature(html$.StyleElement, {
    constructors: () => ({
      _: [html$.StyleElement, []],
      new: [html$.StyleElement, []],
      created: [html$.StyleElement, []]
    })
  });
  html$.StyleElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLStyleElement')), dart.const(new _js_helper.Native("HTMLStyleElement"))];
  dart.registerExtension(dart.global.HTMLStyleElement, html$.StyleElement);
  dart.defineExtensionNames([
    'matchMedium',
    'type'
  ]);
  html$.StyleMedia = class StyleMedia extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.type]() {
      return this.type;
    }
    [dartx.matchMedium](mediaquery) {
      return this.matchMedium(mediaquery);
    }
  };
  dart.setSignature(html$.StyleMedia, {
    constructors: () => ({_: [html$.StyleMedia, []]}),
    methods: () => ({[dartx.matchMedium]: [core.bool, [core.String]]})
  });
  html$.StyleMedia[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('StyleMedia')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("StyleMedia"))];
  dart.registerExtension(dart.global.StyleMedia, html$.StyleMedia);
  dart.defineExtensionNames([
    'registration'
  ]);
  html$.SyncEvent = class SyncEvent extends html$.ExtendableEvent {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, init) {
      let init_1 = html_common.convertDartToNative_Dictionary(init);
      return html$.SyncEvent._create_1(type, init_1);
    }
    static _create_1(type, init) {
      return new SyncEvent(type, init);
    }
    get [dartx.registration]() {
      return this.registration;
    }
  };
  dart.setSignature(html$.SyncEvent, {
    constructors: () => ({
      _: [html$.SyncEvent, []],
      new: [html$.SyncEvent, [core.String, core.Map]]
    }),
    statics: () => ({_create_1: [html$.SyncEvent, [dart.dynamic, dart.dynamic]]}),
    names: ['_create_1']
  });
  html$.SyncEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SyncEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("SyncEvent"))];
  dart.registerExtension(dart.global.SyncEvent, html$.SyncEvent);
  dart.defineExtensionNames([
    'getRegistration',
    'getRegistrations',
    'permissionState',
    'register'
  ]);
  html$.SyncManager = class SyncManager extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.getRegistration](tag) {
      return this.getRegistration(tag);
    }
    [dartx.getRegistrations]() {
      return this.getRegistrations();
    }
    [dartx.permissionState]() {
      return this.permissionState();
    }
    [dartx.register](options) {
      if (options === void 0) options = null;
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        return this[_register_1](options_1);
      }
      return this[_register_2]();
    }
    [_register_1](options) {
      return this.register(options);
    }
    [_register_2]() {
      return this.register();
    }
  };
  dart.setSignature(html$.SyncManager, {
    constructors: () => ({_: [html$.SyncManager, []]}),
    methods: () => ({
      [dartx.getRegistration]: [async.Future, [core.String]],
      [dartx.getRegistrations]: [async.Future, []],
      [dartx.permissionState]: [async.Future, []],
      [dartx.register]: [async.Future, [], [core.Map]],
      [_register_1]: [async.Future, [dart.dynamic]],
      [_register_2]: [async.Future, []]
    })
  });
  html$.SyncManager[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SyncManager')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("SyncManager"))];
  dart.registerExtension(dart.global.SyncManager, html$.SyncManager);
  dart.defineExtensionNames([
    'unregister',
    'tag'
  ]);
  html$.SyncRegistration = class SyncRegistration extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.tag]() {
      return this.tag;
    }
    [dartx.unregister]() {
      return this.unregister();
    }
  };
  dart.setSignature(html$.SyncRegistration, {
    constructors: () => ({_: [html$.SyncRegistration, []]}),
    methods: () => ({[dartx.unregister]: [async.Future, []]})
  });
  html$.SyncRegistration[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SyncRegistration')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("SyncRegistration"))];
  dart.registerExtension(dart.global.SyncRegistration, html$.SyncRegistration);
  html$.TableCaptionElement = class TableCaptionElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("caption"), html$.TableCaptionElement);
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(html$.TableCaptionElement, 'created');
  dart.setSignature(html$.TableCaptionElement, {
    constructors: () => ({
      _: [html$.TableCaptionElement, []],
      new: [html$.TableCaptionElement, []],
      created: [html$.TableCaptionElement, []]
    })
  });
  html$.TableCaptionElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLTableCaptionElement')), dart.const(new _js_helper.Native("HTMLTableCaptionElement"))];
  dart.registerExtension(dart.global.HTMLTableCaptionElement, html$.TableCaptionElement);
  dart.defineExtensionNames([
    'cellIndex',
    'colSpan',
    'headers',
    'rowSpan'
  ]);
  html$.TableCellElement = class TableCellElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("td"), html$.TableCellElement);
    }
    created() {
      this[dartx.cellIndex] = null;
      this[dartx.colSpan] = null;
      this[dartx.headers] = null;
      this[dartx.rowSpan] = null;
      super.created();
    }
    get [dartx.cellIndex]() {
      return this.cellIndex;
    }
    get [dartx.colSpan]() {
      return this.colSpan;
    }
    set [dartx.colSpan](value) {
      this.colSpan = value;
    }
    get [dartx.headers]() {
      return this.headers;
    }
    set [dartx.headers](value) {
      this.headers = value;
    }
    get [dartx.rowSpan]() {
      return this.rowSpan;
    }
    set [dartx.rowSpan](value) {
      this.rowSpan = value;
    }
  };
  dart.defineNamedConstructor(html$.TableCellElement, 'created');
  dart.setSignature(html$.TableCellElement, {
    constructors: () => ({
      _: [html$.TableCellElement, []],
      new: [html$.TableCellElement, []],
      created: [html$.TableCellElement, []]
    })
  });
  html$.TableCellElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLTableCellElement')), dart.const(new _js_helper.Native("HTMLTableCellElement,HTMLTableDataCellElement,HTMLTableHeaderCellElement"))];
  dart.registerExtension(dart.global.HTMLTableCellElement, html$.TableCellElement);
  dart.defineExtensionNames([
    'span'
  ]);
  html$.TableColElement = class TableColElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("col"), html$.TableColElement);
    }
    created() {
      this[dartx.span] = null;
      super.created();
    }
    get [dartx.span]() {
      return this.span;
    }
    set [dartx.span](value) {
      this.span = value;
    }
  };
  dart.defineNamedConstructor(html$.TableColElement, 'created');
  dart.setSignature(html$.TableColElement, {
    constructors: () => ({
      _: [html$.TableColElement, []],
      new: [html$.TableColElement, []],
      created: [html$.TableColElement, []]
    })
  });
  html$.TableColElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLTableColElement')), dart.const(new _js_helper.Native("HTMLTableColElement"))];
  dart.registerExtension(dart.global.HTMLTableColElement, html$.TableColElement);
  const _tBodies = Symbol('_tBodies');
  const _rows = Symbol('_rows');
  const _createCaption = Symbol('_createCaption');
  const _createTBody = Symbol('_createTBody');
  const _createTFoot = Symbol('_createTFoot');
  const _createTHead = Symbol('_createTHead');
  const _insertRow = Symbol('_insertRow');
  const _nativeCreateTBody = Symbol('_nativeCreateTBody');
  dart.defineExtensionNames([
    'tBodies',
    'rows',
    'addRow',
    'createCaption',
    'createTBody',
    'createTFoot',
    'createTHead',
    'insertRow',
    'createFragment',
    'deleteCaption',
    'deleteRow',
    'deleteTFoot',
    'deleteTHead',
    'caption',
    'tFoot',
    'tHead'
  ]);
  html$.TableElement = class TableElement extends html$.HtmlElement {
    get [dartx.tBodies]() {
      return new (html$._WrappedList$(html$.TableSectionElement))(this[_tBodies]);
    }
    get [dartx.rows]() {
      return new (html$._WrappedList$(html$.TableRowElement))(this[_rows]);
    }
    [dartx.addRow]() {
      return this[dartx.insertRow](-1);
    }
    [dartx.createCaption]() {
      return dart.as(this[_createCaption](), html$.TableCaptionElement);
    }
    [dartx.createTBody]() {
      return this[_createTBody]();
    }
    [dartx.createTFoot]() {
      return dart.as(this[_createTFoot](), html$.TableSectionElement);
    }
    [dartx.createTHead]() {
      return dart.as(this[_createTHead](), html$.TableSectionElement);
    }
    [dartx.insertRow](index) {
      return dart.as(this[_insertRow](index), html$.TableRowElement);
    }
    [_createTBody]() {
      if (!!this.createTBody) {
        return this[_nativeCreateTBody]();
      }
      let tbody = html$.Element.tag('tbody');
      this[dartx.children][dartx.add](tbody);
      return dart.as(tbody, html$.TableSectionElement);
    }
    [_nativeCreateTBody]() {
      return this.createTBody();
    }
    [dartx.createFragment](html, opts) {
      let validator = opts && 'validator' in opts ? opts.validator : null;
      let treeSanitizer = opts && 'treeSanitizer' in opts ? opts.treeSanitizer : null;
      if (dart.notNull(html$.Range.supportsCreateContextualFragment)) {
        return super[dartx.createFragment](html, {validator: validator, treeSanitizer: treeSanitizer});
      }
      let contextualHtml = `<table>${html}</table>`;
      let table = html$.Element.html(contextualHtml, {validator: validator, treeSanitizer: treeSanitizer});
      let fragment = html$.DocumentFragment.new();
      fragment[dartx.nodes][dartx.addAll](table[dartx.nodes]);
      return fragment;
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("table"), html$.TableElement);
    }
    created() {
      this[dartx.caption] = null;
      this[_rows] = null;
      this[_tBodies] = null;
      this[dartx.tFoot] = null;
      this[dartx.tHead] = null;
      super.created();
    }
    get [dartx.caption]() {
      return this.caption;
    }
    set [dartx.caption](value) {
      this.caption = value;
    }
    get [_rows]() {
      return this.rows;
    }
    get [_tBodies]() {
      return this.tBodies;
    }
    get [dartx.tFoot]() {
      return this.tFoot;
    }
    set [dartx.tFoot](value) {
      this.tFoot = value;
    }
    get [dartx.tHead]() {
      return this.tHead;
    }
    set [dartx.tHead](value) {
      this.tHead = value;
    }
    [_createCaption]() {
      return this.createCaption();
    }
    [_createTFoot]() {
      return this.createTFoot();
    }
    [_createTHead]() {
      return this.createTHead();
    }
    [dartx.deleteCaption]() {
      return this.deleteCaption();
    }
    [dartx.deleteRow](index) {
      return this.deleteRow(index);
    }
    [dartx.deleteTFoot]() {
      return this.deleteTFoot();
    }
    [dartx.deleteTHead]() {
      return this.deleteTHead();
    }
    [_insertRow](index) {
      return this.insertRow(index);
    }
  };
  dart.defineNamedConstructor(html$.TableElement, 'created');
  dart.setSignature(html$.TableElement, {
    constructors: () => ({
      _: [html$.TableElement, []],
      new: [html$.TableElement, []],
      created: [html$.TableElement, []]
    }),
    methods: () => ({
      [dartx.addRow]: [html$.TableRowElement, []],
      [dartx.createCaption]: [html$.TableCaptionElement, []],
      [dartx.createTBody]: [html$.TableSectionElement, []],
      [dartx.createTFoot]: [html$.TableSectionElement, []],
      [dartx.createTHead]: [html$.TableSectionElement, []],
      [dartx.insertRow]: [html$.TableRowElement, [core.int]],
      [_createTBody]: [html$.TableSectionElement, []],
      [_nativeCreateTBody]: [html$.TableSectionElement, []],
      [_createCaption]: [html$.HtmlElement, []],
      [_createTFoot]: [html$.HtmlElement, []],
      [_createTHead]: [html$.HtmlElement, []],
      [dartx.deleteCaption]: [dart.void, []],
      [dartx.deleteRow]: [dart.void, [core.int]],
      [dartx.deleteTFoot]: [dart.void, []],
      [dartx.deleteTHead]: [dart.void, []],
      [_insertRow]: [html$.HtmlElement, [], [core.int]]
    })
  });
  html$.TableElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLTableElement')), dart.const(new _js_helper.Native("HTMLTableElement"))];
  dart.registerExtension(dart.global.HTMLTableElement, html$.TableElement);
  const _cells = Symbol('_cells');
  const _insertCell = Symbol('_insertCell');
  dart.defineExtensionNames([
    'cells',
    'addCell',
    'insertCell',
    'createFragment',
    'deleteCell',
    'rowIndex',
    'sectionRowIndex'
  ]);
  html$.TableRowElement = class TableRowElement extends html$.HtmlElement {
    get [dartx.cells]() {
      return new (html$._WrappedList$(html$.TableCellElement))(this[_cells]);
    }
    [dartx.addCell]() {
      return this[dartx.insertCell](-1);
    }
    [dartx.insertCell](index) {
      return dart.as(this[_insertCell](index), html$.TableCellElement);
    }
    [dartx.createFragment](html, opts) {
      let validator = opts && 'validator' in opts ? opts.validator : null;
      let treeSanitizer = opts && 'treeSanitizer' in opts ? opts.treeSanitizer : null;
      if (dart.notNull(html$.Range.supportsCreateContextualFragment)) {
        return super[dartx.createFragment](html, {validator: validator, treeSanitizer: treeSanitizer});
      }
      let fragment = html$.DocumentFragment.new();
      let section = html$.TableElement.new()[dartx.createFragment](html, {validator: validator, treeSanitizer: treeSanitizer})[dartx.nodes][dartx.single];
      let row = section[dartx.nodes][dartx.single];
      fragment[dartx.nodes][dartx.addAll](row[dartx.nodes]);
      return fragment;
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("tr"), html$.TableRowElement);
    }
    created() {
      this[_cells] = null;
      this[dartx.rowIndex] = null;
      this[dartx.sectionRowIndex] = null;
      super.created();
    }
    get [_cells]() {
      return this.cells;
    }
    get [dartx.rowIndex]() {
      return this.rowIndex;
    }
    get [dartx.sectionRowIndex]() {
      return this.sectionRowIndex;
    }
    [dartx.deleteCell](index) {
      return this.deleteCell(index);
    }
    [_insertCell](index) {
      return this.insertCell(index);
    }
  };
  dart.defineNamedConstructor(html$.TableRowElement, 'created');
  dart.setSignature(html$.TableRowElement, {
    constructors: () => ({
      _: [html$.TableRowElement, []],
      new: [html$.TableRowElement, []],
      created: [html$.TableRowElement, []]
    }),
    methods: () => ({
      [dartx.addCell]: [html$.TableCellElement, []],
      [dartx.insertCell]: [html$.TableCellElement, [core.int]],
      [dartx.deleteCell]: [dart.void, [core.int]],
      [_insertCell]: [html$.HtmlElement, [], [core.int]]
    })
  });
  html$.TableRowElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLTableRowElement')), dart.const(new _js_helper.Native("HTMLTableRowElement"))];
  dart.registerExtension(dart.global.HTMLTableRowElement, html$.TableRowElement);
  dart.defineExtensionNames([
    'rows',
    'addRow',
    'insertRow',
    'createFragment',
    'deleteRow'
  ]);
  html$.TableSectionElement = class TableSectionElement extends html$.HtmlElement {
    get [dartx.rows]() {
      return new (html$._WrappedList$(html$.TableRowElement))(this[_rows]);
    }
    [dartx.addRow]() {
      return this[dartx.insertRow](-1);
    }
    [dartx.insertRow](index) {
      return dart.as(this[_insertRow](index), html$.TableRowElement);
    }
    [dartx.createFragment](html, opts) {
      let validator = opts && 'validator' in opts ? opts.validator : null;
      let treeSanitizer = opts && 'treeSanitizer' in opts ? opts.treeSanitizer : null;
      if (dart.notNull(html$.Range.supportsCreateContextualFragment)) {
        return super[dartx.createFragment](html, {validator: validator, treeSanitizer: treeSanitizer});
      }
      let fragment = html$.DocumentFragment.new();
      let section = html$.TableElement.new()[dartx.createFragment](html, {validator: validator, treeSanitizer: treeSanitizer})[dartx.nodes][dartx.single];
      fragment[dartx.nodes][dartx.addAll](section[dartx.nodes]);
      return fragment;
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      this[_rows] = null;
      super.created();
    }
    get [_rows]() {
      return this.rows;
    }
    [dartx.deleteRow](index) {
      return this.deleteRow(index);
    }
    [_insertRow](index) {
      return this.insertRow(index);
    }
  };
  dart.defineNamedConstructor(html$.TableSectionElement, 'created');
  dart.setSignature(html$.TableSectionElement, {
    constructors: () => ({
      _: [html$.TableSectionElement, []],
      created: [html$.TableSectionElement, []]
    }),
    methods: () => ({
      [dartx.addRow]: [html$.TableRowElement, []],
      [dartx.insertRow]: [html$.TableRowElement, [core.int]],
      [dartx.deleteRow]: [dart.void, [core.int]],
      [_insertRow]: [html$.HtmlElement, [], [core.int]]
    })
  });
  html$.TableSectionElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLTableSectionElement')), dart.const(new _js_helper.Native("HTMLTableSectionElement"))];
  dart.registerExtension(dart.global.HTMLTableSectionElement, html$.TableSectionElement);
  dart.defineExtensionNames([
    'setInnerHtml',
    'content'
  ]);
  html$.TemplateElement = class TemplateElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("template"), html$.TemplateElement);
    }
    created() {
      this[dartx.content] = null;
      super.created();
    }
    static get supported() {
      return html$.Element.isTagSupported('template');
    }
    get [dartx.content]() {
      return this.content;
    }
    [dartx.setInnerHtml](html, opts) {
      let validator = opts && 'validator' in opts ? opts.validator : null;
      let treeSanitizer = opts && 'treeSanitizer' in opts ? opts.treeSanitizer : null;
      this[dartx.text] = null;
      let fragment = this[dartx.createFragment](html, {validator: validator, treeSanitizer: treeSanitizer});
      this[dartx.content][dartx.append](fragment);
    }
  };
  dart.defineNamedConstructor(html$.TemplateElement, 'created');
  dart.setSignature(html$.TemplateElement, {
    constructors: () => ({
      _: [html$.TemplateElement, []],
      new: [html$.TemplateElement, []],
      created: [html$.TemplateElement, []]
    })
  });
  html$.TemplateElement[dart.metadata] = () => [dart.const(new _metadata.Experimental()), dart.const(new _metadata.DomName('HTMLTemplateElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("HTMLTemplateElement"))];
  dart.registerExtension(dart.global.HTMLTemplateElement, html$.TemplateElement);
  dart.defineExtensionNames([
    'checkValidity',
    'reportValidity',
    'select',
    'setCustomValidity',
    'setRangeText',
    'setSelectionRange',
    'autocapitalize',
    'autofocus',
    'cols',
    'defaultValue',
    'dirName',
    'disabled',
    'form',
    'inputMode',
    'labels',
    'maxLength',
    'minLength',
    'name',
    'placeholder',
    'readOnly',
    'required',
    'rows',
    'selectionDirection',
    'selectionEnd',
    'selectionStart',
    'textLength',
    'type',
    'validationMessage',
    'validity',
    'value',
    'willValidate',
    'wrap'
  ]);
  html$.TextAreaElement = class TextAreaElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("textarea"), html$.TextAreaElement);
    }
    created() {
      this[dartx.autocapitalize] = null;
      this[dartx.autofocus] = null;
      this[dartx.cols] = null;
      this[dartx.defaultValue] = null;
      this[dartx.dirName] = null;
      this[dartx.disabled] = null;
      this[dartx.form] = null;
      this[dartx.inputMode] = null;
      this[dartx.labels] = null;
      this[dartx.maxLength] = null;
      this[dartx.minLength] = null;
      this[dartx.name] = null;
      this[dartx.placeholder] = null;
      this[dartx.readOnly] = null;
      this[dartx.required] = null;
      this[dartx.rows] = null;
      this[dartx.selectionDirection] = null;
      this[dartx.selectionEnd] = null;
      this[dartx.selectionStart] = null;
      this[dartx.textLength] = null;
      this[dartx.type] = null;
      this[dartx.validationMessage] = null;
      this[dartx.validity] = null;
      this[dartx.value] = null;
      this[dartx.willValidate] = null;
      this[dartx.wrap] = null;
      super.created();
    }
    get [dartx.autocapitalize]() {
      return this.autocapitalize;
    }
    set [dartx.autocapitalize](value) {
      this.autocapitalize = value;
    }
    get [dartx.autofocus]() {
      return this.autofocus;
    }
    set [dartx.autofocus](value) {
      this.autofocus = value;
    }
    get [dartx.cols]() {
      return this.cols;
    }
    set [dartx.cols](value) {
      this.cols = value;
    }
    get [dartx.defaultValue]() {
      return this.defaultValue;
    }
    set [dartx.defaultValue](value) {
      this.defaultValue = value;
    }
    get [dartx.dirName]() {
      return this.dirName;
    }
    set [dartx.dirName](value) {
      this.dirName = value;
    }
    get [dartx.disabled]() {
      return this.disabled;
    }
    set [dartx.disabled](value) {
      this.disabled = value;
    }
    get [dartx.form]() {
      return this.form;
    }
    get [dartx.inputMode]() {
      return this.inputMode;
    }
    set [dartx.inputMode](value) {
      this.inputMode = value;
    }
    get [dartx.labels]() {
      return this.labels;
    }
    get [dartx.maxLength]() {
      return this.maxLength;
    }
    set [dartx.maxLength](value) {
      this.maxLength = value;
    }
    get [dartx.minLength]() {
      return this.minLength;
    }
    set [dartx.minLength](value) {
      this.minLength = value;
    }
    get [dartx.name]() {
      return this.name;
    }
    set [dartx.name](value) {
      this.name = value;
    }
    get [dartx.placeholder]() {
      return this.placeholder;
    }
    set [dartx.placeholder](value) {
      this.placeholder = value;
    }
    get [dartx.readOnly]() {
      return this.readOnly;
    }
    set [dartx.readOnly](value) {
      this.readOnly = value;
    }
    get [dartx.required]() {
      return this.required;
    }
    set [dartx.required](value) {
      this.required = value;
    }
    get [dartx.rows]() {
      return this.rows;
    }
    set [dartx.rows](value) {
      this.rows = value;
    }
    get [dartx.selectionDirection]() {
      return this.selectionDirection;
    }
    set [dartx.selectionDirection](value) {
      this.selectionDirection = value;
    }
    get [dartx.selectionEnd]() {
      return this.selectionEnd;
    }
    set [dartx.selectionEnd](value) {
      this.selectionEnd = value;
    }
    get [dartx.selectionStart]() {
      return this.selectionStart;
    }
    set [dartx.selectionStart](value) {
      this.selectionStart = value;
    }
    get [dartx.textLength]() {
      return this.textLength;
    }
    get [dartx.type]() {
      return this.type;
    }
    get [dartx.validationMessage]() {
      return this.validationMessage;
    }
    get [dartx.validity]() {
      return this.validity;
    }
    get [dartx.value]() {
      return this.value;
    }
    set [dartx.value](value) {
      this.value = value;
    }
    get [dartx.willValidate]() {
      return this.willValidate;
    }
    get [dartx.wrap]() {
      return this.wrap;
    }
    set [dartx.wrap](value) {
      this.wrap = value;
    }
    [dartx.checkValidity]() {
      return this.checkValidity();
    }
    [dartx.reportValidity]() {
      return this.reportValidity();
    }
    [dartx.select]() {
      return this.select();
    }
    [dartx.setCustomValidity](error) {
      return this.setCustomValidity(error);
    }
    [dartx.setRangeText](replacement, opts) {
      return this.setRangeText(replacement, opts);
    }
    [dartx.setSelectionRange](start, end, direction) {
      return this.setSelectionRange(start, end, direction);
    }
  };
  dart.defineNamedConstructor(html$.TextAreaElement, 'created');
  dart.setSignature(html$.TextAreaElement, {
    constructors: () => ({
      _: [html$.TextAreaElement, []],
      new: [html$.TextAreaElement, []],
      created: [html$.TextAreaElement, []]
    }),
    methods: () => ({
      [dartx.checkValidity]: [core.bool, []],
      [dartx.reportValidity]: [core.bool, []],
      [dartx.select]: [dart.void, []],
      [dartx.setCustomValidity]: [dart.void, [core.String]],
      [dartx.setRangeText]: [dart.void, [core.String], {start: core.int, end: core.int, selectionMode: core.String}],
      [dartx.setSelectionRange]: [dart.void, [core.int, core.int], [core.String]]
    })
  });
  html$.TextAreaElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLTextAreaElement')), dart.const(new _js_helper.Native("HTMLTextAreaElement"))];
  dart.registerExtension(dart.global.HTMLTextAreaElement, html$.TextAreaElement);
  const _initTextEvent = Symbol('_initTextEvent');
  dart.defineExtensionNames([
    'data'
  ]);
  html$.TextEvent = class TextEvent extends html$.UIEvent {
    static new(type, opts) {
      let canBubble = opts && 'canBubble' in opts ? opts.canBubble : false;
      let cancelable = opts && 'cancelable' in opts ? opts.cancelable : false;
      let view = opts && 'view' in opts ? opts.view : null;
      let data = opts && 'data' in opts ? opts.data : null;
      if (view == null) {
        view = html$.window;
      }
      let e = dart.as(html$.document[_createEvent]("TextEvent"), html$.TextEvent);
      e[_initTextEvent](type, canBubble, cancelable, view, data);
      return e;
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.data]() {
      return this.data;
    }
    [_initTextEvent](typeArg, canBubbleArg, cancelableArg, viewArg, dataArg) {
      return this.initTextEvent(typeArg, canBubbleArg, cancelableArg, viewArg, dataArg);
    }
  };
  dart.setSignature(html$.TextEvent, {
    constructors: () => ({
      new: [html$.TextEvent, [core.String], {canBubble: core.bool, cancelable: core.bool, view: html$.Window, data: core.String}],
      _: [html$.TextEvent, []]
    }),
    methods: () => ({[_initTextEvent]: [dart.void, [core.String, core.bool, core.bool, html$.Window, core.String]]})
  });
  html$.TextEvent[dart.metadata] = () => [dart.const(new _metadata.DomName('TextEvent')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("TextEvent"))];
  dart.registerExtension(dart.global.TextEvent, html$.TextEvent);
  dart.defineExtensionNames([
    'actualBoundingBoxAscent',
    'actualBoundingBoxDescent',
    'actualBoundingBoxLeft',
    'actualBoundingBoxRight',
    'alphabeticBaseline',
    'emHeightAscent',
    'emHeightDescent',
    'fontBoundingBoxAscent',
    'fontBoundingBoxDescent',
    'hangingBaseline',
    'ideographicBaseline',
    'width'
  ]);
  html$.TextMetrics = class TextMetrics extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.actualBoundingBoxAscent]() {
      return this.actualBoundingBoxAscent;
    }
    get [dartx.actualBoundingBoxDescent]() {
      return this.actualBoundingBoxDescent;
    }
    get [dartx.actualBoundingBoxLeft]() {
      return this.actualBoundingBoxLeft;
    }
    get [dartx.actualBoundingBoxRight]() {
      return this.actualBoundingBoxRight;
    }
    get [dartx.alphabeticBaseline]() {
      return this.alphabeticBaseline;
    }
    get [dartx.emHeightAscent]() {
      return this.emHeightAscent;
    }
    get [dartx.emHeightDescent]() {
      return this.emHeightDescent;
    }
    get [dartx.fontBoundingBoxAscent]() {
      return this.fontBoundingBoxAscent;
    }
    get [dartx.fontBoundingBoxDescent]() {
      return this.fontBoundingBoxDescent;
    }
    get [dartx.hangingBaseline]() {
      return this.hangingBaseline;
    }
    get [dartx.ideographicBaseline]() {
      return this.ideographicBaseline;
    }
    get [dartx.width]() {
      return this.width;
    }
  };
  dart.setSignature(html$.TextMetrics, {
    constructors: () => ({_: [html$.TextMetrics, []]})
  });
  html$.TextMetrics[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('TextMetrics')), dart.const(new _js_helper.Native("TextMetrics"))];
  dart.registerExtension(dart.global.TextMetrics, html$.TextMetrics);
  dart.defineExtensionNames([
    'addCue',
    'addRegion',
    'removeCue',
    'removeRegion',
    'onCueChange',
    'activeCues',
    'cues',
    'id',
    'kind',
    'label',
    'language',
    'mode',
    'regions'
  ]);
  html$.TextTrack = class TextTrack extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.activeCues]() {
      return this.activeCues;
    }
    get [dartx.cues]() {
      return this.cues;
    }
    get [dartx.id]() {
      return this.id;
    }
    get [dartx.kind]() {
      return this.kind;
    }
    get [dartx.label]() {
      return this.label;
    }
    get [dartx.language]() {
      return this.language;
    }
    get [dartx.mode]() {
      return this.mode;
    }
    set [dartx.mode](value) {
      this.mode = value;
    }
    get [dartx.regions]() {
      return this.regions;
    }
    [dartx.addCue](cue) {
      return this.addCue(cue);
    }
    [dartx.addRegion](region) {
      return this.addRegion(region);
    }
    [dartx.removeCue](cue) {
      return this.removeCue(cue);
    }
    [dartx.removeRegion](region) {
      return this.removeRegion(region);
    }
    get [dartx.onCueChange]() {
      return html$.TextTrack.cueChangeEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.TextTrack, {
    constructors: () => ({_: [html$.TextTrack, []]}),
    methods: () => ({
      [dartx.addCue]: [dart.void, [html$.TextTrackCue]],
      [dartx.addRegion]: [dart.void, [html$.VttRegion]],
      [dartx.removeCue]: [dart.void, [html$.TextTrackCue]],
      [dartx.removeRegion]: [dart.void, [html$.VttRegion]]
    })
  });
  html$.TextTrack[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('TextTrack')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("TextTrack"))];
  dart.defineLazy(html$.TextTrack, {
    get cueChangeEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('cuechange'));
    }
  });
  dart.registerExtension(dart.global.TextTrack, html$.TextTrack);
  dart.defineExtensionNames([
    'onEnter',
    'onExit',
    'endTime',
    'id',
    'pauseOnExit',
    'startTime',
    'track'
  ]);
  html$.TextTrackCue = class TextTrackCue extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.endTime]() {
      return this.endTime;
    }
    set [dartx.endTime](value) {
      this.endTime = value;
    }
    get [dartx.id]() {
      return this.id;
    }
    set [dartx.id](value) {
      this.id = value;
    }
    get [dartx.pauseOnExit]() {
      return this.pauseOnExit;
    }
    set [dartx.pauseOnExit](value) {
      this.pauseOnExit = value;
    }
    get [dartx.startTime]() {
      return this.startTime;
    }
    set [dartx.startTime](value) {
      this.startTime = value;
    }
    get [dartx.track]() {
      return this.track;
    }
    get [dartx.onEnter]() {
      return html$.TextTrackCue.enterEvent.forTarget(this);
    }
    get [dartx.onExit]() {
      return html$.TextTrackCue.exitEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.TextTrackCue, {
    constructors: () => ({_: [html$.TextTrackCue, []]})
  });
  html$.TextTrackCue[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('TextTrackCue')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("TextTrackCue"))];
  dart.defineLazy(html$.TextTrackCue, {
    get enterEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('enter'));
    },
    get exitEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('exit'));
    }
  });
  dart.registerExtension(dart.global.TextTrackCue, html$.TextTrackCue);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'getCueById',
    'item'
  ]);
  html$.TextTrackCueList = class TextTrackCueList extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(html$.TextTrackCue), html$.ImmutableListMixin$(html$.TextTrackCue)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return this[index];
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return this[0];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return this[dart.notNull(len) - 1];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return this[0];
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [dartx.getCueById](id) {
      return this.getCueById(id);
    }
    [dartx.item](index) {
      return this.item(index);
    }
  };
  html$.TextTrackCueList[dart.implements] = () => [core.List$(html$.TextTrackCue), _js_helper.JavaScriptIndexingBehavior];
  dart.setSignature(html$.TextTrackCueList, {
    constructors: () => ({_: [html$.TextTrackCueList, []]}),
    methods: () => ({
      [dartx.get]: [html$.TextTrackCue, [core.int]],
      [dartx.set]: [dart.void, [core.int, html$.TextTrackCue]],
      [dartx.elementAt]: [html$.TextTrackCue, [core.int]],
      [dartx.getCueById]: [html$.TextTrackCue, [core.String]],
      [dartx.item]: [html$.TextTrackCue, [core.int]]
    })
  });
  html$.TextTrackCueList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('TextTrackCueList')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("TextTrackCueList"))];
  dart.registerExtension(dart.global.TextTrackCueList, html$.TextTrackCueList);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'getTrackById',
    'item',
    'onAddTrack',
    'onChange'
  ]);
  html$.TextTrackList = class TextTrackList extends dart.mixin(html$.EventTarget, collection.ListMixin$(html$.TextTrack), html$.ImmutableListMixin$(html$.TextTrack)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return this[index];
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return this[0];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return this[dart.notNull(len) - 1];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return this[0];
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [dartx.getTrackById](id) {
      return this.getTrackById(id);
    }
    [dartx.item](index) {
      return this.item(index);
    }
    get [dartx.onAddTrack]() {
      return html$.TextTrackList.addTrackEvent.forTarget(this);
    }
    get [dartx.onChange]() {
      return html$.TextTrackList.changeEvent.forTarget(this);
    }
  };
  html$.TextTrackList[dart.implements] = () => [_js_helper.JavaScriptIndexingBehavior, core.List$(html$.TextTrack)];
  dart.setSignature(html$.TextTrackList, {
    constructors: () => ({_: [html$.TextTrackList, []]}),
    methods: () => ({
      [dartx.get]: [html$.TextTrack, [core.int]],
      [dartx.set]: [dart.void, [core.int, html$.TextTrack]],
      [dartx.elementAt]: [html$.TextTrack, [core.int]],
      [dartx.getTrackById]: [html$.TextTrack, [core.String]],
      [dartx.item]: [html$.TextTrack, [core.int]]
    })
  });
  html$.TextTrackList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('TextTrackList')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("TextTrackList"))];
  dart.defineLazy(html$.TextTrackList, {
    get addTrackEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.TrackEvent))('addtrack'));
    },
    get changeEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('change'));
    }
  });
  dart.registerExtension(dart.global.TextTrackList, html$.TextTrackList);
  dart.defineExtensionNames([
    'end',
    'start',
    'length'
  ]);
  html$.TimeRanges = class TimeRanges extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.end](index) {
      return this.end(index);
    }
    [dartx.start](index) {
      return this.start(index);
    }
  };
  dart.setSignature(html$.TimeRanges, {
    constructors: () => ({_: [html$.TimeRanges, []]}),
    methods: () => ({
      [dartx.end]: [core.double, [core.int]],
      [dartx.start]: [core.double, [core.int]]
    })
  });
  html$.TimeRanges[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('TimeRanges')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("TimeRanges"))];
  dart.registerExtension(dart.global.TimeRanges, html$.TimeRanges);
  html$.TimeoutHandler = dart.typedef('TimeoutHandler', () => dart.functionType(dart.void, []));
  html$.TitleElement = class TitleElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("title"), html$.TitleElement);
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(html$.TitleElement, 'created');
  dart.setSignature(html$.TitleElement, {
    constructors: () => ({
      _: [html$.TitleElement, []],
      new: [html$.TitleElement, []],
      created: [html$.TitleElement, []]
    })
  });
  html$.TitleElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLTitleElement')), dart.const(new _js_helper.Native("HTMLTitleElement"))];
  dart.registerExtension(dart.global.HTMLTitleElement, html$.TitleElement);
  const _radiusX = Symbol('_radiusX');
  const _radiusY = Symbol('_radiusY');
  const __clientX = Symbol('__clientX');
  const __clientY = Symbol('__clientY');
  const __screenX = Symbol('__screenX');
  const __screenY = Symbol('__screenY');
  const __pageX = Symbol('__pageX');
  const __pageY = Symbol('__pageY');
  const __radiusX = Symbol('__radiusX');
  const __radiusY = Symbol('__radiusY');
  dart.defineExtensionNames([
    'target',
    'client',
    'page',
    'screen',
    'radiusX',
    'radiusY',
    'force',
    'identifier',
    'rotationAngle'
  ]);
  html$.Touch = class Touch extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [_clientX]() {
      return this.clientX;
    }
    get [_clientY]() {
      return this.clientY;
    }
    get [dartx.force]() {
      return this.force;
    }
    get [dartx.identifier]() {
      return this.identifier;
    }
    get [_pageX]() {
      return this.pageX;
    }
    get [_pageY]() {
      return this.pageY;
    }
    get [_radiusX]() {
      return this.radiusX;
    }
    get [_radiusY]() {
      return this.radiusY;
    }
    get [dartx.rotationAngle]() {
      return this.rotationAngle;
    }
    get [_screenX]() {
      return this.screenX;
    }
    get [_screenY]() {
      return this.screenY;
    }
    get [dartx.target]() {
      return html$._convertNativeToDart_EventTarget(this[_get_target]);
    }
    get [_get_target]() {
      return this.target;
    }
    get [__clientX]() {
      return this.clientX[dartx.round]();
    }
    get [__clientY]() {
      return this.clientY[dartx.round]();
    }
    get [__screenX]() {
      return this.screenX[dartx.round]();
    }
    get [__screenY]() {
      return this.screenY[dartx.round]();
    }
    get [__pageX]() {
      return this.pageX[dartx.round]();
    }
    get [__pageY]() {
      return this.pageY[dartx.round]();
    }
    get [__radiusX]() {
      return this.radiusX[dartx.round]();
    }
    get [__radiusY]() {
      return this.radiusY[dartx.round]();
    }
    get [dartx.client]() {
      return new (math.Point$(core.num))(this[__clientX], this[__clientY]);
    }
    get [dartx.page]() {
      return new (math.Point$(core.num))(this[__pageX], this[__pageY]);
    }
    get [dartx.screen]() {
      return new (math.Point$(core.num))(this[__screenX], this[__screenY]);
    }
    get [dartx.radiusX]() {
      return this[__radiusX];
    }
    get [dartx.radiusY]() {
      return this[__radiusY];
    }
  };
  dart.setSignature(html$.Touch, {
    constructors: () => ({_: [html$.Touch, []]})
  });
  html$.Touch[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Touch')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("Touch"))];
  dart.registerExtension(dart.global.Touch, html$.Touch);
  const _initTouchEvent = Symbol('_initTouchEvent');
  dart.defineExtensionNames([
    'altKey',
    'changedTouches',
    'ctrlKey',
    'metaKey',
    'shiftKey',
    'targetTouches',
    'touches'
  ]);
  html$.TouchEvent = class TouchEvent extends html$.UIEvent {
    static new(touches, targetTouches, changedTouches, type, opts) {
      let view = opts && 'view' in opts ? opts.view : null;
      let screenX = opts && 'screenX' in opts ? opts.screenX : 0;
      let screenY = opts && 'screenY' in opts ? opts.screenY : 0;
      let clientX = opts && 'clientX' in opts ? opts.clientX : 0;
      let clientY = opts && 'clientY' in opts ? opts.clientY : 0;
      let ctrlKey = opts && 'ctrlKey' in opts ? opts.ctrlKey : false;
      let altKey = opts && 'altKey' in opts ? opts.altKey : false;
      let shiftKey = opts && 'shiftKey' in opts ? opts.shiftKey : false;
      let metaKey = opts && 'metaKey' in opts ? opts.metaKey : false;
      if (view == null) {
        view = html$.window;
      }
      let e = dart.as(html$.document[_createEvent]("TouchEvent"), html$.TouchEvent);
      e[_initTouchEvent](touches, targetTouches, changedTouches, type, view, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey);
      return e;
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.altKey]() {
      return this.altKey;
    }
    get [dartx.changedTouches]() {
      return this.changedTouches;
    }
    get [dartx.ctrlKey]() {
      return this.ctrlKey;
    }
    get [dartx.metaKey]() {
      return this.metaKey;
    }
    get [dartx.shiftKey]() {
      return this.shiftKey;
    }
    get [dartx.targetTouches]() {
      return this.targetTouches;
    }
    get [dartx.touches]() {
      return this.touches;
    }
    [_initTouchEvent](touches, targetTouches, changedTouches, type, view, unused1, unused2, unused3, unused4, ctrlKey, altKey, shiftKey, metaKey) {
      return this.initTouchEvent(touches, targetTouches, changedTouches, type, view, unused1, unused2, unused3, unused4, ctrlKey, altKey, shiftKey, metaKey);
    }
    static get supported() {
      return html_common.Device.isEventTypeSupported('TouchEvent');
    }
  };
  dart.setSignature(html$.TouchEvent, {
    constructors: () => ({
      new: [html$.TouchEvent, [html$.TouchList, html$.TouchList, html$.TouchList, core.String], {view: html$.Window, screenX: core.int, screenY: core.int, clientX: core.int, clientY: core.int, ctrlKey: core.bool, altKey: core.bool, shiftKey: core.bool, metaKey: core.bool}],
      _: [html$.TouchEvent, []]
    }),
    methods: () => ({[_initTouchEvent]: [dart.void, [html$.TouchList, html$.TouchList, html$.TouchList, core.String, html$.Window, core.int, core.int, core.int, core.int, core.bool, core.bool, core.bool, core.bool]]})
  });
  html$.TouchEvent[dart.metadata] = () => [dart.const(new _metadata.DomName('TouchEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("TouchEvent"))];
  dart.registerExtension(dart.global.TouchEvent, html$.TouchEvent);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'item'
  ]);
  html$.TouchList = class TouchList extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(html$.Touch), html$.ImmutableListMixin$(html$.Touch)) {
    static new() {
      return null;
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static get supported() {
      return !!document.createTouchList;
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return this[index];
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return this[0];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return this[dart.notNull(len) - 1];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return this[0];
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [dartx.item](index) {
      return this.item(index);
    }
  };
  html$.TouchList[dart.implements] = () => [_js_helper.JavaScriptIndexingBehavior, core.List$(html$.Touch)];
  dart.setSignature(html$.TouchList, {
    constructors: () => ({
      new: [html$.TouchList, []],
      _: [html$.TouchList, []]
    }),
    methods: () => ({
      [dartx.get]: [html$.Touch, [core.int]],
      [dartx.set]: [dart.void, [core.int, html$.Touch]],
      [dartx.elementAt]: [html$.Touch, [core.int]],
      [dartx.item]: [html$.Touch, [core.int]]
    })
  });
  html$.TouchList[dart.metadata] = () => [dart.const(new _metadata.DomName('TouchList')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("TouchList"))];
  dart.registerExtension(dart.global.TouchList, html$.TouchList);
  dart.defineExtensionNames([
    'byteStreamTrackID',
    'kinds',
    'label',
    'language',
    'type'
  ]);
  html$.TrackDefault = class TrackDefault extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, language, label, kinds, byteStreamTrackID) {
      if (byteStreamTrackID === void 0) byteStreamTrackID = null;
      if (byteStreamTrackID != null) {
        let kinds_1 = html_common.convertDartToNative_StringArray(kinds);
        return html$.TrackDefault._create_1(type, language, label, kinds_1, byteStreamTrackID);
      }
      let kinds_1 = html_common.convertDartToNative_StringArray(kinds);
      return html$.TrackDefault._create_2(type, language, label, kinds_1);
    }
    static _create_1(type, language, label, kinds, byteStreamTrackID) {
      return new TrackDefault(type, language, label, kinds, byteStreamTrackID);
    }
    static _create_2(type, language, label, kinds) {
      return new TrackDefault(type, language, label, kinds);
    }
    get [dartx.byteStreamTrackID]() {
      return this.byteStreamTrackID;
    }
    get [dartx.kinds]() {
      return this.kinds;
    }
    get [dartx.label]() {
      return this.label;
    }
    get [dartx.language]() {
      return this.language;
    }
    get [dartx.type]() {
      return this.type;
    }
  };
  dart.setSignature(html$.TrackDefault, {
    constructors: () => ({
      _: [html$.TrackDefault, []],
      new: [html$.TrackDefault, [core.String, core.String, core.String, core.List$(core.String)], [core.String]]
    }),
    statics: () => ({
      _create_1: [html$.TrackDefault, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]],
      _create_2: [html$.TrackDefault, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.TrackDefault[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('TrackDefault')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("TrackDefault"))];
  dart.registerExtension(dart.global.TrackDefault, html$.TrackDefault);
  dart.defineExtensionNames([
    'item',
    'length'
  ]);
  html$.TrackDefaultList = class TrackDefaultList extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(trackDefaults) {
      if (trackDefaults === void 0) trackDefaults = null;
      if (trackDefaults != null) {
        return html$.TrackDefaultList._create_1(trackDefaults);
      }
      return html$.TrackDefaultList._create_2();
    }
    static _create_1(trackDefaults) {
      return new TrackDefaultList(trackDefaults);
    }
    static _create_2() {
      return new TrackDefaultList();
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.item](index) {
      return this.item(index);
    }
  };
  dart.setSignature(html$.TrackDefaultList, {
    constructors: () => ({
      _: [html$.TrackDefaultList, []],
      new: [html$.TrackDefaultList, [], [core.List$(html$.TrackDefault)]]
    }),
    methods: () => ({[dartx.item]: [html$.TrackDefault, [core.int]]}),
    statics: () => ({
      _create_1: [html$.TrackDefaultList, [dart.dynamic]],
      _create_2: [html$.TrackDefaultList, []]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.TrackDefaultList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('TrackDefaultList')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("TrackDefaultList"))];
  dart.registerExtension(dart.global.TrackDefaultList, html$.TrackDefaultList);
  dart.defineExtensionNames([
    'defaultValue',
    'kind',
    'label',
    'readyState',
    'src',
    'srclang',
    'track'
  ]);
  html$.TrackElement = class TrackElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("track"), html$.TrackElement);
    }
    created() {
      this[dartx.defaultValue] = null;
      this[dartx.kind] = null;
      this[dartx.label] = null;
      this[dartx.readyState] = null;
      this[dartx.src] = null;
      this[dartx.srclang] = null;
      this[dartx.track] = null;
      super.created();
    }
    static get supported() {
      return html$.Element.isTagSupported('track');
    }
    get [dartx.defaultValue]() {
      return this.default;
    }
    set [dartx.defaultValue](value) {
      this.default = value;
    }
    get [dartx.kind]() {
      return this.kind;
    }
    set [dartx.kind](value) {
      this.kind = value;
    }
    get [dartx.label]() {
      return this.label;
    }
    set [dartx.label](value) {
      this.label = value;
    }
    get [dartx.readyState]() {
      return this.readyState;
    }
    get [dartx.src]() {
      return this.src;
    }
    set [dartx.src](value) {
      this.src = value;
    }
    get [dartx.srclang]() {
      return this.srclang;
    }
    set [dartx.srclang](value) {
      this.srclang = value;
    }
    get [dartx.track]() {
      return this.track;
    }
  };
  dart.defineNamedConstructor(html$.TrackElement, 'created');
  dart.setSignature(html$.TrackElement, {
    constructors: () => ({
      _: [html$.TrackElement, []],
      new: [html$.TrackElement, []],
      created: [html$.TrackElement, []]
    })
  });
  html$.TrackElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLTrackElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("HTMLTrackElement"))];
  html$.TrackElement.ERROR = 3;
  html$.TrackElement.LOADED = 2;
  html$.TrackElement.LOADING = 1;
  html$.TrackElement.NONE = 0;
  dart.registerExtension(dart.global.HTMLTrackElement, html$.TrackElement);
  dart.defineExtensionNames([
    'track'
  ]);
  html$.TrackEvent = class TrackEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.TrackEvent._create_1(type, eventInitDict_1);
      }
      return html$.TrackEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new TrackEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new TrackEvent(type);
    }
    get [dartx.track]() {
      return this.track;
    }
  };
  dart.setSignature(html$.TrackEvent, {
    constructors: () => ({
      _: [html$.TrackEvent, []],
      new: [html$.TrackEvent, [core.String], [core.Map]]
    }),
    statics: () => ({
      _create_1: [html$.TrackEvent, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.TrackEvent, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.TrackEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('TrackEvent')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("TrackEvent"))];
  dart.registerExtension(dart.global.TrackEvent, html$.TrackEvent);
  dart.defineExtensionNames([
    'elapsedTime',
    'propertyName',
    'pseudoElement'
  ]);
  html$.TransitionEvent = class TransitionEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.TransitionEvent._create_1(type, eventInitDict_1);
      }
      return html$.TransitionEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new TransitionEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new TransitionEvent(type);
    }
    get [dartx.elapsedTime]() {
      return this.elapsedTime;
    }
    get [dartx.propertyName]() {
      return this.propertyName;
    }
    get [dartx.pseudoElement]() {
      return this.pseudoElement;
    }
  };
  dart.setSignature(html$.TransitionEvent, {
    constructors: () => ({
      _: [html$.TransitionEvent, []],
      new: [html$.TransitionEvent, [core.String], [core.Map]]
    }),
    statics: () => ({
      _create_1: [html$.TransitionEvent, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.TransitionEvent, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.TransitionEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('TransitionEvent')), dart.const(new _js_helper.Native("TransitionEvent,WebKitTransitionEvent"))];
  dart.registerExtension(dart.global.TransitionEvent, html$.TransitionEvent);
  dart.defineExtensionNames([
    'firstChild',
    'lastChild',
    'nextNode',
    'nextSibling',
    'parentNode',
    'previousNode',
    'previousSibling',
    'currentNode',
    'filter',
    'root',
    'whatToShow'
  ]);
  html$.TreeWalker = class TreeWalker extends _interceptors.Interceptor {
    static new(root, whatToShow) {
      return html$.document[_createTreeWalker](root, whatToShow, null);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.currentNode]() {
      return this.currentNode;
    }
    set [dartx.currentNode](value) {
      this.currentNode = value;
    }
    get [dartx.filter]() {
      return this.filter;
    }
    get [dartx.root]() {
      return this.root;
    }
    get [dartx.whatToShow]() {
      return this.whatToShow;
    }
    [dartx.firstChild]() {
      return this.firstChild();
    }
    [dartx.lastChild]() {
      return this.lastChild();
    }
    [dartx.nextNode]() {
      return this.nextNode();
    }
    [dartx.nextSibling]() {
      return this.nextSibling();
    }
    [dartx.parentNode]() {
      return this.parentNode();
    }
    [dartx.previousNode]() {
      return this.previousNode();
    }
    [dartx.previousSibling]() {
      return this.previousSibling();
    }
  };
  dart.setSignature(html$.TreeWalker, {
    constructors: () => ({
      new: [html$.TreeWalker, [html$.Node, core.int]],
      _: [html$.TreeWalker, []]
    }),
    methods: () => ({
      [dartx.firstChild]: [html$.Node, []],
      [dartx.lastChild]: [html$.Node, []],
      [dartx.nextNode]: [html$.Node, []],
      [dartx.nextSibling]: [html$.Node, []],
      [dartx.parentNode]: [html$.Node, []],
      [dartx.previousNode]: [html$.Node, []],
      [dartx.previousSibling]: [html$.Node, []]
    })
  });
  html$.TreeWalker[dart.metadata] = () => [dart.const(new _metadata.DomName('TreeWalker')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("TreeWalker"))];
  dart.registerExtension(dart.global.TreeWalker, html$.TreeWalker);
  html$.UListElement = class UListElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("ul"), html$.UListElement);
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(html$.UListElement, 'created');
  dart.setSignature(html$.UListElement, {
    constructors: () => ({
      _: [html$.UListElement, []],
      new: [html$.UListElement, []],
      created: [html$.UListElement, []]
    })
  });
  html$.UListElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLUListElement')), dart.const(new _js_helper.Native("HTMLUListElement"))];
  dart.registerExtension(dart.global.HTMLUListElement, html$.UListElement);
  html$.UnknownElement = class UnknownElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(html$.UnknownElement, 'created');
  dart.setSignature(html$.UnknownElement, {
    constructors: () => ({
      _: [html$.UnknownElement, []],
      created: [html$.UnknownElement, []]
    })
  });
  html$.UnknownElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLUnknownElement')), dart.const(new _js_helper.Native("HTMLUnknownElement"))];
  dart.registerExtension(dart.global.HTMLUnknownElement, html$.UnknownElement);
  dart.defineExtensionNames([
    'toString',
    'hash',
    'host',
    'hostname',
    'href',
    'origin',
    'password',
    'pathname',
    'port',
    'protocol',
    'search',
    'username'
  ]);
  html$.Url = class Url extends _interceptors.Interceptor {
    static createObjectUrl(blob_OR_source_OR_stream) {
      return (self.URL || self.webkitURL).createObjectURL(blob_OR_source_OR_stream);
    }
    static createObjectUrlFromSource(source) {
      return (self.URL || self.webkitURL).createObjectURL(source);
    }
    static createObjectUrlFromStream(stream) {
      return (self.URL || self.webkitURL).createObjectURL(stream);
    }
    static createObjectUrlFromBlob(blob) {
      return (self.URL || self.webkitURL).createObjectURL(blob);
    }
    static revokeObjectUrl(url) {
      return (self.URL || self.webkitURL).revokeObjectURL(url);
    }
    [dartx.toString]() {
      return String(this);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.hash]() {
      return this.hash;
    }
    set [dartx.hash](value) {
      this.hash = value;
    }
    get [dartx.host]() {
      return this.host;
    }
    set [dartx.host](value) {
      this.host = value;
    }
    get [dartx.hostname]() {
      return this.hostname;
    }
    set [dartx.hostname](value) {
      this.hostname = value;
    }
    get [dartx.href]() {
      return this.href;
    }
    set [dartx.href](value) {
      this.href = value;
    }
    get [dartx.origin]() {
      return this.origin;
    }
    get [dartx.password]() {
      return this.password;
    }
    set [dartx.password](value) {
      this.password = value;
    }
    get [dartx.pathname]() {
      return this.pathname;
    }
    set [dartx.pathname](value) {
      this.pathname = value;
    }
    get [dartx.port]() {
      return this.port;
    }
    set [dartx.port](value) {
      this.port = value;
    }
    get [dartx.protocol]() {
      return this.protocol;
    }
    set [dartx.protocol](value) {
      this.protocol = value;
    }
    get [dartx.search]() {
      return this.search;
    }
    set [dartx.search](value) {
      this.search = value;
    }
    get [dartx.username]() {
      return this.username;
    }
    set [dartx.username](value) {
      this.username = value;
    }
  };
  html$.Url[dart.implements] = () => [html$.UrlUtils];
  dart.setSignature(html$.Url, {
    constructors: () => ({_: [html$.Url, []]}),
    statics: () => ({
      createObjectUrl: [core.String, [dart.dynamic]],
      createObjectUrlFromSource: [core.String, [html$.MediaSource]],
      createObjectUrlFromStream: [core.String, [html$.MediaStream]],
      createObjectUrlFromBlob: [core.String, [html$.Blob]],
      revokeObjectUrl: [dart.void, [core.String]]
    }),
    names: ['createObjectUrl', 'createObjectUrlFromSource', 'createObjectUrlFromStream', 'createObjectUrlFromBlob', 'revokeObjectUrl']
  });
  html$.Url[dart.metadata] = () => [dart.const(new _metadata.DomName('URL')), dart.const(new _js_helper.Native("URL"))];
  dart.registerExtension(dart.global.URL, html$.Url);
  dart.defineExtensionNames([
    'hash',
    'host',
    'hostname',
    'href',
    'origin',
    'password',
    'pathname',
    'port',
    'protocol',
    'search',
    'username'
  ]);
  html$.UrlUtils = class UrlUtils extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$.UrlUtils, {
    constructors: () => ({_: [html$.UrlUtils, []]})
  });
  dart.defineExtensionMembers(html$.UrlUtils, [
    'hash',
    'hash',
    'host',
    'host',
    'hostname',
    'hostname',
    'href',
    'href',
    'origin',
    'password',
    'password',
    'pathname',
    'pathname',
    'port',
    'port',
    'protocol',
    'protocol',
    'search',
    'search',
    'username',
    'username'
  ]);
  html$.UrlUtils[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('URLUtils')), dart.const(new _metadata.Experimental())];
  dart.defineExtensionNames([
    'hash',
    'host',
    'hostname',
    'href',
    'origin',
    'pathname',
    'port',
    'protocol',
    'search'
  ]);
  html$.UrlUtilsReadOnly = class UrlUtilsReadOnly extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$.UrlUtilsReadOnly, {
    constructors: () => ({_: [html$.UrlUtilsReadOnly, []]})
  });
  dart.defineExtensionMembers(html$.UrlUtilsReadOnly, [
    'hash',
    'host',
    'hostname',
    'href',
    'origin',
    'pathname',
    'port',
    'protocol',
    'search'
  ]);
  html$.UrlUtilsReadOnly[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('URLUtilsReadOnly')), dart.const(new _metadata.Experimental())];
  dart.defineExtensionNames([
    'currentFieldOfView',
    'eyeTranslation',
    'maximumFieldOfView',
    'minimumFieldOfView',
    'recommendedFieldOfView',
    'renderRect'
  ]);
  html$.VREyeParameters = class VREyeParameters extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.currentFieldOfView]() {
      return this.currentFieldOfView;
    }
    get [dartx.eyeTranslation]() {
      return this.eyeTranslation;
    }
    get [dartx.maximumFieldOfView]() {
      return this.maximumFieldOfView;
    }
    get [dartx.minimumFieldOfView]() {
      return this.minimumFieldOfView;
    }
    get [dartx.recommendedFieldOfView]() {
      return this.recommendedFieldOfView;
    }
    get [dartx.renderRect]() {
      return this.renderRect;
    }
  };
  dart.setSignature(html$.VREyeParameters, {
    constructors: () => ({_: [html$.VREyeParameters, []]})
  });
  html$.VREyeParameters[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('VREyeParameters')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("VREyeParameters"))];
  dart.registerExtension(dart.global.VREyeParameters, html$.VREyeParameters);
  dart.defineExtensionNames([
    'downDegrees',
    'leftDegrees',
    'rightDegrees',
    'upDegrees'
  ]);
  html$.VRFieldOfView = class VRFieldOfView extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(fov) {
      if (fov === void 0) fov = null;
      if (fov != null) {
        let fov_1 = html_common.convertDartToNative_Dictionary(fov);
        return html$.VRFieldOfView._create_1(fov_1);
      }
      return html$.VRFieldOfView._create_2();
    }
    static _create_1(fov) {
      return new VRFieldOfView(fov);
    }
    static _create_2() {
      return new VRFieldOfView();
    }
    get [dartx.downDegrees]() {
      return this.downDegrees;
    }
    set [dartx.downDegrees](value) {
      this.downDegrees = value;
    }
    get [dartx.leftDegrees]() {
      return this.leftDegrees;
    }
    set [dartx.leftDegrees](value) {
      this.leftDegrees = value;
    }
    get [dartx.rightDegrees]() {
      return this.rightDegrees;
    }
    set [dartx.rightDegrees](value) {
      this.rightDegrees = value;
    }
    get [dartx.upDegrees]() {
      return this.upDegrees;
    }
    set [dartx.upDegrees](value) {
      this.upDegrees = value;
    }
  };
  dart.setSignature(html$.VRFieldOfView, {
    constructors: () => ({
      _: [html$.VRFieldOfView, []],
      new: [html$.VRFieldOfView, [], [core.Map]]
    }),
    statics: () => ({
      _create_1: [html$.VRFieldOfView, [dart.dynamic]],
      _create_2: [html$.VRFieldOfView, []]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.VRFieldOfView[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('VRFieldOfView')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("VRFieldOfView"))];
  dart.registerExtension(dart.global.VRFieldOfView, html$.VRFieldOfView);
  dart.defineExtensionNames([
    'angularAcceleration',
    'angularVelocity',
    'linearAcceleration',
    'linearVelocity',
    'orientation',
    'position',
    'timeStamp'
  ]);
  html$.VRPositionState = class VRPositionState extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.angularAcceleration]() {
      return this.angularAcceleration;
    }
    get [dartx.angularVelocity]() {
      return this.angularVelocity;
    }
    get [dartx.linearAcceleration]() {
      return this.linearAcceleration;
    }
    get [dartx.linearVelocity]() {
      return this.linearVelocity;
    }
    get [dartx.orientation]() {
      return this.orientation;
    }
    get [dartx.position]() {
      return this.position;
    }
    get [dartx.timeStamp]() {
      return this.timeStamp;
    }
  };
  dart.setSignature(html$.VRPositionState, {
    constructors: () => ({_: [html$.VRPositionState, []]})
  });
  html$.VRPositionState[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('VRPositionState')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("VRPositionState"))];
  dart.registerExtension(dart.global.VRPositionState, html$.VRPositionState);
  dart.defineExtensionNames([
    'badInput',
    'customError',
    'patternMismatch',
    'rangeOverflow',
    'rangeUnderflow',
    'stepMismatch',
    'tooLong',
    'tooShort',
    'typeMismatch',
    'valid',
    'valueMissing'
  ]);
  html$.ValidityState = class ValidityState extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.badInput]() {
      return this.badInput;
    }
    get [dartx.customError]() {
      return this.customError;
    }
    get [dartx.patternMismatch]() {
      return this.patternMismatch;
    }
    get [dartx.rangeOverflow]() {
      return this.rangeOverflow;
    }
    get [dartx.rangeUnderflow]() {
      return this.rangeUnderflow;
    }
    get [dartx.stepMismatch]() {
      return this.stepMismatch;
    }
    get [dartx.tooLong]() {
      return this.tooLong;
    }
    get [dartx.tooShort]() {
      return this.tooShort;
    }
    get [dartx.typeMismatch]() {
      return this.typeMismatch;
    }
    get [dartx.valid]() {
      return this.valid;
    }
    get [dartx.valueMissing]() {
      return this.valueMissing;
    }
  };
  dart.setSignature(html$.ValidityState, {
    constructors: () => ({_: [html$.ValidityState, []]})
  });
  html$.ValidityState[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ValidityState')), dart.const(new _js_helper.Native("ValidityState"))];
  dart.registerExtension(dart.global.ValidityState, html$.ValidityState);
  dart.defineExtensionNames([
    'getVideoPlaybackQuality',
    'enterFullscreen',
    'exitFullscreen',
    'height',
    'poster',
    'videoHeight',
    'videoWidth',
    'decodedFrameCount',
    'droppedFrameCount',
    'width'
  ]);
  html$.VideoElement = class VideoElement extends html$.MediaElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(html$.document[dartx.createElement]("video"), html$.VideoElement);
    }
    created() {
      this[dartx.height] = null;
      this[dartx.poster] = null;
      this[dartx.videoHeight] = null;
      this[dartx.videoWidth] = null;
      this[dartx.decodedFrameCount] = null;
      this[dartx.droppedFrameCount] = null;
      this[dartx.width] = null;
      super.created();
    }
    get [dartx.height]() {
      return this.height;
    }
    set [dartx.height](value) {
      this.height = value;
    }
    get [dartx.poster]() {
      return this.poster;
    }
    set [dartx.poster](value) {
      this.poster = value;
    }
    get [dartx.videoHeight]() {
      return this.videoHeight;
    }
    get [dartx.videoWidth]() {
      return this.videoWidth;
    }
    get [dartx.decodedFrameCount]() {
      return this.webkitDecodedFrameCount;
    }
    get [dartx.droppedFrameCount]() {
      return this.webkitDroppedFrameCount;
    }
    get [dartx.width]() {
      return this.width;
    }
    set [dartx.width](value) {
      this.width = value;
    }
    [dartx.getVideoPlaybackQuality]() {
      return this.getVideoPlaybackQuality();
    }
    [dartx.enterFullscreen]() {
      return this.webkitEnterFullscreen();
    }
    [dartx.exitFullscreen]() {
      return this.webkitExitFullscreen();
    }
  };
  dart.defineNamedConstructor(html$.VideoElement, 'created');
  html$.VideoElement[dart.implements] = () => [html$.CanvasImageSource];
  dart.setSignature(html$.VideoElement, {
    constructors: () => ({
      _: [html$.VideoElement, []],
      new: [html$.VideoElement, []],
      created: [html$.VideoElement, []]
    }),
    methods: () => ({
      [dartx.getVideoPlaybackQuality]: [html$.VideoPlaybackQuality, []],
      [dartx.enterFullscreen]: [dart.void, []],
      [dartx.exitFullscreen]: [dart.void, []]
    })
  });
  html$.VideoElement[dart.metadata] = () => [dart.const(new _metadata.DomName('HTMLVideoElement')), dart.const(new _js_helper.Native("HTMLVideoElement"))];
  dart.registerExtension(dart.global.HTMLVideoElement, html$.VideoElement);
  dart.defineExtensionNames([
    'corruptedVideoFrames',
    'creationTime',
    'droppedVideoFrames',
    'totalVideoFrames'
  ]);
  html$.VideoPlaybackQuality = class VideoPlaybackQuality extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.corruptedVideoFrames]() {
      return this.corruptedVideoFrames;
    }
    get [dartx.creationTime]() {
      return this.creationTime;
    }
    get [dartx.droppedVideoFrames]() {
      return this.droppedVideoFrames;
    }
    get [dartx.totalVideoFrames]() {
      return this.totalVideoFrames;
    }
  };
  dart.setSignature(html$.VideoPlaybackQuality, {
    constructors: () => ({_: [html$.VideoPlaybackQuality, []]})
  });
  html$.VideoPlaybackQuality[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('VideoPlaybackQuality')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("VideoPlaybackQuality"))];
  dart.registerExtension(dart.global.VideoPlaybackQuality, html$.VideoPlaybackQuality);
  dart.defineExtensionNames([
    'id',
    'kind',
    'label',
    'language',
    'selected'
  ]);
  html$.VideoTrack = class VideoTrack extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.id]() {
      return this.id;
    }
    get [dartx.kind]() {
      return this.kind;
    }
    get [dartx.label]() {
      return this.label;
    }
    get [dartx.language]() {
      return this.language;
    }
    get [dartx.selected]() {
      return this.selected;
    }
    set [dartx.selected](value) {
      this.selected = value;
    }
  };
  dart.setSignature(html$.VideoTrack, {
    constructors: () => ({_: [html$.VideoTrack, []]})
  });
  html$.VideoTrack[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('VideoTrack')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("VideoTrack"))];
  dart.registerExtension(dart.global.VideoTrack, html$.VideoTrack);
  dart.defineExtensionNames([
    'getTrackById',
    'onChange',
    'length',
    'selectedIndex'
  ]);
  html$.VideoTrackList = class VideoTrackList extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    get [dartx.selectedIndex]() {
      return this.selectedIndex;
    }
    [__getter__](index) {
      return this.__getter__(index);
    }
    [dartx.getTrackById](id) {
      return this.getTrackById(id);
    }
    get [dartx.onChange]() {
      return html$.VideoTrackList.changeEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.VideoTrackList, {
    constructors: () => ({_: [html$.VideoTrackList, []]}),
    methods: () => ({
      [__getter__]: [html$.VideoTrack, [core.int]],
      [dartx.getTrackById]: [html$.VideoTrack, [core.String]]
    })
  });
  html$.VideoTrackList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('VideoTrackList')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("VideoTrackList"))];
  dart.defineLazy(html$.VideoTrackList, {
    get changeEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('change'));
    }
  });
  dart.registerExtension(dart.global.VideoTrackList, html$.VideoTrackList);
  html$.VoidCallback = dart.typedef('VoidCallback', () => dart.functionType(dart.void, []));
  dart.defineExtensionNames([
    'getCueAsHtml',
    'align',
    'line',
    'position',
    'regionId',
    'size',
    'snapToLines',
    'text',
    'vertical'
  ]);
  html$.VttCue = class VttCue extends html$.TextTrackCue {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(startTime, endTime, text) {
      return html$.VttCue._create_1(startTime, endTime, text);
    }
    static _create_1(startTime, endTime, text) {
      return new VTTCue(startTime, endTime, text);
    }
    get [dartx.align]() {
      return this.align;
    }
    set [dartx.align](value) {
      this.align = value;
    }
    get [dartx.line]() {
      return this.line;
    }
    set [dartx.line](value) {
      this.line = value;
    }
    get [dartx.position]() {
      return this.position;
    }
    set [dartx.position](value) {
      this.position = value;
    }
    get [dartx.regionId]() {
      return this.regionId;
    }
    set [dartx.regionId](value) {
      this.regionId = value;
    }
    get [dartx.size]() {
      return this.size;
    }
    set [dartx.size](value) {
      this.size = value;
    }
    get [dartx.snapToLines]() {
      return this.snapToLines;
    }
    set [dartx.snapToLines](value) {
      this.snapToLines = value;
    }
    get [dartx.text]() {
      return this.text;
    }
    set [dartx.text](value) {
      this.text = value;
    }
    get [dartx.vertical]() {
      return this.vertical;
    }
    set [dartx.vertical](value) {
      this.vertical = value;
    }
    [dartx.getCueAsHtml]() {
      return this.getCueAsHTML();
    }
  };
  dart.setSignature(html$.VttCue, {
    constructors: () => ({
      _: [html$.VttCue, []],
      new: [html$.VttCue, [core.num, core.num, core.String]]
    }),
    methods: () => ({[dartx.getCueAsHtml]: [html$.DocumentFragment, []]}),
    statics: () => ({_create_1: [html$.VttCue, [dart.dynamic, dart.dynamic, dart.dynamic]]}),
    names: ['_create_1']
  });
  html$.VttCue[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('VTTCue')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("VTTCue"))];
  dart.registerExtension(dart.global.VTTCue, html$.VttCue);
  dart.defineExtensionNames([
    'height',
    'id',
    'regionAnchorX',
    'regionAnchorY',
    'scroll',
    'track',
    'viewportAnchorX',
    'viewportAnchorY',
    'width'
  ]);
  html$.VttRegion = class VttRegion extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.VttRegion._create_1();
    }
    static _create_1() {
      return new VTTRegion();
    }
    get [dartx.height]() {
      return this.height;
    }
    set [dartx.height](value) {
      this.height = value;
    }
    get [dartx.id]() {
      return this.id;
    }
    set [dartx.id](value) {
      this.id = value;
    }
    get [dartx.regionAnchorX]() {
      return this.regionAnchorX;
    }
    set [dartx.regionAnchorX](value) {
      this.regionAnchorX = value;
    }
    get [dartx.regionAnchorY]() {
      return this.regionAnchorY;
    }
    set [dartx.regionAnchorY](value) {
      this.regionAnchorY = value;
    }
    get [dartx.scroll]() {
      return this.scroll;
    }
    set [dartx.scroll](value) {
      this.scroll = value;
    }
    get [dartx.track]() {
      return this.track;
    }
    get [dartx.viewportAnchorX]() {
      return this.viewportAnchorX;
    }
    set [dartx.viewportAnchorX](value) {
      this.viewportAnchorX = value;
    }
    get [dartx.viewportAnchorY]() {
      return this.viewportAnchorY;
    }
    set [dartx.viewportAnchorY](value) {
      this.viewportAnchorY = value;
    }
    get [dartx.width]() {
      return this.width;
    }
    set [dartx.width](value) {
      this.width = value;
    }
  };
  dart.setSignature(html$.VttRegion, {
    constructors: () => ({
      _: [html$.VttRegion, []],
      new: [html$.VttRegion, []]
    }),
    statics: () => ({_create_1: [html$.VttRegion, []]}),
    names: ['_create_1']
  });
  html$.VttRegion[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('VTTRegion')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("VTTRegion"))];
  dart.registerExtension(dart.global.VTTRegion, html$.VttRegion);
  dart.defineExtensionNames([
    'getRegionById',
    'item',
    'length'
  ]);
  html$.VttRegionList = class VttRegionList extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.getRegionById](id) {
      return this.getRegionById(id);
    }
    [dartx.item](index) {
      return this.item(index);
    }
  };
  dart.setSignature(html$.VttRegionList, {
    constructors: () => ({_: [html$.VttRegionList, []]}),
    methods: () => ({
      [dartx.getRegionById]: [html$.VttRegion, [core.String]],
      [dartx.item]: [html$.VttRegion, [core.int]]
    })
  });
  html$.VttRegionList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('VTTRegionList')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("VTTRegionList"))];
  dart.registerExtension(dart.global.VTTRegionList, html$.VttRegionList);
  dart.defineExtensionNames([
    'close',
    'send',
    'sendBlob',
    'sendByteBuffer',
    'sendString',
    'sendTypedData',
    'onClose',
    'onError',
    'onMessage',
    'onOpen',
    'binaryType',
    'bufferedAmount',
    'extensions',
    'protocol',
    'readyState',
    'url'
  ]);
  html$.WebSocket = class WebSocket extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(url, protocols) {
      if (protocols === void 0) protocols = null;
      if (protocols != null) {
        return html$.WebSocket._create_1(url, protocols);
      }
      return html$.WebSocket._create_2(url);
    }
    static _create_1(url, protocols) {
      return new WebSocket(url, protocols);
    }
    static _create_2(url) {
      return new WebSocket(url);
    }
    static get supported() {
      return typeof window.WebSocket != "undefined";
    }
    get [dartx.binaryType]() {
      return this.binaryType;
    }
    set [dartx.binaryType](value) {
      this.binaryType = value;
    }
    get [dartx.bufferedAmount]() {
      return this.bufferedAmount;
    }
    get [dartx.extensions]() {
      return this.extensions;
    }
    get [dartx.protocol]() {
      return this.protocol;
    }
    get [dartx.readyState]() {
      return this.readyState;
    }
    get [dartx.url]() {
      return this.url;
    }
    [dartx.close](code, reason) {
      return this.close(code, reason);
    }
    [dartx.send](data) {
      return this.send(data);
    }
    [dartx.sendBlob](data) {
      return this.send(data);
    }
    [dartx.sendByteBuffer](data) {
      return this.send(data);
    }
    [dartx.sendString](data) {
      return this.send(data);
    }
    [dartx.sendTypedData](data) {
      return this.send(data);
    }
    get [dartx.onClose]() {
      return html$.WebSocket.closeEvent.forTarget(this);
    }
    get [dartx.onError]() {
      return html$.WebSocket.errorEvent.forTarget(this);
    }
    get [dartx.onMessage]() {
      return html$.WebSocket.messageEvent.forTarget(this);
    }
    get [dartx.onOpen]() {
      return html$.WebSocket.openEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.WebSocket, {
    constructors: () => ({
      _: [html$.WebSocket, []],
      new: [html$.WebSocket, [core.String], [core.Object]]
    }),
    methods: () => ({
      [dartx.close]: [dart.void, [], [core.int, core.String]],
      [dartx.send]: [dart.void, [dart.dynamic]],
      [dartx.sendBlob]: [dart.void, [html$.Blob]],
      [dartx.sendByteBuffer]: [dart.void, [typed_data.ByteBuffer]],
      [dartx.sendString]: [dart.void, [core.String]],
      [dartx.sendTypedData]: [dart.void, [typed_data.TypedData]]
    }),
    statics: () => ({
      _create_1: [html$.WebSocket, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.WebSocket, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.WebSocket[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('WebSocket')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("WebSocket"))];
  html$.WebSocket.CLOSED = 3;
  html$.WebSocket.CLOSING = 2;
  html$.WebSocket.CONNECTING = 0;
  html$.WebSocket.OPEN = 1;
  dart.defineLazy(html$.WebSocket, {
    get closeEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.CloseEvent))('close'));
    },
    get errorEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('error'));
    },
    get messageEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MessageEvent))('message'));
    },
    get openEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('open'));
    }
  });
  dart.registerExtension(dart.global.WebSocket, html$.WebSocket);
  const _deltaX = Symbol('_deltaX');
  const _deltaY = Symbol('_deltaY');
  const _wheelDelta = Symbol('_wheelDelta');
  const _wheelDeltaX = Symbol('_wheelDeltaX');
  const _hasInitMouseScrollEvent = Symbol('_hasInitMouseScrollEvent');
  const _initMouseScrollEvent = Symbol('_initMouseScrollEvent');
  const _hasInitWheelEvent = Symbol('_hasInitWheelEvent');
  const _initWheelEvent = Symbol('_initWheelEvent');
  dart.defineExtensionNames([
    'deltaY',
    'deltaX',
    'deltaMode',
    'deltaZ'
  ]);
  html$.WheelEvent = class WheelEvent extends html$.MouseEvent {
    static new(type, opts) {
      let view = opts && 'view' in opts ? opts.view : null;
      let deltaX = opts && 'deltaX' in opts ? opts.deltaX : 0;
      let deltaY = opts && 'deltaY' in opts ? opts.deltaY : 0;
      let deltaZ = opts && 'deltaZ' in opts ? opts.deltaZ : 0;
      let deltaMode = opts && 'deltaMode' in opts ? opts.deltaMode : 0;
      let detail = opts && 'detail' in opts ? opts.detail : 0;
      let screenX = opts && 'screenX' in opts ? opts.screenX : 0;
      let screenY = opts && 'screenY' in opts ? opts.screenY : 0;
      let clientX = opts && 'clientX' in opts ? opts.clientX : 0;
      let clientY = opts && 'clientY' in opts ? opts.clientY : 0;
      let button = opts && 'button' in opts ? opts.button : 0;
      let canBubble = opts && 'canBubble' in opts ? opts.canBubble : true;
      let cancelable = opts && 'cancelable' in opts ? opts.cancelable : true;
      let ctrlKey = opts && 'ctrlKey' in opts ? opts.ctrlKey : false;
      let altKey = opts && 'altKey' in opts ? opts.altKey : false;
      let shiftKey = opts && 'shiftKey' in opts ? opts.shiftKey : false;
      let metaKey = opts && 'metaKey' in opts ? opts.metaKey : false;
      let relatedTarget = opts && 'relatedTarget' in opts ? opts.relatedTarget : null;
      let options = dart.map({view: view, deltaMode: deltaMode, deltaX: deltaX, deltaY: deltaY, deltaZ: deltaZ, detail: detail, screenX: screenX, screenY: screenY, clientX: clientX, clientY: clientY, button: button, bubbles: canBubble, cancelable: cancelable, ctrlKey: ctrlKey, altKey: altKey, shiftKey: shiftKey, metaKey: metaKey, relatedTarget: relatedTarget});
      if (view == null) {
        view = html$.window;
      }
      return new WheelEvent(type, html_common.convertDartToNative_Dictionary(options));
    }
    static _(type, eventInitDict) {
      if (eventInitDict === void 0) eventInitDict = null;
      if (eventInitDict != null) {
        let eventInitDict_1 = html_common.convertDartToNative_Dictionary(eventInitDict);
        return html$.WheelEvent._create_1(type, eventInitDict_1);
      }
      return html$.WheelEvent._create_2(type);
    }
    static _create_1(type, eventInitDict) {
      return new WheelEvent(type, eventInitDict);
    }
    static _create_2(type) {
      return new WheelEvent(type);
    }
    get [_deltaX]() {
      return this.deltaX;
    }
    get [_deltaY]() {
      return this.deltaY;
    }
    get [dartx.deltaZ]() {
      return this.deltaZ;
    }
    get [dartx.deltaY]() {
      if (this.deltaY !== undefined) {
        return this[_deltaY];
      }
      dart.throw(new core.UnsupportedError('deltaY is not supported'));
    }
    get [dartx.deltaX]() {
      if (this.deltaX !== undefined) {
        return this[_deltaX];
      }
      dart.throw(new core.UnsupportedError('deltaX is not supported'));
    }
    get [dartx.deltaMode]() {
      if (!!this.deltaMode) {
        return this.deltaMode;
      }
      return 0;
    }
    get [_wheelDelta]() {
      return this.wheelDelta;
    }
    get [_wheelDeltaX]() {
      return this.wheelDeltaX;
    }
    get [_detail]() {
      return this.detail;
    }
    get [_hasInitMouseScrollEvent]() {
      return !!this.initMouseScrollEvent;
    }
    [_initMouseScrollEvent](type, canBubble, cancelable, view, detail, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey, button, relatedTarget, axis) {
      return this.initMouseScrollEvent(type, canBubble, cancelable, view, detail, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey, button, relatedTarget, axis);
    }
    get [_hasInitWheelEvent]() {
      return !!this.initWheelEvent;
    }
    [_initWheelEvent](eventType, canBubble, cancelable, view, detail, screenX, screenY, clientX, clientY, button, relatedTarget, modifiersList, deltaX, deltaY, deltaZ, deltaMode) {
      return this.initWheelEvent(eventType, canBubble, cancelable, view, detail, screenX, screenY, clientX, clientY, button, relatedTarget, modifiersList, deltaX, deltaY, deltaZ, deltaMode);
    }
  };
  dart.setSignature(html$.WheelEvent, {
    constructors: () => ({
      new: [html$.WheelEvent, [core.String], {view: html$.Window, deltaX: core.num, deltaY: core.num, deltaZ: core.num, deltaMode: core.int, detail: core.int, screenX: core.int, screenY: core.int, clientX: core.int, clientY: core.int, button: core.int, canBubble: core.bool, cancelable: core.bool, ctrlKey: core.bool, altKey: core.bool, shiftKey: core.bool, metaKey: core.bool, relatedTarget: html$.EventTarget}],
      _: [html$.WheelEvent, [core.String], [core.Map]]
    }),
    methods: () => ({
      [_initMouseScrollEvent]: [dart.void, [core.String, core.bool, core.bool, html$.Window, core.int, core.int, core.int, core.int, core.int, core.bool, core.bool, core.bool, core.bool, core.int, html$.EventTarget, core.int]],
      [_initWheelEvent]: [dart.void, [core.String, core.bool, core.bool, html$.Window, core.int, core.int, core.int, core.int, core.int, core.int, html$.EventTarget, core.String, core.int, core.int, core.int, core.int]]
    }),
    statics: () => ({
      _create_1: [html$.WheelEvent, [dart.dynamic, dart.dynamic]],
      _create_2: [html$.WheelEvent, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$.WheelEvent[dart.metadata] = () => [dart.const(new _metadata.DomName('WheelEvent')), dart.const(new _js_helper.Native("WheelEvent"))];
  html$.WheelEvent.DOM_DELTA_LINE = 1;
  html$.WheelEvent.DOM_DELTA_PAGE = 2;
  html$.WheelEvent.DOM_DELTA_PIXEL = 0;
  dart.registerExtension(dart.global.WheelEvent, html$.WheelEvent);
  const _open2 = Symbol('_open2');
  const _open3 = Symbol('_open3');
  const _location = Symbol('_location');
  const _ensureRequestAnimationFrame = Symbol('_ensureRequestAnimationFrame');
  const _requestAnimationFrame = Symbol('_requestAnimationFrame');
  const _cancelAnimationFrame = Symbol('_cancelAnimationFrame');
  const _requestFileSystem = Symbol('_requestFileSystem');
  const _get_opener = Symbol('_get_opener');
  const _pageXOffset = Symbol('_pageXOffset');
  const _pageYOffset = Symbol('_pageYOffset');
  const _get_parent = Symbol('_get_parent');
  const _get_self = Symbol('_get_self');
  const _get_top = Symbol('_get_top');
  const __getter___1 = Symbol('__getter___1');
  const __getter___2 = Symbol('__getter___2');
  const _scroll_4 = Symbol('_scroll_4');
  const _scroll_5 = Symbol('_scroll_5');
  const _scrollBy_4 = Symbol('_scrollBy_4');
  const _scrollBy_5 = Symbol('_scrollBy_5');
  const _scrollTo_4 = Symbol('_scrollTo_4');
  const _scrollTo_5 = Symbol('_scrollTo_5');
  const __requestFileSystem = Symbol('__requestFileSystem');
  const _resolveLocalFileSystemUrl = Symbol('_resolveLocalFileSystemUrl');
  dart.defineExtensionNames([
    'animationFrame',
    'document',
    'open',
    'location',
    'location',
    'requestAnimationFrame',
    'cancelAnimationFrame',
    'indexedDB',
    'console',
    'requestFileSystem',
    'opener',
    'opener',
    'parent',
    'self',
    'top',
    'window',
    'alert',
    'close',
    'confirm',
    'fetch',
    'find',
    'getMatchedCssRules',
    'getSelection',
    'matchMedia',
    'moveBy',
    'openDatabase',
    'postMessage',
    'print',
    'resizeBy',
    'resizeTo',
    'scroll',
    'scrollBy',
    'scrollTo',
    'stop',
    'resolveLocalFileSystemUrl',
    'atob',
    'btoa',
    'onContentLoaded',
    'onAbort',
    'onBlur',
    'onCanPlay',
    'onCanPlayThrough',
    'onChange',
    'onClick',
    'onContextMenu',
    'onDoubleClick',
    'onDeviceMotion',
    'onDeviceOrientation',
    'onDrag',
    'onDragEnd',
    'onDragEnter',
    'onDragLeave',
    'onDragOver',
    'onDragStart',
    'onDrop',
    'onDurationChange',
    'onEmptied',
    'onEnded',
    'onError',
    'onFocus',
    'onHashChange',
    'onInput',
    'onInvalid',
    'onKeyDown',
    'onKeyPress',
    'onKeyUp',
    'onLoad',
    'onLoadedData',
    'onLoadedMetadata',
    'onLoadStart',
    'onMessage',
    'onMouseDown',
    'onMouseEnter',
    'onMouseLeave',
    'onMouseMove',
    'onMouseOut',
    'onMouseOver',
    'onMouseUp',
    'onMouseWheel',
    'onOffline',
    'onOnline',
    'onPageHide',
    'onPageShow',
    'onPause',
    'onPlay',
    'onPlaying',
    'onPopState',
    'onProgress',
    'onRateChange',
    'onReset',
    'onResize',
    'onScroll',
    'onSearch',
    'onSeeked',
    'onSeeking',
    'onSelect',
    'onStalled',
    'onStorage',
    'onSubmit',
    'onSuspend',
    'onTimeUpdate',
    'onTouchCancel',
    'onTouchEnd',
    'onTouchMove',
    'onTouchStart',
    'onTransitionEnd',
    'onUnload',
    'onVolumeChange',
    'onWaiting',
    'onAnimationEnd',
    'onAnimationIteration',
    'onAnimationStart',
    'onBeforeUnload',
    'moveTo',
    'pageXOffset',
    'pageYOffset',
    'scrollX',
    'scrollY',
    'applicationCache',
    'caches',
    'closed',
    'crypto',
    'defaultStatus',
    'defaultstatus',
    'devicePixelRatio',
    'history',
    'innerHeight',
    'innerWidth',
    'localStorage',
    'locationbar',
    'menubar',
    'name',
    'navigator',
    'offscreenBuffering',
    'orientation',
    'outerHeight',
    'outerWidth',
    'performance',
    'screen',
    'screenLeft',
    'screenTop',
    'screenX',
    'screenY',
    'scrollbars',
    'sessionStorage',
    'speechSynthesis',
    'status',
    'statusbar',
    'styleMedia',
    'toolbar'
  ]);
  html$.Window = class Window extends html$.EventTarget {
    get [dartx.animationFrame]() {
      let completer = async.Completer$(core.num).sync();
      this[dartx.requestAnimationFrame](dart.fn(time => {
        completer.complete(time);
      }, dart.void, [core.num]));
      return completer.future;
    }
    get [dartx.document]() {
      return this.document;
    }
    [_open2](url, name) {
      return this.open(url, name);
    }
    [_open3](url, name, options) {
      return this.open(url, name, options);
    }
    [dartx.open](url, name, options) {
      if (options === void 0) options = null;
      if (options == null) {
        return html$._DOMWindowCrossFrame._createSafe(this[_open2](url, name));
      } else {
        return html$._DOMWindowCrossFrame._createSafe(this[_open3](url, name, options));
      }
    }
    get [dartx.location]() {
      return dart.as(this[_location], html$.Location);
    }
    set [dartx.location](value) {
      this[_location] = value;
    }
    get [_location]() {
      return this.location;
    }
    set [_location](value) {
      this.location = value;
    }
    [dartx.requestAnimationFrame](callback) {
      this[_ensureRequestAnimationFrame]();
      return this[_requestAnimationFrame](html$._wrapZone(core.num, dart.dynamic)(callback));
    }
    [dartx.cancelAnimationFrame](id) {
      this[_ensureRequestAnimationFrame]();
      this[_cancelAnimationFrame](id);
    }
    [_requestAnimationFrame](callback) {
      return this.requestAnimationFrame(callback);
    }
    [_cancelAnimationFrame](id) {
      return this.cancelAnimationFrame(id);
    }
    [_ensureRequestAnimationFrame]() {
      if (!!(this.requestAnimationFrame && this.cancelAnimationFrame)) return;
      (function($this) {
        var vendors = ['ms', 'moz', 'webkit', 'o'];
        for (var i = 0; i < vendors.length && !$this.requestAnimationFrame; ++i) {
          $this.requestAnimationFrame = $this[vendors[i] + 'RequestAnimationFrame'];
          $this.cancelAnimationFrame = $this[vendors[i] + 'CancelAnimationFrame'] || $this[vendors[i] + 'CancelRequestAnimationFrame'];
        }
        if ($this.requestAnimationFrame && $this.cancelAnimationFrame) return;
        $this.requestAnimationFrame = function(callback) {
          return window.setTimeout(function() {
            callback(Date.now());
          }, 16);
        };
        $this.cancelAnimationFrame = function(id) {
          clearTimeout(id);
        };
      })(this);
    }
    get [dartx.indexedDB]() {
      return this.indexedDB || this.webkitIndexedDB || this.mozIndexedDB;
    }
    get [dartx.console]() {
      return html$.Console._safeConsole;
    }
    [dartx.requestFileSystem](size, opts) {
      let persistent = opts && 'persistent' in opts ? opts.persistent : false;
      return this[_requestFileSystem](dart.notNull(persistent) ? 1 : 0, size);
    }
    static get supportsPointConversions() {
      return html$.DomPoint.supported;
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.applicationCache]() {
      return this.applicationCache;
    }
    get [dartx.caches]() {
      return this.caches;
    }
    get [dartx.closed]() {
      return this.closed;
    }
    get [dartx.crypto]() {
      return this.crypto;
    }
    get [dartx.defaultStatus]() {
      return this.defaultStatus;
    }
    set [dartx.defaultStatus](value) {
      this.defaultStatus = value;
    }
    get [dartx.defaultstatus]() {
      return this.defaultstatus;
    }
    set [dartx.defaultstatus](value) {
      this.defaultstatus = value;
    }
    get [dartx.devicePixelRatio]() {
      return this.devicePixelRatio;
    }
    get [dartx.history]() {
      return this.history;
    }
    get [dartx.innerHeight]() {
      return this.innerHeight;
    }
    get [dartx.innerWidth]() {
      return this.innerWidth;
    }
    get [dartx.localStorage]() {
      return this.localStorage;
    }
    get [dartx.locationbar]() {
      return this.locationbar;
    }
    get [dartx.menubar]() {
      return this.menubar;
    }
    get [dartx.name]() {
      return this.name;
    }
    set [dartx.name](value) {
      this.name = value;
    }
    get [dartx.navigator]() {
      return this.navigator;
    }
    get [dartx.offscreenBuffering]() {
      return this.offscreenBuffering;
    }
    get [dartx.opener]() {
      return html$._convertNativeToDart_Window(this[_get_opener]);
    }
    get [_get_opener]() {
      return this.opener;
    }
    set [dartx.opener](value) {
      this.opener = value;
    }
    get [dartx.orientation]() {
      return this.orientation;
    }
    get [dartx.outerHeight]() {
      return this.outerHeight;
    }
    get [dartx.outerWidth]() {
      return this.outerWidth;
    }
    get [_pageXOffset]() {
      return this.pageXOffset;
    }
    get [_pageYOffset]() {
      return this.pageYOffset;
    }
    get [dartx.parent]() {
      return html$._convertNativeToDart_Window(this[_get_parent]);
    }
    get [_get_parent]() {
      return this.parent;
    }
    get [dartx.performance]() {
      return this.performance;
    }
    get [dartx.screen]() {
      return this.screen;
    }
    get [dartx.screenLeft]() {
      return this.screenLeft;
    }
    get [dartx.screenTop]() {
      return this.screenTop;
    }
    get [dartx.screenX]() {
      return this.screenX;
    }
    get [dartx.screenY]() {
      return this.screenY;
    }
    get [dartx.scrollbars]() {
      return this.scrollbars;
    }
    get [dartx.self]() {
      return html$._convertNativeToDart_Window(this[_get_self]);
    }
    get [_get_self]() {
      return this.self;
    }
    get [dartx.sessionStorage]() {
      return this.sessionStorage;
    }
    get [dartx.speechSynthesis]() {
      return this.speechSynthesis;
    }
    get [dartx.status]() {
      return this.status;
    }
    set [dartx.status](value) {
      this.status = value;
    }
    get [dartx.statusbar]() {
      return this.statusbar;
    }
    get [dartx.styleMedia]() {
      return this.styleMedia;
    }
    get [dartx.toolbar]() {
      return this.toolbar;
    }
    get [dartx.top]() {
      return html$._convertNativeToDart_Window(this[_get_top]);
    }
    get [_get_top]() {
      return this.top;
    }
    get [dartx.window]() {
      return html$._convertNativeToDart_Window(this[_get_window]);
    }
    get [_get_window]() {
      return this.window;
    }
    [__getter__](index_OR_name) {
      if (typeof index_OR_name == 'number') {
        return html$._convertNativeToDart_Window(this[__getter___1](index_OR_name));
      }
      if (typeof index_OR_name == 'string') {
        return html$._convertNativeToDart_Window(this[__getter___2](index_OR_name));
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    [__getter___1](index) {
      return this.__getter__(index);
    }
    [__getter___2](name) {
      return this.__getter__(name);
    }
    [dartx.alert](message) {
      return this.alert(message);
    }
    [dartx.close]() {
      return this.close();
    }
    [dartx.confirm](message) {
      return this.confirm(message);
    }
    [dartx.fetch](input, init) {
      if (init === void 0) init = null;
      if (init != null) {
        let init_1 = html_common.convertDartToNative_Dictionary(init);
        return this[_fetch_1](input, init_1);
      }
      return this[_fetch_2](input);
    }
    [_fetch_1](input, init) {
      return this.fetch(input, init);
    }
    [_fetch_2](input) {
      return this.fetch(input);
    }
    [dartx.find](string, caseSensitive, backwards, wrap, wholeWord, searchInFrames, showDialog) {
      return this.find(string, caseSensitive, backwards, wrap, wholeWord, searchInFrames, showDialog);
    }
    [_getComputedStyle](elt, pseudoElt) {
      return this.getComputedStyle(elt, pseudoElt);
    }
    [dartx.getMatchedCssRules](element, pseudoElement) {
      return this.getMatchedCSSRules(element, pseudoElement);
    }
    [dartx.getSelection]() {
      return this.getSelection();
    }
    [dartx.matchMedia](query) {
      return this.matchMedia(query);
    }
    [dartx.moveBy](x, y) {
      return this.moveBy(x, y);
    }
    [_moveTo](x, y) {
      return this.moveTo(x, y);
    }
    [dartx.openDatabase](name, version, displayName, estimatedSize, creationCallback) {
      return this.openDatabase(name, version, displayName, estimatedSize, creationCallback);
    }
    [dartx.postMessage](message, targetOrigin, transfer) {
      if (transfer === void 0) transfer = null;
      if (transfer != null) {
        let message_1 = html_common.convertDartToNative_SerializedScriptValue(message);
        this[_postMessage_1](message_1, targetOrigin, transfer);
        return;
      }
      let message_1 = html_common.convertDartToNative_SerializedScriptValue(message);
      this[_postMessage_2](message_1, targetOrigin);
      return;
    }
    [_postMessage_1](message, targetOrigin, transfer) {
      return this.postMessage(message, targetOrigin, transfer);
    }
    [_postMessage_2](message, targetOrigin) {
      return this.postMessage(message, targetOrigin);
    }
    [dartx.print]() {
      return this.print();
    }
    [dartx.resizeBy](x, y) {
      return this.resizeBy(x, y);
    }
    [dartx.resizeTo](x, y) {
      return this.resizeTo(x, y);
    }
    [dartx.scroll](options_OR_x, y, scrollOptions) {
      if (options_OR_x === void 0) options_OR_x = null;
      if (y === void 0) y = null;
      if (scrollOptions === void 0) scrollOptions = null;
      if (options_OR_x == null && y == null && scrollOptions == null) {
        this[_scroll_1]();
        return;
      }
      if (dart.is(options_OR_x, core.Map) && y == null && scrollOptions == null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options_OR_x);
        this[_scroll_2](options_1);
        return;
      }
      if (typeof y == 'number' && typeof options_OR_x == 'number' && scrollOptions == null) {
        this[_scroll_3](options_OR_x, y);
        return;
      }
      if (typeof y == 'number' && typeof options_OR_x == 'number' && scrollOptions == null) {
        this[_scroll_4](options_OR_x, y);
        return;
      }
      if (scrollOptions != null && typeof y == 'number' && typeof options_OR_x == 'number') {
        let scrollOptions_1 = html_common.convertDartToNative_Dictionary(scrollOptions);
        this[_scroll_5](options_OR_x, y, scrollOptions_1);
        return;
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    [_scroll_1]() {
      return this.scroll();
    }
    [_scroll_2](options) {
      return this.scroll(options);
    }
    [_scroll_3](x, y) {
      return this.scroll(x, y);
    }
    [_scroll_4](x, y) {
      return this.scroll(x, y);
    }
    [_scroll_5](x, y, scrollOptions) {
      return this.scroll(x, y, scrollOptions);
    }
    [dartx.scrollBy](options_OR_x, y, scrollOptions) {
      if (options_OR_x === void 0) options_OR_x = null;
      if (y === void 0) y = null;
      if (scrollOptions === void 0) scrollOptions = null;
      if (options_OR_x == null && y == null && scrollOptions == null) {
        this[_scrollBy_1]();
        return;
      }
      if (dart.is(options_OR_x, core.Map) && y == null && scrollOptions == null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options_OR_x);
        this[_scrollBy_2](options_1);
        return;
      }
      if (typeof y == 'number' && typeof options_OR_x == 'number' && scrollOptions == null) {
        this[_scrollBy_3](options_OR_x, y);
        return;
      }
      if (typeof y == 'number' && typeof options_OR_x == 'number' && scrollOptions == null) {
        this[_scrollBy_4](options_OR_x, y);
        return;
      }
      if (scrollOptions != null && typeof y == 'number' && typeof options_OR_x == 'number') {
        let scrollOptions_1 = html_common.convertDartToNative_Dictionary(scrollOptions);
        this[_scrollBy_5](options_OR_x, y, scrollOptions_1);
        return;
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    [_scrollBy_1]() {
      return this.scrollBy();
    }
    [_scrollBy_2](options) {
      return this.scrollBy(options);
    }
    [_scrollBy_3](x, y) {
      return this.scrollBy(x, y);
    }
    [_scrollBy_4](x, y) {
      return this.scrollBy(x, y);
    }
    [_scrollBy_5](x, y, scrollOptions) {
      return this.scrollBy(x, y, scrollOptions);
    }
    [dartx.scrollTo](options_OR_x, y, scrollOptions) {
      if (options_OR_x === void 0) options_OR_x = null;
      if (y === void 0) y = null;
      if (scrollOptions === void 0) scrollOptions = null;
      if (options_OR_x == null && y == null && scrollOptions == null) {
        this[_scrollTo_1]();
        return;
      }
      if (dart.is(options_OR_x, core.Map) && y == null && scrollOptions == null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options_OR_x);
        this[_scrollTo_2](options_1);
        return;
      }
      if (typeof y == 'number' && typeof options_OR_x == 'number' && scrollOptions == null) {
        this[_scrollTo_3](options_OR_x, y);
        return;
      }
      if (typeof y == 'number' && typeof options_OR_x == 'number' && scrollOptions == null) {
        this[_scrollTo_4](options_OR_x, y);
        return;
      }
      if (scrollOptions != null && typeof y == 'number' && typeof options_OR_x == 'number') {
        let scrollOptions_1 = html_common.convertDartToNative_Dictionary(scrollOptions);
        this[_scrollTo_5](options_OR_x, y, scrollOptions_1);
        return;
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    [_scrollTo_1]() {
      return this.scrollTo();
    }
    [_scrollTo_2](options) {
      return this.scrollTo(options);
    }
    [_scrollTo_3](x, y) {
      return this.scrollTo(x, y);
    }
    [_scrollTo_4](x, y) {
      return this.scrollTo(x, y);
    }
    [_scrollTo_5](x, y, scrollOptions) {
      return this.scrollTo(x, y, scrollOptions);
    }
    [dartx.stop]() {
      return this.stop();
    }
    [__requestFileSystem](type, size, successCallback, errorCallback) {
      return this.webkitRequestFileSystem(type, size, successCallback, errorCallback);
    }
    [_requestFileSystem](type, size) {
      let completer = async.Completer$(html$.FileSystem).new();
      this[__requestFileSystem](type, size, dart.fn(value => {
        completer.complete(value);
      }, dart.void, [html$.FileSystem]), dart.fn(error => {
        completer.completeError(error);
      }, dart.void, [html$.FileError]));
      return completer.future;
    }
    [_resolveLocalFileSystemUrl](url, successCallback, errorCallback) {
      return this.webkitResolveLocalFileSystemURL(url, successCallback, errorCallback);
    }
    [dartx.resolveLocalFileSystemUrl](url) {
      let completer = async.Completer$(html$.Entry).new();
      this[_resolveLocalFileSystemUrl](url, dart.fn(value => {
        completer.complete(value);
      }, dart.void, [html$.Entry]), dart.fn(error => {
        completer.completeError(error);
      }, dart.void, [html$.FileError]));
      return completer.future;
    }
    [dartx.atob](atob) {
      return this.atob(atob);
    }
    [dartx.btoa](btoa) {
      return this.btoa(btoa);
    }
    [_setInterval_String](handler, timeout, arguments$) {
      return this.setInterval(handler, timeout, arguments$);
    }
    [_setTimeout_String](handler, timeout, arguments$) {
      return this.setTimeout(handler, timeout, arguments$);
    }
    [_clearInterval](handle) {
      return this.clearInterval(handle);
    }
    [_clearTimeout](handle) {
      return this.clearTimeout(handle);
    }
    [_setInterval](handler, timeout) {
      return this.setInterval(handler, timeout);
    }
    [_setTimeout](handler, timeout) {
      return this.setTimeout(handler, timeout);
    }
    get [dartx.onContentLoaded]() {
      return html$.Window.contentLoadedEvent.forTarget(this);
    }
    get [dartx.onAbort]() {
      return html$.Element.abortEvent.forTarget(this);
    }
    get [dartx.onBlur]() {
      return html$.Element.blurEvent.forTarget(this);
    }
    get [dartx.onCanPlay]() {
      return html$.Element.canPlayEvent.forTarget(this);
    }
    get [dartx.onCanPlayThrough]() {
      return html$.Element.canPlayThroughEvent.forTarget(this);
    }
    get [dartx.onChange]() {
      return html$.Element.changeEvent.forTarget(this);
    }
    get [dartx.onClick]() {
      return html$.Element.clickEvent.forTarget(this);
    }
    get [dartx.onContextMenu]() {
      return html$.Element.contextMenuEvent.forTarget(this);
    }
    get [dartx.onDoubleClick]() {
      return html$.Element.doubleClickEvent.forTarget(this);
    }
    get [dartx.onDeviceMotion]() {
      return html$.Window.deviceMotionEvent.forTarget(this);
    }
    get [dartx.onDeviceOrientation]() {
      return html$.Window.deviceOrientationEvent.forTarget(this);
    }
    get [dartx.onDrag]() {
      return html$.Element.dragEvent.forTarget(this);
    }
    get [dartx.onDragEnd]() {
      return html$.Element.dragEndEvent.forTarget(this);
    }
    get [dartx.onDragEnter]() {
      return html$.Element.dragEnterEvent.forTarget(this);
    }
    get [dartx.onDragLeave]() {
      return html$.Element.dragLeaveEvent.forTarget(this);
    }
    get [dartx.onDragOver]() {
      return html$.Element.dragOverEvent.forTarget(this);
    }
    get [dartx.onDragStart]() {
      return html$.Element.dragStartEvent.forTarget(this);
    }
    get [dartx.onDrop]() {
      return html$.Element.dropEvent.forTarget(this);
    }
    get [dartx.onDurationChange]() {
      return html$.Element.durationChangeEvent.forTarget(this);
    }
    get [dartx.onEmptied]() {
      return html$.Element.emptiedEvent.forTarget(this);
    }
    get [dartx.onEnded]() {
      return html$.Element.endedEvent.forTarget(this);
    }
    get [dartx.onError]() {
      return html$.Element.errorEvent.forTarget(this);
    }
    get [dartx.onFocus]() {
      return html$.Element.focusEvent.forTarget(this);
    }
    get [dartx.onHashChange]() {
      return html$.Window.hashChangeEvent.forTarget(this);
    }
    get [dartx.onInput]() {
      return html$.Element.inputEvent.forTarget(this);
    }
    get [dartx.onInvalid]() {
      return html$.Element.invalidEvent.forTarget(this);
    }
    get [dartx.onKeyDown]() {
      return html$.Element.keyDownEvent.forTarget(this);
    }
    get [dartx.onKeyPress]() {
      return html$.Element.keyPressEvent.forTarget(this);
    }
    get [dartx.onKeyUp]() {
      return html$.Element.keyUpEvent.forTarget(this);
    }
    get [dartx.onLoad]() {
      return html$.Element.loadEvent.forTarget(this);
    }
    get [dartx.onLoadedData]() {
      return html$.Element.loadedDataEvent.forTarget(this);
    }
    get [dartx.onLoadedMetadata]() {
      return html$.Element.loadedMetadataEvent.forTarget(this);
    }
    get [dartx.onLoadStart]() {
      return html$.Window.loadStartEvent.forTarget(this);
    }
    get [dartx.onMessage]() {
      return html$.Window.messageEvent.forTarget(this);
    }
    get [dartx.onMouseDown]() {
      return html$.Element.mouseDownEvent.forTarget(this);
    }
    get [dartx.onMouseEnter]() {
      return html$.Element.mouseEnterEvent.forTarget(this);
    }
    get [dartx.onMouseLeave]() {
      return html$.Element.mouseLeaveEvent.forTarget(this);
    }
    get [dartx.onMouseMove]() {
      return html$.Element.mouseMoveEvent.forTarget(this);
    }
    get [dartx.onMouseOut]() {
      return html$.Element.mouseOutEvent.forTarget(this);
    }
    get [dartx.onMouseOver]() {
      return html$.Element.mouseOverEvent.forTarget(this);
    }
    get [dartx.onMouseUp]() {
      return html$.Element.mouseUpEvent.forTarget(this);
    }
    get [dartx.onMouseWheel]() {
      return html$.Element.mouseWheelEvent.forTarget(this);
    }
    get [dartx.onOffline]() {
      return html$.Window.offlineEvent.forTarget(this);
    }
    get [dartx.onOnline]() {
      return html$.Window.onlineEvent.forTarget(this);
    }
    get [dartx.onPageHide]() {
      return html$.Window.pageHideEvent.forTarget(this);
    }
    get [dartx.onPageShow]() {
      return html$.Window.pageShowEvent.forTarget(this);
    }
    get [dartx.onPause]() {
      return html$.Element.pauseEvent.forTarget(this);
    }
    get [dartx.onPlay]() {
      return html$.Element.playEvent.forTarget(this);
    }
    get [dartx.onPlaying]() {
      return html$.Element.playingEvent.forTarget(this);
    }
    get [dartx.onPopState]() {
      return html$.Window.popStateEvent.forTarget(this);
    }
    get [dartx.onProgress]() {
      return html$.Window.progressEvent.forTarget(this);
    }
    get [dartx.onRateChange]() {
      return html$.Element.rateChangeEvent.forTarget(this);
    }
    get [dartx.onReset]() {
      return html$.Element.resetEvent.forTarget(this);
    }
    get [dartx.onResize]() {
      return html$.Element.resizeEvent.forTarget(this);
    }
    get [dartx.onScroll]() {
      return html$.Element.scrollEvent.forTarget(this);
    }
    get [dartx.onSearch]() {
      return html$.Element.searchEvent.forTarget(this);
    }
    get [dartx.onSeeked]() {
      return html$.Element.seekedEvent.forTarget(this);
    }
    get [dartx.onSeeking]() {
      return html$.Element.seekingEvent.forTarget(this);
    }
    get [dartx.onSelect]() {
      return html$.Element.selectEvent.forTarget(this);
    }
    get [dartx.onStalled]() {
      return html$.Element.stalledEvent.forTarget(this);
    }
    get [dartx.onStorage]() {
      return html$.Window.storageEvent.forTarget(this);
    }
    get [dartx.onSubmit]() {
      return html$.Element.submitEvent.forTarget(this);
    }
    get [dartx.onSuspend]() {
      return html$.Element.suspendEvent.forTarget(this);
    }
    get [dartx.onTimeUpdate]() {
      return html$.Element.timeUpdateEvent.forTarget(this);
    }
    get [dartx.onTouchCancel]() {
      return html$.Element.touchCancelEvent.forTarget(this);
    }
    get [dartx.onTouchEnd]() {
      return html$.Element.touchEndEvent.forTarget(this);
    }
    get [dartx.onTouchMove]() {
      return html$.Element.touchMoveEvent.forTarget(this);
    }
    get [dartx.onTouchStart]() {
      return html$.Element.touchStartEvent.forTarget(this);
    }
    get [dartx.onTransitionEnd]() {
      return html$.Element.transitionEndEvent.forTarget(this);
    }
    get [dartx.onUnload]() {
      return html$.Window.unloadEvent.forTarget(this);
    }
    get [dartx.onVolumeChange]() {
      return html$.Element.volumeChangeEvent.forTarget(this);
    }
    get [dartx.onWaiting]() {
      return html$.Element.waitingEvent.forTarget(this);
    }
    get [dartx.onAnimationEnd]() {
      return html$.Window.animationEndEvent.forTarget(this);
    }
    get [dartx.onAnimationIteration]() {
      return html$.Window.animationIterationEvent.forTarget(this);
    }
    get [dartx.onAnimationStart]() {
      return html$.Window.animationStartEvent.forTarget(this);
    }
    get [dartx.onBeforeUnload]() {
      return html$.Window.beforeUnloadEvent.forTarget(this);
    }
    [dartx.moveTo](p) {
      this[_moveTo](dart.asInt(p.x), dart.asInt(p.y));
    }
    get [dartx.pageXOffset]() {
      return this.pageXOffset[dartx.round]();
    }
    get [dartx.pageYOffset]() {
      return this.pageYOffset[dartx.round]();
    }
    get [dartx.scrollX]() {
      return "scrollX" in this ? this.scrollX[dartx.round]() : this[dartx.document][dartx.documentElement][dartx.scrollLeft];
    }
    get [dartx.scrollY]() {
      return "scrollY" in this ? this.scrollY[dartx.round]() : this[dartx.document][dartx.documentElement][dartx.scrollTop];
    }
  };
  html$.Window[dart.implements] = () => [html$.WindowEventHandlers, html$.WindowBase, html$.GlobalEventHandlers, html$._WindowTimers, html$.WindowBase64];
  dart.setSignature(html$.Window, {
    constructors: () => ({_: [html$.Window, []]}),
    methods: () => ({
      [_open2]: [html$.WindowBase, [dart.dynamic, dart.dynamic]],
      [_open3]: [html$.WindowBase, [dart.dynamic, dart.dynamic, dart.dynamic]],
      [dartx.open]: [html$.WindowBase, [core.String, core.String], [core.String]],
      [dartx.requestAnimationFrame]: [core.int, [html$.FrameRequestCallback]],
      [dartx.cancelAnimationFrame]: [dart.void, [core.int]],
      [_requestAnimationFrame]: [core.int, [html$.FrameRequestCallback]],
      [_cancelAnimationFrame]: [dart.void, [core.int]],
      [_ensureRequestAnimationFrame]: [dart.dynamic, []],
      [dartx.requestFileSystem]: [async.Future$(html$.FileSystem), [core.int], {persistent: core.bool}],
      [__getter__]: [html$.WindowBase, [dart.dynamic]],
      [__getter___1]: [dart.dynamic, [core.int]],
      [__getter___2]: [dart.dynamic, [core.String]],
      [dartx.alert]: [dart.void, [], [core.String]],
      [dartx.close]: [dart.void, []],
      [dartx.confirm]: [core.bool, [], [core.String]],
      [dartx.fetch]: [async.Future, [dart.dynamic], [core.Map]],
      [_fetch_1]: [async.Future, [dart.dynamic, dart.dynamic]],
      [_fetch_2]: [async.Future, [dart.dynamic]],
      [dartx.find]: [core.bool, [core.String, core.bool, core.bool, core.bool, core.bool, core.bool, core.bool]],
      [_getComputedStyle]: [html$.CssStyleDeclaration, [html$.Element, core.String]],
      [dartx.getMatchedCssRules]: [core.List$(html$.CssRule), [html$.Element, core.String]],
      [dartx.getSelection]: [html$.Selection, []],
      [dartx.matchMedia]: [html$.MediaQueryList, [core.String]],
      [dartx.moveBy]: [dart.void, [core.int, core.int]],
      [_moveTo]: [dart.void, [core.int, core.int]],
      [dartx.openDatabase]: [web_sql.SqlDatabase, [core.String, core.String, core.String, core.int], [html$.DatabaseCallback]],
      [dartx.postMessage]: [dart.void, [dart.dynamic, core.String], [core.List$(html$.MessagePort)]],
      [_postMessage_1]: [dart.void, [dart.dynamic, dart.dynamic, core.List$(html$.MessagePort)]],
      [_postMessage_2]: [dart.void, [dart.dynamic, dart.dynamic]],
      [dartx.print]: [dart.void, []],
      [dartx.resizeBy]: [dart.void, [core.int, core.int]],
      [dartx.resizeTo]: [dart.void, [core.int, core.int]],
      [dartx.scroll]: [dart.void, [], [dart.dynamic, dart.dynamic, core.Map]],
      [_scroll_1]: [dart.void, []],
      [_scroll_2]: [dart.void, [dart.dynamic]],
      [_scroll_3]: [dart.void, [core.num, core.num]],
      [_scroll_4]: [dart.void, [core.int, core.int]],
      [_scroll_5]: [dart.void, [core.int, core.int, dart.dynamic]],
      [dartx.scrollBy]: [dart.void, [], [dart.dynamic, dart.dynamic, core.Map]],
      [_scrollBy_1]: [dart.void, []],
      [_scrollBy_2]: [dart.void, [dart.dynamic]],
      [_scrollBy_3]: [dart.void, [core.num, core.num]],
      [_scrollBy_4]: [dart.void, [core.int, core.int]],
      [_scrollBy_5]: [dart.void, [core.int, core.int, dart.dynamic]],
      [dartx.scrollTo]: [dart.void, [], [dart.dynamic, dart.dynamic, core.Map]],
      [_scrollTo_1]: [dart.void, []],
      [_scrollTo_2]: [dart.void, [dart.dynamic]],
      [_scrollTo_3]: [dart.void, [core.num, core.num]],
      [_scrollTo_4]: [dart.void, [core.int, core.int]],
      [_scrollTo_5]: [dart.void, [core.int, core.int, dart.dynamic]],
      [dartx.stop]: [dart.void, []],
      [__requestFileSystem]: [dart.void, [core.int, core.int, html$._FileSystemCallback], [html$._ErrorCallback]],
      [_requestFileSystem]: [async.Future$(html$.FileSystem), [core.int, core.int]],
      [_resolveLocalFileSystemUrl]: [dart.void, [core.String, html$._EntryCallback], [html$._ErrorCallback]],
      [dartx.resolveLocalFileSystemUrl]: [async.Future$(html$.Entry), [core.String]],
      [dartx.atob]: [core.String, [core.String]],
      [dartx.btoa]: [core.String, [core.String]],
      [_setInterval_String]: [core.int, [core.String], [core.int, core.Object]],
      [_setTimeout_String]: [core.int, [core.String], [core.int, core.Object]],
      [_clearInterval]: [dart.void, [], [core.int]],
      [_clearTimeout]: [dart.void, [], [core.int]],
      [_setInterval]: [core.int, [core.Object], [core.int]],
      [_setTimeout]: [core.int, [core.Object], [core.int]],
      [dartx.moveTo]: [dart.void, [math.Point$(core.num)]]
    })
  });
  html$.Window[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Window')), dart.const(new _js_helper.Native("Window,DOMWindow"))];
  html$.Window.PERSISTENT = 1;
  html$.Window.TEMPORARY = 0;
  dart.defineLazy(html$.Window, {
    get contentLoadedEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('DOMContentLoaded'));
    },
    get deviceMotionEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.DeviceMotionEvent))('devicemotion'));
    },
    get deviceOrientationEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.DeviceOrientationEvent))('deviceorientation'));
    },
    get hashChangeEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('hashchange'));
    },
    get loadStartEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('loadstart'));
    },
    get messageEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MessageEvent))('message'));
    },
    get offlineEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('offline'));
    },
    get onlineEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('online'));
    },
    get pageHideEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('pagehide'));
    },
    get pageShowEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('pageshow'));
    },
    get popStateEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.PopStateEvent))('popstate'));
    },
    get progressEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('progress'));
    },
    get storageEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.StorageEvent))('storage'));
    },
    get unloadEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('unload'));
    },
    get animationEndEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.AnimationEvent))('webkitAnimationEnd'));
    },
    get animationIterationEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.AnimationEvent))('webkitAnimationIteration'));
    },
    get animationStartEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.AnimationEvent))('webkitAnimationStart'));
    },
    get beforeUnloadEvent() {
      return dart.const(new html$._BeforeUnloadEventStreamProvider('beforeunload'));
    }
  });
  dart.registerExtension(dart.global.Window, html$.Window);
  const _returnValue = Symbol('_returnValue');
  html$._WrappedEvent = class _WrappedEvent extends core.Object {
    _WrappedEvent(wrapped) {
      this.wrapped = wrapped;
      this[_selector] = null;
    }
    get bubbles() {
      return this.wrapped[dartx.bubbles];
    }
    get cancelable() {
      return this.wrapped[dartx.cancelable];
    }
    get currentTarget() {
      return this.wrapped[dartx.currentTarget];
    }
    get defaultPrevented() {
      return this.wrapped[dartx.defaultPrevented];
    }
    get eventPhase() {
      return this.wrapped[dartx.eventPhase];
    }
    get target() {
      return this.wrapped[dartx.target];
    }
    get timeStamp() {
      return this.wrapped[dartx.timeStamp];
    }
    get type() {
      return this.wrapped[dartx.type];
    }
    [_initEvent](eventTypeArg, canBubbleArg, cancelableArg) {
      dart.throw(new core.UnsupportedError('Cannot initialize this Event.'));
    }
    preventDefault() {
      this.wrapped[dartx.preventDefault]();
    }
    stopImmediatePropagation() {
      this.wrapped[dartx.stopImmediatePropagation]();
    }
    stopPropagation() {
      this.wrapped[dartx.stopPropagation]();
    }
    get matchingTarget() {
      if (this[_selector] == null) {
        dart.throw(new core.UnsupportedError('Cannot call matchingTarget if this Event did' + ' not arise as a result of event delegation.'));
      }
      let currentTarget = dart.as(this.currentTarget, html$.Element);
      let target = dart.as(this.target, html$.Element);
      let matchedTarget = null;
      do {
        if (dart.notNull(target[dartx.matches](this[_selector]))) return target;
        target = target[dartx.parent];
      } while (target != null && !dart.equals(target, currentTarget[dartx.parent]));
      dart.throw(new core.StateError('No selector matched for populating matchedTarget.'));
    }
    get path() {
      return dart.as(this.wrapped[dartx.path], core.List$(html$.Node));
    }
    get [_get_currentTarget]() {
      return this.wrapped[_get_currentTarget];
    }
    get [_get_target]() {
      return this.wrapped[_get_target];
    }
  };
  html$._WrappedEvent[dart.implements] = () => [html$.Event];
  dart.setSignature(html$._WrappedEvent, {
    constructors: () => ({_WrappedEvent: [html$._WrappedEvent, [html$.Event]]}),
    methods: () => ({
      [_initEvent]: [dart.void, [core.String, core.bool, core.bool]],
      preventDefault: [dart.void, []],
      stopImmediatePropagation: [dart.void, []],
      stopPropagation: [dart.void, []]
    })
  });
  html$._BeforeUnloadEvent = class _BeforeUnloadEvent extends html$._WrappedEvent {
    _BeforeUnloadEvent(base) {
      this[_returnValue] = null;
      super._WrappedEvent(base);
    }
    get returnValue() {
      return this[_returnValue];
    }
    set returnValue(value) {
      this[_returnValue] = value;
      if ("returnValue" in this.wrapped) {
        this.wrapped.returnValue = value;
      }
    }
  };
  html$._BeforeUnloadEvent[dart.implements] = () => [html$.BeforeUnloadEvent];
  dart.setSignature(html$._BeforeUnloadEvent, {
    constructors: () => ({_BeforeUnloadEvent: [html$._BeforeUnloadEvent, [html$.Event]]})
  });
  const _eventType = Symbol('_eventType');
  html$._BeforeUnloadEventStreamProvider = class _BeforeUnloadEventStreamProvider extends core.Object {
    _BeforeUnloadEventStreamProvider(eventType) {
      this[_eventType] = eventType;
    }
    forTarget(e, opts) {
      let useCapture = opts && 'useCapture' in opts ? opts.useCapture : false;
      let stream = new (html$._EventStream$(html$.Event))(e, this[_eventType], useCapture);
      let controller = async.StreamController$(html$.BeforeUnloadEvent).new({sync: true});
      stream.listen(dart.fn(event => {
        let wrapped = new html$._BeforeUnloadEvent(event);
        controller.add(wrapped);
      }, dart.void, [html$.Event]));
      return controller.stream;
    }
    getEventType(target) {
      return this[_eventType];
    }
    forElement(e, opts) {
      let useCapture = opts && 'useCapture' in opts ? opts.useCapture : false;
      return new (html$._ElementEventStreamImpl$(html$.Event))(e, this[_eventType], useCapture);
    }
    [_forElementList](e, opts) {
      let useCapture = opts && 'useCapture' in opts ? opts.useCapture : false;
      return new (html$._ElementListEventStreamImpl$(html$.Event))(e, this[_eventType], useCapture);
    }
  };
  html$._BeforeUnloadEventStreamProvider[dart.implements] = () => [html$.EventStreamProvider$(html$.BeforeUnloadEvent)];
  dart.setSignature(html$._BeforeUnloadEventStreamProvider, {
    constructors: () => ({_BeforeUnloadEventStreamProvider: [html$._BeforeUnloadEventStreamProvider, [core.String]]}),
    methods: () => ({
      forTarget: [async.Stream$(html$.BeforeUnloadEvent), [html$.EventTarget], {useCapture: core.bool}],
      getEventType: [core.String, [html$.EventTarget]],
      forElement: [html$.ElementStream$(html$.BeforeUnloadEvent), [html$.Element], {useCapture: core.bool}],
      [_forElementList]: [html$.ElementStream$(html$.BeforeUnloadEvent), [html$.ElementList$(html$.Element)], {useCapture: core.bool}]
    })
  });
  html$.WindowBase64 = class WindowBase64 extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$.WindowBase64, {
    constructors: () => ({_: [html$.WindowBase64, []]})
  });
  html$.WindowBase64[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('WindowBase64')), dart.const(new _metadata.Experimental())];
  dart.defineExtensionNames([
    'focus',
    'focused',
    'visibilityState'
  ]);
  html$.WindowClient = class WindowClient extends html$.Client {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.focused]() {
      return this.focused;
    }
    get [dartx.visibilityState]() {
      return this.visibilityState;
    }
    [dartx.focus]() {
      return this.focus();
    }
  };
  dart.setSignature(html$.WindowClient, {
    constructors: () => ({_: [html$.WindowClient, []]}),
    methods: () => ({[dartx.focus]: [async.Future, []]})
  });
  html$.WindowClient[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('WindowClient')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("WindowClient"))];
  dart.registerExtension(dart.global.WindowClient, html$.WindowClient);
  dart.defineExtensionNames([
    'onHashChange',
    'onMessage',
    'onOffline',
    'onOnline',
    'onPopState',
    'onStorage',
    'onUnload'
  ]);
  html$.WindowEventHandlers = class WindowEventHandlers extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get onHashChange() {
      return html$.WindowEventHandlers.hashChangeEvent.forTarget(this);
    }
    get onMessage() {
      return html$.WindowEventHandlers.messageEvent.forTarget(this);
    }
    get onOffline() {
      return html$.WindowEventHandlers.offlineEvent.forTarget(this);
    }
    get onOnline() {
      return html$.WindowEventHandlers.onlineEvent.forTarget(this);
    }
    get onPopState() {
      return html$.WindowEventHandlers.popStateEvent.forTarget(this);
    }
    get onStorage() {
      return html$.WindowEventHandlers.storageEvent.forTarget(this);
    }
    get onUnload() {
      return html$.WindowEventHandlers.unloadEvent.forTarget(this);
    }
  };
  dart.setSignature(html$.WindowEventHandlers, {
    constructors: () => ({_: [html$.WindowEventHandlers, []]})
  });
  dart.defineExtensionMembers(html$.WindowEventHandlers, [
    'onHashChange',
    'onMessage',
    'onOffline',
    'onOnline',
    'onPopState',
    'onStorage',
    'onUnload'
  ]);
  html$.WindowEventHandlers[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('WindowEventHandlers')), dart.const(new _metadata.Experimental())];
  dart.defineLazy(html$.WindowEventHandlers, {
    get hashChangeEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('hashchange'));
    },
    get messageEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MessageEvent))('message'));
    },
    get offlineEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('offline'));
    },
    get onlineEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('online'));
    },
    get popStateEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.PopStateEvent))('popstate'));
    },
    get storageEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.StorageEvent))('storage'));
    },
    get unloadEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('unload'));
    }
  });
  dart.defineExtensionNames([
    'postMessage',
    'terminate',
    'onError',
    'onMessage'
  ]);
  html$.Worker = class Worker extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(scriptUrl) {
      return html$.Worker._create_1(scriptUrl);
    }
    static _create_1(scriptUrl) {
      return new Worker(scriptUrl);
    }
    static get supported() {
      return typeof window.Worker != "undefined";
    }
    [dartx.postMessage](message, transfer) {
      if (transfer === void 0) transfer = null;
      if (transfer != null) {
        let message_1 = html_common.convertDartToNative_SerializedScriptValue(message);
        this[_postMessage_1](message_1, transfer);
        return;
      }
      let message_1 = html_common.convertDartToNative_SerializedScriptValue(message);
      this[_postMessage_2](message_1);
      return;
    }
    [_postMessage_1](message, transfer) {
      return this.postMessage(message, transfer);
    }
    [_postMessage_2](message) {
      return this.postMessage(message);
    }
    [dartx.terminate]() {
      return this.terminate();
    }
    get [dartx.onError]() {
      return html$.Worker.errorEvent.forTarget(this);
    }
    get [dartx.onMessage]() {
      return html$.Worker.messageEvent.forTarget(this);
    }
  };
  html$.Worker[dart.implements] = () => [html$.AbstractWorker];
  dart.setSignature(html$.Worker, {
    constructors: () => ({
      _: [html$.Worker, []],
      new: [html$.Worker, [core.String]]
    }),
    methods: () => ({
      [dartx.postMessage]: [dart.void, [dart.dynamic], [core.List$(html$.MessagePort)]],
      [_postMessage_1]: [dart.void, [dart.dynamic, core.List$(html$.MessagePort)]],
      [_postMessage_2]: [dart.void, [dart.dynamic]],
      [dartx.terminate]: [dart.void, []]
    }),
    statics: () => ({_create_1: [html$.Worker, [dart.dynamic]]}),
    names: ['_create_1']
  });
  html$.Worker[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Worker')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("Worker"))];
  dart.defineLazy(html$.Worker, {
    get errorEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('error'));
    },
    get messageEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MessageEvent))('message'));
    }
  });
  dart.registerExtension(dart.global.Worker, html$.Worker);
  html$.WorkerConsole = class WorkerConsole extends html$.ConsoleBase {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$.WorkerConsole, {
    constructors: () => ({_: [html$.WorkerConsole, []]})
  });
  html$.WorkerConsole[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('WorkerConsole')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("WorkerConsole"))];
  dart.registerExtension(dart.global.WorkerConsole, html$.WorkerConsole);
  dart.defineExtensionNames([
    'clearMarks',
    'clearMeasures',
    'getEntries',
    'getEntriesByName',
    'getEntriesByType',
    'mark',
    'measure',
    'now',
    'clearResourceTimings',
    'setResourceTimingBufferSize',
    'memory'
  ]);
  html$.WorkerPerformance = class WorkerPerformance extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.memory]() {
      return this.memory;
    }
    [dartx.clearMarks](markName) {
      return this.clearMarks(markName);
    }
    [dartx.clearMeasures](measureName) {
      return this.clearMeasures(measureName);
    }
    [dartx.getEntries]() {
      return this.getEntries();
    }
    [dartx.getEntriesByName](name, entryType) {
      return this.getEntriesByName(name, entryType);
    }
    [dartx.getEntriesByType](entryType) {
      return this.getEntriesByType(entryType);
    }
    [dartx.mark](markName) {
      return this.mark(markName);
    }
    [dartx.measure](measureName, startMark, endMark) {
      return this.measure(measureName, startMark, endMark);
    }
    [dartx.now]() {
      return this.now();
    }
    [dartx.clearResourceTimings]() {
      return this.webkitClearResourceTimings();
    }
    [dartx.setResourceTimingBufferSize](maxSize) {
      return this.webkitSetResourceTimingBufferSize(maxSize);
    }
  };
  dart.setSignature(html$.WorkerPerformance, {
    constructors: () => ({_: [html$.WorkerPerformance, []]}),
    methods: () => ({
      [dartx.clearMarks]: [dart.void, [core.String]],
      [dartx.clearMeasures]: [dart.void, [core.String]],
      [dartx.getEntries]: [core.List$(html$.PerformanceEntry), []],
      [dartx.getEntriesByName]: [core.List$(html$.PerformanceEntry), [core.String, core.String]],
      [dartx.getEntriesByType]: [core.List$(html$.PerformanceEntry), [core.String]],
      [dartx.mark]: [dart.void, [core.String]],
      [dartx.measure]: [dart.void, [core.String, core.String, core.String]],
      [dartx.now]: [core.double, []],
      [dartx.clearResourceTimings]: [dart.void, []],
      [dartx.setResourceTimingBufferSize]: [dart.void, [core.int]]
    })
  });
  html$.WorkerPerformance[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('WorkerPerformance')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("WorkerPerformance"))];
  dart.registerExtension(dart.global.WorkerPerformance, html$.WorkerPerformance);
  dart.defineExtensionNames([
    'createExpression',
    'createNSResolver',
    'evaluate'
  ]);
  html$.XPathEvaluator = class XPathEvaluator extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.XPathEvaluator._create_1();
    }
    static _create_1() {
      return new XPathEvaluator();
    }
    [dartx.createExpression](expression, resolver) {
      return this.createExpression(expression, resolver);
    }
    [dartx.createNSResolver](nodeResolver) {
      return this.createNSResolver(nodeResolver);
    }
    [dartx.evaluate](expression, contextNode, resolver, type, inResult) {
      return this.evaluate(expression, contextNode, resolver, type, inResult);
    }
  };
  dart.setSignature(html$.XPathEvaluator, {
    constructors: () => ({
      _: [html$.XPathEvaluator, []],
      new: [html$.XPathEvaluator, []]
    }),
    methods: () => ({
      [dartx.createExpression]: [html$.XPathExpression, [core.String, html$.XPathNSResolver]],
      [dartx.createNSResolver]: [html$.XPathNSResolver, [html$.Node]],
      [dartx.evaluate]: [html$.XPathResult, [core.String, html$.Node, html$.XPathNSResolver], [core.int, core.Object]]
    }),
    statics: () => ({_create_1: [html$.XPathEvaluator, []]}),
    names: ['_create_1']
  });
  html$.XPathEvaluator[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('XPathEvaluator')), core.deprecated, dart.const(new _js_helper.Native("XPathEvaluator"))];
  dart.registerExtension(dart.global.XPathEvaluator, html$.XPathEvaluator);
  dart.defineExtensionNames([
    'evaluate'
  ]);
  html$.XPathExpression = class XPathExpression extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.evaluate](contextNode, type, inResult) {
      return this.evaluate(contextNode, type, inResult);
    }
  };
  dart.setSignature(html$.XPathExpression, {
    constructors: () => ({_: [html$.XPathExpression, []]}),
    methods: () => ({[dartx.evaluate]: [html$.XPathResult, [html$.Node], [core.int, core.Object]]})
  });
  html$.XPathExpression[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('XPathExpression')), core.deprecated, dart.const(new _js_helper.Native("XPathExpression"))];
  dart.registerExtension(dart.global.XPathExpression, html$.XPathExpression);
  dart.defineExtensionNames([
    'lookupNamespaceUri'
  ]);
  html$.XPathNSResolver = class XPathNSResolver extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.lookupNamespaceUri](prefix) {
      return this.lookupNamespaceURI(prefix);
    }
  };
  dart.setSignature(html$.XPathNSResolver, {
    constructors: () => ({_: [html$.XPathNSResolver, []]}),
    methods: () => ({[dartx.lookupNamespaceUri]: [core.String, [core.String]]})
  });
  html$.XPathNSResolver[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('XPathNSResolver')), core.deprecated, dart.const(new _js_helper.Native("XPathNSResolver"))];
  dart.registerExtension(dart.global.XPathNSResolver, html$.XPathNSResolver);
  dart.defineExtensionNames([
    'iterateNext',
    'snapshotItem',
    'booleanValue',
    'invalidIteratorState',
    'numberValue',
    'resultType',
    'singleNodeValue',
    'snapshotLength',
    'stringValue'
  ]);
  html$.XPathResult = class XPathResult extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.booleanValue]() {
      return this.booleanValue;
    }
    get [dartx.invalidIteratorState]() {
      return this.invalidIteratorState;
    }
    get [dartx.numberValue]() {
      return this.numberValue;
    }
    get [dartx.resultType]() {
      return this.resultType;
    }
    get [dartx.singleNodeValue]() {
      return this.singleNodeValue;
    }
    get [dartx.snapshotLength]() {
      return this.snapshotLength;
    }
    get [dartx.stringValue]() {
      return this.stringValue;
    }
    [dartx.iterateNext]() {
      return this.iterateNext();
    }
    [dartx.snapshotItem](index) {
      return this.snapshotItem(index);
    }
  };
  dart.setSignature(html$.XPathResult, {
    constructors: () => ({_: [html$.XPathResult, []]}),
    methods: () => ({
      [dartx.iterateNext]: [html$.Node, []],
      [dartx.snapshotItem]: [html$.Node, [core.int]]
    })
  });
  html$.XPathResult[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('XPathResult')), core.deprecated, dart.const(new _js_helper.Native("XPathResult"))];
  html$.XPathResult.ANY_TYPE = 0;
  html$.XPathResult.ANY_UNORDERED_NODE_TYPE = 8;
  html$.XPathResult.BOOLEAN_TYPE = 3;
  html$.XPathResult.FIRST_ORDERED_NODE_TYPE = 9;
  html$.XPathResult.NUMBER_TYPE = 1;
  html$.XPathResult.ORDERED_NODE_ITERATOR_TYPE = 5;
  html$.XPathResult.ORDERED_NODE_SNAPSHOT_TYPE = 7;
  html$.XPathResult.STRING_TYPE = 2;
  html$.XPathResult.UNORDERED_NODE_ITERATOR_TYPE = 4;
  html$.XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE = 6;
  dart.registerExtension(dart.global.XPathResult, html$.XPathResult);
  html$.XmlDocument = class XmlDocument extends html$.Document {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$.XmlDocument, {
    constructors: () => ({_: [html$.XmlDocument, []]})
  });
  html$.XmlDocument[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('XMLDocument')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("XMLDocument"))];
  dart.registerExtension(dart.global.XMLDocument, html$.XmlDocument);
  dart.defineExtensionNames([
    'serializeToString'
  ]);
  html$.XmlSerializer = class XmlSerializer extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.XmlSerializer._create_1();
    }
    static _create_1() {
      return new XMLSerializer();
    }
    [dartx.serializeToString](root) {
      return this.serializeToString(root);
    }
  };
  dart.setSignature(html$.XmlSerializer, {
    constructors: () => ({
      _: [html$.XmlSerializer, []],
      new: [html$.XmlSerializer, []]
    }),
    methods: () => ({[dartx.serializeToString]: [core.String, [html$.Node]]}),
    statics: () => ({_create_1: [html$.XmlSerializer, []]}),
    names: ['_create_1']
  });
  html$.XmlSerializer[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('XMLSerializer')), core.deprecated, dart.const(new _js_helper.Native("XMLSerializer"))];
  dart.registerExtension(dart.global.XMLSerializer, html$.XmlSerializer);
  dart.defineExtensionNames([
    'clearParameters',
    'getParameter',
    'importStylesheet',
    'removeParameter',
    'reset',
    'setParameter',
    'transformToDocument',
    'transformToFragment'
  ]);
  html$.XsltProcessor = class XsltProcessor extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$.XsltProcessor._create_1();
    }
    static _create_1() {
      return new XSLTProcessor();
    }
    static get supported() {
      return !!window.XSLTProcessor;
    }
    [dartx.clearParameters]() {
      return this.clearParameters();
    }
    [dartx.getParameter](namespaceURI, localName) {
      return this.getParameter(namespaceURI, localName);
    }
    [dartx.importStylesheet](style) {
      return this.importStylesheet(style);
    }
    [dartx.removeParameter](namespaceURI, localName) {
      return this.removeParameter(namespaceURI, localName);
    }
    [dartx.reset]() {
      return this.reset();
    }
    [dartx.setParameter](namespaceURI, localName, value) {
      return this.setParameter(namespaceURI, localName, value);
    }
    [dartx.transformToDocument](source) {
      return this.transformToDocument(source);
    }
    [dartx.transformToFragment](source, output) {
      return this.transformToFragment(source, output);
    }
  };
  dart.setSignature(html$.XsltProcessor, {
    constructors: () => ({
      _: [html$.XsltProcessor, []],
      new: [html$.XsltProcessor, []]
    }),
    methods: () => ({
      [dartx.clearParameters]: [dart.void, []],
      [dartx.getParameter]: [core.String, [core.String, core.String]],
      [dartx.importStylesheet]: [dart.void, [html$.Node]],
      [dartx.removeParameter]: [dart.void, [core.String, core.String]],
      [dartx.reset]: [dart.void, []],
      [dartx.setParameter]: [dart.void, [core.String, core.String, core.String]],
      [dartx.transformToDocument]: [html$.Document, [html$.Node]],
      [dartx.transformToFragment]: [html$.DocumentFragment, [html$.Node, html$.Document]]
    }),
    statics: () => ({_create_1: [html$.XsltProcessor, []]}),
    names: ['_create_1']
  });
  html$.XsltProcessor[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('XSLTProcessor')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), core.deprecated, dart.const(new _js_helper.Native("XSLTProcessor"))];
  dart.registerExtension(dart.global.XSLTProcessor, html$.XsltProcessor);
  dart.defineExtensionNames([
    'name',
    'value'
  ]);
  html$._Attr = class _Attr extends html$.Node {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.name]() {
      return this.name;
    }
    get [dartx.value]() {
      return this.value;
    }
    set [dartx.value](value) {
      this.value = value;
    }
  };
  dart.setSignature(html$._Attr, {
    constructors: () => ({_: [html$._Attr, []]})
  });
  html$._Attr[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Attr')), dart.const(new _js_helper.Native("Attr"))];
  dart.registerExtension(dart.global.Attr, html$._Attr);
  html$._Cache = class _Cache extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$._Cache, {
    constructors: () => ({_: [html$._Cache, []]})
  });
  html$._Cache[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Cache')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("Cache"))];
  dart.registerExtension(dart.global.Cache, html$._Cache);
  html$._CanvasPathMethods = class _CanvasPathMethods extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$._CanvasPathMethods, {
    constructors: () => ({_: [html$._CanvasPathMethods, []]})
  });
  html$._CanvasPathMethods[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CanvasPathMethods')), dart.const(new _metadata.Experimental())];
  dart.defineExtensionNames([
    'toString',
    '==',
    'hashCode',
    'intersection',
    'intersects',
    'boundingBox',
    'containsRectangle',
    'containsPoint',
    'topLeft',
    'topRight',
    'bottomRight',
    'bottomLeft',
    'bottom',
    'height',
    'left',
    'right',
    'top',
    'width'
  ]);
  html$._ClientRect = class _ClientRect extends _interceptors.Interceptor {
    [dartx.toString]() {
      return `Rectangle (${this[dartx.left]}, ${this[dartx.top]}) ${this[dartx.width]} x ${this[dartx.height]}`;
    }
    [dartx['==']](other) {
      if (!dart.is(other, math.Rectangle$(core.num))) return false;
      return dart.equals(this[dartx.left], dart.dload(other, 'left')) && dart.equals(this[dartx.top], dart.dload(other, 'top')) && dart.equals(this[dartx.width], dart.dload(other, 'width')) && dart.equals(this[dartx.height], dart.dload(other, 'height'));
    }
    get [dartx.hashCode]() {
      return html$._JenkinsSmiHash.hash4(dart.hashCode(this[dartx.left]), dart.hashCode(this[dartx.top]), dart.hashCode(this[dartx.width]), dart.hashCode(this[dartx.height]));
    }
    [dartx.intersection](other) {
      let x0 = math.max(core.num)(this[dartx.left], other[dartx.left]);
      let x1 = math.min(core.num)(dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]), dart.notNull(other[dartx.left]) + dart.notNull(other[dartx.width]));
      if (dart.notNull(x0) <= dart.notNull(x1)) {
        let y0 = math.max(core.num)(this[dartx.top], other[dartx.top]);
        let y1 = math.min(core.num)(dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]), dart.notNull(other[dartx.top]) + dart.notNull(other[dartx.height]));
        if (dart.notNull(y0) <= dart.notNull(y1)) {
          return new (math.Rectangle$(core.num))(x0, y0, dart.notNull(x1) - dart.notNull(x0), dart.notNull(y1) - dart.notNull(y0));
        }
      }
      return null;
    }
    [dartx.intersects](other) {
      return dart.notNull(this[dartx.left]) <= dart.notNull(other[dartx.left]) + dart.notNull(other[dartx.width]) && dart.notNull(other[dartx.left]) <= dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]) && dart.notNull(this[dartx.top]) <= dart.notNull(other[dartx.top]) + dart.notNull(other[dartx.height]) && dart.notNull(other[dartx.top]) <= dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]);
    }
    [dartx.boundingBox](other) {
      let right = math.max(core.num)(dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]), dart.notNull(other[dartx.left]) + dart.notNull(other[dartx.width]));
      let bottom = math.max(core.num)(dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]), dart.notNull(other[dartx.top]) + dart.notNull(other[dartx.height]));
      let left = math.min(core.num)(this[dartx.left], other[dartx.left]);
      let top = math.min(core.num)(this[dartx.top], other[dartx.top]);
      return new (math.Rectangle$(core.num))(left, top, dart.notNull(right) - dart.notNull(left), dart.notNull(bottom) - dart.notNull(top));
    }
    [dartx.containsRectangle](another) {
      return dart.notNull(this[dartx.left]) <= dart.notNull(another[dartx.left]) && dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]) >= dart.notNull(another[dartx.left]) + dart.notNull(another[dartx.width]) && dart.notNull(this[dartx.top]) <= dart.notNull(another[dartx.top]) && dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]) >= dart.notNull(another[dartx.top]) + dart.notNull(another[dartx.height]);
    }
    [dartx.containsPoint](another) {
      return dart.notNull(another.x) >= dart.notNull(this[dartx.left]) && dart.notNull(another.x) <= dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]) && dart.notNull(another.y) >= dart.notNull(this[dartx.top]) && dart.notNull(another.y) <= dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]);
    }
    get [dartx.topLeft]() {
      return new (math.Point$(core.num))(this[dartx.left], this[dartx.top]);
    }
    get [dartx.topRight]() {
      return new (math.Point$(core.num))(dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]), this[dartx.top]);
    }
    get [dartx.bottomRight]() {
      return new (math.Point$(core.num))(dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]), dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]));
    }
    get [dartx.bottomLeft]() {
      return new (math.Point$(core.num))(this[dartx.left], dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]));
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.bottom]() {
      return this.bottom;
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.left]() {
      return this.left;
    }
    get [dartx.right]() {
      return this.right;
    }
    get [dartx.top]() {
      return this.top;
    }
    get [dartx.width]() {
      return this.width;
    }
  };
  html$._ClientRect[dart.implements] = () => [math.Rectangle$(core.num)];
  dart.setSignature(html$._ClientRect, {
    constructors: () => ({_: [html$._ClientRect, []]}),
    methods: () => ({
      [dartx.intersection]: [math.Rectangle$(core.num), [math.Rectangle$(core.num)]],
      [dartx.intersects]: [core.bool, [math.Rectangle$(core.num)]],
      [dartx.boundingBox]: [math.Rectangle$(core.num), [math.Rectangle$(core.num)]],
      [dartx.containsRectangle]: [core.bool, [math.Rectangle$(core.num)]],
      [dartx.containsPoint]: [core.bool, [math.Point$(core.num)]]
    })
  });
  html$._ClientRect[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ClientRect')), dart.const(new _js_helper.Native("ClientRect"))];
  dart.registerExtension(dart.global.ClientRect, html$._ClientRect);
  html$._JenkinsSmiHash = class _JenkinsSmiHash extends core.Object {
    static combine(hash, value) {
      hash = 536870911 & dart.notNull(hash) + dart.notNull(value);
      hash = 536870911 & dart.notNull(hash) + ((524287 & dart.notNull(hash)) << 10);
      return (dart.notNull(hash) ^ hash[dartx['>>']](6)) >>> 0;
    }
    static finish(hash) {
      hash = 536870911 & dart.notNull(hash) + ((67108863 & dart.notNull(hash)) << 3);
      hash = (dart.notNull(hash) ^ hash[dartx['>>']](11)) >>> 0;
      return 536870911 & dart.notNull(hash) + ((16383 & dart.notNull(hash)) << 15);
    }
    static hash2(a, b) {
      return html$._JenkinsSmiHash.finish(html$._JenkinsSmiHash.combine(html$._JenkinsSmiHash.combine(0, dart.as(a, core.int)), dart.as(b, core.int)));
    }
    static hash4(a, b, c, d) {
      return html$._JenkinsSmiHash.finish(html$._JenkinsSmiHash.combine(html$._JenkinsSmiHash.combine(html$._JenkinsSmiHash.combine(html$._JenkinsSmiHash.combine(0, dart.as(a, core.int)), dart.as(b, core.int)), dart.as(c, core.int)), dart.as(d, core.int)));
    }
  };
  dart.setSignature(html$._JenkinsSmiHash, {
    statics: () => ({
      combine: [core.int, [core.int, core.int]],
      finish: [core.int, [core.int]],
      hash2: [core.int, [dart.dynamic, dart.dynamic]],
      hash4: [core.int, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]]
    }),
    names: ['combine', 'finish', 'hash2', 'hash4']
  });
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'item'
  ]);
  html$._ClientRectList = class _ClientRectList extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(math.Rectangle$(core.num)), html$.ImmutableListMixin$(math.Rectangle$(core.num))) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return this[dartx.item](index);
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return this[0];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return this[dart.notNull(len) - 1];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return this[0];
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [__getter__](index) {
      return this.__getter__(index);
    }
    [dartx.item](index) {
      return this.item(index);
    }
  };
  html$._ClientRectList[dart.implements] = () => [core.List$(math.Rectangle$(core.num))];
  dart.setSignature(html$._ClientRectList, {
    constructors: () => ({_: [html$._ClientRectList, []]}),
    methods: () => ({
      [dartx.get]: [math.Rectangle$(core.num), [core.int]],
      [dartx.set]: [dart.void, [core.int, math.Rectangle$(core.num)]],
      [dartx.elementAt]: [math.Rectangle$(core.num), [core.int]],
      [__getter__]: [math.Rectangle$(core.num), [core.int]],
      [dartx.item]: [math.Rectangle$(core.num), [core.int]]
    })
  });
  html$._ClientRectList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ClientRectList')), dart.const(new _js_helper.Native("ClientRectList,DOMRectList"))];
  dart.registerExtension(dart.global.ClientRectList, html$._ClientRectList);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'item'
  ]);
  html$._CssRuleList = class _CssRuleList extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(html$.CssRule), html$.ImmutableListMixin$(html$.CssRule)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return this[index];
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return this[0];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return this[dart.notNull(len) - 1];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return this[0];
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [dartx.item](index) {
      return this.item(index);
    }
  };
  html$._CssRuleList[dart.implements] = () => [_js_helper.JavaScriptIndexingBehavior, core.List$(html$.CssRule)];
  dart.setSignature(html$._CssRuleList, {
    constructors: () => ({_: [html$._CssRuleList, []]}),
    methods: () => ({
      [dartx.get]: [html$.CssRule, [core.int]],
      [dartx.set]: [dart.void, [core.int, html$.CssRule]],
      [dartx.elementAt]: [html$.CssRule, [core.int]],
      [dartx.item]: [html$.CssRule, [core.int]]
    })
  });
  html$._CssRuleList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CSSRuleList')), dart.const(new _js_helper.Native("CSSRuleList"))];
  dart.registerExtension(dart.global.CSSRuleList, html$._CssRuleList);
  html$._DOMFileSystemSync = class _DOMFileSystemSync extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$._DOMFileSystemSync, {
    constructors: () => ({_: [html$._DOMFileSystemSync, []]})
  });
  html$._DOMFileSystemSync[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DOMFileSystemSync')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("DOMFileSystemSync"))];
  dart.registerExtension(dart.global.DOMFileSystemSync, html$._DOMFileSystemSync);
  html$._EntrySync = class _EntrySync extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$._EntrySync, {
    constructors: () => ({_: [html$._EntrySync, []]})
  });
  html$._EntrySync[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('EntrySync')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("EntrySync"))];
  dart.registerExtension(dart.global.EntrySync, html$._EntrySync);
  html$._DirectoryEntrySync = class _DirectoryEntrySync extends html$._EntrySync {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$._DirectoryEntrySync, {
    constructors: () => ({_: [html$._DirectoryEntrySync, []]})
  });
  html$._DirectoryEntrySync[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DirectoryEntrySync')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("DirectoryEntrySync"))];
  dart.registerExtension(dart.global.DirectoryEntrySync, html$._DirectoryEntrySync);
  html$._DirectoryReaderSync = class _DirectoryReaderSync extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$._DirectoryReaderSync, {
    constructors: () => ({_: [html$._DirectoryReaderSync, []]})
  });
  html$._DirectoryReaderSync[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DirectoryReaderSync')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("DirectoryReaderSync"))];
  dart.registerExtension(dart.global.DirectoryReaderSync, html$._DirectoryReaderSync);
  html$._DocumentType = class _DocumentType extends html$.Node {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  html$._DocumentType[dart.implements] = () => [html$.ChildNode];
  dart.setSignature(html$._DocumentType, {
    constructors: () => ({_: [html$._DocumentType, []]})
  });
  html$._DocumentType[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DocumentType')), core.deprecated, dart.const(new _js_helper.Native("DocumentType"))];
  dart.registerExtension(dart.global.DocumentType, html$._DocumentType);
  dart.defineExtensionNames([
    'height',
    'height',
    'width',
    'width',
    'x',
    'x',
    'y',
    'y'
  ]);
  html$._DomRect = class _DomRect extends html$.DomRectReadOnly {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(x, y, width, height) {
      if (x === void 0) x = null;
      if (y === void 0) y = null;
      if (width === void 0) width = null;
      if (height === void 0) height = null;
      if (height != null) {
        return html$._DomRect._create_1(x, y, width, height);
      }
      if (width != null) {
        return html$._DomRect._create_2(x, y, width);
      }
      if (y != null) {
        return html$._DomRect._create_3(x, y);
      }
      if (x != null) {
        return html$._DomRect._create_4(x);
      }
      return html$._DomRect._create_5();
    }
    static _create_1(x, y, width, height) {
      return new DOMRect(x, y, width, height);
    }
    static _create_2(x, y, width) {
      return new DOMRect(x, y, width);
    }
    static _create_3(x, y) {
      return new DOMRect(x, y);
    }
    static _create_4(x) {
      return new DOMRect(x);
    }
    static _create_5() {
      return new DOMRect();
    }
    get [dartx.height]() {
      return this.height;
    }
    set [dartx.height](value) {
      this.height = value;
    }
    get [dartx.width]() {
      return this.width;
    }
    set [dartx.width](value) {
      this.width = value;
    }
    get [dartx.x]() {
      return this.x;
    }
    set [dartx.x](value) {
      this.x = value;
    }
    get [dartx.y]() {
      return this.y;
    }
    set [dartx.y](value) {
      this.y = value;
    }
  };
  dart.setSignature(html$._DomRect, {
    constructors: () => ({
      _: [html$._DomRect, []],
      new: [html$._DomRect, [], [core.num, core.num, core.num, core.num]]
    }),
    statics: () => ({
      _create_1: [html$._DomRect, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]],
      _create_2: [html$._DomRect, [dart.dynamic, dart.dynamic, dart.dynamic]],
      _create_3: [html$._DomRect, [dart.dynamic, dart.dynamic]],
      _create_4: [html$._DomRect, [dart.dynamic]],
      _create_5: [html$._DomRect, []]
    }),
    names: ['_create_1', '_create_2', '_create_3', '_create_4', '_create_5']
  });
  html$._DomRect[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DOMRect')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("DOMRect"))];
  dart.registerExtension(dart.global.DOMRect, html$._DomRect);
  html$._FileEntrySync = class _FileEntrySync extends html$._EntrySync {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$._FileEntrySync, {
    constructors: () => ({_: [html$._FileEntrySync, []]})
  });
  html$._FileEntrySync[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('FileEntrySync')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("FileEntrySync"))];
  dart.registerExtension(dart.global.FileEntrySync, html$._FileEntrySync);
  html$._FileReaderSync = class _FileReaderSync extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return html$._FileReaderSync._create_1();
    }
    static _create_1() {
      return new FileReaderSync();
    }
  };
  dart.setSignature(html$._FileReaderSync, {
    constructors: () => ({
      _: [html$._FileReaderSync, []],
      new: [html$._FileReaderSync, []]
    }),
    statics: () => ({_create_1: [html$._FileReaderSync, []]}),
    names: ['_create_1']
  });
  html$._FileReaderSync[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('FileReaderSync')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("FileReaderSync"))];
  dart.registerExtension(dart.global.FileReaderSync, html$._FileReaderSync);
  html$._FileWriterSync = class _FileWriterSync extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$._FileWriterSync, {
    constructors: () => ({_: [html$._FileWriterSync, []]})
  });
  html$._FileWriterSync[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('FileWriterSync')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("FileWriterSync"))];
  dart.registerExtension(dart.global.FileWriterSync, html$._FileWriterSync);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'item'
  ]);
  html$._GamepadList = class _GamepadList extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(html$.Gamepad), html$.ImmutableListMixin$(html$.Gamepad)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return this[index];
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return this[0];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return this[dart.notNull(len) - 1];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return this[0];
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [dartx.item](index) {
      return this.item(index);
    }
  };
  html$._GamepadList[dart.implements] = () => [_js_helper.JavaScriptIndexingBehavior, core.List$(html$.Gamepad)];
  dart.setSignature(html$._GamepadList, {
    constructors: () => ({_: [html$._GamepadList, []]}),
    methods: () => ({
      [dartx.get]: [html$.Gamepad, [core.int]],
      [dartx.set]: [dart.void, [core.int, html$.Gamepad]],
      [dartx.elementAt]: [html$.Gamepad, [core.int]],
      [dartx.item]: [html$.Gamepad, [core.int]]
    })
  });
  html$._GamepadList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('GamepadList')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("GamepadList"))];
  dart.registerExtension(dart.global.GamepadList, html$._GamepadList);
  html$._HTMLAllCollection = class _HTMLAllCollection extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [_item](index) {
      return this.item(index);
    }
  };
  dart.setSignature(html$._HTMLAllCollection, {
    constructors: () => ({_: [html$._HTMLAllCollection, []]}),
    methods: () => ({[_item]: [html$.Element, [core.int]]})
  });
  html$._HTMLAllCollection[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLAllCollection')), core.deprecated, dart.const(new _js_helper.Native("HTMLAllCollection"))];
  dart.registerExtension(dart.global.HTMLAllCollection, html$._HTMLAllCollection);
  html$._HTMLAppletElement = class _HTMLAppletElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(html$._HTMLAppletElement, 'created');
  dart.setSignature(html$._HTMLAppletElement, {
    constructors: () => ({
      _: [html$._HTMLAppletElement, []],
      created: [html$._HTMLAppletElement, []]
    })
  });
  html$._HTMLAppletElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLAppletElement')), core.deprecated, dart.const(new _js_helper.Native("HTMLAppletElement"))];
  dart.registerExtension(dart.global.HTMLAppletElement, html$._HTMLAppletElement);
  html$._HTMLDirectoryElement = class _HTMLDirectoryElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(html$._HTMLDirectoryElement, 'created');
  dart.setSignature(html$._HTMLDirectoryElement, {
    constructors: () => ({
      _: [html$._HTMLDirectoryElement, []],
      created: [html$._HTMLDirectoryElement, []]
    })
  });
  html$._HTMLDirectoryElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLDirectoryElement')), core.deprecated, dart.const(new _js_helper.Native("HTMLDirectoryElement"))];
  dart.registerExtension(dart.global.HTMLDirectoryElement, html$._HTMLDirectoryElement);
  html$._HTMLFontElement = class _HTMLFontElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(html$._HTMLFontElement, 'created');
  dart.setSignature(html$._HTMLFontElement, {
    constructors: () => ({
      _: [html$._HTMLFontElement, []],
      created: [html$._HTMLFontElement, []]
    })
  });
  html$._HTMLFontElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLFontElement')), core.deprecated, dart.const(new _js_helper.Native("HTMLFontElement"))];
  dart.registerExtension(dart.global.HTMLFontElement, html$._HTMLFontElement);
  html$._HTMLFrameElement = class _HTMLFrameElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(html$._HTMLFrameElement, 'created');
  dart.setSignature(html$._HTMLFrameElement, {
    constructors: () => ({
      _: [html$._HTMLFrameElement, []],
      created: [html$._HTMLFrameElement, []]
    })
  });
  html$._HTMLFrameElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLFrameElement')), core.deprecated, dart.const(new _js_helper.Native("HTMLFrameElement"))];
  dart.registerExtension(dart.global.HTMLFrameElement, html$._HTMLFrameElement);
  html$._HTMLFrameSetElement = class _HTMLFrameSetElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(html$._HTMLFrameSetElement, 'created');
  html$._HTMLFrameSetElement[dart.implements] = () => [html$.WindowEventHandlers];
  dart.setSignature(html$._HTMLFrameSetElement, {
    constructors: () => ({
      _: [html$._HTMLFrameSetElement, []],
      created: [html$._HTMLFrameSetElement, []]
    })
  });
  html$._HTMLFrameSetElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLFrameSetElement')), core.deprecated, dart.const(new _js_helper.Native("HTMLFrameSetElement"))];
  dart.registerExtension(dart.global.HTMLFrameSetElement, html$._HTMLFrameSetElement);
  html$._HTMLMarqueeElement = class _HTMLMarqueeElement extends html$.HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(html$._HTMLMarqueeElement, 'created');
  dart.setSignature(html$._HTMLMarqueeElement, {
    constructors: () => ({
      _: [html$._HTMLMarqueeElement, []],
      created: [html$._HTMLMarqueeElement, []]
    })
  });
  html$._HTMLMarqueeElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLMarqueeElement')), core.deprecated, dart.const(new _js_helper.Native("HTMLMarqueeElement"))];
  dart.registerExtension(dart.global.HTMLMarqueeElement, html$._HTMLMarqueeElement);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'getNamedItem',
    'getNamedItemNS',
    'item',
    'removeNamedItem',
    'removeNamedItemNS',
    'setNamedItem',
    'setNamedItemNS'
  ]);
  html$._NamedNodeMap = class _NamedNodeMap extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(html$.Node), html$.ImmutableListMixin$(html$.Node)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return this[index];
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return this[0];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return this[dart.notNull(len) - 1];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return this[0];
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [dartx.getNamedItem](name) {
      return this.getNamedItem(name);
    }
    [dartx.getNamedItemNS](namespaceURI, localName) {
      return this.getNamedItemNS(namespaceURI, localName);
    }
    [dartx.item](index) {
      return this.item(index);
    }
    [dartx.removeNamedItem](name) {
      return this.removeNamedItem(name);
    }
    [dartx.removeNamedItemNS](namespaceURI, localName) {
      return this.removeNamedItemNS(namespaceURI, localName);
    }
    [dartx.setNamedItem](attr) {
      return this.setNamedItem(attr);
    }
    [dartx.setNamedItemNS](attr) {
      return this.setNamedItemNS(attr);
    }
  };
  html$._NamedNodeMap[dart.implements] = () => [_js_helper.JavaScriptIndexingBehavior, core.List$(html$.Node)];
  dart.setSignature(html$._NamedNodeMap, {
    constructors: () => ({_: [html$._NamedNodeMap, []]}),
    methods: () => ({
      [dartx.get]: [html$.Node, [core.int]],
      [dartx.set]: [dart.void, [core.int, html$.Node]],
      [dartx.elementAt]: [html$.Node, [core.int]],
      [dartx.getNamedItem]: [html$._Attr, [core.String]],
      [dartx.getNamedItemNS]: [html$._Attr, [core.String, core.String]],
      [dartx.item]: [html$._Attr, [core.int]],
      [dartx.removeNamedItem]: [html$._Attr, [core.String]],
      [dartx.removeNamedItemNS]: [html$._Attr, [core.String, core.String]],
      [dartx.setNamedItem]: [html$._Attr, [html$._Attr]],
      [dartx.setNamedItemNS]: [html$._Attr, [html$._Attr]]
    })
  });
  html$._NamedNodeMap[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('NamedNodeMap')), core.deprecated, dart.const(new _js_helper.Native("NamedNodeMap,MozNamedAttrMap"))];
  dart.registerExtension(dart.global.NamedNodeMap, html$._NamedNodeMap);
  html$._PagePopupController = class _PagePopupController extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$._PagePopupController, {
    constructors: () => ({_: [html$._PagePopupController, []]})
  });
  html$._PagePopupController[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('PagePopupController')), core.deprecated, dart.const(new _js_helper.Native("PagePopupController"))];
  dart.registerExtension(dart.global.PagePopupController, html$._PagePopupController);
  dart.defineExtensionNames([
    'clone',
    'context',
    'credentials',
    'headers',
    'mode',
    'referrer',
    'url'
  ]);
  html$._Request = class _Request extends html$.Body {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(input, requestInitDict) {
      if (requestInitDict === void 0) requestInitDict = null;
      if (requestInitDict != null) {
        let requestInitDict_1 = html_common.convertDartToNative_Dictionary(requestInitDict);
        return html$._Request._create_1(input, requestInitDict_1);
      }
      return html$._Request._create_2(input);
    }
    static _create_1(input, requestInitDict) {
      return new Request(input, requestInitDict);
    }
    static _create_2(input) {
      return new Request(input);
    }
    get [dartx.context]() {
      return this.context;
    }
    get [dartx.credentials]() {
      return this.credentials;
    }
    get [dartx.headers]() {
      return this.headers;
    }
    get [dartx.mode]() {
      return this.mode;
    }
    get [dartx.referrer]() {
      return this.referrer;
    }
    get [dartx.url]() {
      return this.url;
    }
    [dartx.clone]() {
      return this.clone();
    }
  };
  dart.setSignature(html$._Request, {
    constructors: () => ({
      _: [html$._Request, []],
      new: [html$._Request, [core.Object], [core.Map]]
    }),
    methods: () => ({[dartx.clone]: [html$._Request, []]}),
    statics: () => ({
      _create_1: [html$._Request, [dart.dynamic, dart.dynamic]],
      _create_2: [html$._Request, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  html$._Request[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Request')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("Request"))];
  dart.registerExtension(dart.global.Request, html$._Request);
  html$._Response = class _Response extends html$.Body {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(body, responseInitDict) {
      if (body === void 0) body = null;
      if (responseInitDict === void 0) responseInitDict = null;
      if (responseInitDict != null) {
        let responseInitDict_1 = html_common.convertDartToNative_Dictionary(responseInitDict);
        return html$._Response._create_1(body, responseInitDict_1);
      }
      if (body != null) {
        return html$._Response._create_2(body);
      }
      return html$._Response._create_3();
    }
    static _create_1(body, responseInitDict) {
      return new Response(body, responseInitDict);
    }
    static _create_2(body) {
      return new Response(body);
    }
    static _create_3() {
      return new Response();
    }
  };
  dart.setSignature(html$._Response, {
    constructors: () => ({
      _: [html$._Response, []],
      new: [html$._Response, [], [core.Object, core.Map]]
    }),
    statics: () => ({
      _create_1: [html$._Response, [dart.dynamic, dart.dynamic]],
      _create_2: [html$._Response, [dart.dynamic]],
      _create_3: [html$._Response, []]
    }),
    names: ['_create_1', '_create_2', '_create_3']
  });
  html$._Response[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Response')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("Response"))];
  dart.registerExtension(dart.global.Response, html$._Response);
  html$._ServiceWorker = class _ServiceWorker extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  html$._ServiceWorker[dart.implements] = () => [html$.AbstractWorker];
  dart.setSignature(html$._ServiceWorker, {
    constructors: () => ({_: [html$._ServiceWorker, []]})
  });
  html$._ServiceWorker[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ServiceWorker')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("ServiceWorker"))];
  dart.registerExtension(dart.global.ServiceWorker, html$._ServiceWorker);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'item'
  ]);
  html$._SpeechRecognitionResultList = class _SpeechRecognitionResultList extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(html$.SpeechRecognitionResult), html$.ImmutableListMixin$(html$.SpeechRecognitionResult)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return this[index];
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return this[0];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return this[dart.notNull(len) - 1];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return this[0];
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [dartx.item](index) {
      return this.item(index);
    }
  };
  html$._SpeechRecognitionResultList[dart.implements] = () => [_js_helper.JavaScriptIndexingBehavior, core.List$(html$.SpeechRecognitionResult)];
  dart.setSignature(html$._SpeechRecognitionResultList, {
    constructors: () => ({_: [html$._SpeechRecognitionResultList, []]}),
    methods: () => ({
      [dartx.get]: [html$.SpeechRecognitionResult, [core.int]],
      [dartx.set]: [dart.void, [core.int, html$.SpeechRecognitionResult]],
      [dartx.elementAt]: [html$.SpeechRecognitionResult, [core.int]],
      [dartx.item]: [html$.SpeechRecognitionResult, [core.int]]
    })
  });
  html$._SpeechRecognitionResultList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SpeechRecognitionResultList')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("SpeechRecognitionResultList"))];
  dart.registerExtension(dart.global.SpeechRecognitionResultList, html$._SpeechRecognitionResultList);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'item'
  ]);
  html$._StyleSheetList = class _StyleSheetList extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(html$.StyleSheet), html$.ImmutableListMixin$(html$.StyleSheet)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return this[index];
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return this[0];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return this[dart.notNull(len) - 1];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return this[0];
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [__getter__](name) {
      return this.__getter__(name);
    }
    [dartx.item](index) {
      return this.item(index);
    }
  };
  html$._StyleSheetList[dart.implements] = () => [_js_helper.JavaScriptIndexingBehavior, core.List$(html$.StyleSheet)];
  dart.setSignature(html$._StyleSheetList, {
    constructors: () => ({_: [html$._StyleSheetList, []]}),
    methods: () => ({
      [dartx.get]: [html$.StyleSheet, [core.int]],
      [dartx.set]: [dart.void, [core.int, html$.StyleSheet]],
      [dartx.elementAt]: [html$.StyleSheet, [core.int]],
      [__getter__]: [html$.CssStyleSheet, [core.String]],
      [dartx.item]: [html$.StyleSheet, [core.int]]
    })
  });
  html$._StyleSheetList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('StyleSheetList')), dart.const(new _js_helper.Native("StyleSheetList"))];
  dart.registerExtension(dart.global.StyleSheetList, html$._StyleSheetList);
  html$._SubtleCrypto = class _SubtleCrypto extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$._SubtleCrypto, {
    constructors: () => ({_: [html$._SubtleCrypto, []]})
  });
  html$._SubtleCrypto[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SubtleCrypto')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("SubtleCrypto"))];
  dart.registerExtension(dart.global.SubtleCrypto, html$._SubtleCrypto);
  html$._WebKitCSSMatrix = class _WebKitCSSMatrix extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(cssValue) {
      if (cssValue === void 0) cssValue = null;
      if (cssValue != null) {
        return html$._WebKitCSSMatrix._create_1(cssValue);
      }
      return html$._WebKitCSSMatrix._create_2();
    }
    static _create_1(cssValue) {
      return new WebKitCSSMatrix(cssValue);
    }
    static _create_2() {
      return new WebKitCSSMatrix();
    }
  };
  dart.setSignature(html$._WebKitCSSMatrix, {
    constructors: () => ({
      _: [html$._WebKitCSSMatrix, []],
      new: [html$._WebKitCSSMatrix, [], [core.String]]
    }),
    statics: () => ({
      _create_1: [html$._WebKitCSSMatrix, [dart.dynamic]],
      _create_2: [html$._WebKitCSSMatrix, []]
    }),
    names: ['_create_1', '_create_2']
  });
  html$._WebKitCSSMatrix[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('WebKitCSSMatrix')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Experimental()), core.deprecated, dart.const(new _js_helper.Native("WebKitCSSMatrix"))];
  dart.registerExtension(dart.global.WebKitCSSMatrix, html$._WebKitCSSMatrix);
  html$._WindowTimers = class _WindowTimers extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$._WindowTimers, {
    constructors: () => ({_: [html$._WindowTimers, []]})
  });
  html$._WindowTimers[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('WindowTimers')), dart.const(new _metadata.Experimental())];
  html$._WorkerLocation = class _WorkerLocation extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  html$._WorkerLocation[dart.implements] = () => [html$.UrlUtilsReadOnly];
  dart.setSignature(html$._WorkerLocation, {
    constructors: () => ({_: [html$._WorkerLocation, []]})
  });
  html$._WorkerLocation[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('WorkerLocation')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("WorkerLocation"))];
  dart.registerExtension(dart.global.WorkerLocation, html$._WorkerLocation);
  html$._WorkerNavigator = class _WorkerNavigator extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  html$._WorkerNavigator[dart.implements] = () => [html$.NavigatorCpu, html$.NavigatorOnLine, html$.NavigatorID];
  dart.setSignature(html$._WorkerNavigator, {
    constructors: () => ({_: [html$._WorkerNavigator, []]})
  });
  html$._WorkerNavigator[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('WorkerNavigator')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("WorkerNavigator"))];
  dart.registerExtension(dart.global.WorkerNavigator, html$._WorkerNavigator);
  html$._XMLHttpRequestProgressEvent = class _XMLHttpRequestProgressEvent extends html$.ProgressEvent {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(html$._XMLHttpRequestProgressEvent, {
    constructors: () => ({_: [html$._XMLHttpRequestProgressEvent, []]})
  });
  html$._XMLHttpRequestProgressEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('XMLHttpRequestProgressEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("XMLHttpRequestProgressEvent"))];
  dart.registerExtension(dart.global.XMLHttpRequestProgressEvent, html$._XMLHttpRequestProgressEvent);
  const _matches = Symbol('_matches');
  html$._AttributeMap = class _AttributeMap extends core.Object {
    _AttributeMap(element) {
      this[_element$] = element;
    }
    addAll(other) {
      other[dartx.forEach](dart.fn((k, v) => {
        this.set(k, v);
      }, dart.void, [core.String, core.String]));
    }
    containsValue(value) {
      for (let v of this.values) {
        if (dart.equals(value, v)) {
          return true;
        }
      }
      return false;
    }
    putIfAbsent(key, ifAbsent) {
      if (!dart.notNull(this[dartx.containsKey](key))) {
        this.set(key, ifAbsent());
      }
      return this.get(key);
    }
    clear() {
      for (let key of this.keys) {
        this[dartx.remove](key);
      }
    }
    forEach(f) {
      for (let key of this.keys) {
        let value = this.get(key);
        f(key, value);
      }
    }
    get keys() {
      let attributes = this[_element$][_attributes$];
      let keys = dart.list([], core.String);
      for (let i = 0, len = attributes[dartx.length]; i < dart.notNull(len); i++) {
        let attr = dart.as(attributes[dartx.get](i), html$._Attr);
        if (dart.notNull(this[_matches](attr))) {
          keys[dartx.add](attr[dartx.name]);
        }
      }
      return keys;
    }
    get values() {
      let attributes = this[_element$][_attributes$];
      let values = dart.list([], core.String);
      for (let i = 0, len = attributes[dartx.length]; i < dart.notNull(len); i++) {
        let attr = dart.as(attributes[dartx.get](i), html$._Attr);
        if (dart.notNull(this[_matches](attr))) {
          values[dartx.add](attr[dartx.value]);
        }
      }
      return values;
    }
    get isEmpty() {
      return this[dartx.length] == 0;
    }
    get isNotEmpty() {
      return !dart.notNull(this.isEmpty);
    }
  };
  html$._AttributeMap[dart.implements] = () => [core.Map$(core.String, core.String)];
  dart.setSignature(html$._AttributeMap, {
    constructors: () => ({_AttributeMap: [html$._AttributeMap, [html$.Element]]}),
    methods: () => ({
      addAll: [dart.void, [core.Map$(core.String, core.String)]],
      containsValue: [core.bool, [core.Object]],
      putIfAbsent: [core.String, [core.String, dart.functionType(core.String, [])]],
      clear: [dart.void, []],
      forEach: [dart.void, [dart.functionType(dart.void, [core.String, core.String])]]
    })
  });
  dart.defineExtensionMembers(html$._AttributeMap, [
    'addAll',
    'containsValue',
    'putIfAbsent',
    'clear',
    'forEach',
    'keys',
    'values',
    'isEmpty',
    'isNotEmpty'
  ]);
  html$._ElementAttributeMap = class _ElementAttributeMap extends html$._AttributeMap {
    _ElementAttributeMap(element) {
      super._AttributeMap(element);
    }
    containsKey(key) {
      return this[_element$][_hasAttribute](dart.as(key, core.String));
    }
    get(key) {
      return this[_element$][dartx.getAttribute](dart.as(key, core.String));
    }
    set(key, value) {
      this[_element$][dartx.setAttribute](key, value);
      return value;
    }
    remove(key) {
      let value = this[_element$][dartx.getAttribute](dart.as(key, core.String));
      this[_element$][_removeAttribute](dart.as(key, core.String));
      return value;
    }
    get length() {
      return this.keys[dartx.length];
    }
    [_matches](node) {
      return node[_namespaceUri] == null;
    }
  };
  dart.setSignature(html$._ElementAttributeMap, {
    constructors: () => ({_ElementAttributeMap: [html$._ElementAttributeMap, [html$.Element]]}),
    methods: () => ({
      containsKey: [core.bool, [core.Object]],
      get: [core.String, [core.Object]],
      set: [dart.void, [core.String, core.String]],
      remove: [core.String, [core.Object]],
      [_matches]: [core.bool, [html$.Node]]
    })
  });
  dart.defineExtensionMembers(html$._ElementAttributeMap, [
    'containsKey',
    'get',
    'set',
    'remove',
    'length'
  ]);
  const _namespace = Symbol('_namespace');
  html$._NamespacedAttributeMap = class _NamespacedAttributeMap extends html$._AttributeMap {
    _NamespacedAttributeMap(element, namespace) {
      this[_namespace] = namespace;
      super._AttributeMap(element);
    }
    containsKey(key) {
      return this[_element$][_hasAttributeNS](this[_namespace], dart.as(key, core.String));
    }
    get(key) {
      return this[_element$][dartx.getAttributeNS](this[_namespace], dart.as(key, core.String));
    }
    set(key, value) {
      this[_element$][dartx.setAttributeNS](this[_namespace], key, value);
      return value;
    }
    remove(key) {
      let value = this.get(key);
      this[_element$][_removeAttributeNS](this[_namespace], dart.as(key, core.String));
      return value;
    }
    get length() {
      return this.keys[dartx.length];
    }
    [_matches](node) {
      return node[_namespaceUri] == this[_namespace];
    }
  };
  dart.setSignature(html$._NamespacedAttributeMap, {
    constructors: () => ({_NamespacedAttributeMap: [html$._NamespacedAttributeMap, [html$.Element, core.String]]}),
    methods: () => ({
      containsKey: [core.bool, [core.Object]],
      get: [core.String, [core.Object]],
      set: [dart.void, [core.String, core.String]],
      remove: [core.String, [core.Object]],
      [_matches]: [core.bool, [html$.Node]]
    })
  });
  dart.defineExtensionMembers(html$._NamespacedAttributeMap, [
    'containsKey',
    'get',
    'set',
    'remove',
    'length'
  ]);
  const _attr = Symbol('_attr');
  const _strip = Symbol('_strip');
  const _toHyphenedName = Symbol('_toHyphenedName');
  const _toCamelCase = Symbol('_toCamelCase');
  html$._DataAttributeMap = class _DataAttributeMap extends core.Object {
    _DataAttributeMap(attributes) {
      this[_attributes$] = attributes;
    }
    addAll(other) {
      other[dartx.forEach](dart.fn((k, v) => {
        this.set(k, v);
      }, dart.void, [core.String, core.String]));
    }
    containsValue(value) {
      return this.values[dartx.any](dart.fn(v => dart.equals(v, value), core.bool, [core.String]));
    }
    containsKey(key) {
      return this[_attributes$][dartx.containsKey](this[_attr](dart.as(key, core.String)));
    }
    get(key) {
      return this[_attributes$][dartx.get](this[_attr](dart.as(key, core.String)));
    }
    set(key, value) {
      this[_attributes$][dartx.set](this[_attr](key), value);
      return value;
    }
    putIfAbsent(key, ifAbsent) {
      return this[_attributes$][dartx.putIfAbsent](this[_attr](key), ifAbsent);
    }
    remove(key) {
      return this[_attributes$][dartx.remove](this[_attr](dart.as(key, core.String)));
    }
    clear() {
      for (let key of this.keys) {
        this.remove(key);
      }
    }
    forEach(f) {
      this[_attributes$][dartx.forEach](dart.fn((key, value) => {
        if (dart.notNull(this[_matches](key))) {
          f(this[_strip](key), value);
        }
      }, dart.void, [core.String, core.String]));
    }
    get keys() {
      let keys = dart.list([], core.String);
      this[_attributes$][dartx.forEach](dart.fn((key, value) => {
        if (dart.notNull(this[_matches](key))) {
          keys[dartx.add](this[_strip](key));
        }
      }, dart.void, [core.String, core.String]));
      return keys;
    }
    get values() {
      let values = dart.list([], core.String);
      this[_attributes$][dartx.forEach](dart.fn((key, value) => {
        if (dart.notNull(this[_matches](key))) {
          values[dartx.add](value);
        }
      }, dart.void, [core.String, core.String]));
      return values;
    }
    get length() {
      return this.keys[dartx.length];
    }
    get isEmpty() {
      return this.length == 0;
    }
    get isNotEmpty() {
      return !dart.notNull(this.isEmpty);
    }
    [_attr](key) {
      return `data-${this[_toHyphenedName](key)}`;
    }
    [_matches](key) {
      return key[dartx.startsWith]('data-');
    }
    [_strip](key) {
      return this[_toCamelCase](key[dartx.substring](5));
    }
    [_toCamelCase](hyphenedName, opts) {
      let startUppercase = opts && 'startUppercase' in opts ? opts.startUppercase : false;
      let segments = hyphenedName[dartx.split]('-');
      let start = dart.notNull(startUppercase) ? 0 : 1;
      for (let i = start; i < dart.notNull(segments[dartx.length]); i++) {
        let segment = segments[dartx.get](i);
        if (dart.notNull(segment[dartx.length]) > 0) {
          segments[dartx.set](i, `${segment[dartx.get](0)[dartx.toUpperCase]()}${segment[dartx.substring](1)}`);
        }
      }
      return segments[dartx.join]('');
    }
    [_toHyphenedName](word) {
      let sb = new core.StringBuffer();
      for (let i = 0; i < dart.notNull(word[dartx.length]); i++) {
        let lower = word[dartx.get](i)[dartx.toLowerCase]();
        if (word[dartx.get](i) != lower && i > 0) sb.write('-');
        sb.write(lower);
      }
      return sb.toString();
    }
  };
  html$._DataAttributeMap[dart.implements] = () => [core.Map$(core.String, core.String)];
  dart.setSignature(html$._DataAttributeMap, {
    constructors: () => ({_DataAttributeMap: [html$._DataAttributeMap, [core.Map$(core.String, core.String)]]}),
    methods: () => ({
      addAll: [dart.void, [core.Map$(core.String, core.String)]],
      containsValue: [core.bool, [core.Object]],
      containsKey: [core.bool, [core.Object]],
      get: [core.String, [core.Object]],
      set: [dart.void, [core.String, core.String]],
      putIfAbsent: [core.String, [core.String, dart.functionType(core.String, [])]],
      remove: [core.String, [core.Object]],
      clear: [dart.void, []],
      forEach: [dart.void, [dart.functionType(dart.void, [core.String, core.String])]],
      [_attr]: [core.String, [core.String]],
      [_matches]: [core.bool, [core.String]],
      [_strip]: [core.String, [core.String]],
      [_toCamelCase]: [core.String, [core.String], {startUppercase: core.bool}],
      [_toHyphenedName]: [core.String, [core.String]]
    })
  });
  dart.defineExtensionMembers(html$._DataAttributeMap, [
    'addAll',
    'containsValue',
    'containsKey',
    'get',
    'set',
    'putIfAbsent',
    'remove',
    'clear',
    'forEach',
    'keys',
    'values',
    'length',
    'isEmpty',
    'isNotEmpty'
  ]);
  html$.CanvasImageSource = class CanvasImageSource extends core.Object {};
  html$.WindowBase = class WindowBase extends core.Object {};
  html$.WindowBase[dart.implements] = () => [html$.EventTarget];
  html$.LocationBase = class LocationBase extends core.Object {};
  html$.HistoryBase = class HistoryBase extends core.Object {};
  html$.CssClassSet = class CssClassSet extends core.Object {};
  html$.CssClassSet[dart.implements] = () => [core.Set$(core.String)];
  const _addOrSubtractToBoxModel = Symbol('_addOrSubtractToBoxModel');
  html$.CssRect = class CssRect extends core.Object {
    CssRect(element) {
      this[_element$] = element;
    }
    set height(newHeight) {
      dart.throw(new core.UnsupportedError("Can only set height for content rect."));
    }
    set width(newWidth) {
      dart.throw(new core.UnsupportedError("Can only set width for content rect."));
    }
    [_addOrSubtractToBoxModel](dimensions, augmentingMeasurement) {
      let styles = this[_element$][dartx.getComputedStyle]();
      let val = 0;
      for (let measurement of dimensions) {
        if (augmentingMeasurement == html$._MARGIN) {
          val = dart.notNull(val) + dart.notNull(dart.asInt(new html$.Dimension.css(styles[dartx.getPropertyValue](`${augmentingMeasurement}-${measurement}`)).value));
        }
        if (augmentingMeasurement == html$._CONTENT) {
          val = dart.notNull(val) - dart.notNull(dart.asInt(new html$.Dimension.css(styles[dartx.getPropertyValue](`${html$._PADDING}-${measurement}`)).value));
        }
        if (augmentingMeasurement != html$._MARGIN) {
          val = dart.notNull(val) - dart.notNull(dart.asInt(new html$.Dimension.css(styles[dartx.getPropertyValue](`border-${measurement}-width`)).value));
        }
      }
      return val;
    }
    get right() {
      return dart.notNull(this.left) + dart.notNull(this.width);
    }
    get bottom() {
      return dart.notNull(this.top) + dart.notNull(this.height);
    }
    toString() {
      return `Rectangle (${this.left}, ${this.top}) ${this.width} x ${this.height}`;
    }
    ['=='](other) {
      if (!dart.is(other, math.Rectangle$(core.num))) return false;
      return dart.equals(this.left, dart.dload(other, 'left')) && dart.equals(this.top, dart.dload(other, 'top')) && dart.equals(this.right, dart.dload(other, 'right')) && dart.equals(this.bottom, dart.dload(other, 'bottom'));
    }
    get hashCode() {
      return html$._JenkinsSmiHash.hash4(dart.hashCode(this.left), dart.hashCode(this.top), dart.hashCode(this.right), dart.hashCode(this.bottom));
    }
    intersection(other) {
      let x0 = math.max(core.num)(this.left, other[dartx.left]);
      let x1 = math.min(core.num)(dart.notNull(this.left) + dart.notNull(this.width), dart.notNull(other[dartx.left]) + dart.notNull(other[dartx.width]));
      if (dart.notNull(x0) <= dart.notNull(x1)) {
        let y0 = math.max(core.num)(this.top, other[dartx.top]);
        let y1 = math.min(core.num)(dart.notNull(this.top) + dart.notNull(this.height), dart.notNull(other[dartx.top]) + dart.notNull(other[dartx.height]));
        if (dart.notNull(y0) <= dart.notNull(y1)) {
          return new (math.Rectangle$(core.num))(x0, y0, dart.notNull(x1) - dart.notNull(x0), dart.notNull(y1) - dart.notNull(y0));
        }
      }
      return null;
    }
    intersects(other) {
      return dart.notNull(this.left) <= dart.notNull(other[dartx.left]) + dart.notNull(other[dartx.width]) && dart.notNull(other[dartx.left]) <= dart.notNull(this.left) + dart.notNull(this.width) && dart.notNull(this.top) <= dart.notNull(other[dartx.top]) + dart.notNull(other[dartx.height]) && dart.notNull(other[dartx.top]) <= dart.notNull(this.top) + dart.notNull(this.height);
    }
    boundingBox(other) {
      let right = math.max(core.num)(dart.notNull(this.left) + dart.notNull(this.width), dart.notNull(other[dartx.left]) + dart.notNull(other[dartx.width]));
      let bottom = math.max(core.num)(dart.notNull(this.top) + dart.notNull(this.height), dart.notNull(other[dartx.top]) + dart.notNull(other[dartx.height]));
      let left = math.min(core.num)(this.left, other[dartx.left]);
      let top = math.min(core.num)(this.top, other[dartx.top]);
      return new (math.Rectangle$(core.num))(left, top, dart.notNull(right) - dart.notNull(left), dart.notNull(bottom) - dart.notNull(top));
    }
    containsRectangle(another) {
      return dart.notNull(this.left) <= dart.notNull(another[dartx.left]) && dart.notNull(this.left) + dart.notNull(this.width) >= dart.notNull(another[dartx.left]) + dart.notNull(another[dartx.width]) && dart.notNull(this.top) <= dart.notNull(another[dartx.top]) && dart.notNull(this.top) + dart.notNull(this.height) >= dart.notNull(another[dartx.top]) + dart.notNull(another[dartx.height]);
    }
    containsPoint(another) {
      return dart.notNull(another.x) >= dart.notNull(this.left) && dart.notNull(another.x) <= dart.notNull(this.left) + dart.notNull(this.width) && dart.notNull(another.y) >= dart.notNull(this.top) && dart.notNull(another.y) <= dart.notNull(this.top) + dart.notNull(this.height);
    }
    get topLeft() {
      return new (math.Point$(core.num))(this.left, this.top);
    }
    get topRight() {
      return new (math.Point$(core.num))(dart.notNull(this.left) + dart.notNull(this.width), this.top);
    }
    get bottomRight() {
      return new (math.Point$(core.num))(dart.notNull(this.left) + dart.notNull(this.width), dart.notNull(this.top) + dart.notNull(this.height));
    }
    get bottomLeft() {
      return new (math.Point$(core.num))(this.left, dart.notNull(this.top) + dart.notNull(this.height));
    }
  };
  html$.CssRect[dart.implements] = () => [math.Rectangle$(core.num)];
  dart.setSignature(html$.CssRect, {
    constructors: () => ({CssRect: [html$.CssRect, [html$.Element]]}),
    methods: () => ({
      [_addOrSubtractToBoxModel]: [core.num, [core.List$(core.String), core.String]],
      intersection: [math.Rectangle$(core.num), [math.Rectangle$(core.num)]],
      intersects: [core.bool, [math.Rectangle$(core.num)]],
      boundingBox: [math.Rectangle$(core.num), [math.Rectangle$(core.num)]],
      containsRectangle: [core.bool, [math.Rectangle$(core.num)]],
      containsPoint: [core.bool, [math.Point$(core.num)]]
    })
  });
  dart.defineExtensionMembers(html$.CssRect, [
    'toString',
    '==',
    'intersection',
    'intersects',
    'boundingBox',
    'containsRectangle',
    'containsPoint',
    'right',
    'bottom',
    'hashCode',
    'topLeft',
    'topRight',
    'bottomRight',
    'bottomLeft'
  ]);
  html$._ContentCssRect = class _ContentCssRect extends html$.CssRect {
    _ContentCssRect(element) {
      super.CssRect(element);
    }
    get height() {
      return dart.notNull(this[_element$][dartx.offsetHeight]) + dart.notNull(this[_addOrSubtractToBoxModel](html$._HEIGHT, html$._CONTENT));
    }
    get width() {
      return dart.notNull(this[_element$][dartx.offsetWidth]) + dart.notNull(this[_addOrSubtractToBoxModel](html$._WIDTH, html$._CONTENT));
    }
    set height(newHeight) {
      if (dart.is(newHeight, html$.Dimension)) {
        if (dart.test(dart.dsend(dart.dload(newHeight, 'value'), '<', 0))) newHeight = new html$.Dimension.px(0);
        this[_element$][dartx.style][dartx.height] = dart.toString(newHeight);
      } else if (typeof newHeight == 'number') {
        if (dart.test(dart.dsend(newHeight, '<', 0))) newHeight = 0;
        this[_element$][dartx.style][dartx.height] = `${newHeight}px`;
      } else {
        dart.throw(new core.ArgumentError("newHeight is not a Dimension or num"));
      }
    }
    set width(newWidth) {
      if (dart.is(newWidth, html$.Dimension)) {
        if (dart.test(dart.dsend(dart.dload(newWidth, 'value'), '<', 0))) newWidth = new html$.Dimension.px(0);
        this[_element$][dartx.style][dartx.width] = dart.toString(newWidth);
      } else if (typeof newWidth == 'number') {
        if (dart.test(dart.dsend(newWidth, '<', 0))) newWidth = 0;
        this[_element$][dartx.style][dartx.width] = `${newWidth}px`;
      } else {
        dart.throw(new core.ArgumentError("newWidth is not a Dimension or num"));
      }
    }
    get left() {
      return dart.notNull(this[_element$][dartx.getBoundingClientRect]()[dartx.left]) - dart.notNull(this[_addOrSubtractToBoxModel](dart.list(['left'], core.String), html$._CONTENT));
    }
    get top() {
      return dart.notNull(this[_element$][dartx.getBoundingClientRect]()[dartx.top]) - dart.notNull(this[_addOrSubtractToBoxModel](dart.list(['top'], core.String), html$._CONTENT));
    }
  };
  dart.setSignature(html$._ContentCssRect, {
    constructors: () => ({_ContentCssRect: [html$._ContentCssRect, [html$.Element]]})
  });
  dart.defineExtensionMembers(html$._ContentCssRect, ['height', 'width', 'left', 'top']);
  const _elementList = Symbol('_elementList');
  html$._ContentCssListRect = class _ContentCssListRect extends html$._ContentCssRect {
    _ContentCssListRect(elementList) {
      this[_elementList] = null;
      super._ContentCssRect(elementList[dartx.first]);
      this[_elementList] = elementList;
    }
    set height(newHeight) {
      this[_elementList][dartx.forEach](dart.fn(e => e[dartx.contentEdge].height = newHeight, dart.void, [html$.Element]));
    }
    get height() {
      return super.height;
    }
    set width(newWidth) {
      this[_elementList][dartx.forEach](dart.fn(e => e[dartx.contentEdge].width = newWidth, dart.void, [html$.Element]));
    }
    get width() {
      return super.width;
    }
  };
  dart.setSignature(html$._ContentCssListRect, {
    constructors: () => ({_ContentCssListRect: [html$._ContentCssListRect, [core.List$(html$.Element)]]})
  });
  html$._PaddingCssRect = class _PaddingCssRect extends html$.CssRect {
    _PaddingCssRect(element) {
      super.CssRect(dart.as(element, html$.Element));
    }
    get height() {
      return dart.notNull(this[_element$][dartx.offsetHeight]) + dart.notNull(this[_addOrSubtractToBoxModel](html$._HEIGHT, html$._PADDING));
    }
    set height(value) {
      super.height = value;
    }
    get width() {
      return dart.notNull(this[_element$][dartx.offsetWidth]) + dart.notNull(this[_addOrSubtractToBoxModel](html$._WIDTH, html$._PADDING));
    }
    set width(value) {
      super.width = value;
    }
    get left() {
      return dart.notNull(this[_element$][dartx.getBoundingClientRect]()[dartx.left]) - dart.notNull(this[_addOrSubtractToBoxModel](dart.list(['left'], core.String), html$._PADDING));
    }
    get top() {
      return dart.notNull(this[_element$][dartx.getBoundingClientRect]()[dartx.top]) - dart.notNull(this[_addOrSubtractToBoxModel](dart.list(['top'], core.String), html$._PADDING));
    }
  };
  dart.setSignature(html$._PaddingCssRect, {
    constructors: () => ({_PaddingCssRect: [html$._PaddingCssRect, [dart.dynamic]]})
  });
  dart.defineExtensionMembers(html$._PaddingCssRect, ['height', 'width', 'left', 'top']);
  html$._BorderCssRect = class _BorderCssRect extends html$.CssRect {
    _BorderCssRect(element) {
      super.CssRect(dart.as(element, html$.Element));
    }
    get height() {
      return this[_element$][dartx.offsetHeight];
    }
    set height(value) {
      super.height = value;
    }
    get width() {
      return this[_element$][dartx.offsetWidth];
    }
    set width(value) {
      super.width = value;
    }
    get left() {
      return this[_element$][dartx.getBoundingClientRect]()[dartx.left];
    }
    get top() {
      return this[_element$][dartx.getBoundingClientRect]()[dartx.top];
    }
  };
  dart.setSignature(html$._BorderCssRect, {
    constructors: () => ({_BorderCssRect: [html$._BorderCssRect, [dart.dynamic]]})
  });
  dart.defineExtensionMembers(html$._BorderCssRect, ['height', 'width', 'left', 'top']);
  html$._MarginCssRect = class _MarginCssRect extends html$.CssRect {
    _MarginCssRect(element) {
      super.CssRect(dart.as(element, html$.Element));
    }
    get height() {
      return dart.notNull(this[_element$][dartx.offsetHeight]) + dart.notNull(this[_addOrSubtractToBoxModel](html$._HEIGHT, html$._MARGIN));
    }
    set height(value) {
      super.height = value;
    }
    get width() {
      return dart.notNull(this[_element$][dartx.offsetWidth]) + dart.notNull(this[_addOrSubtractToBoxModel](html$._WIDTH, html$._MARGIN));
    }
    set width(value) {
      super.width = value;
    }
    get left() {
      return dart.notNull(this[_element$][dartx.getBoundingClientRect]()[dartx.left]) - dart.notNull(this[_addOrSubtractToBoxModel](dart.list(['left'], core.String), html$._MARGIN));
    }
    get top() {
      return dart.notNull(this[_element$][dartx.getBoundingClientRect]()[dartx.top]) - dart.notNull(this[_addOrSubtractToBoxModel](dart.list(['top'], core.String), html$._MARGIN));
    }
  };
  dart.setSignature(html$._MarginCssRect, {
    constructors: () => ({_MarginCssRect: [html$._MarginCssRect, [dart.dynamic]]})
  });
  dart.defineExtensionMembers(html$._MarginCssRect, ['height', 'width', 'left', 'top']);
  dart.defineLazy(html$, {
    get _HEIGHT() {
      return dart.list(['top', 'bottom'], core.String);
    }
  });
  dart.defineLazy(html$, {
    get _WIDTH() {
      return dart.list(['right', 'left'], core.String);
    }
  });
  html$._CONTENT = 'content';
  html$._PADDING = 'padding';
  html$._MARGIN = 'margin';
  const _sets = Symbol('_sets');
  const _validateToken = Symbol('_validateToken');
  html_common.CssClassSetImpl = class CssClassSetImpl extends core.Object {
    [_validateToken](value) {
      if (dart.notNull(html_common.CssClassSetImpl._validTokenRE.hasMatch(value))) return value;
      dart.throw(new core.ArgumentError.value(value, 'value', 'Not a valid class token'));
    }
    toString() {
      return this.readClasses().join(' ');
    }
    toggle(value, shouldAdd) {
      if (shouldAdd === void 0) shouldAdd = null;
      this[_validateToken](value);
      let s = this.readClasses();
      let result = false;
      if (shouldAdd == null) shouldAdd = !dart.notNull(s.contains(value));
      if (dart.notNull(shouldAdd)) {
        s.add(value);
        result = true;
      } else {
        s.remove(value);
      }
      this.writeClasses(s);
      return result;
    }
    get frozen() {
      return false;
    }
    get iterator() {
      return this.readClasses().iterator;
    }
    [Symbol.iterator]() {
      return new dart.JsIterator(this.iterator);
    }
    forEach(f) {
      this.readClasses().forEach(f);
    }
    join(separator) {
      if (separator === void 0) separator = "";
      return this.readClasses().join(separator);
    }
    map(T) {
      return f => {
        return this.readClasses().map(T)(f);
      };
    }
    where(f) {
      return this.readClasses().where(f);
    }
    expand(T) {
      return f => {
        return this.readClasses().expand(T)(f);
      };
    }
    every(f) {
      return this.readClasses().every(f);
    }
    any(f) {
      return this.readClasses().any(f);
    }
    get isEmpty() {
      return this.readClasses().isEmpty;
    }
    get isNotEmpty() {
      return this.readClasses().isNotEmpty;
    }
    get length() {
      return this.readClasses().length;
    }
    reduce(combine) {
      return this.readClasses().reduce(combine);
    }
    fold(T) {
      return (initialValue, combine) => {
        return this.readClasses().fold(T)(initialValue, combine);
      };
    }
    contains(value) {
      if (!(typeof value == 'string')) return false;
      this[_validateToken](dart.as(value, core.String));
      return this.readClasses().contains(value);
    }
    lookup(value) {
      return dart.as(dart.notNull(this.contains(value)) ? value : null, core.String);
    }
    add(value) {
      this[_validateToken](value);
      return dart.as(this.modify(dart.fn(s => s.add(value), core.bool, [core.Set$(core.String)])), core.bool);
    }
    remove(value) {
      this[_validateToken](dart.as(value, core.String));
      if (!(typeof value == 'string')) return false;
      let s = this.readClasses();
      let result = s.remove(value);
      this.writeClasses(s);
      return result;
    }
    addAll(iterable) {
      this.modify(dart.fn(s => s.addAll(iterable[dartx.map](core.String)(dart.bind(this, _validateToken))), dart.void, [core.Set$(core.String)]));
    }
    removeAll(iterable) {
      this.modify(dart.fn(s => s.removeAll(iterable), dart.void, [core.Set$(core.String)]));
    }
    toggleAll(iterable, shouldAdd) {
      if (shouldAdd === void 0) shouldAdd = null;
      iterable[dartx.forEach](dart.fn(e => this.toggle(e, shouldAdd), core.bool, [core.String]));
    }
    retainAll(iterable) {
      this.modify(dart.fn(s => s.retainAll(iterable), dart.void, [core.Set$(core.String)]));
    }
    removeWhere(test) {
      this.modify(dart.fn(s => s.removeWhere(test), dart.void, [core.Set$(core.String)]));
    }
    retainWhere(test) {
      this.modify(dart.fn(s => s.retainWhere(test), dart.void, [core.Set$(core.String)]));
    }
    containsAll(collection) {
      return this.readClasses().containsAll(collection);
    }
    intersection(other) {
      return this.readClasses().intersection(other);
    }
    union(other) {
      return this.readClasses().union(other);
    }
    difference(other) {
      return this.readClasses().difference(other);
    }
    get first() {
      return this.readClasses().first;
    }
    get last() {
      return this.readClasses().last;
    }
    get single() {
      return this.readClasses().single;
    }
    toList(opts) {
      let growable = opts && 'growable' in opts ? opts.growable : true;
      return this.readClasses().toList({growable: growable});
    }
    toSet() {
      return this.readClasses().toSet();
    }
    take(n) {
      return this.readClasses().take(n);
    }
    takeWhile(test) {
      return this.readClasses().takeWhile(test);
    }
    skip(n) {
      return this.readClasses().skip(n);
    }
    skipWhile(test) {
      return this.readClasses().skipWhile(test);
    }
    firstWhere(test, opts) {
      let orElse = opts && 'orElse' in opts ? opts.orElse : null;
      return this.readClasses().firstWhere(test, {orElse: orElse});
    }
    lastWhere(test, opts) {
      let orElse = opts && 'orElse' in opts ? opts.orElse : null;
      return this.readClasses().lastWhere(test, {orElse: orElse});
    }
    singleWhere(test) {
      return this.readClasses().singleWhere(test);
    }
    elementAt(index) {
      return this.readClasses().elementAt(index);
    }
    clear() {
      this.modify(dart.fn(s => s.clear(), dart.void, [core.Set$(core.String)]));
    }
    modify(f) {
      let s = this.readClasses();
      let ret = f(s);
      this.writeClasses(s);
      return ret;
    }
  };
  html_common.CssClassSetImpl[dart.implements] = () => [html$.CssClassSet];
  dart.setSignature(html_common.CssClassSetImpl, {
    methods: () => ({
      [_validateToken]: [core.String, [core.String]],
      toggle: [core.bool, [core.String], [core.bool]],
      forEach: [dart.void, [dart.functionType(dart.void, [core.String])]],
      join: [core.String, [], [core.String]],
      map: [T => [core.Iterable$(T), [dart.functionType(T, [core.String])]]],
      where: [core.Iterable$(core.String), [dart.functionType(core.bool, [core.String])]],
      expand: [T => [core.Iterable$(T), [dart.functionType(core.Iterable$(T), [core.String])]]],
      every: [core.bool, [dart.functionType(core.bool, [core.String])]],
      any: [core.bool, [dart.functionType(core.bool, [core.String])]],
      reduce: [core.String, [dart.functionType(core.String, [core.String, core.String])]],
      fold: [T => [T, [T, dart.functionType(T, [T, core.String])]]],
      contains: [core.bool, [core.Object]],
      lookup: [core.String, [core.Object]],
      add: [core.bool, [core.String]],
      remove: [core.bool, [core.Object]],
      addAll: [dart.void, [core.Iterable$(core.String)]],
      removeAll: [dart.void, [core.Iterable$(core.Object)]],
      toggleAll: [dart.void, [core.Iterable$(core.String)], [core.bool]],
      retainAll: [dart.void, [core.Iterable$(core.Object)]],
      removeWhere: [dart.void, [dart.functionType(core.bool, [core.String])]],
      retainWhere: [dart.void, [dart.functionType(core.bool, [core.String])]],
      containsAll: [core.bool, [core.Iterable$(core.Object)]],
      intersection: [core.Set$(core.String), [core.Set$(core.Object)]],
      union: [core.Set$(core.String), [core.Set$(core.String)]],
      difference: [core.Set$(core.String), [core.Set$(core.Object)]],
      toList: [core.List$(core.String), [], {growable: core.bool}],
      toSet: [core.Set$(core.String), []],
      take: [core.Iterable$(core.String), [core.int]],
      takeWhile: [core.Iterable$(core.String), [dart.functionType(core.bool, [core.String])]],
      skip: [core.Iterable$(core.String), [core.int]],
      skipWhile: [core.Iterable$(core.String), [dart.functionType(core.bool, [core.String])]],
      firstWhere: [core.String, [dart.functionType(core.bool, [core.String])], {orElse: dart.functionType(core.String, [])}],
      lastWhere: [core.String, [dart.functionType(core.bool, [core.String])], {orElse: dart.functionType(core.String, [])}],
      singleWhere: [core.String, [dart.functionType(core.bool, [core.String])]],
      elementAt: [core.String, [core.int]],
      clear: [dart.void, []],
      modify: [dart.dynamic, [dart.functionType(dart.dynamic, [core.Set$(core.String)])]]
    })
  });
  dart.defineExtensionMembers(html_common.CssClassSetImpl, [
    'toString',
    'forEach',
    'join',
    'map',
    'where',
    'expand',
    'every',
    'any',
    'reduce',
    'fold',
    'contains',
    'toList',
    'toSet',
    'take',
    'takeWhile',
    'skip',
    'skipWhile',
    'firstWhere',
    'lastWhere',
    'singleWhere',
    'elementAt',
    'iterator',
    'isEmpty',
    'isNotEmpty',
    'length',
    'first',
    'last',
    'single'
  ]);
  dart.defineLazy(html_common.CssClassSetImpl, {
    get _validTokenRE() {
      return core.RegExp.new('^\\S+$');
    }
  });
  html$._MultiElementCssClassSet = class _MultiElementCssClassSet extends html_common.CssClassSetImpl {
    static new(elements) {
      return new html$._MultiElementCssClassSet._(elements, dart.as(elements[dartx.map](html$.CssClassSet)(dart.fn(e => e[dartx.classes], html$.CssClassSet, [html$.Element]))[dartx.toList](), core.List$(html_common.CssClassSetImpl)));
    }
    _(elementIterable, sets) {
      this[_elementIterable] = elementIterable;
      this[_sets] = sets;
    }
    readClasses() {
      let s = collection.LinkedHashSet$(core.String).new();
      this[_sets][dartx.forEach](dart.fn(e => s.addAll(e.readClasses()), dart.void, [html_common.CssClassSetImpl]));
      return s;
    }
    writeClasses(s) {
      let classes = s.join(' ');
      for (let e of this[_elementIterable]) {
        e[dartx.className] = classes;
      }
    }
    modify(f) {
      this[_sets][dartx.forEach](dart.fn(e => e.modify(f), dart.void, [html_common.CssClassSetImpl]));
    }
    toggle(value, shouldAdd) {
      if (shouldAdd === void 0) shouldAdd = null;
      return this[_sets][dartx.fold](core.bool)(false, dart.fn((changed, e) => dart.notNull(e.toggle(value, shouldAdd)) || dart.notNull(changed), core.bool, [core.bool, html_common.CssClassSetImpl]));
    }
    remove(value) {
      return this[_sets][dartx.fold](core.bool)(false, dart.fn((changed, e) => dart.notNull(e.remove(value)) || dart.notNull(changed), core.bool, [core.bool, html_common.CssClassSetImpl]));
    }
  };
  dart.defineNamedConstructor(html$._MultiElementCssClassSet, '_');
  dart.setSignature(html$._MultiElementCssClassSet, {
    constructors: () => ({
      new: [html$._MultiElementCssClassSet, [core.Iterable$(html$.Element)]],
      _: [html$._MultiElementCssClassSet, [core.Iterable$(html$.Element), core.List$(html_common.CssClassSetImpl)]]
    }),
    methods: () => ({
      readClasses: [core.Set$(core.String), []],
      writeClasses: [dart.void, [core.Set$(core.String)]]
    })
  });
  html$._ElementCssClassSet = class _ElementCssClassSet extends html_common.CssClassSetImpl {
    _ElementCssClassSet(element) {
      this[_element$] = element;
    }
    readClasses() {
      let s = collection.LinkedHashSet$(core.String).new();
      let classname = this[_element$][dartx.className];
      for (let name of classname[dartx.split](' ')) {
        let trimmed = name[dartx.trim]();
        if (!dart.notNull(trimmed[dartx.isEmpty])) {
          s.add(trimmed);
        }
      }
      return s;
    }
    writeClasses(s) {
      this[_element$][dartx.className] = s.join(' ');
    }
    get length() {
      return html$._ElementCssClassSet._classListLength(html$._ElementCssClassSet._classListOf(this[_element$]));
    }
    get isEmpty() {
      return this.length == 0;
    }
    get isNotEmpty() {
      return this.length != 0;
    }
    clear() {
      this[_element$][dartx.className] = '';
    }
    contains(value) {
      return html$._ElementCssClassSet._contains(this[_element$], value);
    }
    add(value) {
      return html$._ElementCssClassSet._add(this[_element$], value);
    }
    remove(value) {
      return typeof value == 'string' && dart.notNull(html$._ElementCssClassSet._remove(this[_element$], value));
    }
    toggle(value, shouldAdd) {
      if (shouldAdd === void 0) shouldAdd = null;
      return html$._ElementCssClassSet._toggle(this[_element$], value, shouldAdd);
    }
    addAll(iterable) {
      html$._ElementCssClassSet._addAll(this[_element$], iterable);
    }
    removeAll(iterable) {
      html$._ElementCssClassSet._removeAll(this[_element$], dart.as(iterable, core.Iterable$(core.String)));
    }
    retainAll(iterable) {
      html$._ElementCssClassSet._removeWhere(this[_element$], dart.bind(iterable[dartx.toSet](), 'contains'), false);
    }
    removeWhere(test) {
      html$._ElementCssClassSet._removeWhere(this[_element$], test, true);
    }
    retainWhere(test) {
      html$._ElementCssClassSet._removeWhere(this[_element$], test, false);
    }
    static _contains(_element, value) {
      return typeof value == 'string' && dart.notNull(html$._ElementCssClassSet._classListContains(html$._ElementCssClassSet._classListOf(_element), value));
    }
    static _add(_element, value) {
      let list = html$._ElementCssClassSet._classListOf(_element);
      let added = !dart.notNull(html$._ElementCssClassSet._classListContainsBeforeAddOrRemove(list, value));
      html$._ElementCssClassSet._classListAdd(list, value);
      return added;
    }
    static _remove(_element, value) {
      let list = html$._ElementCssClassSet._classListOf(_element);
      let removed = html$._ElementCssClassSet._classListContainsBeforeAddOrRemove(list, value);
      html$._ElementCssClassSet._classListRemove(list, value);
      return removed;
    }
    static _toggle(_element, value, shouldAdd) {
      return shouldAdd == null ? html$._ElementCssClassSet._toggleDefault(_element, value) : html$._ElementCssClassSet._toggleOnOff(_element, value, shouldAdd);
    }
    static _toggleDefault(_element, value) {
      let list = html$._ElementCssClassSet._classListOf(_element);
      return html$._ElementCssClassSet._classListToggle1(list, value);
    }
    static _toggleOnOff(_element, value, shouldAdd) {
      let list = html$._ElementCssClassSet._classListOf(_element);
      if (dart.notNull(shouldAdd)) {
        html$._ElementCssClassSet._classListAdd(list, value);
        return true;
      } else {
        html$._ElementCssClassSet._classListRemove(list, value);
        return false;
      }
    }
    static _addAll(_element, iterable) {
      let list = html$._ElementCssClassSet._classListOf(_element);
      for (let value of iterable) {
        html$._ElementCssClassSet._classListAdd(list, value);
      }
    }
    static _removeAll(_element, iterable) {
      let list = html$._ElementCssClassSet._classListOf(_element);
      for (let value of iterable) {
        html$._ElementCssClassSet._classListRemove(list, value);
      }
    }
    static _removeWhere(_element, test, doRemove) {
      let list = html$._ElementCssClassSet._classListOf(_element);
      let i = 0;
      while (i < dart.notNull(html$._ElementCssClassSet._classListLength(list))) {
        let item = list[dartx.item](i);
        if (doRemove == test(item)) {
          html$._ElementCssClassSet._classListRemove(list, item);
        } else {
          ++i;
        }
      }
    }
    static _classListOf(e) {
      return e.classList;
    }
    static _classListLength(list) {
      return list.length;
    }
    static _classListContains(list, value) {
      return list.contains(value);
    }
    static _classListContainsBeforeAddOrRemove(list, value) {
      return list.contains(value);
    }
    static _classListAdd(list, value) {
      list.add(value);
    }
    static _classListRemove(list, value) {
      list.remove(value);
    }
    static _classListToggle1(list, value) {
      return list.toggle(value);
    }
    static _classListToggle2(list, value, shouldAdd) {
      return list.toggle(value, shouldAdd);
    }
  };
  dart.setSignature(html$._ElementCssClassSet, {
    constructors: () => ({_ElementCssClassSet: [html$._ElementCssClassSet, [html$.Element]]}),
    methods: () => ({
      readClasses: [core.Set$(core.String), []],
      writeClasses: [dart.void, [core.Set$(core.String)]]
    }),
    statics: () => ({
      _contains: [core.bool, [html$.Element, core.Object]],
      _add: [core.bool, [html$.Element, core.String]],
      _remove: [core.bool, [html$.Element, core.String]],
      _toggle: [core.bool, [html$.Element, core.String, core.bool]],
      _toggleDefault: [core.bool, [html$.Element, core.String]],
      _toggleOnOff: [core.bool, [html$.Element, core.String, core.bool]],
      _addAll: [dart.void, [html$.Element, core.Iterable$(core.String)]],
      _removeAll: [dart.void, [html$.Element, core.Iterable$(core.String)]],
      _removeWhere: [dart.void, [html$.Element, dart.functionType(core.bool, [core.String]), core.bool]],
      _classListOf: [html$.DomTokenList, [html$.Element]],
      _classListLength: [core.int, [html$.DomTokenList]],
      _classListContains: [core.bool, [html$.DomTokenList, core.String]],
      _classListContainsBeforeAddOrRemove: [core.bool, [html$.DomTokenList, core.String]],
      _classListAdd: [dart.void, [html$.DomTokenList, core.String]],
      _classListRemove: [dart.void, [html$.DomTokenList, core.String]],
      _classListToggle1: [core.bool, [html$.DomTokenList, core.String]],
      _classListToggle2: [core.bool, [html$.DomTokenList, core.String, core.bool]]
    }),
    names: ['_contains', '_add', '_remove', '_toggle', '_toggleDefault', '_toggleOnOff', '_addAll', '_removeAll', '_removeWhere', '_classListOf', '_classListLength', '_classListContains', '_classListContainsBeforeAddOrRemove', '_classListAdd', '_classListRemove', '_classListToggle1', '_classListToggle2']
  });
  dart.defineExtensionMembers(html$._ElementCssClassSet, ['contains', 'length', 'isEmpty', 'isNotEmpty']);
  const _unit = Symbol('_unit');
  html$.Dimension = class Dimension extends core.Object {
    percent(value) {
      this[_value$1] = value;
      this[_unit] = '%';
    }
    px(value) {
      this[_value$1] = value;
      this[_unit] = 'px';
    }
    pc(value) {
      this[_value$1] = value;
      this[_unit] = 'pc';
    }
    pt(value) {
      this[_value$1] = value;
      this[_unit] = 'pt';
    }
    inch(value) {
      this[_value$1] = value;
      this[_unit] = 'in';
    }
    cm(value) {
      this[_value$1] = value;
      this[_unit] = 'cm';
    }
    mm(value) {
      this[_value$1] = value;
      this[_unit] = 'mm';
    }
    em(value) {
      this[_value$1] = value;
      this[_unit] = 'em';
    }
    ex(value) {
      this[_value$1] = value;
      this[_unit] = 'ex';
    }
    css(cssValue) {
      this[_value$1] = null;
      this[_unit] = null;
      if (cssValue == '') cssValue = '0px';
      if (dart.notNull(cssValue[dartx.endsWith]('%'))) {
        this[_unit] = '%';
      } else {
        this[_unit] = cssValue[dartx.substring](dart.notNull(cssValue[dartx.length]) - 2);
      }
      if (dart.notNull(cssValue[dartx.contains]('.'))) {
        this[_value$1] = core.double.parse(cssValue[dartx.substring](0, dart.notNull(cssValue[dartx.length]) - dart.notNull(this[_unit][dartx.length])));
      } else {
        this[_value$1] = core.int.parse(cssValue[dartx.substring](0, dart.notNull(cssValue[dartx.length]) - dart.notNull(this[_unit][dartx.length])));
      }
    }
    toString() {
      return `${this[_value$1]}${this[_unit]}`;
    }
    get value() {
      return this[_value$1];
    }
  };
  dart.defineNamedConstructor(html$.Dimension, 'percent');
  dart.defineNamedConstructor(html$.Dimension, 'px');
  dart.defineNamedConstructor(html$.Dimension, 'pc');
  dart.defineNamedConstructor(html$.Dimension, 'pt');
  dart.defineNamedConstructor(html$.Dimension, 'inch');
  dart.defineNamedConstructor(html$.Dimension, 'cm');
  dart.defineNamedConstructor(html$.Dimension, 'mm');
  dart.defineNamedConstructor(html$.Dimension, 'em');
  dart.defineNamedConstructor(html$.Dimension, 'ex');
  dart.defineNamedConstructor(html$.Dimension, 'css');
  dart.setSignature(html$.Dimension, {
    constructors: () => ({
      percent: [html$.Dimension, [core.num]],
      px: [html$.Dimension, [core.num]],
      pc: [html$.Dimension, [core.num]],
      pt: [html$.Dimension, [core.num]],
      inch: [html$.Dimension, [core.num]],
      cm: [html$.Dimension, [core.num]],
      mm: [html$.Dimension, [core.num]],
      em: [html$.Dimension, [core.num]],
      ex: [html$.Dimension, [core.num]],
      css: [html$.Dimension, [core.String]]
    })
  });
  html$.Dimension[dart.metadata] = () => [dart.const(new _metadata.Experimental())];
  html$.EventListener = dart.typedef('EventListener', () => dart.functionType(dart.dynamic, [html$.Event]));
  html$.EventStreamProvider$ = dart.generic(T => {
    class EventStreamProvider extends core.Object {
      EventStreamProvider(eventType) {
        this[_eventType] = eventType;
      }
      forTarget(e, opts) {
        let useCapture = opts && 'useCapture' in opts ? opts.useCapture : false;
        return new (html$._EventStream$(T))(e, this[_eventType], useCapture);
      }
      forElement(e, opts) {
        let useCapture = opts && 'useCapture' in opts ? opts.useCapture : false;
        return new (html$._ElementEventStreamImpl$(T))(e, this[_eventType], useCapture);
      }
      [_forElementList](e, opts) {
        let useCapture = opts && 'useCapture' in opts ? opts.useCapture : false;
        return new (html$._ElementListEventStreamImpl$(html$.Event))(e, this[_eventType], useCapture);
      }
      getEventType(target) {
        return this[_eventType];
      }
    }
    dart.setSignature(EventStreamProvider, {
      constructors: () => ({EventStreamProvider: [html$.EventStreamProvider$(T), [core.String]]}),
      methods: () => ({
        forTarget: [async.Stream$(T), [html$.EventTarget], {useCapture: core.bool}],
        forElement: [html$.ElementStream$(T), [html$.Element], {useCapture: core.bool}],
        [_forElementList]: [html$.ElementStream$(T), [html$.ElementList$(html$.Element)], {useCapture: core.bool}],
        getEventType: [core.String, [html$.EventTarget]]
      })
    });
    return EventStreamProvider;
  });
  html$.EventStreamProvider = html$.EventStreamProvider$();
  html$.ElementStream$ = dart.generic(T => {
    class ElementStream extends core.Object {}
    ElementStream[dart.implements] = () => [async.Stream$(T)];
    return ElementStream;
  });
  html$.ElementStream = html$.ElementStream$();
  const _target$ = Symbol('_target');
  const _useCapture = Symbol('_useCapture');
  html$._EventStream$ = dart.generic(T => {
    class _EventStream extends async.Stream$(T) {
      _EventStream(target, eventType, useCapture) {
        this[_target$] = target;
        this[_eventType] = eventType;
        this[_useCapture] = useCapture;
        super.Stream();
      }
      asBroadcastStream(opts) {
        let onListen = opts && 'onListen' in opts ? opts.onListen : null;
        dart.as(onListen, dart.functionType(dart.void, [async.StreamSubscription$(T)]));
        let onCancel = opts && 'onCancel' in opts ? opts.onCancel : null;
        dart.as(onCancel, dart.functionType(dart.void, [async.StreamSubscription$(T)]));
        return this;
      }
      get isBroadcast() {
        return true;
      }
      listen(onData, opts) {
        dart.as(onData, dart.functionType(dart.void, [T]));
        let onError = opts && 'onError' in opts ? opts.onError : null;
        let onDone = opts && 'onDone' in opts ? opts.onDone : null;
        dart.as(onDone, dart.functionType(dart.void, []));
        let cancelOnError = opts && 'cancelOnError' in opts ? opts.cancelOnError : null;
        return new (html$._EventStreamSubscription$(T))(this[_target$], this[_eventType], onData, this[_useCapture]);
      }
    }
    dart.setSignature(_EventStream, {
      constructors: () => ({_EventStream: [html$._EventStream$(T), [html$.EventTarget, core.String, core.bool]]}),
      methods: () => ({
        asBroadcastStream: [async.Stream$(T), [], {onListen: dart.functionType(dart.void, [async.StreamSubscription$(T)]), onCancel: dart.functionType(dart.void, [async.StreamSubscription$(T)])}],
        listen: [async.StreamSubscription$(T), [dart.functionType(dart.void, [T])], {onError: core.Function, onDone: dart.functionType(dart.void, []), cancelOnError: core.bool}]
      })
    });
    return _EventStream;
  });
  html$._EventStream = html$._EventStream$();
  html$._matchesWithAncestors = function(event, selector) {
    let target = event[dartx.target];
    return dart.is(target, html$.Element) ? target[dartx.matchesWithAncestors](selector) : false;
  };
  dart.fn(html$._matchesWithAncestors, core.bool, [html$.Event, core.String]);
  html$._ElementEventStreamImpl$ = dart.generic(T => {
    class _ElementEventStreamImpl extends html$._EventStream$(T) {
      _ElementEventStreamImpl(target, eventType, useCapture) {
        super._EventStream(dart.as(target, html$.EventTarget), dart.as(eventType, core.String), dart.as(useCapture, core.bool));
      }
      matches(selector) {
        return this.where(dart.fn(event => {
          dart.as(event, T);
          return html$._matchesWithAncestors(event, selector);
        }, core.bool, [T])).map(T)(dart.fn(e => {
          dart.as(e, T);
          e[_selector] = selector;
          return e;
        }, T, [T]));
      }
      capture(onData) {
        dart.as(onData, dart.functionType(dart.void, [T]));
        return new (html$._EventStreamSubscription$(T))(this[_target$], this[_eventType], onData, true);
      }
    }
    _ElementEventStreamImpl[dart.implements] = () => [html$.ElementStream$(T)];
    dart.setSignature(_ElementEventStreamImpl, {
      constructors: () => ({_ElementEventStreamImpl: [html$._ElementEventStreamImpl$(T), [dart.dynamic, dart.dynamic, dart.dynamic]]}),
      methods: () => ({
        matches: [async.Stream$(T), [core.String]],
        capture: [async.StreamSubscription$(T), [dart.functionType(dart.void, [T])]]
      })
    });
    return _ElementEventStreamImpl;
  });
  html$._ElementEventStreamImpl = html$._ElementEventStreamImpl$();
  const _targetList = Symbol('_targetList');
  html$._ElementListEventStreamImpl$ = dart.generic(T => {
    class _ElementListEventStreamImpl extends async.Stream$(T) {
      _ElementListEventStreamImpl(targetList, eventType, useCapture) {
        this[_targetList] = targetList;
        this[_eventType] = eventType;
        this[_useCapture] = useCapture;
        super.Stream();
      }
      matches(selector) {
        return this.where(dart.fn(event => {
          dart.as(event, T);
          return html$._matchesWithAncestors(event, selector);
        }, core.bool, [T])).map(T)(dart.fn(e => {
          dart.as(e, T);
          e[_selector] = selector;
          return e;
        }, T, [T]));
      }
      listen(onData, opts) {
        dart.as(onData, dart.functionType(dart.void, [T]));
        let onError = opts && 'onError' in opts ? opts.onError : null;
        let onDone = opts && 'onDone' in opts ? opts.onDone : null;
        dart.as(onDone, dart.functionType(dart.void, []));
        let cancelOnError = opts && 'cancelOnError' in opts ? opts.cancelOnError : null;
        let pool = new (html$._StreamPool$(T)).broadcast();
        for (let target of this[_targetList]) {
          pool.add(new (html$._EventStream$(T))(target, this[_eventType], this[_useCapture]));
        }
        return pool.stream.listen(onData, {onError: onError, onDone: onDone, cancelOnError: cancelOnError});
      }
      capture(onData) {
        dart.as(onData, dart.functionType(dart.void, [T]));
        let pool = new (html$._StreamPool$(T)).broadcast();
        for (let target of this[_targetList]) {
          pool.add(new (html$._EventStream$(T))(target, this[_eventType], true));
        }
        return pool.stream.listen(onData);
      }
      asBroadcastStream(opts) {
        let onListen = opts && 'onListen' in opts ? opts.onListen : null;
        dart.as(onListen, dart.functionType(dart.void, [async.StreamSubscription$(T)]));
        let onCancel = opts && 'onCancel' in opts ? opts.onCancel : null;
        dart.as(onCancel, dart.functionType(dart.void, [async.StreamSubscription$(T)]));
        return this;
      }
      get isBroadcast() {
        return true;
      }
    }
    _ElementListEventStreamImpl[dart.implements] = () => [html$.ElementStream$(T)];
    dart.setSignature(_ElementListEventStreamImpl, {
      constructors: () => ({_ElementListEventStreamImpl: [html$._ElementListEventStreamImpl$(T), [core.Iterable$(html$.Element), core.String, core.bool]]}),
      methods: () => ({
        matches: [async.Stream$(T), [core.String]],
        listen: [async.StreamSubscription$(T), [dart.functionType(dart.void, [T])], {onError: core.Function, onDone: dart.functionType(dart.void, []), cancelOnError: core.bool}],
        capture: [async.StreamSubscription$(T), [dart.functionType(dart.void, [T])]],
        asBroadcastStream: [async.Stream$(T), [], {onListen: dart.functionType(dart.void, [async.StreamSubscription$(T)]), onCancel: dart.functionType(dart.void, [async.StreamSubscription$(T)])}]
      })
    });
    return _ElementListEventStreamImpl;
  });
  html$._ElementListEventStreamImpl = html$._ElementListEventStreamImpl$();
  html$._EventListener$ = dart.generic(T => {
    const _EventListener = dart.typedef('_EventListener', () => dart.functionType(dart.dynamic, [T]));
    return _EventListener;
  });
  html$._EventListener = html$._EventListener$();
  const _onData$ = Symbol('_onData');
  const _pauseCount$ = Symbol('_pauseCount');
  const _tryResume = Symbol('_tryResume');
  const _canceled = Symbol('_canceled');
  const _unlisten = Symbol('_unlisten');
  html$._EventStreamSubscription$ = dart.generic(T => {
    class _EventStreamSubscription extends async.StreamSubscription$(T) {
      _EventStreamSubscription(target, eventType, onData, useCapture) {
        this[_target$] = target;
        this[_eventType] = eventType;
        this[_useCapture] = useCapture;
        this[_onData$] = html$._wrapZone(html$.Event, dart.dynamic)(dart.as(onData, html$._wrapZoneCallback$(html$.Event, dart.dynamic)));
        this[_pauseCount$] = 0;
        this[_tryResume]();
      }
      cancel() {
        if (dart.notNull(this[_canceled])) return null;
        this[_unlisten]();
        this[_target$] = null;
        this[_onData$] = null;
        return null;
      }
      get [_canceled]() {
        return this[_target$] == null;
      }
      onData(handleData) {
        dart.as(handleData, dart.functionType(dart.void, [T]));
        if (dart.notNull(this[_canceled])) {
          dart.throw(new core.StateError("Subscription has been canceled."));
        }
        this[_unlisten]();
        this[_onData$] = html$._wrapZone(html$.Event, dart.dynamic)(dart.as(handleData, html$._wrapZoneCallback$(html$.Event, dart.dynamic)));
        this[_tryResume]();
      }
      onError(handleError) {}
      onDone(handleDone) {
        dart.as(handleDone, dart.functionType(dart.void, []));
      }
      pause(resumeSignal) {
        if (resumeSignal === void 0) resumeSignal = null;
        if (dart.notNull(this[_canceled])) return;
        this[_pauseCount$] = dart.notNull(this[_pauseCount$]) + 1;
        this[_unlisten]();
        if (resumeSignal != null) {
          resumeSignal.whenComplete(dart.bind(this, 'resume'));
        }
      }
      get isPaused() {
        return dart.notNull(this[_pauseCount$]) > 0;
      }
      resume() {
        if (dart.notNull(this[_canceled]) || !dart.notNull(this.isPaused)) return;
        this[_pauseCount$] = dart.notNull(this[_pauseCount$]) - 1;
        this[_tryResume]();
      }
      [_tryResume]() {
        if (this[_onData$] != null && !dart.notNull(this.isPaused)) {
          this[_target$][dartx.addEventListener](this[_eventType], this[_onData$], this[_useCapture]);
        }
      }
      [_unlisten]() {
        if (this[_onData$] != null) {
          this[_target$][dartx.removeEventListener](this[_eventType], this[_onData$], this[_useCapture]);
        }
      }
      asFuture(futureValue) {
        if (futureValue === void 0) futureValue = null;
        let completer = async.Completer.new();
        return completer.future;
      }
    }
    dart.setSignature(_EventStreamSubscription, {
      constructors: () => ({_EventStreamSubscription: [html$._EventStreamSubscription$(T), [html$.EventTarget, core.String, dart.functionType(dart.void, [T]), core.bool]]}),
      methods: () => ({
        cancel: [async.Future, []],
        onData: [dart.void, [dart.functionType(dart.void, [T])]],
        onError: [dart.void, [core.Function]],
        onDone: [dart.void, [dart.functionType(dart.void, [])]],
        pause: [dart.void, [], [async.Future]],
        resume: [dart.void, []],
        [_tryResume]: [dart.void, []],
        [_unlisten]: [dart.void, []],
        asFuture: [async.Future, [], [dart.dynamic]]
      })
    });
    return _EventStreamSubscription;
  });
  html$._EventStreamSubscription = html$._EventStreamSubscription$();
  html$.CustomStream$ = dart.generic(T => {
    class CustomStream extends core.Object {}
    CustomStream[dart.implements] = () => [async.Stream$(T)];
    return CustomStream;
  });
  html$.CustomStream = html$.CustomStream$();
  const _streamController = Symbol('_streamController');
  const _type = Symbol('_type');
  html$._CustomEventStreamImpl$ = dart.generic(T => {
    class _CustomEventStreamImpl extends async.Stream$(T) {
      _CustomEventStreamImpl(type) {
        this[_streamController] = null;
        this[_type] = null;
        super.Stream();
        this[_type] = type;
        this[_streamController] = async.StreamController$(T).broadcast({sync: true});
      }
      listen(onData, opts) {
        dart.as(onData, dart.functionType(dart.void, [T]));
        let onError = opts && 'onError' in opts ? opts.onError : null;
        let onDone = opts && 'onDone' in opts ? opts.onDone : null;
        dart.as(onDone, dart.functionType(dart.void, []));
        let cancelOnError = opts && 'cancelOnError' in opts ? opts.cancelOnError : null;
        return this[_streamController].stream.listen(onData, {onError: onError, onDone: onDone, cancelOnError: cancelOnError});
      }
      asBroadcastStream(opts) {
        let onListen = opts && 'onListen' in opts ? opts.onListen : null;
        dart.as(onListen, dart.functionType(dart.void, [async.StreamSubscription$(T)]));
        let onCancel = opts && 'onCancel' in opts ? opts.onCancel : null;
        dart.as(onCancel, dart.functionType(dart.void, [async.StreamSubscription$(T)]));
        return this[_streamController].stream;
      }
      get isBroadcast() {
        return true;
      }
      add(event) {
        dart.as(event, T);
        if (event[dartx.type] == this[_type]) this[_streamController].add(event);
      }
    }
    _CustomEventStreamImpl[dart.implements] = () => [html$.CustomStream$(T)];
    dart.setSignature(_CustomEventStreamImpl, {
      constructors: () => ({_CustomEventStreamImpl: [html$._CustomEventStreamImpl$(T), [core.String]]}),
      methods: () => ({
        listen: [async.StreamSubscription$(T), [dart.functionType(dart.void, [T])], {onError: core.Function, onDone: dart.functionType(dart.void, []), cancelOnError: core.bool}],
        asBroadcastStream: [async.Stream$(T), [], {onListen: dart.functionType(dart.void, [async.StreamSubscription$(T)]), onCancel: dart.functionType(dart.void, [async.StreamSubscription$(T)])}],
        add: [dart.void, [T]]
      })
    });
    return _CustomEventStreamImpl;
  });
  html$._CustomEventStreamImpl = html$._CustomEventStreamImpl$();
  const _parent$ = Symbol('_parent');
  const _shadowKeyCode = Symbol('_shadowKeyCode');
  const _shadowCharCode = Symbol('_shadowCharCode');
  const _shadowAltKey = Symbol('_shadowAltKey');
  const _realKeyCode = Symbol('_realKeyCode');
  const _realCharCode = Symbol('_realCharCode');
  const _realAltKey = Symbol('_realAltKey');
  const _currentTarget = Symbol('_currentTarget');
  const _shadowKeyIdentifier = Symbol('_shadowKeyIdentifier');
  html$.KeyEvent = class KeyEvent extends html$._WrappedEvent {
    get keyCode() {
      return this[_shadowKeyCode];
    }
    get charCode() {
      return this.type == 'keypress' ? this[_shadowCharCode] : 0;
    }
    get altKey() {
      return this[_shadowAltKey];
    }
    get which() {
      return this.keyCode;
    }
    get [_realKeyCode]() {
      return this[_parent$].keyCode;
    }
    get [_realCharCode]() {
      return this[_parent$].charCode;
    }
    get [_realAltKey]() {
      return this[_parent$].altKey;
    }
    static _makeRecord() {
      let interceptor = _foreign_helper.JS_INTERCEPTOR_CONSTANT(dart.wrapType(html$.KeyboardEvent));
      return _js_helper.makeLeafDispatchRecord(interceptor);
    }
    wrap(parent) {
      this[_parent$] = null;
      this[_shadowAltKey] = null;
      this[_shadowCharCode] = null;
      this[_shadowKeyCode] = null;
      this[_currentTarget] = null;
      super._WrappedEvent(parent);
      this[_parent$] = parent;
      this[_shadowAltKey] = this[_realAltKey];
      this[_shadowCharCode] = this[_realCharCode];
      this[_shadowKeyCode] = this[_realKeyCode];
      this[_currentTarget] = this[_parent$][dartx.currentTarget];
    }
    static new(type, opts) {
      let view = opts && 'view' in opts ? opts.view : null;
      let canBubble = opts && 'canBubble' in opts ? opts.canBubble : true;
      let cancelable = opts && 'cancelable' in opts ? opts.cancelable : true;
      let keyCode = opts && 'keyCode' in opts ? opts.keyCode : 0;
      let charCode = opts && 'charCode' in opts ? opts.charCode : 0;
      let keyLocation = opts && 'keyLocation' in opts ? opts.keyLocation : 1;
      let ctrlKey = opts && 'ctrlKey' in opts ? opts.ctrlKey : false;
      let altKey = opts && 'altKey' in opts ? opts.altKey : false;
      let shiftKey = opts && 'shiftKey' in opts ? opts.shiftKey : false;
      let metaKey = opts && 'metaKey' in opts ? opts.metaKey : false;
      let currentTarget = opts && 'currentTarget' in opts ? opts.currentTarget : null;
      if (view == null) {
        view = html$.window;
      }
      let eventObj = null;
      if (dart.notNull(html$.KeyEvent.canUseDispatchEvent)) {
        eventObj = html$.Event.eventType('Event', type, {canBubble: canBubble, cancelable: cancelable});
        eventObj.keyCode = keyCode;
        eventObj.which = keyCode;
        eventObj.charCode = charCode;
        eventObj.keyLocation = keyLocation;
        eventObj.ctrlKey = ctrlKey;
        eventObj.altKey = altKey;
        eventObj.shiftKey = shiftKey;
        eventObj.metaKey = metaKey;
      } else {
        eventObj = html$.Event.eventType('KeyboardEvent', type, {canBubble: canBubble, cancelable: cancelable});
        Object.defineProperty(eventObj, 'keyCode', {
          get: function() {
            return this.keyCodeVal;
          }
        });
        Object.defineProperty(eventObj, 'which', {
          get: function() {
            return this.keyCodeVal;
          }
        });
        Object.defineProperty(eventObj, 'charCode', {
          get: function() {
            return this.charCodeVal;
          }
        });
        let keyIdentifier = html$.KeyEvent._convertToHexString(charCode, keyCode);
        dart.dsend(eventObj, _initKeyboardEvent, type, canBubble, cancelable, view, keyIdentifier, keyLocation, ctrlKey, altKey, shiftKey, metaKey);
        eventObj.keyCodeVal = keyCode;
        eventObj.charCodeVal = charCode;
      }
      _interceptors.setDispatchProperty(eventObj, html$.KeyEvent._keyboardEventDispatchRecord);
      let keyEvent = new html$.KeyEvent.wrap(dart.as(eventObj, html$.KeyboardEvent));
      if (keyEvent[_currentTarget] == null) {
        keyEvent[_currentTarget] = currentTarget == null ? html$.window : currentTarget;
      }
      return keyEvent;
    }
    static get canUseDispatchEvent() {
      return typeof document.body.dispatchEvent == "function" && document.body.dispatchEvent.length > 0;
    }
    get currentTarget() {
      return this[_currentTarget];
    }
    static _convertToHexString(charCode, keyCode) {
      if (charCode != -1) {
        let hex = charCode[dartx.toRadixString](16);
        let sb = new core.StringBuffer('U+');
        for (let i = 0; i < 4 - dart.notNull(hex[dartx.length]); i++)
          sb.write('0');
        sb.write(hex);
        return sb.toString();
      } else {
        return html$.KeyCode._convertKeyCodeToKeyName(keyCode);
      }
    }
    get code() {
      return this[_parent$][dartx.code];
    }
    get ctrlKey() {
      return this[_parent$][dartx.ctrlKey];
    }
    get detail() {
      return this[_parent$][dartx.detail];
    }
    get key() {
      return this[_parent$][dartx.key];
    }
    get keyLocation() {
      return this[_parent$][dartx.keyLocation];
    }
    get metaKey() {
      return this[_parent$][dartx.metaKey];
    }
    get shiftKey() {
      return this[_parent$][dartx.shiftKey];
    }
    get sourceDevice() {
      return this[_parent$][dartx.sourceDevice];
    }
    get view() {
      return dart.as(this[_parent$][dartx.view], html$.Window);
    }
    [_initUIEvent](type, canBubble, cancelable, view, detail) {
      dart.throw(new core.UnsupportedError("Cannot initialize a UI Event from a KeyEvent."));
    }
    get [_shadowKeyIdentifier]() {
      return this[_parent$].keyIdentifier;
    }
    get [_charCode]() {
      return this.charCode;
    }
    get [_keyCode]() {
      return this.keyCode;
    }
    get [_which]() {
      return this.which;
    }
    get [_keyIdentifier]() {
      dart.throw(new core.UnsupportedError("keyIdentifier is unsupported."));
    }
    [_initKeyboardEvent](type, canBubble, cancelable, view, keyIdentifier, keyLocation, ctrlKey, altKey, shiftKey, metaKey) {
      dart.throw(new core.UnsupportedError("Cannot initialize a KeyboardEvent from a KeyEvent."));
    }
    getModifierState(keyArgument) {
      return dart.throw(new core.UnimplementedError());
    }
    get location() {
      return dart.throw(new core.UnimplementedError());
    }
    get repeat() {
      return dart.throw(new core.UnimplementedError());
    }
    get [_get_view]() {
      return dart.throw(new core.UnimplementedError());
    }
  };
  dart.defineNamedConstructor(html$.KeyEvent, 'wrap');
  html$.KeyEvent[dart.implements] = () => [html$.KeyboardEvent];
  dart.setSignature(html$.KeyEvent, {
    constructors: () => ({
      wrap: [html$.KeyEvent, [html$.KeyboardEvent]],
      new: [html$.KeyEvent, [core.String], {view: html$.Window, canBubble: core.bool, cancelable: core.bool, keyCode: core.int, charCode: core.int, keyLocation: core.int, ctrlKey: core.bool, altKey: core.bool, shiftKey: core.bool, metaKey: core.bool, currentTarget: html$.EventTarget}]
    }),
    methods: () => ({
      [_initUIEvent]: [dart.void, [core.String, core.bool, core.bool, html$.Window, core.int]],
      [_initKeyboardEvent]: [dart.void, [core.String, core.bool, core.bool, html$.Window, core.String, core.int, core.bool, core.bool, core.bool, core.bool]],
      getModifierState: [core.bool, [core.String]]
    }),
    statics: () => ({
      _makeRecord: [dart.dynamic, []],
      _convertToHexString: [core.String, [core.int, core.int]]
    }),
    names: ['_makeRecord', '_convertToHexString']
  });
  html$.KeyEvent[dart.metadata] = () => [dart.const(new _metadata.Experimental())];
  dart.defineLazy(html$.KeyEvent, {
    get _keyboardEventDispatchRecord() {
      return html$.KeyEvent._makeRecord();
    },
    get keyDownEvent() {
      return new html$._KeyboardEventHandler('keydown');
    },
    set keyDownEvent(_) {},
    get keyUpEvent() {
      return new html$._KeyboardEventHandler('keyup');
    },
    set keyUpEvent(_) {},
    get keyPressEvent() {
      return new html$._KeyboardEventHandler('keypress');
    },
    set keyPressEvent(_) {}
  });
  html$._CustomKeyEventStreamImpl = class _CustomKeyEventStreamImpl extends html$._CustomEventStreamImpl$(html$.KeyEvent) {
    _CustomKeyEventStreamImpl(type) {
      super._CustomEventStreamImpl(type);
    }
    add(event) {
      if (event.type == this[_type]) {
        event.currentTarget[dartx.dispatchEvent](event[_parent$]);
        this[_streamController].add(event);
      }
    }
  };
  html$._CustomKeyEventStreamImpl[dart.implements] = () => [html$.CustomStream$(html$.KeyEvent)];
  dart.setSignature(html$._CustomKeyEventStreamImpl, {
    constructors: () => ({_CustomKeyEventStreamImpl: [html$._CustomKeyEventStreamImpl, [core.String]]}),
    methods: () => ({add: [dart.void, [html$.KeyEvent]]})
  });
  const _subscriptions = Symbol('_subscriptions');
  const _controller$0 = Symbol('_controller');
  html$._StreamPool$ = dart.generic(T => {
    class _StreamPool extends core.Object {
      broadcast() {
        this[_subscriptions] = core.Map$(async.Stream$(T), async.StreamSubscription$(T)).new();
        this[_controller$0] = null;
        this[_controller$0] = async.StreamController$(T).broadcast({sync: true, onCancel: dart.bind(this, 'close')});
      }
      get stream() {
        return this[_controller$0].stream;
      }
      add(stream) {
        dart.as(stream, async.Stream$(T));
        if (dart.notNull(this[_subscriptions][dartx.containsKey](stream))) return;
        this[_subscriptions][dartx.set](stream, stream.listen(dart.bind(this[_controller$0], 'add'), {onError: dart.bind(this[_controller$0], 'addError'), onDone: dart.fn(() => this.remove(stream), dart.void, [])}));
      }
      remove(stream) {
        dart.as(stream, async.Stream$(T));
        let subscription = this[_subscriptions][dartx.remove](stream);
        if (subscription != null) subscription.cancel();
      }
      close() {
        for (let subscription of this[_subscriptions][dartx.values]) {
          subscription.cancel();
        }
        this[_subscriptions][dartx.clear]();
        this[_controller$0].close();
      }
    }
    dart.defineNamedConstructor(_StreamPool, 'broadcast');
    dart.setSignature(_StreamPool, {
      constructors: () => ({broadcast: [html$._StreamPool$(T), []]}),
      methods: () => ({
        add: [dart.void, [async.Stream$(T)]],
        remove: [dart.void, [async.Stream$(T)]],
        close: [dart.void, []]
      })
    });
    return _StreamPool;
  });
  html$._StreamPool = html$._StreamPool$();
  const _eventTypeGetter = Symbol('_eventTypeGetter');
  html$._CustomEventStreamProvider$ = dart.generic(T => {
    class _CustomEventStreamProvider extends core.Object {
      _CustomEventStreamProvider(eventTypeGetter) {
        this[_eventTypeGetter] = eventTypeGetter;
      }
      forTarget(e, opts) {
        let useCapture = opts && 'useCapture' in opts ? opts.useCapture : false;
        return new (html$._EventStream$(T))(e, dart.as(dart.dcall(this[_eventTypeGetter], e), core.String), useCapture);
      }
      forElement(e, opts) {
        let useCapture = opts && 'useCapture' in opts ? opts.useCapture : false;
        return new (html$._ElementEventStreamImpl$(T))(e, dart.dcall(this[_eventTypeGetter], e), useCapture);
      }
      [_forElementList](e, opts) {
        let useCapture = opts && 'useCapture' in opts ? opts.useCapture : false;
        return new (html$._ElementListEventStreamImpl$(T))(e, dart.as(dart.dcall(this[_eventTypeGetter], e), core.String), useCapture);
      }
      getEventType(target) {
        return dart.as(dart.dcall(this[_eventTypeGetter], target), core.String);
      }
      get [_eventType]() {
        return dart.throw(new core.UnsupportedError('Access type through getEventType method.'));
      }
    }
    _CustomEventStreamProvider[dart.implements] = () => [html$.EventStreamProvider$(T)];
    dart.setSignature(_CustomEventStreamProvider, {
      constructors: () => ({_CustomEventStreamProvider: [html$._CustomEventStreamProvider$(T), [dart.dynamic]]}),
      methods: () => ({
        forTarget: [async.Stream$(T), [html$.EventTarget], {useCapture: core.bool}],
        forElement: [html$.ElementStream$(T), [html$.Element], {useCapture: core.bool}],
        [_forElementList]: [html$.ElementStream$(T), [html$.ElementList$(html$.Element)], {useCapture: core.bool}],
        getEventType: [core.String, [html$.EventTarget]]
      })
    });
    return _CustomEventStreamProvider;
  });
  html$._CustomEventStreamProvider = html$._CustomEventStreamProvider$();
  html$._Html5NodeValidator = class _Html5NodeValidator extends core.Object {
    _Html5NodeValidator(opts) {
      let uriPolicy = opts && 'uriPolicy' in opts ? opts.uriPolicy : null;
      this.uriPolicy = uriPolicy != null ? uriPolicy : html$.UriPolicy.new();
      if (dart.notNull(html$._Html5NodeValidator._attributeValidators[dartx.isEmpty])) {
        for (let attr of html$._Html5NodeValidator._standardAttributes) {
          html$._Html5NodeValidator._attributeValidators[dartx.set](attr, html$._Html5NodeValidator._standardAttributeValidator);
        }
        for (let attr of html$._Html5NodeValidator._uriAttributes) {
          html$._Html5NodeValidator._attributeValidators[dartx.set](attr, html$._Html5NodeValidator._uriAttributeValidator);
        }
      }
    }
    allowsElement(element) {
      return html$._Html5NodeValidator._allowedElements.contains(html$.Element._safeTagName(element));
    }
    allowsAttribute(element, attributeName, value) {
      let tagName = html$.Element._safeTagName(element);
      let validator = html$._Html5NodeValidator._attributeValidators[dartx.get](`${tagName}::${attributeName}`);
      if (validator == null) {
        validator = html$._Html5NodeValidator._attributeValidators[dartx.get](`*::${attributeName}`);
      }
      if (validator == null) {
        return false;
      }
      return dart.as(dart.dcall(validator, element, attributeName, value, this), core.bool);
    }
    static _standardAttributeValidator(element, attributeName, value, context) {
      return true;
    }
    static _uriAttributeValidator(element, attributeName, value, context) {
      return context.uriPolicy.allowsUri(value);
    }
  };
  html$._Html5NodeValidator[dart.implements] = () => [html$.NodeValidator];
  dart.setSignature(html$._Html5NodeValidator, {
    constructors: () => ({_Html5NodeValidator: [html$._Html5NodeValidator, [], {uriPolicy: html$.UriPolicy}]}),
    methods: () => ({
      allowsElement: [core.bool, [html$.Element]],
      allowsAttribute: [core.bool, [html$.Element, core.String, core.String]]
    }),
    statics: () => ({
      _standardAttributeValidator: [core.bool, [html$.Element, core.String, core.String, html$._Html5NodeValidator]],
      _uriAttributeValidator: [core.bool, [html$.Element, core.String, core.String, html$._Html5NodeValidator]]
    }),
    names: ['_standardAttributeValidator', '_uriAttributeValidator']
  });
  html$._Html5NodeValidator._standardAttributes = dart.const(dart.list(['*::class', '*::dir', '*::draggable', '*::hidden', '*::id', '*::inert', '*::itemprop', '*::itemref', '*::itemscope', '*::lang', '*::spellcheck', '*::title', '*::translate', 'A::accesskey', 'A::coords', 'A::hreflang', 'A::name', 'A::shape', 'A::tabindex', 'A::target', 'A::type', 'AREA::accesskey', 'AREA::alt', 'AREA::coords', 'AREA::nohref', 'AREA::shape', 'AREA::tabindex', 'AREA::target', 'AUDIO::controls', 'AUDIO::loop', 'AUDIO::mediagroup', 'AUDIO::muted', 'AUDIO::preload', 'BDO::dir', 'BODY::alink', 'BODY::bgcolor', 'BODY::link', 'BODY::text', 'BODY::vlink', 'BR::clear', 'BUTTON::accesskey', 'BUTTON::disabled', 'BUTTON::name', 'BUTTON::tabindex', 'BUTTON::type', 'BUTTON::value', 'CANVAS::height', 'CANVAS::width', 'CAPTION::align', 'COL::align', 'COL::char', 'COL::charoff', 'COL::span', 'COL::valign', 'COL::width', 'COLGROUP::align', 'COLGROUP::char', 'COLGROUP::charoff', 'COLGROUP::span', 'COLGROUP::valign', 'COLGROUP::width', 'COMMAND::checked', 'COMMAND::command', 'COMMAND::disabled', 'COMMAND::label', 'COMMAND::radiogroup', 'COMMAND::type', 'DATA::value', 'DEL::datetime', 'DETAILS::open', 'DIR::compact', 'DIV::align', 'DL::compact', 'FIELDSET::disabled', 'FONT::color', 'FONT::face', 'FONT::size', 'FORM::accept', 'FORM::autocomplete', 'FORM::enctype', 'FORM::method', 'FORM::name', 'FORM::novalidate', 'FORM::target', 'FRAME::name', 'H1::align', 'H2::align', 'H3::align', 'H4::align', 'H5::align', 'H6::align', 'HR::align', 'HR::noshade', 'HR::size', 'HR::width', 'HTML::version', 'IFRAME::align', 'IFRAME::frameborder', 'IFRAME::height', 'IFRAME::marginheight', 'IFRAME::marginwidth', 'IFRAME::width', 'IMG::align', 'IMG::alt', 'IMG::border', 'IMG::height', 'IMG::hspace', 'IMG::ismap', 'IMG::name', 'IMG::usemap', 'IMG::vspace', 'IMG::width', 'INPUT::accept', 'INPUT::accesskey', 'INPUT::align', 'INPUT::alt', 'INPUT::autocomplete', 'INPUT::autofocus', 'INPUT::checked', 'INPUT::disabled', 'INPUT::inputmode', 'INPUT::ismap', 'INPUT::list', 'INPUT::max', 'INPUT::maxlength', 'INPUT::min', 'INPUT::multiple', 'INPUT::name', 'INPUT::placeholder', 'INPUT::readonly', 'INPUT::required', 'INPUT::size', 'INPUT::step', 'INPUT::tabindex', 'INPUT::type', 'INPUT::usemap', 'INPUT::value', 'INS::datetime', 'KEYGEN::disabled', 'KEYGEN::keytype', 'KEYGEN::name', 'LABEL::accesskey', 'LABEL::for', 'LEGEND::accesskey', 'LEGEND::align', 'LI::type', 'LI::value', 'LINK::sizes', 'MAP::name', 'MENU::compact', 'MENU::label', 'MENU::type', 'METER::high', 'METER::low', 'METER::max', 'METER::min', 'METER::value', 'OBJECT::typemustmatch', 'OL::compact', 'OL::reversed', 'OL::start', 'OL::type', 'OPTGROUP::disabled', 'OPTGROUP::label', 'OPTION::disabled', 'OPTION::label', 'OPTION::selected', 'OPTION::value', 'OUTPUT::for', 'OUTPUT::name', 'P::align', 'PRE::width', 'PROGRESS::max', 'PROGRESS::min', 'PROGRESS::value', 'SELECT::autocomplete', 'SELECT::disabled', 'SELECT::multiple', 'SELECT::name', 'SELECT::required', 'SELECT::size', 'SELECT::tabindex', 'SOURCE::type', 'TABLE::align', 'TABLE::bgcolor', 'TABLE::border', 'TABLE::cellpadding', 'TABLE::cellspacing', 'TABLE::frame', 'TABLE::rules', 'TABLE::summary', 'TABLE::width', 'TBODY::align', 'TBODY::char', 'TBODY::charoff', 'TBODY::valign', 'TD::abbr', 'TD::align', 'TD::axis', 'TD::bgcolor', 'TD::char', 'TD::charoff', 'TD::colspan', 'TD::headers', 'TD::height', 'TD::nowrap', 'TD::rowspan', 'TD::scope', 'TD::valign', 'TD::width', 'TEXTAREA::accesskey', 'TEXTAREA::autocomplete', 'TEXTAREA::cols', 'TEXTAREA::disabled', 'TEXTAREA::inputmode', 'TEXTAREA::name', 'TEXTAREA::placeholder', 'TEXTAREA::readonly', 'TEXTAREA::required', 'TEXTAREA::rows', 'TEXTAREA::tabindex', 'TEXTAREA::wrap', 'TFOOT::align', 'TFOOT::char', 'TFOOT::charoff', 'TFOOT::valign', 'TH::abbr', 'TH::align', 'TH::axis', 'TH::bgcolor', 'TH::char', 'TH::charoff', 'TH::colspan', 'TH::headers', 'TH::height', 'TH::nowrap', 'TH::rowspan', 'TH::scope', 'TH::valign', 'TH::width', 'THEAD::align', 'THEAD::char', 'THEAD::charoff', 'THEAD::valign', 'TR::align', 'TR::bgcolor', 'TR::char', 'TR::charoff', 'TR::valign', 'TRACK::default', 'TRACK::kind', 'TRACK::label', 'TRACK::srclang', 'UL::compact', 'UL::type', 'VIDEO::controls', 'VIDEO::height', 'VIDEO::loop', 'VIDEO::mediagroup', 'VIDEO::muted', 'VIDEO::preload', 'VIDEO::width'], core.String));
  html$._Html5NodeValidator._uriAttributes = dart.const(dart.list(['A::href', 'AREA::href', 'BLOCKQUOTE::cite', 'BODY::background', 'COMMAND::icon', 'DEL::cite', 'FORM::action', 'IMG::src', 'INPUT::src', 'INS::cite', 'Q::cite', 'VIDEO::poster'], core.String));
  dart.defineLazy(html$._Html5NodeValidator, {
    get _allowedElements() {
      return core.Set$(core.String).from(dart.list(['A', 'ABBR', 'ACRONYM', 'ADDRESS', 'AREA', 'ARTICLE', 'ASIDE', 'AUDIO', 'B', 'BDI', 'BDO', 'BIG', 'BLOCKQUOTE', 'BR', 'BUTTON', 'CANVAS', 'CAPTION', 'CENTER', 'CITE', 'CODE', 'COL', 'COLGROUP', 'COMMAND', 'DATA', 'DATALIST', 'DD', 'DEL', 'DETAILS', 'DFN', 'DIR', 'DIV', 'DL', 'DT', 'EM', 'FIELDSET', 'FIGCAPTION', 'FIGURE', 'FONT', 'FOOTER', 'FORM', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'HEADER', 'HGROUP', 'HR', 'I', 'IFRAME', 'IMG', 'INPUT', 'INS', 'KBD', 'LABEL', 'LEGEND', 'LI', 'MAP', 'MARK', 'MENU', 'METER', 'NAV', 'NOBR', 'OL', 'OPTGROUP', 'OPTION', 'OUTPUT', 'P', 'PRE', 'PROGRESS', 'Q', 'S', 'SAMP', 'SECTION', 'SELECT', 'SMALL', 'SOURCE', 'SPAN', 'STRIKE', 'STRONG', 'SUB', 'SUMMARY', 'SUP', 'TABLE', 'TBODY', 'TD', 'TEXTAREA', 'TFOOT', 'TH', 'THEAD', 'TIME', 'TR', 'TRACK', 'TT', 'U', 'UL', 'VAR', 'VIDEO', 'WBR'], core.String));
    },
    get _attributeValidators() {
      return dart.map();
    }
  });
  html$.KeyCode = class KeyCode extends core.Object {
    static isCharacterKey(keyCode) {
      if (dart.notNull(keyCode) >= dart.notNull(html$.KeyCode.ZERO) && dart.notNull(keyCode) <= dart.notNull(html$.KeyCode.NINE) || dart.notNull(keyCode) >= dart.notNull(html$.KeyCode.NUM_ZERO) && dart.notNull(keyCode) <= dart.notNull(html$.KeyCode.NUM_MULTIPLY) || dart.notNull(keyCode) >= dart.notNull(html$.KeyCode.A) && dart.notNull(keyCode) <= dart.notNull(html$.KeyCode.Z)) {
        return true;
      }
      if (dart.notNull(html_common.Device.isWebKit) && keyCode == 0) {
        return true;
      }
      return keyCode == html$.KeyCode.SPACE || keyCode == html$.KeyCode.QUESTION_MARK || keyCode == html$.KeyCode.NUM_PLUS || keyCode == html$.KeyCode.NUM_MINUS || keyCode == html$.KeyCode.NUM_PERIOD || keyCode == html$.KeyCode.NUM_DIVISION || keyCode == html$.KeyCode.SEMICOLON || keyCode == html$.KeyCode.FF_SEMICOLON || keyCode == html$.KeyCode.DASH || keyCode == html$.KeyCode.EQUALS || keyCode == html$.KeyCode.FF_EQUALS || keyCode == html$.KeyCode.COMMA || keyCode == html$.KeyCode.PERIOD || keyCode == html$.KeyCode.SLASH || keyCode == html$.KeyCode.APOSTROPHE || keyCode == html$.KeyCode.SINGLE_QUOTE || keyCode == html$.KeyCode.OPEN_SQUARE_BRACKET || keyCode == html$.KeyCode.BACKSLASH || keyCode == html$.KeyCode.CLOSE_SQUARE_BRACKET;
    }
    static _convertKeyCodeToKeyName(keyCode) {
      switch (keyCode) {
        case html$.KeyCode.ALT:
        {
          return html$._KeyName.ALT;
        }
        case html$.KeyCode.BACKSPACE:
        {
          return html$._KeyName.BACKSPACE;
        }
        case html$.KeyCode.CAPS_LOCK:
        {
          return html$._KeyName.CAPS_LOCK;
        }
        case html$.KeyCode.CTRL:
        {
          return html$._KeyName.CONTROL;
        }
        case html$.KeyCode.DELETE:
        {
          return html$._KeyName.DEL;
        }
        case html$.KeyCode.DOWN:
        {
          return html$._KeyName.DOWN;
        }
        case html$.KeyCode.END:
        {
          return html$._KeyName.END;
        }
        case html$.KeyCode.ENTER:
        {
          return html$._KeyName.ENTER;
        }
        case html$.KeyCode.ESC:
        {
          return html$._KeyName.ESC;
        }
        case html$.KeyCode.F1:
        {
          return html$._KeyName.F1;
        }
        case html$.KeyCode.F2:
        {
          return html$._KeyName.F2;
        }
        case html$.KeyCode.F3:
        {
          return html$._KeyName.F3;
        }
        case html$.KeyCode.F4:
        {
          return html$._KeyName.F4;
        }
        case html$.KeyCode.F5:
        {
          return html$._KeyName.F5;
        }
        case html$.KeyCode.F6:
        {
          return html$._KeyName.F6;
        }
        case html$.KeyCode.F7:
        {
          return html$._KeyName.F7;
        }
        case html$.KeyCode.F8:
        {
          return html$._KeyName.F8;
        }
        case html$.KeyCode.F9:
        {
          return html$._KeyName.F9;
        }
        case html$.KeyCode.F10:
        {
          return html$._KeyName.F10;
        }
        case html$.KeyCode.F11:
        {
          return html$._KeyName.F11;
        }
        case html$.KeyCode.F12:
        {
          return html$._KeyName.F12;
        }
        case html$.KeyCode.HOME:
        {
          return html$._KeyName.HOME;
        }
        case html$.KeyCode.INSERT:
        {
          return html$._KeyName.INSERT;
        }
        case html$.KeyCode.LEFT:
        {
          return html$._KeyName.LEFT;
        }
        case html$.KeyCode.META:
        {
          return html$._KeyName.META;
        }
        case html$.KeyCode.NUMLOCK:
        {
          return html$._KeyName.NUM_LOCK;
        }
        case html$.KeyCode.PAGE_DOWN:
        {
          return html$._KeyName.PAGE_DOWN;
        }
        case html$.KeyCode.PAGE_UP:
        {
          return html$._KeyName.PAGE_UP;
        }
        case html$.KeyCode.PAUSE:
        {
          return html$._KeyName.PAUSE;
        }
        case html$.KeyCode.PRINT_SCREEN:
        {
          return html$._KeyName.PRINT_SCREEN;
        }
        case html$.KeyCode.RIGHT:
        {
          return html$._KeyName.RIGHT;
        }
        case html$.KeyCode.SCROLL_LOCK:
        {
          return html$._KeyName.SCROLL;
        }
        case html$.KeyCode.SHIFT:
        {
          return html$._KeyName.SHIFT;
        }
        case html$.KeyCode.SPACE:
        {
          return html$._KeyName.SPACEBAR;
        }
        case html$.KeyCode.TAB:
        {
          return html$._KeyName.TAB;
        }
        case html$.KeyCode.UP:
        {
          return html$._KeyName.UP;
        }
        case html$.KeyCode.WIN_IME:
        case html$.KeyCode.WIN_KEY:
        case html$.KeyCode.WIN_KEY_LEFT:
        case html$.KeyCode.WIN_KEY_RIGHT:
        {
          return html$._KeyName.WIN;
        }
        default:
        {
          return html$._KeyName.UNIDENTIFIED;
        }
      }
      return html$._KeyName.UNIDENTIFIED;
    }
  };
  dart.setSignature(html$.KeyCode, {
    statics: () => ({
      isCharacterKey: [core.bool, [core.int]],
      _convertKeyCodeToKeyName: [core.String, [core.int]]
    }),
    names: ['isCharacterKey', '_convertKeyCodeToKeyName']
  });
  html$.KeyCode.WIN_KEY_FF_LINUX = 0;
  html$.KeyCode.MAC_ENTER = 3;
  html$.KeyCode.BACKSPACE = 8;
  html$.KeyCode.TAB = 9;
  html$.KeyCode.NUM_CENTER = 12;
  html$.KeyCode.ENTER = 13;
  html$.KeyCode.SHIFT = 16;
  html$.KeyCode.CTRL = 17;
  html$.KeyCode.ALT = 18;
  html$.KeyCode.PAUSE = 19;
  html$.KeyCode.CAPS_LOCK = 20;
  html$.KeyCode.ESC = 27;
  html$.KeyCode.SPACE = 32;
  html$.KeyCode.PAGE_UP = 33;
  html$.KeyCode.PAGE_DOWN = 34;
  html$.KeyCode.END = 35;
  html$.KeyCode.HOME = 36;
  html$.KeyCode.LEFT = 37;
  html$.KeyCode.UP = 38;
  html$.KeyCode.RIGHT = 39;
  html$.KeyCode.DOWN = 40;
  html$.KeyCode.NUM_NORTH_EAST = 33;
  html$.KeyCode.NUM_SOUTH_EAST = 34;
  html$.KeyCode.NUM_SOUTH_WEST = 35;
  html$.KeyCode.NUM_NORTH_WEST = 36;
  html$.KeyCode.NUM_WEST = 37;
  html$.KeyCode.NUM_NORTH = 38;
  html$.KeyCode.NUM_EAST = 39;
  html$.KeyCode.NUM_SOUTH = 40;
  html$.KeyCode.PRINT_SCREEN = 44;
  html$.KeyCode.INSERT = 45;
  html$.KeyCode.NUM_INSERT = 45;
  html$.KeyCode.DELETE = 46;
  html$.KeyCode.NUM_DELETE = 46;
  html$.KeyCode.ZERO = 48;
  html$.KeyCode.ONE = 49;
  html$.KeyCode.TWO = 50;
  html$.KeyCode.THREE = 51;
  html$.KeyCode.FOUR = 52;
  html$.KeyCode.FIVE = 53;
  html$.KeyCode.SIX = 54;
  html$.KeyCode.SEVEN = 55;
  html$.KeyCode.EIGHT = 56;
  html$.KeyCode.NINE = 57;
  html$.KeyCode.FF_SEMICOLON = 59;
  html$.KeyCode.FF_EQUALS = 61;
  html$.KeyCode.QUESTION_MARK = 63;
  html$.KeyCode.A = 65;
  html$.KeyCode.B = 66;
  html$.KeyCode.C = 67;
  html$.KeyCode.D = 68;
  html$.KeyCode.E = 69;
  html$.KeyCode.F = 70;
  html$.KeyCode.G = 71;
  html$.KeyCode.H = 72;
  html$.KeyCode.I = 73;
  html$.KeyCode.J = 74;
  html$.KeyCode.K = 75;
  html$.KeyCode.L = 76;
  html$.KeyCode.M = 77;
  html$.KeyCode.N = 78;
  html$.KeyCode.O = 79;
  html$.KeyCode.P = 80;
  html$.KeyCode.Q = 81;
  html$.KeyCode.R = 82;
  html$.KeyCode.S = 83;
  html$.KeyCode.T = 84;
  html$.KeyCode.U = 85;
  html$.KeyCode.V = 86;
  html$.KeyCode.W = 87;
  html$.KeyCode.X = 88;
  html$.KeyCode.Y = 89;
  html$.KeyCode.Z = 90;
  html$.KeyCode.META = 91;
  html$.KeyCode.WIN_KEY_LEFT = 91;
  html$.KeyCode.WIN_KEY_RIGHT = 92;
  html$.KeyCode.CONTEXT_MENU = 93;
  html$.KeyCode.NUM_ZERO = 96;
  html$.KeyCode.NUM_ONE = 97;
  html$.KeyCode.NUM_TWO = 98;
  html$.KeyCode.NUM_THREE = 99;
  html$.KeyCode.NUM_FOUR = 100;
  html$.KeyCode.NUM_FIVE = 101;
  html$.KeyCode.NUM_SIX = 102;
  html$.KeyCode.NUM_SEVEN = 103;
  html$.KeyCode.NUM_EIGHT = 104;
  html$.KeyCode.NUM_NINE = 105;
  html$.KeyCode.NUM_MULTIPLY = 106;
  html$.KeyCode.NUM_PLUS = 107;
  html$.KeyCode.NUM_MINUS = 109;
  html$.KeyCode.NUM_PERIOD = 110;
  html$.KeyCode.NUM_DIVISION = 111;
  html$.KeyCode.F1 = 112;
  html$.KeyCode.F2 = 113;
  html$.KeyCode.F3 = 114;
  html$.KeyCode.F4 = 115;
  html$.KeyCode.F5 = 116;
  html$.KeyCode.F6 = 117;
  html$.KeyCode.F7 = 118;
  html$.KeyCode.F8 = 119;
  html$.KeyCode.F9 = 120;
  html$.KeyCode.F10 = 121;
  html$.KeyCode.F11 = 122;
  html$.KeyCode.F12 = 123;
  html$.KeyCode.NUMLOCK = 144;
  html$.KeyCode.SCROLL_LOCK = 145;
  html$.KeyCode.FIRST_MEDIA_KEY = 166;
  html$.KeyCode.LAST_MEDIA_KEY = 183;
  html$.KeyCode.SEMICOLON = 186;
  html$.KeyCode.DASH = 189;
  html$.KeyCode.EQUALS = 187;
  html$.KeyCode.COMMA = 188;
  html$.KeyCode.PERIOD = 190;
  html$.KeyCode.SLASH = 191;
  html$.KeyCode.APOSTROPHE = 192;
  html$.KeyCode.TILDE = 192;
  html$.KeyCode.SINGLE_QUOTE = 222;
  html$.KeyCode.OPEN_SQUARE_BRACKET = 219;
  html$.KeyCode.BACKSLASH = 220;
  html$.KeyCode.CLOSE_SQUARE_BRACKET = 221;
  html$.KeyCode.WIN_KEY = 224;
  html$.KeyCode.MAC_FF_META = 224;
  html$.KeyCode.WIN_IME = 229;
  html$.KeyCode.UNKNOWN = -1;
  html$.KeyLocation = class KeyLocation extends core.Object {};
  html$.KeyLocation.STANDARD = 0;
  html$.KeyLocation.LEFT = 1;
  html$.KeyLocation.RIGHT = 2;
  html$.KeyLocation.NUMPAD = 3;
  html$.KeyLocation.MOBILE = 4;
  html$.KeyLocation.JOYSTICK = 5;
  html$._KeyName = class _KeyName extends core.Object {};
  html$._KeyName.ACCEPT = "Accept";
  html$._KeyName.ADD = "Add";
  html$._KeyName.AGAIN = "Again";
  html$._KeyName.ALL_CANDIDATES = "AllCandidates";
  html$._KeyName.ALPHANUMERIC = "Alphanumeric";
  html$._KeyName.ALT = "Alt";
  html$._KeyName.ALT_GRAPH = "AltGraph";
  html$._KeyName.APPS = "Apps";
  html$._KeyName.ATTN = "Attn";
  html$._KeyName.BROWSER_BACK = "BrowserBack";
  html$._KeyName.BROWSER_FAVORTIES = "BrowserFavorites";
  html$._KeyName.BROWSER_FORWARD = "BrowserForward";
  html$._KeyName.BROWSER_NAME = "BrowserHome";
  html$._KeyName.BROWSER_REFRESH = "BrowserRefresh";
  html$._KeyName.BROWSER_SEARCH = "BrowserSearch";
  html$._KeyName.BROWSER_STOP = "BrowserStop";
  html$._KeyName.CAMERA = "Camera";
  html$._KeyName.CAPS_LOCK = "CapsLock";
  html$._KeyName.CLEAR = "Clear";
  html$._KeyName.CODE_INPUT = "CodeInput";
  html$._KeyName.COMPOSE = "Compose";
  html$._KeyName.CONTROL = "Control";
  html$._KeyName.CRSEL = "Crsel";
  html$._KeyName.CONVERT = "Convert";
  html$._KeyName.COPY = "Copy";
  html$._KeyName.CUT = "Cut";
  html$._KeyName.DECIMAL = "Decimal";
  html$._KeyName.DIVIDE = "Divide";
  html$._KeyName.DOWN = "Down";
  html$._KeyName.DOWN_LEFT = "DownLeft";
  html$._KeyName.DOWN_RIGHT = "DownRight";
  html$._KeyName.EJECT = "Eject";
  html$._KeyName.END = "End";
  html$._KeyName.ENTER = "Enter";
  html$._KeyName.ERASE_EOF = "EraseEof";
  html$._KeyName.EXECUTE = "Execute";
  html$._KeyName.EXSEL = "Exsel";
  html$._KeyName.FN = "Fn";
  html$._KeyName.F1 = "F1";
  html$._KeyName.F2 = "F2";
  html$._KeyName.F3 = "F3";
  html$._KeyName.F4 = "F4";
  html$._KeyName.F5 = "F5";
  html$._KeyName.F6 = "F6";
  html$._KeyName.F7 = "F7";
  html$._KeyName.F8 = "F8";
  html$._KeyName.F9 = "F9";
  html$._KeyName.F10 = "F10";
  html$._KeyName.F11 = "F11";
  html$._KeyName.F12 = "F12";
  html$._KeyName.F13 = "F13";
  html$._KeyName.F14 = "F14";
  html$._KeyName.F15 = "F15";
  html$._KeyName.F16 = "F16";
  html$._KeyName.F17 = "F17";
  html$._KeyName.F18 = "F18";
  html$._KeyName.F19 = "F19";
  html$._KeyName.F20 = "F20";
  html$._KeyName.F21 = "F21";
  html$._KeyName.F22 = "F22";
  html$._KeyName.F23 = "F23";
  html$._KeyName.F24 = "F24";
  html$._KeyName.FINAL_MODE = "FinalMode";
  html$._KeyName.FIND = "Find";
  html$._KeyName.FULL_WIDTH = "FullWidth";
  html$._KeyName.HALF_WIDTH = "HalfWidth";
  html$._KeyName.HANGUL_MODE = "HangulMode";
  html$._KeyName.HANJA_MODE = "HanjaMode";
  html$._KeyName.HELP = "Help";
  html$._KeyName.HIRAGANA = "Hiragana";
  html$._KeyName.HOME = "Home";
  html$._KeyName.INSERT = "Insert";
  html$._KeyName.JAPANESE_HIRAGANA = "JapaneseHiragana";
  html$._KeyName.JAPANESE_KATAKANA = "JapaneseKatakana";
  html$._KeyName.JAPANESE_ROMAJI = "JapaneseRomaji";
  html$._KeyName.JUNJA_MODE = "JunjaMode";
  html$._KeyName.KANA_MODE = "KanaMode";
  html$._KeyName.KANJI_MODE = "KanjiMode";
  html$._KeyName.KATAKANA = "Katakana";
  html$._KeyName.LAUNCH_APPLICATION_1 = "LaunchApplication1";
  html$._KeyName.LAUNCH_APPLICATION_2 = "LaunchApplication2";
  html$._KeyName.LAUNCH_MAIL = "LaunchMail";
  html$._KeyName.LEFT = "Left";
  html$._KeyName.MENU = "Menu";
  html$._KeyName.META = "Meta";
  html$._KeyName.MEDIA_NEXT_TRACK = "MediaNextTrack";
  html$._KeyName.MEDIA_PAUSE_PLAY = "MediaPlayPause";
  html$._KeyName.MEDIA_PREVIOUS_TRACK = "MediaPreviousTrack";
  html$._KeyName.MEDIA_STOP = "MediaStop";
  html$._KeyName.MODE_CHANGE = "ModeChange";
  html$._KeyName.NEXT_CANDIDATE = "NextCandidate";
  html$._KeyName.NON_CONVERT = "Nonconvert";
  html$._KeyName.NUM_LOCK = "NumLock";
  html$._KeyName.PAGE_DOWN = "PageDown";
  html$._KeyName.PAGE_UP = "PageUp";
  html$._KeyName.PASTE = "Paste";
  html$._KeyName.PAUSE = "Pause";
  html$._KeyName.PLAY = "Play";
  html$._KeyName.POWER = "Power";
  html$._KeyName.PREVIOUS_CANDIDATE = "PreviousCandidate";
  html$._KeyName.PRINT_SCREEN = "PrintScreen";
  html$._KeyName.PROCESS = "Process";
  html$._KeyName.PROPS = "Props";
  html$._KeyName.RIGHT = "Right";
  html$._KeyName.ROMAN_CHARACTERS = "RomanCharacters";
  html$._KeyName.SCROLL = "Scroll";
  html$._KeyName.SELECT = "Select";
  html$._KeyName.SELECT_MEDIA = "SelectMedia";
  html$._KeyName.SEPARATOR = "Separator";
  html$._KeyName.SHIFT = "Shift";
  html$._KeyName.SOFT_1 = "Soft1";
  html$._KeyName.SOFT_2 = "Soft2";
  html$._KeyName.SOFT_3 = "Soft3";
  html$._KeyName.SOFT_4 = "Soft4";
  html$._KeyName.STOP = "Stop";
  html$._KeyName.SUBTRACT = "Subtract";
  html$._KeyName.SYMBOL_LOCK = "SymbolLock";
  html$._KeyName.UP = "Up";
  html$._KeyName.UP_LEFT = "UpLeft";
  html$._KeyName.UP_RIGHT = "UpRight";
  html$._KeyName.UNDO = "Undo";
  html$._KeyName.VOLUME_DOWN = "VolumeDown";
  html$._KeyName.VOLUMN_MUTE = "VolumeMute";
  html$._KeyName.VOLUMN_UP = "VolumeUp";
  html$._KeyName.WIN = "Win";
  html$._KeyName.ZOOM = "Zoom";
  html$._KeyName.BACKSPACE = "Backspace";
  html$._KeyName.TAB = "Tab";
  html$._KeyName.CANCEL = "Cancel";
  html$._KeyName.ESC = "Esc";
  html$._KeyName.SPACEBAR = "Spacebar";
  html$._KeyName.DEL = "Del";
  html$._KeyName.DEAD_GRAVE = "DeadGrave";
  html$._KeyName.DEAD_EACUTE = "DeadEacute";
  html$._KeyName.DEAD_CIRCUMFLEX = "DeadCircumflex";
  html$._KeyName.DEAD_TILDE = "DeadTilde";
  html$._KeyName.DEAD_MACRON = "DeadMacron";
  html$._KeyName.DEAD_BREVE = "DeadBreve";
  html$._KeyName.DEAD_ABOVE_DOT = "DeadAboveDot";
  html$._KeyName.DEAD_UMLAUT = "DeadUmlaut";
  html$._KeyName.DEAD_ABOVE_RING = "DeadAboveRing";
  html$._KeyName.DEAD_DOUBLEACUTE = "DeadDoubleacute";
  html$._KeyName.DEAD_CARON = "DeadCaron";
  html$._KeyName.DEAD_CEDILLA = "DeadCedilla";
  html$._KeyName.DEAD_OGONEK = "DeadOgonek";
  html$._KeyName.DEAD_IOTA = "DeadIota";
  html$._KeyName.DEAD_VOICED_SOUND = "DeadVoicedSound";
  html$._KeyName.DEC_SEMIVOICED_SOUND = "DeadSemivoicedSound";
  html$._KeyName.UNIDENTIFIED = "Unidentified";
  const _stream$ = Symbol('_stream');
  const _keyDownList = Symbol('_keyDownList');
  const _capsLockOn = Symbol('_capsLockOn');
  const _determineKeyCodeForKeypress = Symbol('_determineKeyCodeForKeypress');
  const _findCharCodeKeyDown = Symbol('_findCharCodeKeyDown');
  const _firesKeyPressEvent = Symbol('_firesKeyPressEvent');
  const _normalizeKeyCodes = Symbol('_normalizeKeyCodes');
  html$._KeyboardEventHandler = class _KeyboardEventHandler extends html$.EventStreamProvider$(html$.KeyEvent) {
    forTarget(e, opts) {
      let useCapture = opts && 'useCapture' in opts ? opts.useCapture : false;
      let handler = new html$._KeyboardEventHandler.initializeAllEventListeners(this[_type], e);
      return handler[_stream$];
    }
    _KeyboardEventHandler(type) {
      this[_keyDownList] = dart.list([], html$.KeyEvent);
      this[_type] = type;
      this[_stream$] = new html$._CustomKeyEventStreamImpl('event');
      this[_target$] = null;
      super.EventStreamProvider(html$._KeyboardEventHandler._EVENT_TYPE);
    }
    initializeAllEventListeners(type, target) {
      this[_keyDownList] = dart.list([], html$.KeyEvent);
      this[_type] = type;
      this[_target$] = target;
      this[_stream$] = null;
      super.EventStreamProvider(html$._KeyboardEventHandler._EVENT_TYPE);
      html$.Element.keyDownEvent.forTarget(this[_target$], {useCapture: true}).listen(dart.bind(this, 'processKeyDown'));
      html$.Element.keyPressEvent.forTarget(this[_target$], {useCapture: true}).listen(dart.bind(this, 'processKeyPress'));
      html$.Element.keyUpEvent.forTarget(this[_target$], {useCapture: true}).listen(dart.bind(this, 'processKeyUp'));
      this[_stream$] = new html$._CustomKeyEventStreamImpl(this[_type]);
    }
    get [_capsLockOn]() {
      return this[_keyDownList][dartx.any](dart.fn(element => element.keyCode == html$.KeyCode.CAPS_LOCK, core.bool, [html$.KeyEvent]));
    }
    [_determineKeyCodeForKeypress](event) {
      for (let prevEvent of this[_keyDownList]) {
        if (prevEvent[_shadowCharCode] == event[dartx.charCode]) {
          return prevEvent.keyCode;
        }
        if ((dart.notNull(event[dartx.shiftKey]) || dart.notNull(this[_capsLockOn])) && dart.notNull(event[dartx.charCode]) >= dart.notNull("A"[dartx.codeUnits][dartx.get](0)) && dart.notNull(event[dartx.charCode]) <= dart.notNull("Z"[dartx.codeUnits][dartx.get](0)) && dart.notNull(event[dartx.charCode]) + dart.notNull(html$._KeyboardEventHandler._ROMAN_ALPHABET_OFFSET) == prevEvent[_shadowCharCode]) {
          return prevEvent.keyCode;
        }
      }
      return html$.KeyCode.UNKNOWN;
    }
    [_findCharCodeKeyDown](event) {
      if (event[dartx.keyLocation] == 3) {
        switch (event[dartx.keyCode]) {
          case html$.KeyCode.NUM_ZERO:
          {
            return html$.KeyCode.ZERO;
          }
          case html$.KeyCode.NUM_ONE:
          {
            return html$.KeyCode.ONE;
          }
          case html$.KeyCode.NUM_TWO:
          {
            return html$.KeyCode.TWO;
          }
          case html$.KeyCode.NUM_THREE:
          {
            return html$.KeyCode.THREE;
          }
          case html$.KeyCode.NUM_FOUR:
          {
            return html$.KeyCode.FOUR;
          }
          case html$.KeyCode.NUM_FIVE:
          {
            return html$.KeyCode.FIVE;
          }
          case html$.KeyCode.NUM_SIX:
          {
            return html$.KeyCode.SIX;
          }
          case html$.KeyCode.NUM_SEVEN:
          {
            return html$.KeyCode.SEVEN;
          }
          case html$.KeyCode.NUM_EIGHT:
          {
            return html$.KeyCode.EIGHT;
          }
          case html$.KeyCode.NUM_NINE:
          {
            return html$.KeyCode.NINE;
          }
          case html$.KeyCode.NUM_MULTIPLY:
          {
            return 42;
          }
          case html$.KeyCode.NUM_PLUS:
          {
            return 43;
          }
          case html$.KeyCode.NUM_MINUS:
          {
            return 45;
          }
          case html$.KeyCode.NUM_PERIOD:
          {
            return 46;
          }
          case html$.KeyCode.NUM_DIVISION:
          {
            return 47;
          }
        }
      } else if (dart.notNull(event[dartx.keyCode]) >= 65 && dart.notNull(event[dartx.keyCode]) <= 90) {
        return dart.notNull(event[dartx.keyCode]) + dart.notNull(html$._KeyboardEventHandler._ROMAN_ALPHABET_OFFSET);
      }
      switch (event[dartx.keyCode]) {
        case html$.KeyCode.SEMICOLON:
        {
          return html$.KeyCode.FF_SEMICOLON;
        }
        case html$.KeyCode.EQUALS:
        {
          return html$.KeyCode.FF_EQUALS;
        }
        case html$.KeyCode.COMMA:
        {
          return 44;
        }
        case html$.KeyCode.DASH:
        {
          return 45;
        }
        case html$.KeyCode.PERIOD:
        {
          return 46;
        }
        case html$.KeyCode.SLASH:
        {
          return 47;
        }
        case html$.KeyCode.APOSTROPHE:
        {
          return 96;
        }
        case html$.KeyCode.OPEN_SQUARE_BRACKET:
        {
          return 91;
        }
        case html$.KeyCode.BACKSLASH:
        {
          return 92;
        }
        case html$.KeyCode.CLOSE_SQUARE_BRACKET:
        {
          return 93;
        }
        case html$.KeyCode.SINGLE_QUOTE:
        {
          return 39;
        }
      }
      return event[dartx.keyCode];
    }
    [_firesKeyPressEvent](event) {
      if (!dart.notNull(html_common.Device.isIE) && !dart.notNull(html_common.Device.isWebKit)) {
        return true;
      }
      if (dart.notNull(html_common.Device.userAgent[dartx.contains]('Mac')) && dart.notNull(event.altKey)) {
        return html$.KeyCode.isCharacterKey(event.keyCode);
      }
      if (dart.notNull(event.altKey) && !dart.notNull(event.ctrlKey)) {
        return false;
      }
      if (!dart.notNull(event.shiftKey) && (this[_keyDownList][dartx.last].keyCode == html$.KeyCode.CTRL || this[_keyDownList][dartx.last].keyCode == html$.KeyCode.ALT || dart.notNull(html_common.Device.userAgent[dartx.contains]('Mac')) && this[_keyDownList][dartx.last].keyCode == html$.KeyCode.META)) {
        return false;
      }
      if (dart.notNull(html_common.Device.isWebKit) && dart.notNull(event.ctrlKey) && dart.notNull(event.shiftKey) && (event.keyCode == html$.KeyCode.BACKSLASH || event.keyCode == html$.KeyCode.OPEN_SQUARE_BRACKET || event.keyCode == html$.KeyCode.CLOSE_SQUARE_BRACKET || event.keyCode == html$.KeyCode.TILDE || event.keyCode == html$.KeyCode.SEMICOLON || event.keyCode == html$.KeyCode.DASH || event.keyCode == html$.KeyCode.EQUALS || event.keyCode == html$.KeyCode.COMMA || event.keyCode == html$.KeyCode.PERIOD || event.keyCode == html$.KeyCode.SLASH || event.keyCode == html$.KeyCode.APOSTROPHE || event.keyCode == html$.KeyCode.SINGLE_QUOTE)) {
        return false;
      }
      switch (event.keyCode) {
        case html$.KeyCode.ENTER:
        {
          return !dart.notNull(html_common.Device.isIE);
        }
        case html$.KeyCode.ESC:
        {
          return !dart.notNull(html_common.Device.isWebKit);
        }
      }
      return html$.KeyCode.isCharacterKey(event.keyCode);
    }
    [_normalizeKeyCodes](event) {
      if (dart.notNull(html_common.Device.isFirefox)) {
        switch (event[dartx.keyCode]) {
          case html$.KeyCode.FF_EQUALS:
          {
            return html$.KeyCode.EQUALS;
          }
          case html$.KeyCode.FF_SEMICOLON:
          {
            return html$.KeyCode.SEMICOLON;
          }
          case html$.KeyCode.MAC_FF_META:
          {
            return html$.KeyCode.META;
          }
          case html$.KeyCode.WIN_KEY_FF_LINUX:
          {
            return html$.KeyCode.WIN_KEY;
          }
        }
      }
      return event[dartx.keyCode];
    }
    processKeyDown(e) {
      if (dart.notNull(this[_keyDownList][dartx.length]) > 0 && (this[_keyDownList][dartx.last].keyCode == html$.KeyCode.CTRL && !dart.notNull(e[dartx.ctrlKey]) || this[_keyDownList][dartx.last].keyCode == html$.KeyCode.ALT && !dart.notNull(e[dartx.altKey]) || dart.notNull(html_common.Device.userAgent[dartx.contains]('Mac')) && this[_keyDownList][dartx.last].keyCode == html$.KeyCode.META && !dart.notNull(e[dartx.metaKey]))) {
        this[_keyDownList][dartx.clear]();
      }
      let event = new html$.KeyEvent.wrap(e);
      event[_shadowKeyCode] = this[_normalizeKeyCodes](event);
      event[_shadowCharCode] = this[_findCharCodeKeyDown](event);
      if (dart.notNull(this[_keyDownList][dartx.length]) > 0 && event.keyCode != this[_keyDownList][dartx.last].keyCode && !dart.notNull(this[_firesKeyPressEvent](event))) {
        this.processKeyPress(e);
      }
      this[_keyDownList][dartx.add](event);
      this[_stream$].add(event);
    }
    processKeyPress(event) {
      let e = new html$.KeyEvent.wrap(event);
      if (dart.notNull(html_common.Device.isIE)) {
        if (e.keyCode == html$.KeyCode.ENTER || e.keyCode == html$.KeyCode.ESC) {
          e[_shadowCharCode] = 0;
        } else {
          e[_shadowCharCode] = e.keyCode;
        }
      } else if (dart.notNull(html_common.Device.isOpera)) {
        e[_shadowCharCode] = dart.notNull(html$.KeyCode.isCharacterKey(e.keyCode)) ? e.keyCode : 0;
      }
      e[_shadowKeyCode] = this[_determineKeyCodeForKeypress](e);
      if (e[_shadowKeyIdentifier] != null && dart.notNull(html$._KeyboardEventHandler._keyIdentifier[dartx.containsKey](e[_shadowKeyIdentifier]))) {
        e[_shadowKeyCode] = html$._KeyboardEventHandler._keyIdentifier[dartx.get](e[_shadowKeyIdentifier]);
      }
      e[_shadowAltKey] = this[_keyDownList][dartx.any](dart.fn(element => element.altKey, core.bool, [html$.KeyEvent]));
      this[_stream$].add(e);
    }
    processKeyUp(event) {
      let e = new html$.KeyEvent.wrap(event);
      let toRemove = null;
      for (let key of this[_keyDownList]) {
        if (key.keyCode == e.keyCode) {
          toRemove = key;
        }
      }
      if (toRemove != null) {
        this[_keyDownList][dartx.removeWhere](dart.fn(element => dart.equals(element, toRemove), core.bool, [html$.KeyEvent]));
      } else if (dart.notNull(this[_keyDownList][dartx.length]) > 0) {
        this[_keyDownList][dartx.removeLast]();
      }
      this[_stream$].add(e);
    }
  };
  dart.defineNamedConstructor(html$._KeyboardEventHandler, 'initializeAllEventListeners');
  dart.setSignature(html$._KeyboardEventHandler, {
    constructors: () => ({
      _KeyboardEventHandler: [html$._KeyboardEventHandler, [core.String]],
      initializeAllEventListeners: [html$._KeyboardEventHandler, [core.String, html$.EventTarget]]
    }),
    methods: () => ({
      forTarget: [html$.CustomStream$(html$.KeyEvent), [html$.EventTarget], {useCapture: core.bool}],
      [_determineKeyCodeForKeypress]: [core.int, [html$.KeyboardEvent]],
      [_findCharCodeKeyDown]: [core.int, [html$.KeyboardEvent]],
      [_firesKeyPressEvent]: [core.bool, [html$.KeyEvent]],
      [_normalizeKeyCodes]: [core.int, [html$.KeyboardEvent]],
      processKeyDown: [dart.void, [html$.KeyboardEvent]],
      processKeyPress: [dart.void, [html$.KeyboardEvent]],
      processKeyUp: [dart.void, [html$.KeyboardEvent]]
    })
  });
  html$._KeyboardEventHandler._EVENT_TYPE = 'KeyEvent';
  html$._KeyboardEventHandler._keyIdentifier = dart.const(dart.map({Up: html$.KeyCode.UP, Down: html$.KeyCode.DOWN, Left: html$.KeyCode.LEFT, Right: html$.KeyCode.RIGHT, Enter: html$.KeyCode.ENTER, F1: html$.KeyCode.F1, F2: html$.KeyCode.F2, F3: html$.KeyCode.F3, F4: html$.KeyCode.F4, F5: html$.KeyCode.F5, F6: html$.KeyCode.F6, F7: html$.KeyCode.F7, F8: html$.KeyCode.F8, F9: html$.KeyCode.F9, F10: html$.KeyCode.F10, F11: html$.KeyCode.F11, F12: html$.KeyCode.F12, 'U+007F': html$.KeyCode.DELETE, Home: html$.KeyCode.HOME, End: html$.KeyCode.END, PageUp: html$.KeyCode.PAGE_UP, PageDown: html$.KeyCode.PAGE_DOWN, Insert: html$.KeyCode.INSERT}));
  dart.defineLazy(html$._KeyboardEventHandler, {
    get _ROMAN_ALPHABET_OFFSET() {
      return dart.notNull("a"[dartx.codeUnits][dartx.get](0)) - dart.notNull("A"[dartx.codeUnits][dartx.get](0));
    }
  });
  html$.KeyboardEventStream = class KeyboardEventStream extends core.Object {
    static onKeyPress(target) {
      return new html$._KeyboardEventHandler('keypress').forTarget(target);
    }
    static onKeyUp(target) {
      return new html$._KeyboardEventHandler('keyup').forTarget(target);
    }
    static onKeyDown(target) {
      return new html$._KeyboardEventHandler('keydown').forTarget(target);
    }
  };
  dart.setSignature(html$.KeyboardEventStream, {
    statics: () => ({
      onKeyPress: [html$.CustomStream$(html$.KeyEvent), [html$.EventTarget]],
      onKeyUp: [html$.CustomStream$(html$.KeyEvent), [html$.EventTarget]],
      onKeyDown: [html$.CustomStream$(html$.KeyEvent), [html$.EventTarget]]
    }),
    names: ['onKeyPress', 'onKeyUp', 'onKeyDown']
  });
  const _validators = Symbol('_validators');
  html$.NodeValidatorBuilder = class NodeValidatorBuilder extends core.Object {
    NodeValidatorBuilder() {
      this[_validators] = dart.list([], html$.NodeValidator);
    }
    common() {
      this[_validators] = dart.list([], html$.NodeValidator);
      this.allowHtml5();
      this.allowTemplating();
    }
    allowNavigation(uriPolicy) {
      if (uriPolicy === void 0) uriPolicy = null;
      if (uriPolicy == null) {
        uriPolicy = html$.UriPolicy.new();
      }
      this.add(html$._SimpleNodeValidator.allowNavigation(uriPolicy));
    }
    allowImages(uriPolicy) {
      if (uriPolicy === void 0) uriPolicy = null;
      if (uriPolicy == null) {
        uriPolicy = html$.UriPolicy.new();
      }
      this.add(html$._SimpleNodeValidator.allowImages(uriPolicy));
    }
    allowTextElements() {
      this.add(html$._SimpleNodeValidator.allowTextElements());
    }
    allowInlineStyles(opts) {
      let tagName = opts && 'tagName' in opts ? opts.tagName : null;
      if (tagName == null) {
        tagName = '*';
      } else {
        tagName = tagName[dartx.toUpperCase]();
      }
      this.add(new html$._SimpleNodeValidator(null, {allowedAttributes: dart.list([`${tagName}::style`], core.String)}));
    }
    allowHtml5(opts) {
      let uriPolicy = opts && 'uriPolicy' in opts ? opts.uriPolicy : null;
      this.add(new html$._Html5NodeValidator({uriPolicy: uriPolicy}));
    }
    allowSvg() {
      this.add(new html$._SvgNodeValidator());
    }
    allowCustomElement(tagName, opts) {
      let uriPolicy = opts && 'uriPolicy' in opts ? opts.uriPolicy : null;
      let attributes = opts && 'attributes' in opts ? opts.attributes : null;
      let uriAttributes = opts && 'uriAttributes' in opts ? opts.uriAttributes : null;
      let tagNameUpper = tagName[dartx.toUpperCase]();
      let attrs = dart.nullSafe(attributes, _ => _[dartx.map](dart.fn(name => `${tagNameUpper}::${name[dartx.toLowerCase]()}`, core.String, [core.String])));
      let uriAttrs = dart.nullSafe(uriAttributes, _ => _[dartx.map](dart.fn(name => `${tagNameUpper}::${name[dartx.toLowerCase]()}`, core.String, [core.String])));
      if (uriPolicy == null) {
        uriPolicy = html$.UriPolicy.new();
      }
      this.add(new html$._CustomElementNodeValidator(uriPolicy, dart.list([tagNameUpper], core.String), attrs, uriAttrs, false, true));
    }
    allowTagExtension(tagName, baseName, opts) {
      let uriPolicy = opts && 'uriPolicy' in opts ? opts.uriPolicy : null;
      let attributes = opts && 'attributes' in opts ? opts.attributes : null;
      let uriAttributes = opts && 'uriAttributes' in opts ? opts.uriAttributes : null;
      let baseNameUpper = baseName[dartx.toUpperCase]();
      let tagNameUpper = tagName[dartx.toUpperCase]();
      let attrs = dart.nullSafe(attributes, _ => _[dartx.map](dart.fn(name => `${baseNameUpper}::${name[dartx.toLowerCase]()}`, core.String, [core.String])));
      let uriAttrs = dart.nullSafe(uriAttributes, _ => _[dartx.map](dart.fn(name => `${baseNameUpper}::${name[dartx.toLowerCase]()}`, core.String, [core.String])));
      if (uriPolicy == null) {
        uriPolicy = html$.UriPolicy.new();
      }
      this.add(new html$._CustomElementNodeValidator(uriPolicy, dart.list([tagNameUpper, baseNameUpper], core.String), attrs, uriAttrs, true, false));
    }
    allowElement(tagName, opts) {
      let uriPolicy = opts && 'uriPolicy' in opts ? opts.uriPolicy : null;
      let attributes = opts && 'attributes' in opts ? opts.attributes : null;
      let uriAttributes = opts && 'uriAttributes' in opts ? opts.uriAttributes : null;
      this.allowCustomElement(tagName, {uriPolicy: uriPolicy, attributes: attributes, uriAttributes: uriAttributes});
    }
    allowTemplating() {
      this.add(new html$._TemplatingNodeValidator());
    }
    add(validator) {
      this[_validators][dartx.add](validator);
    }
    allowsElement(element) {
      return this[_validators][dartx.any](dart.fn(v => v.allowsElement(element), core.bool, [html$.NodeValidator]));
    }
    allowsAttribute(element, attributeName, value) {
      return this[_validators][dartx.any](dart.fn(v => v.allowsAttribute(element, attributeName, value), core.bool, [html$.NodeValidator]));
    }
  };
  dart.defineNamedConstructor(html$.NodeValidatorBuilder, 'common');
  html$.NodeValidatorBuilder[dart.implements] = () => [html$.NodeValidator];
  dart.setSignature(html$.NodeValidatorBuilder, {
    constructors: () => ({
      NodeValidatorBuilder: [html$.NodeValidatorBuilder, []],
      common: [html$.NodeValidatorBuilder, []]
    }),
    methods: () => ({
      allowNavigation: [dart.void, [], [html$.UriPolicy]],
      allowImages: [dart.void, [], [html$.UriPolicy]],
      allowTextElements: [dart.void, []],
      allowInlineStyles: [dart.void, [], {tagName: core.String}],
      allowHtml5: [dart.void, [], {uriPolicy: html$.UriPolicy}],
      allowSvg: [dart.void, []],
      allowCustomElement: [dart.void, [core.String], {uriPolicy: html$.UriPolicy, attributes: core.Iterable$(core.String), uriAttributes: core.Iterable$(core.String)}],
      allowTagExtension: [dart.void, [core.String, core.String], {uriPolicy: html$.UriPolicy, attributes: core.Iterable$(core.String), uriAttributes: core.Iterable$(core.String)}],
      allowElement: [dart.void, [core.String], {uriPolicy: html$.UriPolicy, attributes: core.Iterable$(core.String), uriAttributes: core.Iterable$(core.String)}],
      allowTemplating: [dart.void, []],
      add: [dart.void, [html$.NodeValidator]],
      allowsElement: [core.bool, [html$.Element]],
      allowsAttribute: [core.bool, [html$.Element, core.String, core.String]]
    })
  });
  html$._SimpleNodeValidator = class _SimpleNodeValidator extends core.Object {
    static allowNavigation(uriPolicy) {
      return new html$._SimpleNodeValidator(uriPolicy, {allowedElements: dart.const(dart.list(['A', 'FORM'], core.String)), allowedAttributes: dart.const(dart.list(['A::accesskey', 'A::coords', 'A::hreflang', 'A::name', 'A::shape', 'A::tabindex', 'A::target', 'A::type', 'FORM::accept', 'FORM::autocomplete', 'FORM::enctype', 'FORM::method', 'FORM::name', 'FORM::novalidate', 'FORM::target'], core.String)), allowedUriAttributes: dart.const(dart.list(['A::href', 'FORM::action'], core.String))});
    }
    static allowImages(uriPolicy) {
      return new html$._SimpleNodeValidator(uriPolicy, {allowedElements: dart.const(dart.list(['IMG'], core.String)), allowedAttributes: dart.const(dart.list(['IMG::align', 'IMG::alt', 'IMG::border', 'IMG::height', 'IMG::hspace', 'IMG::ismap', 'IMG::name', 'IMG::usemap', 'IMG::vspace', 'IMG::width'], core.String)), allowedUriAttributes: dart.const(dart.list(['IMG::src'], core.String))});
    }
    static allowTextElements() {
      return new html$._SimpleNodeValidator(null, {allowedElements: dart.const(dart.list(['B', 'BLOCKQUOTE', 'BR', 'EM', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'HR', 'I', 'LI', 'OL', 'P', 'SPAN', 'UL'], core.String))});
    }
    _SimpleNodeValidator(uriPolicy, opts) {
      let allowedElements = opts && 'allowedElements' in opts ? opts.allowedElements : null;
      let allowedAttributes = opts && 'allowedAttributes' in opts ? opts.allowedAttributes : null;
      let allowedUriAttributes = opts && 'allowedUriAttributes' in opts ? opts.allowedUriAttributes : null;
      this.allowedElements = core.Set$(core.String).new();
      this.allowedAttributes = core.Set$(core.String).new();
      this.allowedUriAttributes = core.Set$(core.String).new();
      this.uriPolicy = uriPolicy;
      this.allowedElements.addAll((allowedElements != null ? allowedElements : dart.const(dart.list([], core.String))));
      allowedAttributes = allowedAttributes != null ? allowedAttributes : dart.const(dart.list([], core.String));
      allowedUriAttributes = allowedUriAttributes != null ? allowedUriAttributes : dart.const(dart.list([], core.String));
      let legalAttributes = allowedAttributes[dartx.where](dart.fn(x => !dart.notNull(html$._Html5NodeValidator._uriAttributes[dartx.contains](x)), core.bool, [core.String]));
      let extraUriAttributes = allowedAttributes[dartx.where](dart.fn(x => html$._Html5NodeValidator._uriAttributes[dartx.contains](x), core.bool, [core.String]));
      this.allowedAttributes.addAll(legalAttributes);
      this.allowedUriAttributes.addAll(allowedUriAttributes);
      this.allowedUriAttributes.addAll(extraUriAttributes);
    }
    allowsElement(element) {
      return this.allowedElements.contains(html$.Element._safeTagName(element));
    }
    allowsAttribute(element, attributeName, value) {
      let tagName = html$.Element._safeTagName(element);
      if (dart.notNull(this.allowedUriAttributes.contains(`${tagName}::${attributeName}`))) {
        return this.uriPolicy.allowsUri(value);
      } else if (dart.notNull(this.allowedUriAttributes.contains(`*::${attributeName}`))) {
        return this.uriPolicy.allowsUri(value);
      } else if (dart.notNull(this.allowedAttributes.contains(`${tagName}::${attributeName}`))) {
        return true;
      } else if (dart.notNull(this.allowedAttributes.contains(`*::${attributeName}`))) {
        return true;
      } else if (dart.notNull(this.allowedAttributes.contains(`${tagName}::*`))) {
        return true;
      } else if (dart.notNull(this.allowedAttributes.contains('*::*'))) {
        return true;
      }
      return false;
    }
  };
  html$._SimpleNodeValidator[dart.implements] = () => [html$.NodeValidator];
  dart.setSignature(html$._SimpleNodeValidator, {
    constructors: () => ({
      allowNavigation: [html$._SimpleNodeValidator, [html$.UriPolicy]],
      allowImages: [html$._SimpleNodeValidator, [html$.UriPolicy]],
      allowTextElements: [html$._SimpleNodeValidator, []],
      _SimpleNodeValidator: [html$._SimpleNodeValidator, [html$.UriPolicy], {allowedElements: core.Iterable$(core.String), allowedAttributes: core.Iterable$(core.String), allowedUriAttributes: core.Iterable$(core.String)}]
    }),
    methods: () => ({
      allowsElement: [core.bool, [html$.Element]],
      allowsAttribute: [core.bool, [html$.Element, core.String, core.String]]
    })
  });
  html$._CustomElementNodeValidator = class _CustomElementNodeValidator extends html$._SimpleNodeValidator {
    _CustomElementNodeValidator(uriPolicy, allowedElements, allowedAttributes, allowedUriAttributes, allowTypeExtension, allowCustomTag) {
      this.allowTypeExtension = allowTypeExtension == true;
      this.allowCustomTag = allowCustomTag == true;
      super._SimpleNodeValidator(uriPolicy, {allowedElements: allowedElements, allowedAttributes: allowedAttributes, allowedUriAttributes: allowedUriAttributes});
    }
    allowsElement(element) {
      if (dart.notNull(this.allowTypeExtension)) {
        let isAttr = element[dartx.attributes][dartx.get]('is');
        if (isAttr != null) {
          return dart.notNull(this.allowedElements.contains(isAttr[dartx.toUpperCase]())) && dart.notNull(this.allowedElements.contains(html$.Element._safeTagName(element)));
        }
      }
      return dart.notNull(this.allowCustomTag) && dart.notNull(this.allowedElements.contains(html$.Element._safeTagName(element)));
    }
    allowsAttribute(element, attributeName, value) {
      if (dart.notNull(this.allowsElement(element))) {
        if (dart.notNull(this.allowTypeExtension) && attributeName == 'is' && dart.notNull(this.allowedElements.contains(value[dartx.toUpperCase]()))) {
          return true;
        }
        return super.allowsAttribute(element, attributeName, value);
      }
      return false;
    }
  };
  dart.setSignature(html$._CustomElementNodeValidator, {
    constructors: () => ({_CustomElementNodeValidator: [html$._CustomElementNodeValidator, [html$.UriPolicy, core.Iterable$(core.String), core.Iterable$(core.String), core.Iterable$(core.String), core.bool, core.bool]]})
  });
  const _templateAttrs = Symbol('_templateAttrs');
  html$._TemplatingNodeValidator = class _TemplatingNodeValidator extends html$._SimpleNodeValidator {
    _TemplatingNodeValidator() {
      this[_templateAttrs] = core.Set$(core.String).from(html$._TemplatingNodeValidator._TEMPLATE_ATTRS);
      super._SimpleNodeValidator(null, {allowedElements: dart.list(['TEMPLATE'], core.String), allowedAttributes: html$._TemplatingNodeValidator._TEMPLATE_ATTRS[dartx.map](core.String)(dart.fn(attr => `TEMPLATE::${attr}`, core.String, [core.String]))});
    }
    allowsAttribute(element, attributeName, value) {
      if (dart.notNull(super.allowsAttribute(element, attributeName, value))) {
        return true;
      }
      if (attributeName == 'template' && value == "") {
        return true;
      }
      if (element[dartx.attributes][dartx.get]('template') == "") {
        return this[_templateAttrs].contains(attributeName);
      }
      return false;
    }
  };
  dart.setSignature(html$._TemplatingNodeValidator, {
    constructors: () => ({_TemplatingNodeValidator: [html$._TemplatingNodeValidator, []]})
  });
  html$._TemplatingNodeValidator._TEMPLATE_ATTRS = dart.const(dart.list(['bind', 'if', 'ref', 'repeat', 'syntax'], core.String));
  html$._SvgNodeValidator = class _SvgNodeValidator extends core.Object {
    allowsElement(element) {
      if (dart.is(element, svg$.ScriptElement)) {
        return false;
      }
      if (dart.is(element, svg$.SvgElement) && html$.Element._safeTagName(element) == 'foreignObject') {
        return false;
      }
      if (dart.is(element, svg$.SvgElement)) {
        return true;
      }
      return false;
    }
    allowsAttribute(element, attributeName, value) {
      if (attributeName == 'is' || dart.notNull(attributeName[dartx.startsWith]('on'))) {
        return false;
      }
      return this.allowsElement(element);
    }
  };
  html$._SvgNodeValidator[dart.implements] = () => [html$.NodeValidator];
  dart.setSignature(html$._SvgNodeValidator, {
    methods: () => ({
      allowsElement: [core.bool, [html$.Element]],
      allowsAttribute: [core.bool, [html$.Element, core.String, core.String]]
    })
  });
  html$.ReadyState = class ReadyState extends core.Object {};
  html$.ReadyState.LOADING = "loading";
  html$.ReadyState.INTERACTIVE = "interactive";
  html$.ReadyState.COMPLETE = "complete";
  const _list$ = Symbol('_list');
  html$._WrappedList$ = dart.generic(E => {
    class _WrappedList extends collection.ListBase$(E) {
      _WrappedList(list) {
        this[_list$] = list;
      }
      get iterator() {
        return new (html$._WrappedIterator$(html$.Node))(this[_list$][dartx.iterator]);
      }
      get length() {
        return this[_list$][dartx.length];
      }
      add(element) {
        dart.as(element, E);
        this[_list$][dartx.add](element);
      }
      remove(element) {
        return this[_list$][dartx.remove](element);
      }
      clear() {
        this[_list$][dartx.clear]();
      }
      get(index) {
        return html$._downcast(html$.Node, E)(this[_list$][dartx.get](index));
      }
      set(index, value) {
        dart.as(value, E);
        this[_list$][dartx.set](index, value);
        return value;
      }
      set length(newLength) {
        this[_list$][dartx.length] = newLength;
      }
      sort(compare) {
        if (compare === void 0) compare = null;
        dart.as(compare, dart.functionType(core.int, [E, E]));
        this[_list$][dartx.sort](dart.fn((a, b) => compare(html$._downcast(html$.Node, E)(a), html$._downcast(html$.Node, E)(b)), core.int, [html$.Node, html$.Node]));
      }
      indexOf(element, start) {
        if (start === void 0) start = 0;
        return this[_list$][dartx.indexOf](dart.as(element, html$.Node), start);
      }
      lastIndexOf(element, start) {
        if (start === void 0) start = null;
        return this[_list$][dartx.lastIndexOf](dart.as(element, html$.Node), start);
      }
      insert(index, element) {
        dart.as(element, E);
        return this[_list$][dartx.insert](index, element);
      }
      removeAt(index) {
        return html$._downcast(html$.Node, E)(this[_list$][dartx.removeAt](index));
      }
      setRange(start, end, iterable, skipCount) {
        dart.as(iterable, core.Iterable$(E));
        if (skipCount === void 0) skipCount = 0;
        this[_list$][dartx.setRange](start, end, iterable, skipCount);
      }
      removeRange(start, end) {
        this[_list$][dartx.removeRange](start, end);
      }
      replaceRange(start, end, iterable) {
        dart.as(iterable, core.Iterable$(E));
        this[_list$][dartx.replaceRange](start, end, iterable);
      }
      fillRange(start, end, fillValue) {
        if (fillValue === void 0) fillValue = null;
        dart.as(fillValue, E);
        this[_list$][dartx.fillRange](start, end, fillValue);
      }
      get rawList() {
        return this[_list$];
      }
    }
    _WrappedList[dart.implements] = () => [html_common.NodeListWrapper];
    dart.setSignature(_WrappedList, {
      constructors: () => ({_WrappedList: [html$._WrappedList$(E), [core.List$(html$.Node)]]}),
      methods: () => ({
        add: [dart.void, [E]],
        get: [E, [core.int]],
        set: [dart.void, [core.int, E]],
        sort: [dart.void, [], [dart.functionType(core.int, [E, E])]],
        insert: [dart.void, [core.int, E]],
        removeAt: [E, [core.int]],
        setRange: [dart.void, [core.int, core.int, core.Iterable$(E)], [core.int]],
        replaceRange: [dart.void, [core.int, core.int, core.Iterable$(E)]],
        fillRange: [dart.void, [core.int, core.int], [E]]
      })
    });
    dart.defineExtensionMembers(_WrappedList, [
      'add',
      'remove',
      'clear',
      'get',
      'set',
      'sort',
      'indexOf',
      'lastIndexOf',
      'insert',
      'removeAt',
      'setRange',
      'removeRange',
      'replaceRange',
      'fillRange',
      'iterator',
      'length',
      'length'
    ]);
    return _WrappedList;
  });
  html$._WrappedList = html$._WrappedList$();
  const _iterator$1 = Symbol('_iterator');
  html$._WrappedIterator$ = dart.generic(E => {
    class _WrappedIterator extends core.Object {
      _WrappedIterator(iterator) {
        this[_iterator$1] = iterator;
      }
      moveNext() {
        return this[_iterator$1].moveNext();
      }
      get current() {
        return html$._downcast(html$.Node, E)(this[_iterator$1].current);
      }
    }
    _WrappedIterator[dart.implements] = () => [core.Iterator$(E)];
    dart.setSignature(_WrappedIterator, {
      constructors: () => ({_WrappedIterator: [html$._WrappedIterator$(E), [core.Iterator$(html$.Node)]]}),
      methods: () => ({moveNext: [core.bool, []]})
    });
    return _WrappedIterator;
  });
  html$._WrappedIterator = html$._WrappedIterator$();
  html$._downcast = function(From, To) {
    return x => {
      return dart.as(x, To);
    };
  };
  dart.fn(html$._downcast, (From, To) => [To, [From]]);
  html$._HttpRequestUtils = class _HttpRequestUtils extends core.Object {
    static get(url, onComplete, withCredentials) {
      let request = html$.HttpRequest.new();
      request[dartx.open]('GET', url, {async: true});
      request[dartx.withCredentials] = withCredentials;
      request[dartx.onReadyStateChange].listen(dart.fn(e => {
        if (request[dartx.readyState] == html$.HttpRequest.DONE) {
          onComplete(request);
        }
      }, dart.void, [html$.ProgressEvent]));
      request[dartx.send]();
      return request;
    }
  };
  dart.setSignature(html$._HttpRequestUtils, {
    statics: () => ({get: [html$.HttpRequest, [core.String, dart.functionType(dart.dynamic, [html$.HttpRequest]), core.bool]]}),
    names: ['get']
  });
  const _array = Symbol('_array');
  const _current$4 = Symbol('_current');
  html$.FixedSizeListIterator$ = dart.generic(T => {
    class FixedSizeListIterator extends core.Object {
      FixedSizeListIterator(array) {
        this[_array] = array;
        this[_position$0] = -1;
        this[_length$2] = array[dartx.length];
        this[_current$4] = null;
      }
      moveNext() {
        let nextPosition = dart.notNull(this[_position$0]) + 1;
        if (nextPosition < dart.notNull(this[_length$2])) {
          this[_current$4] = this[_array][dartx.get](nextPosition);
          this[_position$0] = nextPosition;
          return true;
        }
        this[_current$4] = null;
        this[_position$0] = this[_length$2];
        return false;
      }
      get current() {
        return this[_current$4];
      }
    }
    FixedSizeListIterator[dart.implements] = () => [core.Iterator$(T)];
    dart.setSignature(FixedSizeListIterator, {
      constructors: () => ({FixedSizeListIterator: [html$.FixedSizeListIterator$(T), [core.List$(T)]]}),
      methods: () => ({moveNext: [core.bool, []]})
    });
    return FixedSizeListIterator;
  });
  html$.FixedSizeListIterator = html$.FixedSizeListIterator$();
  html$._VariableSizeListIterator$ = dart.generic(T => {
    class _VariableSizeListIterator extends core.Object {
      _VariableSizeListIterator(array) {
        this[_array] = array;
        this[_position$0] = -1;
        this[_current$4] = null;
      }
      moveNext() {
        let nextPosition = dart.notNull(this[_position$0]) + 1;
        if (nextPosition < dart.notNull(this[_array][dartx.length])) {
          this[_current$4] = this[_array][dartx.get](nextPosition);
          this[_position$0] = nextPosition;
          return true;
        }
        this[_current$4] = null;
        this[_position$0] = this[_array][dartx.length];
        return false;
      }
      get current() {
        return this[_current$4];
      }
    }
    _VariableSizeListIterator[dart.implements] = () => [core.Iterator$(T)];
    dart.setSignature(_VariableSizeListIterator, {
      constructors: () => ({_VariableSizeListIterator: [html$._VariableSizeListIterator$(T), [core.List$(T)]]}),
      methods: () => ({moveNext: [core.bool, []]})
    });
    return _VariableSizeListIterator;
  });
  html$._VariableSizeListIterator = html$._VariableSizeListIterator$();
  html$._convertNativeToDart_Window = function(win) {
    if (win == null) return null;
    return html$._DOMWindowCrossFrame._createSafe(win);
  };
  dart.fn(html$._convertNativeToDart_Window, html$.WindowBase, [dart.dynamic]);
  html$._convertNativeToDart_EventTarget = function(e) {
    if (e == null) {
      return null;
    }
    if ("postMessage" in e) {
      let window = html$._DOMWindowCrossFrame._createSafe(e);
      if (dart.is(window, html$.EventTarget)) {
        return window;
      }
      return null;
    } else
      return dart.as(e, html$.EventTarget);
  };
  dart.fn(html$._convertNativeToDart_EventTarget, html$.EventTarget, [dart.dynamic]);
  const _window = Symbol('_window');
  html$._convertDartToNative_EventTarget = function(e) {
    if (dart.is(e, html$._DOMWindowCrossFrame)) {
      return dart.as(e[_window], html$.EventTarget);
    } else {
      return dart.as(e, html$.EventTarget);
    }
  };
  dart.fn(html$._convertDartToNative_EventTarget, html$.EventTarget, [dart.dynamic]);
  html$._convertNativeToDart_XHR_Response = function(o) {
    if (dart.is(o, html$.Document)) {
      return o;
    }
    return html_common.convertNativeToDart_SerializedScriptValue(o);
  };
  dart.fn(html$._convertNativeToDart_XHR_Response);
  html$._callConstructor = function(constructor, interceptor) {
    return dart.fn(receiver => {
      _js_helper.setNativeSubclassDispatchRecord(receiver, interceptor);
      receiver.constructor = receiver.__proto__.constructor;
      return constructor(receiver);
    });
  };
  dart.fn(html$._callConstructor);
  html$._callAttached = function(receiver) {
    return dart.dsend(receiver, 'attached');
  };
  dart.fn(html$._callAttached);
  html$._callDetached = function(receiver) {
    return dart.dsend(receiver, 'detached');
  };
  dart.fn(html$._callDetached);
  html$._callAttributeChanged = function(receiver, name, oldValue, newValue) {
    return dart.dsend(receiver, 'attributeChanged', name, oldValue, newValue);
  };
  dart.fn(html$._callAttributeChanged);
  html$._makeCallbackMethod = function(callback) {
    return (function(invokeCallback) {
      return function() {
        return invokeCallback(this);
      };
    })(_js_helper.convertDartClosureToJS(dart.dynamic)(callback, 1));
  };
  dart.fn(html$._makeCallbackMethod);
  html$._makeCallbackMethod3 = function(callback) {
    return (function(invokeCallback) {
      return function(arg1, arg2, arg3) {
        return invokeCallback(this, arg1, arg2, arg3);
      };
    })(_js_helper.convertDartClosureToJS(dart.dynamic)(callback, 4));
  };
  dart.fn(html$._makeCallbackMethod3);
  html$._registerCustomElement = function(context, document, tag, type, extendsTagName) {
    let interceptorClass = _interceptors.findInterceptorConstructorForType(type);
    if (interceptorClass == null) {
      dart.throw(new core.ArgumentError(type));
    }
    let interceptor = interceptorClass.prototype;
    let constructor = _interceptors.findConstructorForNativeSubclassType(type, 'created');
    if (constructor == null) {
      dart.throw(new core.ArgumentError(`${type} has no constructor called 'created'`));
    }
    _interceptors.getNativeInterceptor(html$.Element.tag('article'));
    let baseClassName = dart.as(_js_helper.findDispatchTagForInterceptorClass(interceptorClass), core.String);
    if (baseClassName == null) {
      dart.throw(new core.ArgumentError(type));
    }
    if (extendsTagName == null) {
      if (baseClassName != 'HTMLElement') {
        dart.throw(new core.UnsupportedError('Class must provide extendsTag if base ' + 'native class is not HtmlElement'));
      }
    } else {
      if (!(document.createElement(extendsTagName) instanceof window[baseClassName])) {
        dart.throw(new core.UnsupportedError('extendsTag does not match base native class'));
      }
    }
    let baseConstructor = context[baseClassName];
    let properties = {};
    properties.createdCallback = {value: html$._makeCallbackMethod(html$._callConstructor(constructor, interceptor))};
    properties.attachedCallback = {value: html$._makeCallbackMethod(html$._callAttached)};
    properties.detachedCallback = {value: html$._makeCallbackMethod(html$._callDetached)};
    properties.attributeChangedCallback = {value: html$._makeCallbackMethod3(html$._callAttributeChanged)};
    let baseProto = baseConstructor.prototype;
    let proto = Object.create(baseProto, properties);
    _js_helper.setNativeSubclassDispatchRecord(proto, interceptor);
    let options = {prototype: proto};
    if (extendsTagName != null) {
      options.extends = extendsTagName;
    }
    document.registerElement(tag, options);
  };
  dart.fn(html$._registerCustomElement, dart.void, [dart.dynamic, dart.dynamic, core.String, core.Type, core.String]);
  html$._initializeCustomElement = function(e) {
  };
  dart.fn(html$._initializeCustomElement, dart.void, [html$.Element]);
  const _interceptor = Symbol('_interceptor');
  const _constructor = Symbol('_constructor');
  const _nativeType = Symbol('_nativeType');
  html$._JSElementUpgrader = class _JSElementUpgrader extends core.Object {
    _JSElementUpgrader(document, type, extendsTag) {
      this[_interceptor] = null;
      this[_constructor] = null;
      this[_nativeType] = null;
      let interceptorClass = _interceptors.findInterceptorConstructorForType(type);
      if (interceptorClass == null) {
        dart.throw(new core.ArgumentError(type));
      }
      this[_constructor] = _interceptors.findConstructorForNativeSubclassType(type, 'created');
      if (this[_constructor] == null) {
        dart.throw(new core.ArgumentError(`${type} has no constructor called 'created'`));
      }
      _interceptors.getNativeInterceptor(html$.Element.tag('article'));
      let baseClassName = _js_helper.findDispatchTagForInterceptorClass(interceptorClass);
      if (baseClassName == null) {
        dart.throw(new core.ArgumentError(type));
      }
      if (extendsTag == null) {
        if (!dart.equals(baseClassName, 'HTMLElement')) {
          dart.throw(new core.UnsupportedError('Class must provide extendsTag if base ' + 'native class is not HtmlElement'));
        }
        this[_nativeType] = dart.wrapType(html$.HtmlElement);
      } else {
        let element = document[dartx.createElement](extendsTag);
        if (!(element instanceof window[baseClassName])) {
          dart.throw(new core.UnsupportedError('extendsTag does not match base native class'));
        }
        this[_nativeType] = dart.runtimeType(element);
      }
      this[_interceptor] = interceptorClass.prototype;
    }
    upgrade(element) {
      if (!dart.equals(dart.runtimeType(element), this[_nativeType])) {
        dart.throw(new core.ArgumentError(`element is not subclass of ${this[_nativeType]}`));
      }
      _js_helper.setNativeSubclassDispatchRecord(element, this[_interceptor]);
      this[_constructor](element);
      return element;
    }
  };
  html$._JSElementUpgrader[dart.implements] = () => [html$.ElementUpgrader];
  dart.setSignature(html$._JSElementUpgrader, {
    constructors: () => ({_JSElementUpgrader: [html$._JSElementUpgrader, [html$.Document, core.Type, core.String]]}),
    methods: () => ({upgrade: [html$.Element, [html$.Element]]})
  });
  html$._DOMWindowCrossFrame = class _DOMWindowCrossFrame extends core.Object {
    get history() {
      return html$._HistoryCrossFrame._createSafe(this[_window].history);
    }
    get location() {
      return html$._LocationCrossFrame._createSafe(this[_window].location);
    }
    get closed() {
      return this[_window].closed;
    }
    get opener() {
      return html$._DOMWindowCrossFrame._createSafe(this[_window].opener);
    }
    get parent() {
      return html$._DOMWindowCrossFrame._createSafe(this[_window].parent);
    }
    get top() {
      return html$._DOMWindowCrossFrame._createSafe(this[_window].top);
    }
    close() {
      return this[_window].close();
    }
    postMessage(message, targetOrigin, messagePorts) {
      if (messagePorts === void 0) messagePorts = null;
      if (messagePorts == null) {
        this[_window].postMessage(html_common.convertDartToNative_SerializedScriptValue(message), targetOrigin);
      } else {
        this[_window].postMessage(html_common.convertDartToNative_SerializedScriptValue(message), targetOrigin, messagePorts);
      }
    }
    _DOMWindowCrossFrame(window) {
      this[_window] = window;
    }
    static _createSafe(w) {
      if (core.identical(w, html$.window)) {
        return dart.as(w, html$.WindowBase);
      } else {
        return new html$._DOMWindowCrossFrame(w);
      }
    }
    get on() {
      return dart.throw(new core.UnsupportedError('You can only attach EventListeners to your own window.'));
    }
    [_addEventListener](type, listener, useCapture) {
      if (useCapture === void 0) useCapture = null;
      return dart.throw(new core.UnsupportedError('You can only attach EventListeners to your own window.'));
    }
    addEventListener(type, listener, useCapture) {
      if (useCapture === void 0) useCapture = null;
      return dart.throw(new core.UnsupportedError('You can only attach EventListeners to your own window.'));
    }
    dispatchEvent(event) {
      return dart.throw(new core.UnsupportedError('You can only attach EventListeners to your own window.'));
    }
    [_removeEventListener](type, listener, useCapture) {
      if (useCapture === void 0) useCapture = null;
      return dart.throw(new core.UnsupportedError('You can only attach EventListeners to your own window.'));
    }
    removeEventListener(type, listener, useCapture) {
      if (useCapture === void 0) useCapture = null;
      return dart.throw(new core.UnsupportedError('You can only attach EventListeners to your own window.'));
    }
  };
  html$._DOMWindowCrossFrame[dart.implements] = () => [html$.WindowBase];
  dart.setSignature(html$._DOMWindowCrossFrame, {
    constructors: () => ({_DOMWindowCrossFrame: [html$._DOMWindowCrossFrame, [dart.dynamic]]}),
    methods: () => ({
      close: [dart.void, []],
      postMessage: [dart.void, [dart.dynamic, core.String], [core.List]],
      [_addEventListener]: [dart.void, [core.String, html$.EventListener], [core.bool]],
      addEventListener: [dart.void, [core.String, html$.EventListener], [core.bool]],
      dispatchEvent: [core.bool, [html$.Event]],
      [_removeEventListener]: [dart.void, [core.String, html$.EventListener], [core.bool]],
      removeEventListener: [dart.void, [core.String, html$.EventListener], [core.bool]]
    }),
    statics: () => ({_createSafe: [html$.WindowBase, [dart.dynamic]]}),
    names: ['_createSafe']
  });
  dart.defineExtensionMembers(html$._DOMWindowCrossFrame, [
    'close',
    'postMessage',
    'history',
    'location',
    'closed',
    'opener',
    'parent',
    'top'
  ]);
  html$._LocationCrossFrame = class _LocationCrossFrame extends core.Object {
    set href(val) {
      return html$._LocationCrossFrame._setHref(this[_location], val);
    }
    static _setHref(location, val) {
      location.href = val;
    }
    _LocationCrossFrame(location) {
      this[_location] = location;
    }
    static _createSafe(location) {
      if (core.identical(location, html$.window[dartx.location])) {
        return dart.as(location, html$.LocationBase);
      } else {
        return new html$._LocationCrossFrame(location);
      }
    }
  };
  html$._LocationCrossFrame[dart.implements] = () => [html$.LocationBase];
  dart.setSignature(html$._LocationCrossFrame, {
    constructors: () => ({_LocationCrossFrame: [html$._LocationCrossFrame, [dart.dynamic]]}),
    statics: () => ({
      _setHref: [dart.void, [dart.dynamic, dart.dynamic]],
      _createSafe: [html$.LocationBase, [dart.dynamic]]
    }),
    names: ['_setHref', '_createSafe']
  });
  dart.defineExtensionMembers(html$._LocationCrossFrame, ['href']);
  const _history = Symbol('_history');
  html$._HistoryCrossFrame = class _HistoryCrossFrame extends core.Object {
    back() {
      return this[_history].back();
    }
    forward() {
      return this[_history].forward();
    }
    go(distance) {
      return this[_history].go(distance);
    }
    _HistoryCrossFrame(history) {
      this[_history] = history;
    }
    static _createSafe(h) {
      if (core.identical(h, html$.window[dartx.history])) {
        return dart.as(h, html$.HistoryBase);
      } else {
        return new html$._HistoryCrossFrame(h);
      }
    }
  };
  html$._HistoryCrossFrame[dart.implements] = () => [html$.HistoryBase];
  dart.setSignature(html$._HistoryCrossFrame, {
    constructors: () => ({_HistoryCrossFrame: [html$._HistoryCrossFrame, [dart.dynamic]]}),
    methods: () => ({
      back: [dart.void, []],
      forward: [dart.void, []],
      go: [dart.void, [core.int]]
    }),
    statics: () => ({_createSafe: [html$.HistoryBase, [dart.dynamic]]}),
    names: ['_createSafe']
  });
  dart.defineExtensionMembers(html$._HistoryCrossFrame, ['back', 'forward', 'go']);
  html$.Platform = class Platform extends core.Object {};
  html$.Platform.supportsSimd = false;
  dart.defineLazy(html$.Platform, {
    get supportsTypedData() {
      return !!window.ArrayBuffer;
    }
  });
  html$._wrapZoneCallback$ = dart.generic((A, R) => {
    const _wrapZoneCallback = dart.typedef('_wrapZoneCallback', () => dart.functionType(R, [A]));
    return _wrapZoneCallback;
  });
  html$._wrapZoneCallback = html$._wrapZoneCallback$();
  html$._wrapZoneBinaryCallback$ = dart.generic((A, B, R) => {
    const _wrapZoneBinaryCallback = dart.typedef('_wrapZoneBinaryCallback', () => dart.functionType(R, [A, B]));
    return _wrapZoneBinaryCallback;
  });
  html$._wrapZoneBinaryCallback = html$._wrapZoneBinaryCallback$();
  html$._wrapZone = function(A, R) {
    return callback => {
      if (dart.equals(async.Zone.current, async.Zone.ROOT)) return callback;
      if (callback == null) return null;
      return async.Zone.current.bindUnaryCallback(R, A)(callback, {runGuarded: true});
    };
  };
  dart.fn(html$._wrapZone, (A, R) => [html$._wrapZoneCallback$(A, R), [html$._wrapZoneCallback$(A, R)]]);
  html$._wrapBinaryZone = function(A, B, R) {
    return callback => {
      if (dart.equals(async.Zone.current, async.Zone.ROOT)) return callback;
      if (callback == null) return null;
      return async.Zone.current.bindBinaryCallback(R, A, B)(callback, {runGuarded: true});
    };
  };
  dart.fn(html$._wrapBinaryZone, (A, B, R) => [html$._wrapZoneBinaryCallback$(A, B, R), [html$._wrapZoneBinaryCallback$(A, B, R)]]);
  html$.query = function(relativeSelectors) {
    return html$.document[dartx.query](relativeSelectors);
  };
  dart.fn(html$.query, html$.Element, [core.String]);
  html$.queryAll = function(relativeSelectors) {
    return html$.document[dartx.queryAll](html$.Element)(relativeSelectors);
  };
  dart.fn(html$.queryAll, html$.ElementList$(html$.Element), [core.String]);
  html$.querySelector = function(selectors) {
    return html$.document[dartx.querySelector](selectors);
  };
  dart.fn(html$.querySelector, html$.Element, [core.String]);
  html$.querySelectorAll = function(selectors) {
    return html$.document[dartx.querySelectorAll](html$.Element)(selectors);
  };
  dart.fn(html$.querySelectorAll, html$.ElementList$(html$.Element), [core.String]);
  html$.ElementUpgrader = class ElementUpgrader extends core.Object {};
  html$.NodeValidator = class NodeValidator extends core.Object {
    static new(opts) {
      let uriPolicy = opts && 'uriPolicy' in opts ? opts.uriPolicy : null;
      return new html$._Html5NodeValidator({uriPolicy: uriPolicy});
    }
    static throws(base) {
      return new html$._ThrowsNodeValidator(base);
    }
  };
  dart.setSignature(html$.NodeValidator, {
    constructors: () => ({
      new: [html$.NodeValidator, [], {uriPolicy: html$.UriPolicy}],
      throws: [html$.NodeValidator, [html$.NodeValidator]]
    })
  });
  html$.NodeTreeSanitizer = class NodeTreeSanitizer extends core.Object {
    static new(validator) {
      return new html$._ValidatingTreeSanitizer(validator);
    }
  };
  dart.setSignature(html$.NodeTreeSanitizer, {
    constructors: () => ({new: [html$.NodeTreeSanitizer, [html$.NodeValidator]]})
  });
  dart.defineLazy(html$.NodeTreeSanitizer, {
    get trusted() {
      return dart.const(new html$._TrustedHtmlTreeSanitizer());
    }
  });
  html$._TrustedHtmlTreeSanitizer = class _TrustedHtmlTreeSanitizer extends core.Object {
    _TrustedHtmlTreeSanitizer() {
    }
    sanitizeTree(node) {}
  };
  html$._TrustedHtmlTreeSanitizer[dart.implements] = () => [html$.NodeTreeSanitizer];
  dart.setSignature(html$._TrustedHtmlTreeSanitizer, {
    constructors: () => ({_TrustedHtmlTreeSanitizer: [html$._TrustedHtmlTreeSanitizer, []]}),
    methods: () => ({sanitizeTree: [dart.void, [html$.Node]]})
  });
  html$.UriPolicy = class UriPolicy extends core.Object {
    static new() {
      return new html$._SameOriginUriPolicy();
    }
  };
  dart.setSignature(html$.UriPolicy, {
    constructors: () => ({new: [html$.UriPolicy, []]})
  });
  const _hiddenAnchor = Symbol('_hiddenAnchor');
  const _loc = Symbol('_loc');
  html$._SameOriginUriPolicy = class _SameOriginUriPolicy extends core.Object {
    _SameOriginUriPolicy() {
      this[_hiddenAnchor] = html$.AnchorElement.new();
      this[_loc] = html$.window[dartx.location];
    }
    allowsUri(uri) {
      this[_hiddenAnchor][dartx.href] = uri;
      return this[_hiddenAnchor][dartx.hostname] == this[_loc][dartx.hostname] && this[_hiddenAnchor][dartx.port] == this[_loc][dartx.port] && this[_hiddenAnchor][dartx.protocol] == this[_loc][dartx.protocol] || this[_hiddenAnchor][dartx.hostname] == '' && this[_hiddenAnchor][dartx.port] == '' && (this[_hiddenAnchor][dartx.protocol] == ':' || this[_hiddenAnchor][dartx.protocol] == '');
    }
  };
  html$._SameOriginUriPolicy[dart.implements] = () => [html$.UriPolicy];
  dart.setSignature(html$._SameOriginUriPolicy, {
    methods: () => ({allowsUri: [core.bool, [core.String]]})
  });
  html$._ThrowsNodeValidator = class _ThrowsNodeValidator extends core.Object {
    _ThrowsNodeValidator(validator) {
      this.validator = validator;
    }
    allowsElement(element) {
      if (!dart.notNull(this.validator.allowsElement(element))) {
        dart.throw(new core.ArgumentError(html$.Element._safeTagName(element)));
      }
      return true;
    }
    allowsAttribute(element, attributeName, value) {
      if (!dart.notNull(this.validator.allowsAttribute(element, attributeName, value))) {
        dart.throw(new core.ArgumentError(`${html$.Element._safeTagName(element)}[${attributeName}="${value}"]`));
      }
    }
  };
  html$._ThrowsNodeValidator[dart.implements] = () => [html$.NodeValidator];
  dart.setSignature(html$._ThrowsNodeValidator, {
    constructors: () => ({_ThrowsNodeValidator: [html$._ThrowsNodeValidator, [html$.NodeValidator]]}),
    methods: () => ({
      allowsElement: [core.bool, [html$.Element]],
      allowsAttribute: [core.bool, [html$.Element, core.String, core.String]]
    })
  });
  const _removeNode = Symbol('_removeNode');
  const _sanitizeElement = Symbol('_sanitizeElement');
  const _sanitizeUntrustedElement = Symbol('_sanitizeUntrustedElement');
  html$._ValidatingTreeSanitizer = class _ValidatingTreeSanitizer extends core.Object {
    _ValidatingTreeSanitizer(validator) {
      this.validator = validator;
    }
    sanitizeTree(node) {
      const walk = (function(node, parent) {
        this.sanitizeNode(node, parent);
        let child = node[dartx.lastChild];
        while (child != null) {
          let nextChild = child[dartx.previousNode];
          walk(child, node);
          child = nextChild;
        }
      }).bind(this);
      dart.fn(walk, dart.void, [html$.Node, html$.Node]);
      walk(node, null);
    }
    [_removeNode](node, parent) {
      if (parent == null) {
        node[dartx.remove]();
      } else {
        parent[_removeChild](node);
      }
    }
    [_sanitizeUntrustedElement](element, parent) {
      let corrupted = true;
      let attrs = null;
      let isAttr = null;
      try {
        attrs = dart.dload(element, 'attributes');
        isAttr = dart.dindex(attrs, 'is');
        let corruptedTest1 = html$.Element._hasCorruptedAttributes(dart.as(element, html$.Element));
        corrupted = dart.notNull(corruptedTest1) ? true : html$.Element._hasCorruptedAttributesAdditionalCheck(dart.as(element, html$.Element));
      } catch (e) {
      }

      let elementText = 'element unprintable';
      try {
        elementText = dart.toString(element);
      } catch (e) {
      }

      try {
        let elementTagName = html$.Element._safeTagName(element);
        this[_sanitizeElement](dart.as(element, html$.Element), parent, corrupted, elementText, elementTagName, dart.as(attrs, core.Map), dart.as(isAttr, core.String));
      } catch (e$) {
        if (dart.is(e$, core.ArgumentError)) {
          throw e$;
        } else {
          let e = e$;
          this[_removeNode](dart.as(element, html$.Node), parent);
          html$.window[dartx.console].warn(`Removing corrupted element ${elementText}`);
        }
      }

    }
    [_sanitizeElement](element, parent, corrupted, text, tag, attrs, isAttr) {
      if (false != corrupted) {
        this[_removeNode](element, parent);
        html$.window[dartx.console].warn(`Removing element due to corrupted attributes on <${text}>`);
        return;
      }
      if (!dart.notNull(this.validator.allowsElement(element))) {
        this[_removeNode](element, parent);
        html$.window[dartx.console].warn(`Removing disallowed element <${tag}> from ${parent}`);
        return;
      }
      if (isAttr != null) {
        if (!dart.notNull(this.validator.allowsAttribute(element, 'is', isAttr))) {
          this[_removeNode](element, parent);
          html$.window[dartx.console].warn('Removing disallowed type extension ' + `<${tag} is="${isAttr}">`);
          return;
        }
      }
      let keys = attrs[dartx.keys][dartx.toList]();
      for (let i = dart.notNull(attrs[dartx.length]) - 1; i >= 0; --i) {
        let name = keys[dartx.get](i);
        if (!dart.notNull(this.validator.allowsAttribute(element, dart.as(dart.dsend(name, 'toLowerCase'), core.String), dart.as(attrs[dartx.get](name), core.String)))) {
          html$.window[dartx.console].warn('Removing disallowed attribute ' + `<${tag} ${name}="${attrs[dartx.get](name)}">`);
          attrs[dartx.remove](name);
        }
      }
      if (dart.is(element, html$.TemplateElement)) {
        let template = element;
        this.sanitizeTree(template[dartx.content]);
      }
    }
    sanitizeNode(node, parent) {
      switch (node[dartx.nodeType]) {
        case html$.Node.ELEMENT_NODE:
        {
          this[_sanitizeUntrustedElement](node, parent);
          break;
        }
        case html$.Node.COMMENT_NODE:
        case html$.Node.DOCUMENT_FRAGMENT_NODE:
        case html$.Node.TEXT_NODE:
        case html$.Node.CDATA_SECTION_NODE:
        {
          break;
        }
        default:
        {
          this[_removeNode](node, parent);
        }
      }
    }
  };
  html$._ValidatingTreeSanitizer[dart.implements] = () => [html$.NodeTreeSanitizer];
  dart.setSignature(html$._ValidatingTreeSanitizer, {
    constructors: () => ({_ValidatingTreeSanitizer: [html$._ValidatingTreeSanitizer, [html$.NodeValidator]]}),
    methods: () => ({
      sanitizeTree: [dart.void, [html$.Node]],
      [_removeNode]: [dart.void, [html$.Node, html$.Node]],
      [_sanitizeUntrustedElement]: [dart.void, [dart.dynamic, html$.Node]],
      [_sanitizeElement]: [dart.void, [html$.Element, html$.Node, core.bool, core.String, core.String, core.Map, core.String]],
      sanitizeNode: [dart.void, [html$.Node, html$.Node]]
    })
  });
  html$.Point$ = math.Point$;
  html$.Point = math.Point;
  html$.Rectangle$ = math.Rectangle$;
  html$.Rectangle = math.Rectangle;
  html_common.SupportedBrowser = _metadata.SupportedBrowser;
  html_common.Unstable = _metadata.Unstable;
  html_common.DocsEditable = _metadata.DocsEditable;
  html_common.Experimental = _metadata.Experimental;
  html_common.DomName = _metadata.DomName;
  html_common.convertDartToNative_SerializedScriptValue = function(value) {
    return html_common.convertDartToNative_PrepareForStructuredClone(value);
  };
  dart.fn(html_common.convertDartToNative_SerializedScriptValue);
  html_common.convertNativeToDart_SerializedScriptValue = function(object) {
    return html_common.convertNativeToDart_AcceptStructuredClone(object, {mustCopy: true});
  };
  dart.fn(html_common.convertNativeToDart_SerializedScriptValue);
  html_common._StructuredClone = class _StructuredClone extends core.Object {
    _StructuredClone() {
      this.values = [];
      this.copies = [];
    }
    findSlot(value) {
      let length = this.values[dartx.length];
      for (let i = 0; i < dart.notNull(length); i++) {
        if (core.identical(this.values[dartx.get](i), value)) return i;
      }
      this.values[dartx.add](value);
      this.copies[dartx.add](null);
      return length;
    }
    readSlot(i) {
      return this.copies[dartx.get](i);
    }
    writeSlot(i, x) {
      this.copies[dartx.set](i, x);
    }
    cleanupSlots() {}
    walk(e) {
      if (e == null) return e;
      if (typeof e == 'boolean') return e;
      if (typeof e == 'number') return e;
      if (typeof e == 'string') return e;
      if (dart.is(e, core.DateTime)) {
        return html_common.convertDartToNative_DateTime(e);
      }
      if (dart.is(e, core.RegExp)) {
        dart.throw(new core.UnimplementedError('structured clone of RegExp'));
      }
      if (dart.is(e, html$.File)) return e;
      if (dart.is(e, html$.Blob)) return e;
      if (dart.is(e, html$.FileList)) return e;
      if (dart.is(e, html$.ImageData)) return e;
      if (dart.notNull(this.cloneNotRequired(e))) return e;
      if (dart.is(e, core.Map)) {
        let slot = this.findSlot(e);
        let copy = this.readSlot(slot);
        if (copy != null) return copy;
        copy = this.newJsMap();
        this.writeSlot(slot, copy);
        e[dartx.forEach](dart.fn((key, value) => {
          this.putIntoMap(copy, key, this.walk(value));
        }, dart.void, [dart.dynamic, dart.dynamic]));
        return copy;
      }
      if (dart.is(e, core.List)) {
        let slot = this.findSlot(e);
        let copy = this.readSlot(slot);
        if (copy != null) return copy;
        copy = this.copyList(e, slot);
        return copy;
      }
      dart.throw(new core.UnimplementedError('structured clone of other type'));
    }
    copyList(e, slot) {
      let i = 0;
      let length = e[dartx.length];
      let copy = this.newJsList(length);
      this.writeSlot(slot, copy);
      for (; i < dart.notNull(length); i++) {
        dart.dsetindex(copy, i, this.walk(e[dartx.get](i)));
      }
      return copy;
    }
    convertDartToNative_PrepareForStructuredClone(value) {
      let copy = this.walk(value);
      this.cleanupSlots();
      return copy;
    }
  };
  dart.setSignature(html_common._StructuredClone, {
    methods: () => ({
      findSlot: [core.int, [dart.dynamic]],
      readSlot: [dart.dynamic, [core.int]],
      writeSlot: [dart.dynamic, [core.int, dart.dynamic]],
      cleanupSlots: [dart.dynamic, []],
      walk: [dart.dynamic, [dart.dynamic]],
      copyList: [dart.dynamic, [core.List, core.int]],
      convertDartToNative_PrepareForStructuredClone: [dart.dynamic, [dart.dynamic]]
    })
  });
  html_common._AcceptStructuredClone = class _AcceptStructuredClone extends core.Object {
    _AcceptStructuredClone() {
      this.values = [];
      this.copies = [];
      this.mustCopy = false;
    }
    findSlot(value) {
      let length = this.values[dartx.length];
      for (let i = 0; i < dart.notNull(length); i++) {
        if (dart.notNull(this.identicalInJs(this.values[dartx.get](i), value))) return i;
      }
      this.values[dartx.add](value);
      this.copies[dartx.add](null);
      return length;
    }
    readSlot(i) {
      return this.copies[dartx.get](i);
    }
    writeSlot(i, x) {
      this.copies[dartx.set](i, x);
    }
    walk(e) {
      if (e == null) return e;
      if (typeof e == 'boolean') return e;
      if (typeof e == 'number') return e;
      if (typeof e == 'string') return e;
      if (dart.notNull(html_common.isJavaScriptDate(e))) {
        return html_common.convertNativeToDart_DateTime(e);
      }
      if (dart.notNull(html_common.isJavaScriptRegExp(e))) {
        dart.throw(new core.UnimplementedError('structured clone of RegExp'));
      }
      if (dart.notNull(html_common.isJavaScriptPromise(e))) {
        return html_common.convertNativePromiseToDartFuture(e);
      }
      if (dart.notNull(html_common.isJavaScriptSimpleObject(e))) {
        let slot = this.findSlot(e);
        let copy = this.readSlot(slot);
        if (copy != null) return copy;
        copy = dart.map();
        this.writeSlot(slot, copy);
        this.forEachJsField(e, dart.fn((key, value) => dart.dsetindex(copy, key, this.walk(value))));
        return copy;
      }
      if (dart.notNull(html_common.isJavaScriptArray(e))) {
        let slot = this.findSlot(e);
        let copy = this.readSlot(slot);
        if (copy != null) return copy;
        let length = dart.as(dart.dload(e, 'length'), core.int);
        copy = dart.notNull(this.mustCopy) ? this.newDartList(length) : e;
        this.writeSlot(slot, copy);
        for (let i = 0; i < dart.notNull(length); i++) {
          dart.dsetindex(copy, i, this.walk(dart.dindex(e, i)));
        }
        return copy;
      }
      return e;
    }
    convertNativeToDart_AcceptStructuredClone(object, opts) {
      let mustCopy = opts && 'mustCopy' in opts ? opts.mustCopy : false;
      this.mustCopy = dart.as(mustCopy, core.bool);
      let copy = this.walk(object);
      return copy;
    }
  };
  dart.setSignature(html_common._AcceptStructuredClone, {
    methods: () => ({
      findSlot: [core.int, [dart.dynamic]],
      readSlot: [dart.dynamic, [core.int]],
      writeSlot: [dart.dynamic, [core.int, dart.dynamic]],
      walk: [dart.dynamic, [dart.dynamic]],
      convertNativeToDart_AcceptStructuredClone: [dart.dynamic, [dart.dynamic], {mustCopy: dart.dynamic}]
    })
  });
  html_common.ContextAttributes = class ContextAttributes extends core.Object {
    ContextAttributes(alpha, antialias, depth, failIfMajorPerformanceCaveat, premultipliedAlpha, preserveDrawingBuffer, stencil) {
      this.alpha = alpha;
      this.antialias = antialias;
      this.depth = depth;
      this.failIfMajorPerformanceCaveat = failIfMajorPerformanceCaveat;
      this.premultipliedAlpha = premultipliedAlpha;
      this.preserveDrawingBuffer = preserveDrawingBuffer;
      this.stencil = stencil;
    }
  };
  dart.setSignature(html_common.ContextAttributes, {
    constructors: () => ({ContextAttributes: [html_common.ContextAttributes, [core.bool, core.bool, core.bool, core.bool, core.bool, core.bool, core.bool]]})
  });
  html_common.convertNativeToDart_ContextAttributes = function(nativeContextAttributes) {
    return new html_common.ContextAttributes(nativeContextAttributes.alpha, nativeContextAttributes.antialias, nativeContextAttributes.depth, nativeContextAttributes.failIfMajorPerformanceCaveat, nativeContextAttributes.premultipliedAlpha, nativeContextAttributes.preserveDrawingBuffer, nativeContextAttributes.stencil);
  };
  dart.fn(html_common.convertNativeToDart_ContextAttributes);
  html_common._TypedImageData = class _TypedImageData extends core.Object {
    _TypedImageData(data, height, width) {
      this.data = data;
      this.height = height;
      this.width = width;
    }
  };
  html_common._TypedImageData[dart.implements] = () => [html$.ImageData];
  dart.setSignature(html_common._TypedImageData, {
    constructors: () => ({_TypedImageData: [html_common._TypedImageData, [typed_data.Uint8ClampedList, core.int, core.int]]})
  });
  html_common.convertNativeToDart_ImageData = function(nativeImageData) {
    0;
    if (dart.is(nativeImageData, html$.ImageData)) {
      let data = nativeImageData[dartx.data];
      if (data.constructor === Array) {
        if (typeof CanvasPixelArray !== "undefined") {
          data.constructor = CanvasPixelArray;
          data.BYTES_PER_ELEMENT = 1;
        }
      }
      return nativeImageData;
    }
    return new html_common._TypedImageData(nativeImageData.data, nativeImageData.height, nativeImageData.width);
  };
  dart.fn(html_common.convertNativeToDart_ImageData, html$.ImageData, [dart.dynamic]);
  html_common.convertDartToNative_ImageData = function(imageData) {
    if (dart.is(imageData, html_common._TypedImageData)) {
      return {data: imageData.data, height: imageData.height, width: imageData.width};
    }
    return imageData;
  };
  dart.fn(html_common.convertDartToNative_ImageData, dart.dynamic, [html$.ImageData]);
  html_common._serializedScriptValue = 'num|String|bool|' + 'JSExtendableArray|=Object|' + 'Blob|File|NativeByteBuffer|NativeTypedData';
  html_common.annotation_Creates_SerializedScriptValue = dart.const(new _js_helper.Creates(html_common._serializedScriptValue));
  html_common.annotation_Returns_SerializedScriptValue = dart.const(new _js_helper.Returns(html_common._serializedScriptValue));
  html_common.convertNativeToDart_Dictionary = function(object) {
    if (object == null) return null;
    let dict = dart.map();
    let keys = Object.getOwnPropertyNames(object);
    for (let key of dart.as(keys, core.Iterable)) {
      dict[dartx.set](key, object[key]);
    }
    return dict;
  };
  dart.fn(html_common.convertNativeToDart_Dictionary, core.Map, [dart.dynamic]);
  html_common.convertDartToNative_Dictionary = function(dict, postCreate) {
    if (postCreate === void 0) postCreate = null;
    if (dict == null) return null;
    let object = {};
    if (postCreate != null) {
      dart.dcall(postCreate, object);
    }
    dict[dartx.forEach](dart.fn((key, value) => {
      object[key] = value;
    }, dart.void, [core.String, dart.dynamic]));
    return object;
  };
  dart.fn(html_common.convertDartToNative_Dictionary, dart.dynamic, [core.Map], [dart.functionType(dart.void, [dart.dynamic])]);
  html_common.convertDartToNative_StringArray = function(input) {
    return input;
  };
  dart.fn(html_common.convertDartToNative_StringArray, core.List, [core.List$(core.String)]);
  html_common.convertNativeToDart_DateTime = function(date) {
    let millisSinceEpoch = date.getTime();
    return new core.DateTime.fromMillisecondsSinceEpoch(millisSinceEpoch, {isUtc: true});
  };
  dart.fn(html_common.convertNativeToDart_DateTime, core.DateTime, [dart.dynamic]);
  html_common.convertDartToNative_DateTime = function(date) {
    return new Date(date.millisecondsSinceEpoch);
  };
  dart.fn(html_common.convertDartToNative_DateTime, dart.dynamic, [core.DateTime]);
  html_common.convertDartToNative_PrepareForStructuredClone = function(value) {
    return new html_common._StructuredCloneDart2Js().convertDartToNative_PrepareForStructuredClone(value);
  };
  dart.fn(html_common.convertDartToNative_PrepareForStructuredClone);
  html_common.convertNativeToDart_AcceptStructuredClone = function(object, opts) {
    let mustCopy = opts && 'mustCopy' in opts ? opts.mustCopy : false;
    return new html_common._AcceptStructuredCloneDart2Js().convertNativeToDart_AcceptStructuredClone(object, {mustCopy: mustCopy});
  };
  dart.fn(html_common.convertNativeToDart_AcceptStructuredClone, dart.dynamic, [dart.dynamic], {mustCopy: dart.dynamic});
  html_common._StructuredCloneDart2Js = class _StructuredCloneDart2Js extends html_common._StructuredClone {
    _StructuredCloneDart2Js() {
      super._StructuredClone();
    }
    newJsMap() {
      return {};
    }
    putIntoMap(map, key, value) {
      return map[key] = value;
    }
    newJsList(length) {
      return new Array(length);
    }
    cloneNotRequired(e) {
      return dart.is(e, _native_typed_data.NativeByteBuffer) || dart.is(e, _native_typed_data.NativeTypedData);
    }
  };
  dart.setSignature(html_common._StructuredCloneDart2Js, {
    methods: () => ({
      newJsMap: [dart.dynamic, []],
      putIntoMap: [dart.void, [dart.dynamic, dart.dynamic, dart.dynamic]],
      newJsList: [dart.dynamic, [dart.dynamic]],
      cloneNotRequired: [core.bool, [dart.dynamic]]
    })
  });
  html_common._AcceptStructuredCloneDart2Js = class _AcceptStructuredCloneDart2Js extends html_common._AcceptStructuredClone {
    _AcceptStructuredCloneDart2Js() {
      super._AcceptStructuredClone();
    }
    newJsList(length) {
      return new Array(length);
    }
    newDartList(length) {
      return this.newJsList(length);
    }
    identicalInJs(a, b) {
      return core.identical(a, b);
    }
    forEachJsField(object, action) {
      for (let key of Object.keys(object)) {
        dart.dcall(action, key, object[key]);
      }
    }
  };
  dart.setSignature(html_common._AcceptStructuredCloneDart2Js, {
    methods: () => ({
      newJsList: [dart.dynamic, [dart.dynamic]],
      newDartList: [dart.dynamic, [dart.dynamic]],
      identicalInJs: [core.bool, [dart.dynamic, dart.dynamic]],
      forEachJsField: [dart.void, [dart.dynamic, dart.dynamic]]
    })
  });
  html_common.isJavaScriptDate = function(value) {
    return value instanceof Date;
  };
  dart.fn(html_common.isJavaScriptDate, core.bool, [dart.dynamic]);
  html_common.isJavaScriptRegExp = function(value) {
    return value instanceof RegExp;
  };
  dart.fn(html_common.isJavaScriptRegExp, core.bool, [dart.dynamic]);
  html_common.isJavaScriptArray = function(value) {
    return value instanceof Array;
  };
  dart.fn(html_common.isJavaScriptArray, core.bool, [dart.dynamic]);
  html_common.isJavaScriptSimpleObject = function(value) {
    let proto = Object.getPrototypeOf(value);
    return proto === Object.prototype || proto === null;
  };
  dart.fn(html_common.isJavaScriptSimpleObject, core.bool, [dart.dynamic]);
  html_common.isImmutableJavaScriptArray = function(value) {
    return !!value.immutable$list;
  };
  dart.fn(html_common.isImmutableJavaScriptArray, core.bool, [dart.dynamic]);
  html_common.isJavaScriptPromise = function(value) {
    return typeof Promise != "undefined" && value instanceof Promise;
  };
  dart.fn(html_common.isJavaScriptPromise, core.bool, [dart.dynamic]);
  html_common.convertNativePromiseToDartFuture = function(promise) {
    let completer = async.Completer.new();
    let then = _js_helper.convertDartClosureToJS(dart.functionType(dart.void, [dart.dynamic]))(dart.fn(result => completer.complete(result), dart.void, [dart.dynamic]), 1);
    let error = _js_helper.convertDartClosureToJS(dart.functionType(dart.void, [dart.dynamic]))(dart.fn(result => completer.completeError(result), dart.void, [dart.dynamic]), 1);
    let newPromise = promise.then(then).catch(error);
    return completer.future;
  };
  dart.fn(html_common.convertNativePromiseToDartFuture, async.Future, [dart.dynamic]);
  html_common.Device = class Device extends core.Object {
    static get userAgent() {
      return html$.window[dartx.navigator][dartx.userAgent];
    }
    static get isOpera() {
      if (html_common.Device._isOpera == null) {
        html_common.Device._isOpera = html_common.Device.userAgent[dartx.contains]("Opera", 0);
      }
      return html_common.Device._isOpera;
    }
    static get isIE() {
      if (html_common.Device._isIE == null) {
        html_common.Device._isIE = !dart.notNull(html_common.Device.isOpera) && dart.notNull(html_common.Device.userAgent[dartx.contains]("Trident/", 0));
      }
      return html_common.Device._isIE;
    }
    static get isFirefox() {
      if (html_common.Device._isFirefox == null) {
        html_common.Device._isFirefox = html_common.Device.userAgent[dartx.contains]("Firefox", 0);
      }
      return html_common.Device._isFirefox;
    }
    static get isWebKit() {
      if (html_common.Device._isWebKit == null) {
        html_common.Device._isWebKit = !dart.notNull(html_common.Device.isOpera) && dart.notNull(html_common.Device.userAgent[dartx.contains]("WebKit", 0));
      }
      return html_common.Device._isWebKit;
    }
    static get cssPrefix() {
      let prefix = html_common.Device._cachedCssPrefix;
      if (prefix != null) return prefix;
      if (dart.notNull(html_common.Device.isFirefox)) {
        prefix = '-moz-';
      } else if (dart.notNull(html_common.Device.isIE)) {
        prefix = '-ms-';
      } else if (dart.notNull(html_common.Device.isOpera)) {
        prefix = '-o-';
      } else {
        prefix = '-webkit-';
      }
      return html_common.Device._cachedCssPrefix = prefix;
    }
    static get propertyPrefix() {
      let prefix = html_common.Device._cachedPropertyPrefix;
      if (prefix != null) return prefix;
      if (dart.notNull(html_common.Device.isFirefox)) {
        prefix = 'moz';
      } else if (dart.notNull(html_common.Device.isIE)) {
        prefix = 'ms';
      } else if (dart.notNull(html_common.Device.isOpera)) {
        prefix = 'o';
      } else {
        prefix = 'webkit';
      }
      return html_common.Device._cachedPropertyPrefix = prefix;
    }
    static isEventTypeSupported(eventType) {
      try {
        let e = html$.Event.eventType(eventType, '');
        return dart.is(e, html$.Event);
      } catch (_) {
      }

      return false;
    }
  };
  dart.setSignature(html_common.Device, {
    statics: () => ({isEventTypeSupported: [core.bool, [core.String]]}),
    names: ['isEventTypeSupported']
  });
  html_common.Device._isOpera = null;
  html_common.Device._isIE = null;
  html_common.Device._isFirefox = null;
  html_common.Device._isWebKit = null;
  html_common.Device._cachedCssPrefix = null;
  html_common.Device._cachedPropertyPrefix = null;
  const _childNodes = Symbol('_childNodes');
  const _node = Symbol('_node');
  const _iterable$0 = Symbol('_iterable');
  const _filtered = Symbol('_filtered');
  html_common.FilteredElementList = class FilteredElementList extends collection.ListBase$(html$.Element) {
    FilteredElementList(node) {
      this[_childNodes] = node[dartx.nodes];
      this[_node] = node;
    }
    get [_iterable$0]() {
      return this[_childNodes][dartx.where](dart.fn(n => dart.is(n, html$.Element), core.bool, [html$.Node]))[dartx.map](html$.Element)(dart.fn(n => dart.as(n, html$.Element), html$.Element, [html$.Node]));
    }
    get [_filtered]() {
      return core.List$(html$.Element).from(this[_iterable$0], {growable: false});
    }
    forEach(f) {
      this[_filtered][dartx.forEach](f);
    }
    set(index, value) {
      this.get(index)[dartx.replaceWith](value);
      return value;
    }
    set length(newLength) {
      let len = this.length;
      if (dart.notNull(newLength) >= dart.notNull(len)) {
        return;
      } else if (dart.notNull(newLength) < 0) {
        dart.throw(new core.ArgumentError("Invalid list length"));
      }
      this.removeRange(newLength, len);
    }
    add(value) {
      this[_childNodes][dartx.add](value);
    }
    addAll(iterable) {
      for (let element of iterable) {
        this.add(element);
      }
    }
    contains(needle) {
      if (!dart.is(needle, html$.Element)) return false;
      let element = dart.as(needle, html$.Element);
      return dart.equals(element[dartx.parentNode], this[_node]);
    }
    get reversed() {
      return this[_filtered][dartx.reversed];
    }
    sort(compare) {
      if (compare === void 0) compare = null;
      dart.throw(new core.UnsupportedError('Cannot sort filtered list'));
    }
    setRange(start, end, iterable, skipCount) {
      if (skipCount === void 0) skipCount = 0;
      dart.throw(new core.UnsupportedError('Cannot setRange on filtered list'));
    }
    fillRange(start, end, fillValue) {
      if (fillValue === void 0) fillValue = null;
      dart.throw(new core.UnsupportedError('Cannot fillRange on filtered list'));
    }
    replaceRange(start, end, iterable) {
      dart.throw(new core.UnsupportedError('Cannot replaceRange on filtered list'));
    }
    removeRange(start, end) {
      core.List.from(this[_iterable$0][dartx.skip](start)[dartx.take](dart.notNull(end) - dart.notNull(start)))[dartx.forEach](dart.fn(el => dart.dsend(el, 'remove'), dart.void, [dart.dynamic]));
    }
    clear() {
      this[_childNodes][dartx.clear]();
    }
    removeLast() {
      let result = this[_iterable$0][dartx.last];
      if (result != null) {
        result[dartx.remove]();
      }
      return result;
    }
    insert(index, value) {
      if (index == this.length) {
        this.add(value);
      } else {
        let element = this[_iterable$0][dartx.elementAt](index);
        element[dartx.parentNode][dartx.insertBefore](value, element);
      }
    }
    insertAll(index, iterable) {
      if (index == this.length) {
        this.addAll(iterable);
      } else {
        let element = this[_iterable$0][dartx.elementAt](index);
        element[dartx.parentNode][dartx.insertAllBefore](iterable, element);
      }
    }
    removeAt(index) {
      let result = this.get(index);
      result[dartx.remove]();
      return result;
    }
    remove(element) {
      if (!dart.is(element, html$.Element)) return false;
      if (dart.notNull(this.contains(element))) {
        dart.as(element, html$.Element)[dartx.remove]();
        return true;
      } else {
        return false;
      }
    }
    get length() {
      return this[_iterable$0][dartx.length];
    }
    get(index) {
      return this[_iterable$0][dartx.elementAt](index);
    }
    get iterator() {
      return this[_filtered][dartx.iterator];
    }
    get rawList() {
      return this[_node][dartx.childNodes];
    }
  };
  html_common.FilteredElementList[dart.implements] = () => [html_common.NodeListWrapper];
  dart.setSignature(html_common.FilteredElementList, {
    constructors: () => ({FilteredElementList: [html_common.FilteredElementList, [html$.Node]]}),
    methods: () => ({
      forEach: [dart.void, [dart.functionType(dart.void, [html$.Element])]],
      set: [dart.void, [core.int, html$.Element]],
      add: [dart.void, [html$.Element]],
      addAll: [dart.void, [core.Iterable$(html$.Element)]],
      sort: [dart.void, [], [dart.functionType(core.int, [html$.Element, html$.Element])]],
      setRange: [dart.void, [core.int, core.int, core.Iterable$(html$.Element)], [core.int]],
      fillRange: [dart.void, [core.int, core.int], [html$.Element]],
      replaceRange: [dart.void, [core.int, core.int, core.Iterable$(html$.Element)]],
      removeLast: [html$.Element, []],
      insert: [dart.void, [core.int, html$.Element]],
      insertAll: [dart.void, [core.int, core.Iterable$(html$.Element)]],
      removeAt: [html$.Element, [core.int]],
      get: [html$.Element, [core.int]]
    })
  });
  dart.defineExtensionMembers(html_common.FilteredElementList, [
    'forEach',
    'set',
    'add',
    'addAll',
    'contains',
    'sort',
    'setRange',
    'fillRange',
    'replaceRange',
    'removeRange',
    'clear',
    'removeLast',
    'insert',
    'insertAll',
    'removeAt',
    'remove',
    'get',
    'length',
    'reversed',
    'length',
    'iterator'
  ]);
  html_common.Lists = class Lists extends core.Object {
    static indexOf(a, element, startIndex, endIndex) {
      if (dart.notNull(startIndex) >= dart.notNull(a[dartx.length])) {
        return -1;
      }
      if (dart.notNull(startIndex) < 0) {
        startIndex = 0;
      }
      for (let i = startIndex; dart.notNull(i) < dart.notNull(endIndex); i = dart.notNull(i) + 1) {
        if (dart.equals(a[dartx.get](i), element)) {
          return i;
        }
      }
      return -1;
    }
    static lastIndexOf(a, element, startIndex) {
      if (dart.notNull(startIndex) < 0) {
        return -1;
      }
      if (dart.notNull(startIndex) >= dart.notNull(a[dartx.length])) {
        startIndex = dart.notNull(a[dartx.length]) - 1;
      }
      for (let i = startIndex; dart.notNull(i) >= 0; i = dart.notNull(i) - 1) {
        if (dart.equals(a[dartx.get](i), element)) {
          return i;
        }
      }
      return -1;
    }
    static getRange(a, start, end, accumulator) {
      if (dart.notNull(start) < 0) dart.throw(new core.RangeError.value(start));
      if (dart.notNull(end) < dart.notNull(start)) dart.throw(new core.RangeError.value(end));
      if (dart.notNull(end) > dart.notNull(a[dartx.length])) dart.throw(new core.RangeError.value(end));
      for (let i = start; dart.notNull(i) < dart.notNull(end); i = dart.notNull(i) + 1) {
        accumulator[dartx.add](a[dartx.get](i));
      }
      return accumulator;
    }
  };
  dart.setSignature(html_common.Lists, {
    statics: () => ({
      indexOf: [core.int, [core.List, core.Object, core.int, core.int]],
      lastIndexOf: [core.int, [core.List, core.Object, core.int]],
      getRange: [core.List, [core.List, core.int, core.int, core.List]]
    }),
    names: ['indexOf', 'lastIndexOf', 'getRange']
  });
  html_common.NodeListWrapper = class NodeListWrapper extends core.Object {};
  svg$._SvgElementFactoryProvider = class _SvgElementFactoryProvider extends core.Object {
    static createSvgElement_tag(tag) {
      let temp = html$.document[dartx.createElementNS]("http://www.w3.org/2000/svg", tag);
      return dart.as(temp, svg$.SvgElement);
    }
  };
  dart.setSignature(svg$._SvgElementFactoryProvider, {
    statics: () => ({createSvgElement_tag: [svg$.SvgElement, [core.String]]}),
    names: ['createSvgElement_tag']
  });
  const _children$ = Symbol('_children');
  const _svgClassName = Symbol('_svgClassName');
  dart.defineExtensionNames([
    'classes',
    'children',
    'children',
    'outerHtml',
    'innerHtml',
    'innerHtml',
    'createFragment',
    'insertAdjacentText',
    'insertAdjacentHtml',
    'insertAdjacentElement',
    'isContentEditable',
    'click',
    'blur',
    'focus',
    'onAbort',
    'onBlur',
    'onCanPlay',
    'onCanPlayThrough',
    'onChange',
    'onClick',
    'onContextMenu',
    'onDoubleClick',
    'onDrag',
    'onDragEnd',
    'onDragEnter',
    'onDragLeave',
    'onDragOver',
    'onDragStart',
    'onDrop',
    'onDurationChange',
    'onEmptied',
    'onEnded',
    'onError',
    'onFocus',
    'onInput',
    'onInvalid',
    'onKeyDown',
    'onKeyPress',
    'onKeyUp',
    'onLoad',
    'onLoadedData',
    'onLoadedMetadata',
    'onMouseDown',
    'onMouseEnter',
    'onMouseLeave',
    'onMouseMove',
    'onMouseOut',
    'onMouseOver',
    'onMouseUp',
    'onMouseWheel',
    'onPause',
    'onPlay',
    'onPlaying',
    'onRateChange',
    'onReset',
    'onResize',
    'onScroll',
    'onSeeked',
    'onSeeking',
    'onSelect',
    'onStalled',
    'onSubmit',
    'onSuspend',
    'onTimeUpdate',
    'onVolumeChange',
    'onWaiting',
    'ownerSvgElement',
    'viewportElement'
  ]);
  svg$.SvgElement = class SvgElement extends html$.Element {
    static tag(tag) {
      return dart.as(html$.document[dartx.createElementNS]("http://www.w3.org/2000/svg", tag), svg$.SvgElement);
    }
    static svg(svg, opts) {
      let validator = opts && 'validator' in opts ? opts.validator : null;
      let treeSanitizer = opts && 'treeSanitizer' in opts ? opts.treeSanitizer : null;
      if (validator == null && treeSanitizer == null) {
        validator = new html$.NodeValidatorBuilder.common();
        validator.allowSvg();
      }
      let match = svg$.SvgElement._START_TAG_REGEXP.firstMatch(svg);
      let parentElement = null;
      if (match != null && match.group(1)[dartx.toLowerCase]() == 'svg') {
        parentElement = html$.document[dartx.body];
      } else {
        parentElement = svg$.SvgSvgElement.new();
      }
      let fragment = dart.dsend(parentElement, 'createFragment', svg, {validator: validator, treeSanitizer: treeSanitizer});
      return dart.as(dart.dload(dart.dsend(dart.dload(fragment, 'nodes'), 'where', dart.fn(e => dart.is(e, svg$.SvgElement), core.bool, [dart.dynamic])), 'single'), svg$.SvgElement);
    }
    get [dartx.classes]() {
      return new svg$._AttributeClassSet(this);
    }
    set [dartx.classes](value) {
      super[dartx.classes] = value;
    }
    get [dartx.children]() {
      return new html_common.FilteredElementList(this);
    }
    set [dartx.children](value) {
      let children = this[dartx.children];
      children[dartx.clear]();
      children[dartx.addAll](value);
    }
    get [dartx.outerHtml]() {
      let container = html$.Element.tag("div");
      let cloned = dart.as(this[dartx.clone](true), svg$.SvgElement);
      container[dartx.children][dartx.add](cloned);
      return container[dartx.innerHtml];
    }
    get [dartx.innerHtml]() {
      let container = html$.Element.tag("div");
      let cloned = dart.as(this[dartx.clone](true), svg$.SvgElement);
      container[dartx.children][dartx.addAll](cloned[dartx.children]);
      return container[dartx.innerHtml];
    }
    set [dartx.innerHtml](value) {
      this[dartx.setInnerHtml](value);
    }
    [dartx.createFragment](svg, opts) {
      let validator = opts && 'validator' in opts ? opts.validator : null;
      let treeSanitizer = opts && 'treeSanitizer' in opts ? opts.treeSanitizer : null;
      if (treeSanitizer == null) {
        if (validator == null) {
          validator = new html$.NodeValidatorBuilder.common();
          validator.allowSvg();
        }
        treeSanitizer = html$.NodeTreeSanitizer.new(validator);
      }
      let html = `<svg version="1.1">${svg}</svg>`;
      let fragment = html$.document[dartx.body][dartx.createFragment](html, {treeSanitizer: treeSanitizer});
      let svgFragment = html$.DocumentFragment.new();
      let root = fragment[dartx.nodes][dartx.single];
      while (root[dartx.firstChild] != null) {
        svgFragment[dartx.append](root[dartx.firstChild]);
      }
      return svgFragment;
    }
    [dartx.insertAdjacentText](where, text) {
      dart.throw(new core.UnsupportedError("Cannot invoke insertAdjacentText on SVG."));
    }
    [dartx.insertAdjacentHtml](where, text, opts) {
      let validator = opts && 'validator' in opts ? opts.validator : null;
      let treeSanitizer = opts && 'treeSanitizer' in opts ? opts.treeSanitizer : null;
      dart.throw(new core.UnsupportedError("Cannot invoke insertAdjacentHtml on SVG."));
    }
    [dartx.insertAdjacentElement](where, element) {
      dart.throw(new core.UnsupportedError("Cannot invoke insertAdjacentElement on SVG."));
    }
    get [_children$]() {
      dart.throw(new core.UnsupportedError("Cannot get _children on SVG."));
    }
    get [dartx.isContentEditable]() {
      return false;
    }
    [dartx.click]() {
      dart.throw(new core.UnsupportedError("Cannot invoke click SVG."));
    }
    static isTagSupported(tag) {
      let e = svg$.SvgElement.tag(tag);
      return dart.is(e, svg$.SvgElement) && !dart.is(e, html$.UnknownElement);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      this[dartx.ownerSvgElement] = null;
      this[dartx.viewportElement] = null;
      super.created();
    }
    get [_svgClassName]() {
      return this.className;
    }
    get [dartx.ownerSvgElement]() {
      return this.ownerSVGElement;
    }
    get [dartx.viewportElement]() {
      return this.viewportElement;
    }
    [dartx.blur]() {
      return this.blur();
    }
    [dartx.focus]() {
      return this.focus();
    }
    get [dartx.onAbort]() {
      return svg$.SvgElement.abortEvent.forElement(this);
    }
    get [dartx.onBlur]() {
      return svg$.SvgElement.blurEvent.forElement(this);
    }
    get [dartx.onCanPlay]() {
      return svg$.SvgElement.canPlayEvent.forElement(this);
    }
    get [dartx.onCanPlayThrough]() {
      return svg$.SvgElement.canPlayThroughEvent.forElement(this);
    }
    get [dartx.onChange]() {
      return svg$.SvgElement.changeEvent.forElement(this);
    }
    get [dartx.onClick]() {
      return svg$.SvgElement.clickEvent.forElement(this);
    }
    get [dartx.onContextMenu]() {
      return svg$.SvgElement.contextMenuEvent.forElement(this);
    }
    get [dartx.onDoubleClick]() {
      return svg$.SvgElement.doubleClickEvent.forElement(this);
    }
    get [dartx.onDrag]() {
      return svg$.SvgElement.dragEvent.forElement(this);
    }
    get [dartx.onDragEnd]() {
      return svg$.SvgElement.dragEndEvent.forElement(this);
    }
    get [dartx.onDragEnter]() {
      return svg$.SvgElement.dragEnterEvent.forElement(this);
    }
    get [dartx.onDragLeave]() {
      return svg$.SvgElement.dragLeaveEvent.forElement(this);
    }
    get [dartx.onDragOver]() {
      return svg$.SvgElement.dragOverEvent.forElement(this);
    }
    get [dartx.onDragStart]() {
      return svg$.SvgElement.dragStartEvent.forElement(this);
    }
    get [dartx.onDrop]() {
      return svg$.SvgElement.dropEvent.forElement(this);
    }
    get [dartx.onDurationChange]() {
      return svg$.SvgElement.durationChangeEvent.forElement(this);
    }
    get [dartx.onEmptied]() {
      return svg$.SvgElement.emptiedEvent.forElement(this);
    }
    get [dartx.onEnded]() {
      return svg$.SvgElement.endedEvent.forElement(this);
    }
    get [dartx.onError]() {
      return svg$.SvgElement.errorEvent.forElement(this);
    }
    get [dartx.onFocus]() {
      return svg$.SvgElement.focusEvent.forElement(this);
    }
    get [dartx.onInput]() {
      return svg$.SvgElement.inputEvent.forElement(this);
    }
    get [dartx.onInvalid]() {
      return svg$.SvgElement.invalidEvent.forElement(this);
    }
    get [dartx.onKeyDown]() {
      return svg$.SvgElement.keyDownEvent.forElement(this);
    }
    get [dartx.onKeyPress]() {
      return svg$.SvgElement.keyPressEvent.forElement(this);
    }
    get [dartx.onKeyUp]() {
      return svg$.SvgElement.keyUpEvent.forElement(this);
    }
    get [dartx.onLoad]() {
      return svg$.SvgElement.loadEvent.forElement(this);
    }
    get [dartx.onLoadedData]() {
      return svg$.SvgElement.loadedDataEvent.forElement(this);
    }
    get [dartx.onLoadedMetadata]() {
      return svg$.SvgElement.loadedMetadataEvent.forElement(this);
    }
    get [dartx.onMouseDown]() {
      return svg$.SvgElement.mouseDownEvent.forElement(this);
    }
    get [dartx.onMouseEnter]() {
      return svg$.SvgElement.mouseEnterEvent.forElement(this);
    }
    get [dartx.onMouseLeave]() {
      return svg$.SvgElement.mouseLeaveEvent.forElement(this);
    }
    get [dartx.onMouseMove]() {
      return svg$.SvgElement.mouseMoveEvent.forElement(this);
    }
    get [dartx.onMouseOut]() {
      return svg$.SvgElement.mouseOutEvent.forElement(this);
    }
    get [dartx.onMouseOver]() {
      return svg$.SvgElement.mouseOverEvent.forElement(this);
    }
    get [dartx.onMouseUp]() {
      return svg$.SvgElement.mouseUpEvent.forElement(this);
    }
    get [dartx.onMouseWheel]() {
      return svg$.SvgElement.mouseWheelEvent.forElement(this);
    }
    get [dartx.onPause]() {
      return svg$.SvgElement.pauseEvent.forElement(this);
    }
    get [dartx.onPlay]() {
      return svg$.SvgElement.playEvent.forElement(this);
    }
    get [dartx.onPlaying]() {
      return svg$.SvgElement.playingEvent.forElement(this);
    }
    get [dartx.onRateChange]() {
      return svg$.SvgElement.rateChangeEvent.forElement(this);
    }
    get [dartx.onReset]() {
      return svg$.SvgElement.resetEvent.forElement(this);
    }
    get [dartx.onResize]() {
      return svg$.SvgElement.resizeEvent.forElement(this);
    }
    get [dartx.onScroll]() {
      return svg$.SvgElement.scrollEvent.forElement(this);
    }
    get [dartx.onSeeked]() {
      return svg$.SvgElement.seekedEvent.forElement(this);
    }
    get [dartx.onSeeking]() {
      return svg$.SvgElement.seekingEvent.forElement(this);
    }
    get [dartx.onSelect]() {
      return svg$.SvgElement.selectEvent.forElement(this);
    }
    get [dartx.onStalled]() {
      return svg$.SvgElement.stalledEvent.forElement(this);
    }
    get [dartx.onSubmit]() {
      return svg$.SvgElement.submitEvent.forElement(this);
    }
    get [dartx.onSuspend]() {
      return svg$.SvgElement.suspendEvent.forElement(this);
    }
    get [dartx.onTimeUpdate]() {
      return svg$.SvgElement.timeUpdateEvent.forElement(this);
    }
    get [dartx.onVolumeChange]() {
      return svg$.SvgElement.volumeChangeEvent.forElement(this);
    }
    get [dartx.onWaiting]() {
      return svg$.SvgElement.waitingEvent.forElement(this);
    }
  };
  dart.defineNamedConstructor(svg$.SvgElement, 'created');
  svg$.SvgElement[dart.implements] = () => [html$.GlobalEventHandlers];
  dart.setSignature(svg$.SvgElement, {
    constructors: () => ({
      tag: [svg$.SvgElement, [core.String]],
      svg: [svg$.SvgElement, [core.String], {validator: html$.NodeValidator, treeSanitizer: html$.NodeTreeSanitizer}],
      _: [svg$.SvgElement, []],
      created: [svg$.SvgElement, []]
    })
  });
  svg$.SvgElement[dart.metadata] = () => [dart.const(new _metadata.DomName('SVGElement')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGElement"))];
  dart.defineLazy(svg$.SvgElement, {
    get _START_TAG_REGEXP() {
      return core.RegExp.new('<(\\w+)');
    },
    get abortEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('abort'));
    },
    get blurEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('blur'));
    },
    get canPlayEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('canplay'));
    },
    get canPlayThroughEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('canplaythrough'));
    },
    get changeEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('change'));
    },
    get clickEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MouseEvent))('click'));
    },
    get contextMenuEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MouseEvent))('contextmenu'));
    },
    get doubleClickEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('dblclick'));
    },
    get dragEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MouseEvent))('drag'));
    },
    get dragEndEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MouseEvent))('dragend'));
    },
    get dragEnterEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MouseEvent))('dragenter'));
    },
    get dragLeaveEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MouseEvent))('dragleave'));
    },
    get dragOverEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MouseEvent))('dragover'));
    },
    get dragStartEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MouseEvent))('dragstart'));
    },
    get dropEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MouseEvent))('drop'));
    },
    get durationChangeEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('durationchange'));
    },
    get emptiedEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('emptied'));
    },
    get endedEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('ended'));
    },
    get errorEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('error'));
    },
    get focusEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('focus'));
    },
    get inputEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('input'));
    },
    get invalidEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('invalid'));
    },
    get keyDownEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.KeyboardEvent))('keydown'));
    },
    get keyPressEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.KeyboardEvent))('keypress'));
    },
    get keyUpEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.KeyboardEvent))('keyup'));
    },
    get loadEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('load'));
    },
    get loadedDataEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('loadeddata'));
    },
    get loadedMetadataEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('loadedmetadata'));
    },
    get mouseDownEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MouseEvent))('mousedown'));
    },
    get mouseEnterEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MouseEvent))('mouseenter'));
    },
    get mouseLeaveEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MouseEvent))('mouseleave'));
    },
    get mouseMoveEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MouseEvent))('mousemove'));
    },
    get mouseOutEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MouseEvent))('mouseout'));
    },
    get mouseOverEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MouseEvent))('mouseover'));
    },
    get mouseUpEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.MouseEvent))('mouseup'));
    },
    get mouseWheelEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.WheelEvent))('mousewheel'));
    },
    get pauseEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('pause'));
    },
    get playEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('play'));
    },
    get playingEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('playing'));
    },
    get rateChangeEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('ratechange'));
    },
    get resetEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('reset'));
    },
    get resizeEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('resize'));
    },
    get scrollEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('scroll'));
    },
    get seekedEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('seeked'));
    },
    get seekingEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('seeking'));
    },
    get selectEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('select'));
    },
    get stalledEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('stalled'));
    },
    get submitEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('submit'));
    },
    get suspendEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('suspend'));
    },
    get timeUpdateEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('timeupdate'));
    },
    get volumeChangeEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('volumechange'));
    },
    get waitingEvent() {
      return dart.const(new (html$.EventStreamProvider$(html$.Event))('waiting'));
    }
  });
  dart.registerExtension(dart.global.SVGElement, svg$.SvgElement);
  dart.defineExtensionNames([
    'getBBox',
    'getCtm',
    'getScreenCtm',
    'getTransformToElement',
    'hasExtension',
    'farthestViewportElement',
    'nearestViewportElement',
    'transform',
    'requiredExtensions',
    'requiredFeatures',
    'systemLanguage'
  ]);
  svg$.GraphicsElement = class GraphicsElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      this[dartx.farthestViewportElement] = null;
      this[dartx.nearestViewportElement] = null;
      this[dartx.transform] = null;
      this[dartx.requiredExtensions] = null;
      this[dartx.requiredFeatures] = null;
      this[dartx.systemLanguage] = null;
      super.created();
    }
    get [dartx.farthestViewportElement]() {
      return this.farthestViewportElement;
    }
    get [dartx.nearestViewportElement]() {
      return this.nearestViewportElement;
    }
    get [dartx.transform]() {
      return this.transform;
    }
    [dartx.getBBox]() {
      return this.getBBox();
    }
    [dartx.getCtm]() {
      return this.getCTM();
    }
    [dartx.getScreenCtm]() {
      return this.getScreenCTM();
    }
    [dartx.getTransformToElement](element) {
      return this.getTransformToElement(element);
    }
    get [dartx.requiredExtensions]() {
      return this.requiredExtensions;
    }
    get [dartx.requiredFeatures]() {
      return this.requiredFeatures;
    }
    get [dartx.systemLanguage]() {
      return this.systemLanguage;
    }
    [dartx.hasExtension](extension) {
      return this.hasExtension(extension);
    }
  };
  dart.defineNamedConstructor(svg$.GraphicsElement, 'created');
  svg$.GraphicsElement[dart.implements] = () => [svg$.Tests];
  dart.setSignature(svg$.GraphicsElement, {
    constructors: () => ({
      _: [svg$.GraphicsElement, []],
      created: [svg$.GraphicsElement, []]
    }),
    methods: () => ({
      [dartx.getBBox]: [svg$.Rect, []],
      [dartx.getCtm]: [svg$.Matrix, []],
      [dartx.getScreenCtm]: [svg$.Matrix, []],
      [dartx.getTransformToElement]: [svg$.Matrix, [svg$.SvgElement]],
      [dartx.hasExtension]: [core.bool, [core.String]]
    })
  });
  svg$.GraphicsElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGGraphicsElement')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("SVGGraphicsElement"))];
  dart.registerExtension(dart.global.SVGGraphicsElement, svg$.GraphicsElement);
  dart.defineExtensionNames([
    'target',
    'href'
  ]);
  svg$.AElement = class AElement extends svg$.GraphicsElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("a"), svg$.AElement);
    }
    created() {
      this[dartx.target] = null;
      this[dartx.href] = null;
      super.created();
    }
    get [dartx.target]() {
      return this.target;
    }
    get [dartx.href]() {
      return this.href;
    }
  };
  dart.defineNamedConstructor(svg$.AElement, 'created');
  svg$.AElement[dart.implements] = () => [svg$.UriReference];
  dart.setSignature(svg$.AElement, {
    constructors: () => ({
      _: [svg$.AElement, []],
      new: [svg$.AElement, []],
      created: [svg$.AElement, []]
    })
  });
  svg$.AElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGAElement')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGAElement"))];
  dart.registerExtension(dart.global.SVGAElement, svg$.AElement);
  dart.defineExtensionNames([
    'convertToSpecifiedUnits',
    'newValueSpecifiedUnits',
    'unitType',
    'value',
    'valueAsString',
    'valueInSpecifiedUnits'
  ]);
  svg$.Angle = class Angle extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.unitType]() {
      return this.unitType;
    }
    get [dartx.value]() {
      return this.value;
    }
    set [dartx.value](value) {
      this.value = value;
    }
    get [dartx.valueAsString]() {
      return this.valueAsString;
    }
    set [dartx.valueAsString](value) {
      this.valueAsString = value;
    }
    get [dartx.valueInSpecifiedUnits]() {
      return this.valueInSpecifiedUnits;
    }
    set [dartx.valueInSpecifiedUnits](value) {
      this.valueInSpecifiedUnits = value;
    }
    [dartx.convertToSpecifiedUnits](unitType) {
      return this.convertToSpecifiedUnits(unitType);
    }
    [dartx.newValueSpecifiedUnits](unitType, valueInSpecifiedUnits) {
      return this.newValueSpecifiedUnits(unitType, valueInSpecifiedUnits);
    }
  };
  dart.setSignature(svg$.Angle, {
    constructors: () => ({_: [svg$.Angle, []]}),
    methods: () => ({
      [dartx.convertToSpecifiedUnits]: [dart.void, [core.int]],
      [dartx.newValueSpecifiedUnits]: [dart.void, [core.int, core.num]]
    })
  });
  svg$.Angle[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGAngle')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGAngle"))];
  svg$.Angle.SVG_ANGLETYPE_DEG = 2;
  svg$.Angle.SVG_ANGLETYPE_GRAD = 4;
  svg$.Angle.SVG_ANGLETYPE_RAD = 3;
  svg$.Angle.SVG_ANGLETYPE_UNKNOWN = 0;
  svg$.Angle.SVG_ANGLETYPE_UNSPECIFIED = 1;
  dart.registerExtension(dart.global.SVGAngle, svg$.Angle);
  dart.defineExtensionNames([
    'beginElement',
    'beginElementAt',
    'endElement',
    'endElementAt',
    'getCurrentTime',
    'getSimpleDuration',
    'getStartTime',
    'hasExtension',
    'targetElement',
    'requiredExtensions',
    'requiredFeatures',
    'systemLanguage'
  ]);
  svg$.AnimationElement = class AnimationElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("animation"), svg$.AnimationElement);
    }
    created() {
      this[dartx.targetElement] = null;
      this[dartx.requiredExtensions] = null;
      this[dartx.requiredFeatures] = null;
      this[dartx.systemLanguage] = null;
      super.created();
    }
    get [dartx.targetElement]() {
      return this.targetElement;
    }
    [dartx.beginElement]() {
      return this.beginElement();
    }
    [dartx.beginElementAt](offset) {
      return this.beginElementAt(offset);
    }
    [dartx.endElement]() {
      return this.endElement();
    }
    [dartx.endElementAt](offset) {
      return this.endElementAt(offset);
    }
    [dartx.getCurrentTime]() {
      return this.getCurrentTime();
    }
    [dartx.getSimpleDuration]() {
      return this.getSimpleDuration();
    }
    [dartx.getStartTime]() {
      return this.getStartTime();
    }
    get [dartx.requiredExtensions]() {
      return this.requiredExtensions;
    }
    get [dartx.requiredFeatures]() {
      return this.requiredFeatures;
    }
    get [dartx.systemLanguage]() {
      return this.systemLanguage;
    }
    [dartx.hasExtension](extension) {
      return this.hasExtension(extension);
    }
  };
  dart.defineNamedConstructor(svg$.AnimationElement, 'created');
  svg$.AnimationElement[dart.implements] = () => [svg$.Tests];
  dart.setSignature(svg$.AnimationElement, {
    constructors: () => ({
      _: [svg$.AnimationElement, []],
      new: [svg$.AnimationElement, []],
      created: [svg$.AnimationElement, []]
    }),
    methods: () => ({
      [dartx.beginElement]: [dart.void, []],
      [dartx.beginElementAt]: [dart.void, [core.num]],
      [dartx.endElement]: [dart.void, []],
      [dartx.endElementAt]: [dart.void, [core.num]],
      [dartx.getCurrentTime]: [core.double, []],
      [dartx.getSimpleDuration]: [core.double, []],
      [dartx.getStartTime]: [core.double, []],
      [dartx.hasExtension]: [core.bool, [core.String]]
    })
  });
  svg$.AnimationElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGAnimationElement')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGAnimationElement"))];
  dart.registerExtension(dart.global.SVGAnimationElement, svg$.AnimationElement);
  svg$.AnimateElement = class AnimateElement extends svg$.AnimationElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("animate"), svg$.AnimateElement);
    }
    created() {
      super.created();
    }
    static get supported() {
      return dart.notNull(svg$.SvgElement.isTagSupported('animate')) && dart.is(svg$.SvgElement.tag('animate'), svg$.AnimateElement);
    }
  };
  dart.defineNamedConstructor(svg$.AnimateElement, 'created');
  dart.setSignature(svg$.AnimateElement, {
    constructors: () => ({
      _: [svg$.AnimateElement, []],
      new: [svg$.AnimateElement, []],
      created: [svg$.AnimateElement, []]
    })
  });
  svg$.AnimateElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGAnimateElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGAnimateElement"))];
  dart.registerExtension(dart.global.SVGAnimateElement, svg$.AnimateElement);
  svg$.AnimateMotionElement = class AnimateMotionElement extends svg$.AnimationElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("animateMotion"), svg$.AnimateMotionElement);
    }
    created() {
      super.created();
    }
    static get supported() {
      return dart.notNull(svg$.SvgElement.isTagSupported('animateMotion')) && dart.is(svg$.SvgElement.tag('animateMotion'), svg$.AnimateMotionElement);
    }
  };
  dart.defineNamedConstructor(svg$.AnimateMotionElement, 'created');
  dart.setSignature(svg$.AnimateMotionElement, {
    constructors: () => ({
      _: [svg$.AnimateMotionElement, []],
      new: [svg$.AnimateMotionElement, []],
      created: [svg$.AnimateMotionElement, []]
    })
  });
  svg$.AnimateMotionElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGAnimateMotionElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGAnimateMotionElement"))];
  dart.registerExtension(dart.global.SVGAnimateMotionElement, svg$.AnimateMotionElement);
  svg$.AnimateTransformElement = class AnimateTransformElement extends svg$.AnimationElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("animateTransform"), svg$.AnimateTransformElement);
    }
    created() {
      super.created();
    }
    static get supported() {
      return dart.notNull(svg$.SvgElement.isTagSupported('animateTransform')) && dart.is(svg$.SvgElement.tag('animateTransform'), svg$.AnimateTransformElement);
    }
  };
  dart.defineNamedConstructor(svg$.AnimateTransformElement, 'created');
  dart.setSignature(svg$.AnimateTransformElement, {
    constructors: () => ({
      _: [svg$.AnimateTransformElement, []],
      new: [svg$.AnimateTransformElement, []],
      created: [svg$.AnimateTransformElement, []]
    })
  });
  svg$.AnimateTransformElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGAnimateTransformElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGAnimateTransformElement"))];
  dart.registerExtension(dart.global.SVGAnimateTransformElement, svg$.AnimateTransformElement);
  dart.defineExtensionNames([
    'animVal',
    'baseVal'
  ]);
  svg$.AnimatedAngle = class AnimatedAngle extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.animVal]() {
      return this.animVal;
    }
    get [dartx.baseVal]() {
      return this.baseVal;
    }
  };
  dart.setSignature(svg$.AnimatedAngle, {
    constructors: () => ({_: [svg$.AnimatedAngle, []]})
  });
  svg$.AnimatedAngle[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGAnimatedAngle')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGAnimatedAngle"))];
  dart.registerExtension(dart.global.SVGAnimatedAngle, svg$.AnimatedAngle);
  dart.defineExtensionNames([
    'animVal',
    'baseVal'
  ]);
  svg$.AnimatedBoolean = class AnimatedBoolean extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.animVal]() {
      return this.animVal;
    }
    get [dartx.baseVal]() {
      return this.baseVal;
    }
    set [dartx.baseVal](value) {
      this.baseVal = value;
    }
  };
  dart.setSignature(svg$.AnimatedBoolean, {
    constructors: () => ({_: [svg$.AnimatedBoolean, []]})
  });
  svg$.AnimatedBoolean[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGAnimatedBoolean')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGAnimatedBoolean"))];
  dart.registerExtension(dart.global.SVGAnimatedBoolean, svg$.AnimatedBoolean);
  dart.defineExtensionNames([
    'animVal',
    'baseVal'
  ]);
  svg$.AnimatedEnumeration = class AnimatedEnumeration extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.animVal]() {
      return this.animVal;
    }
    get [dartx.baseVal]() {
      return this.baseVal;
    }
    set [dartx.baseVal](value) {
      this.baseVal = value;
    }
  };
  dart.setSignature(svg$.AnimatedEnumeration, {
    constructors: () => ({_: [svg$.AnimatedEnumeration, []]})
  });
  svg$.AnimatedEnumeration[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGAnimatedEnumeration')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGAnimatedEnumeration"))];
  dart.registerExtension(dart.global.SVGAnimatedEnumeration, svg$.AnimatedEnumeration);
  dart.defineExtensionNames([
    'animVal',
    'baseVal'
  ]);
  svg$.AnimatedInteger = class AnimatedInteger extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.animVal]() {
      return this.animVal;
    }
    get [dartx.baseVal]() {
      return this.baseVal;
    }
    set [dartx.baseVal](value) {
      this.baseVal = value;
    }
  };
  dart.setSignature(svg$.AnimatedInteger, {
    constructors: () => ({_: [svg$.AnimatedInteger, []]})
  });
  svg$.AnimatedInteger[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGAnimatedInteger')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGAnimatedInteger"))];
  dart.registerExtension(dart.global.SVGAnimatedInteger, svg$.AnimatedInteger);
  dart.defineExtensionNames([
    'animVal',
    'baseVal'
  ]);
  svg$.AnimatedLength = class AnimatedLength extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.animVal]() {
      return this.animVal;
    }
    get [dartx.baseVal]() {
      return this.baseVal;
    }
  };
  dart.setSignature(svg$.AnimatedLength, {
    constructors: () => ({_: [svg$.AnimatedLength, []]})
  });
  svg$.AnimatedLength[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGAnimatedLength')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGAnimatedLength"))];
  dart.registerExtension(dart.global.SVGAnimatedLength, svg$.AnimatedLength);
  dart.defineExtensionNames([
    'animVal',
    'baseVal'
  ]);
  svg$.AnimatedLengthList = class AnimatedLengthList extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.animVal]() {
      return this.animVal;
    }
    get [dartx.baseVal]() {
      return this.baseVal;
    }
  };
  dart.setSignature(svg$.AnimatedLengthList, {
    constructors: () => ({_: [svg$.AnimatedLengthList, []]})
  });
  svg$.AnimatedLengthList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGAnimatedLengthList')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGAnimatedLengthList"))];
  dart.registerExtension(dart.global.SVGAnimatedLengthList, svg$.AnimatedLengthList);
  dart.defineExtensionNames([
    'animVal',
    'baseVal'
  ]);
  svg$.AnimatedNumber = class AnimatedNumber extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.animVal]() {
      return this.animVal;
    }
    get [dartx.baseVal]() {
      return this.baseVal;
    }
    set [dartx.baseVal](value) {
      this.baseVal = value;
    }
  };
  dart.setSignature(svg$.AnimatedNumber, {
    constructors: () => ({_: [svg$.AnimatedNumber, []]})
  });
  svg$.AnimatedNumber[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGAnimatedNumber')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGAnimatedNumber"))];
  dart.registerExtension(dart.global.SVGAnimatedNumber, svg$.AnimatedNumber);
  dart.defineExtensionNames([
    'animVal',
    'baseVal'
  ]);
  svg$.AnimatedNumberList = class AnimatedNumberList extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.animVal]() {
      return this.animVal;
    }
    get [dartx.baseVal]() {
      return this.baseVal;
    }
  };
  dart.setSignature(svg$.AnimatedNumberList, {
    constructors: () => ({_: [svg$.AnimatedNumberList, []]})
  });
  svg$.AnimatedNumberList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGAnimatedNumberList')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGAnimatedNumberList"))];
  dart.registerExtension(dart.global.SVGAnimatedNumberList, svg$.AnimatedNumberList);
  dart.defineExtensionNames([
    'animVal',
    'baseVal'
  ]);
  svg$.AnimatedPreserveAspectRatio = class AnimatedPreserveAspectRatio extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.animVal]() {
      return this.animVal;
    }
    get [dartx.baseVal]() {
      return this.baseVal;
    }
  };
  dart.setSignature(svg$.AnimatedPreserveAspectRatio, {
    constructors: () => ({_: [svg$.AnimatedPreserveAspectRatio, []]})
  });
  svg$.AnimatedPreserveAspectRatio[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGAnimatedPreserveAspectRatio')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGAnimatedPreserveAspectRatio"))];
  dart.registerExtension(dart.global.SVGAnimatedPreserveAspectRatio, svg$.AnimatedPreserveAspectRatio);
  dart.defineExtensionNames([
    'animVal',
    'baseVal'
  ]);
  svg$.AnimatedRect = class AnimatedRect extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.animVal]() {
      return this.animVal;
    }
    get [dartx.baseVal]() {
      return this.baseVal;
    }
  };
  dart.setSignature(svg$.AnimatedRect, {
    constructors: () => ({_: [svg$.AnimatedRect, []]})
  });
  svg$.AnimatedRect[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGAnimatedRect')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGAnimatedRect"))];
  dart.registerExtension(dart.global.SVGAnimatedRect, svg$.AnimatedRect);
  dart.defineExtensionNames([
    'animVal',
    'baseVal'
  ]);
  svg$.AnimatedString = class AnimatedString extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.animVal]() {
      return this.animVal;
    }
    get [dartx.baseVal]() {
      return this.baseVal;
    }
    set [dartx.baseVal](value) {
      this.baseVal = value;
    }
  };
  dart.setSignature(svg$.AnimatedString, {
    constructors: () => ({_: [svg$.AnimatedString, []]})
  });
  svg$.AnimatedString[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGAnimatedString')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGAnimatedString"))];
  dart.registerExtension(dart.global.SVGAnimatedString, svg$.AnimatedString);
  dart.defineExtensionNames([
    'animVal',
    'baseVal'
  ]);
  svg$.AnimatedTransformList = class AnimatedTransformList extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.animVal]() {
      return this.animVal;
    }
    get [dartx.baseVal]() {
      return this.baseVal;
    }
  };
  dart.setSignature(svg$.AnimatedTransformList, {
    constructors: () => ({_: [svg$.AnimatedTransformList, []]})
  });
  svg$.AnimatedTransformList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGAnimatedTransformList')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGAnimatedTransformList"))];
  dart.registerExtension(dart.global.SVGAnimatedTransformList, svg$.AnimatedTransformList);
  dart.defineExtensionNames([
    'isPointInFill',
    'isPointInStroke'
  ]);
  svg$.GeometryElement = class GeometryElement extends svg$.GraphicsElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      super.created();
    }
    [dartx.isPointInFill](point) {
      return this.isPointInFill(point);
    }
    [dartx.isPointInStroke](point) {
      return this.isPointInStroke(point);
    }
  };
  dart.defineNamedConstructor(svg$.GeometryElement, 'created');
  dart.setSignature(svg$.GeometryElement, {
    constructors: () => ({
      _: [svg$.GeometryElement, []],
      created: [svg$.GeometryElement, []]
    }),
    methods: () => ({
      [dartx.isPointInFill]: [core.bool, [svg$.Point]],
      [dartx.isPointInStroke]: [core.bool, [svg$.Point]]
    })
  });
  svg$.GeometryElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGGeometryElement')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("SVGGeometryElement"))];
  dart.registerExtension(dart.global.SVGGeometryElement, svg$.GeometryElement);
  dart.defineExtensionNames([
    'cx',
    'cy',
    'r'
  ]);
  svg$.CircleElement = class CircleElement extends svg$.GeometryElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("circle"), svg$.CircleElement);
    }
    created() {
      this[dartx.cx] = null;
      this[dartx.cy] = null;
      this[dartx.r] = null;
      super.created();
    }
    get [dartx.cx]() {
      return this.cx;
    }
    get [dartx.cy]() {
      return this.cy;
    }
    get [dartx.r]() {
      return this.r;
    }
  };
  dart.defineNamedConstructor(svg$.CircleElement, 'created');
  dart.setSignature(svg$.CircleElement, {
    constructors: () => ({
      _: [svg$.CircleElement, []],
      new: [svg$.CircleElement, []],
      created: [svg$.CircleElement, []]
    })
  });
  svg$.CircleElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGCircleElement')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGCircleElement"))];
  dart.registerExtension(dart.global.SVGCircleElement, svg$.CircleElement);
  dart.defineExtensionNames([
    'clipPathUnits'
  ]);
  svg$.ClipPathElement = class ClipPathElement extends svg$.GraphicsElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("clipPath"), svg$.ClipPathElement);
    }
    created() {
      this[dartx.clipPathUnits] = null;
      super.created();
    }
    get [dartx.clipPathUnits]() {
      return this.clipPathUnits;
    }
  };
  dart.defineNamedConstructor(svg$.ClipPathElement, 'created');
  dart.setSignature(svg$.ClipPathElement, {
    constructors: () => ({
      _: [svg$.ClipPathElement, []],
      new: [svg$.ClipPathElement, []],
      created: [svg$.ClipPathElement, []]
    })
  });
  svg$.ClipPathElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGClipPathElement')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGClipPathElement"))];
  dart.registerExtension(dart.global.SVGClipPathElement, svg$.ClipPathElement);
  svg$.DefsElement = class DefsElement extends svg$.GraphicsElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("defs"), svg$.DefsElement);
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(svg$.DefsElement, 'created');
  dart.setSignature(svg$.DefsElement, {
    constructors: () => ({
      _: [svg$.DefsElement, []],
      new: [svg$.DefsElement, []],
      created: [svg$.DefsElement, []]
    })
  });
  svg$.DefsElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGDefsElement')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGDefsElement"))];
  dart.registerExtension(dart.global.SVGDefsElement, svg$.DefsElement);
  svg$.DescElement = class DescElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("desc"), svg$.DescElement);
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(svg$.DescElement, 'created');
  dart.setSignature(svg$.DescElement, {
    constructors: () => ({
      _: [svg$.DescElement, []],
      new: [svg$.DescElement, []],
      created: [svg$.DescElement, []]
    })
  });
  svg$.DescElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGDescElement')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGDescElement"))];
  dart.registerExtension(dart.global.SVGDescElement, svg$.DescElement);
  svg$.DiscardElement = class DiscardElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(svg$.DiscardElement, 'created');
  dart.setSignature(svg$.DiscardElement, {
    constructors: () => ({
      _: [svg$.DiscardElement, []],
      created: [svg$.DiscardElement, []]
    })
  });
  svg$.DiscardElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGDiscardElement')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("SVGDiscardElement"))];
  dart.registerExtension(dart.global.SVGDiscardElement, svg$.DiscardElement);
  dart.defineExtensionNames([
    'cx',
    'cy',
    'rx',
    'ry'
  ]);
  svg$.EllipseElement = class EllipseElement extends svg$.GeometryElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("ellipse"), svg$.EllipseElement);
    }
    created() {
      this[dartx.cx] = null;
      this[dartx.cy] = null;
      this[dartx.rx] = null;
      this[dartx.ry] = null;
      super.created();
    }
    get [dartx.cx]() {
      return this.cx;
    }
    get [dartx.cy]() {
      return this.cy;
    }
    get [dartx.rx]() {
      return this.rx;
    }
    get [dartx.ry]() {
      return this.ry;
    }
  };
  dart.defineNamedConstructor(svg$.EllipseElement, 'created');
  dart.setSignature(svg$.EllipseElement, {
    constructors: () => ({
      _: [svg$.EllipseElement, []],
      new: [svg$.EllipseElement, []],
      created: [svg$.EllipseElement, []]
    })
  });
  svg$.EllipseElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGEllipseElement')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGEllipseElement"))];
  dart.registerExtension(dart.global.SVGEllipseElement, svg$.EllipseElement);
  dart.defineExtensionNames([
    'in1',
    'in2',
    'mode',
    'height',
    'result',
    'width',
    'x',
    'y'
  ]);
  svg$.FEBlendElement = class FEBlendElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("feBlend"), svg$.FEBlendElement);
    }
    created() {
      this[dartx.in1] = null;
      this[dartx.in2] = null;
      this[dartx.mode] = null;
      this[dartx.height] = null;
      this[dartx.result] = null;
      this[dartx.width] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      super.created();
    }
    static get supported() {
      return dart.notNull(svg$.SvgElement.isTagSupported('feBlend')) && dart.is(svg$.SvgElement.tag('feBlend'), svg$.FEBlendElement);
    }
    get [dartx.in1]() {
      return this.in1;
    }
    get [dartx.in2]() {
      return this.in2;
    }
    get [dartx.mode]() {
      return this.mode;
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.result]() {
      return this.result;
    }
    get [dartx.width]() {
      return this.width;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
  };
  dart.defineNamedConstructor(svg$.FEBlendElement, 'created');
  svg$.FEBlendElement[dart.implements] = () => [svg$.FilterPrimitiveStandardAttributes];
  dart.setSignature(svg$.FEBlendElement, {
    constructors: () => ({
      _: [svg$.FEBlendElement, []],
      new: [svg$.FEBlendElement, []],
      created: [svg$.FEBlendElement, []]
    })
  });
  svg$.FEBlendElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGFEBlendElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGFEBlendElement"))];
  svg$.FEBlendElement.SVG_FEBLEND_MODE_DARKEN = 4;
  svg$.FEBlendElement.SVG_FEBLEND_MODE_LIGHTEN = 5;
  svg$.FEBlendElement.SVG_FEBLEND_MODE_MULTIPLY = 2;
  svg$.FEBlendElement.SVG_FEBLEND_MODE_NORMAL = 1;
  svg$.FEBlendElement.SVG_FEBLEND_MODE_SCREEN = 3;
  svg$.FEBlendElement.SVG_FEBLEND_MODE_UNKNOWN = 0;
  dart.registerExtension(dart.global.SVGFEBlendElement, svg$.FEBlendElement);
  dart.defineExtensionNames([
    'in1',
    'type',
    'values',
    'height',
    'result',
    'width',
    'x',
    'y'
  ]);
  svg$.FEColorMatrixElement = class FEColorMatrixElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("feColorMatrix"), svg$.FEColorMatrixElement);
    }
    created() {
      this[dartx.in1] = null;
      this[dartx.type] = null;
      this[dartx.values] = null;
      this[dartx.height] = null;
      this[dartx.result] = null;
      this[dartx.width] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      super.created();
    }
    static get supported() {
      return dart.notNull(svg$.SvgElement.isTagSupported('feColorMatrix')) && dart.is(svg$.SvgElement.tag('feColorMatrix'), svg$.FEColorMatrixElement);
    }
    get [dartx.in1]() {
      return this.in1;
    }
    get [dartx.type]() {
      return this.type;
    }
    get [dartx.values]() {
      return this.values;
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.result]() {
      return this.result;
    }
    get [dartx.width]() {
      return this.width;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
  };
  dart.defineNamedConstructor(svg$.FEColorMatrixElement, 'created');
  svg$.FEColorMatrixElement[dart.implements] = () => [svg$.FilterPrimitiveStandardAttributes];
  dart.setSignature(svg$.FEColorMatrixElement, {
    constructors: () => ({
      _: [svg$.FEColorMatrixElement, []],
      new: [svg$.FEColorMatrixElement, []],
      created: [svg$.FEColorMatrixElement, []]
    })
  });
  svg$.FEColorMatrixElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGFEColorMatrixElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGFEColorMatrixElement"))];
  svg$.FEColorMatrixElement.SVG_FECOLORMATRIX_TYPE_HUEROTATE = 3;
  svg$.FEColorMatrixElement.SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA = 4;
  svg$.FEColorMatrixElement.SVG_FECOLORMATRIX_TYPE_MATRIX = 1;
  svg$.FEColorMatrixElement.SVG_FECOLORMATRIX_TYPE_SATURATE = 2;
  svg$.FEColorMatrixElement.SVG_FECOLORMATRIX_TYPE_UNKNOWN = 0;
  dart.registerExtension(dart.global.SVGFEColorMatrixElement, svg$.FEColorMatrixElement);
  dart.defineExtensionNames([
    'in1',
    'height',
    'result',
    'width',
    'x',
    'y'
  ]);
  svg$.FEComponentTransferElement = class FEComponentTransferElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("feComponentTransfer"), svg$.FEComponentTransferElement);
    }
    created() {
      this[dartx.in1] = null;
      this[dartx.height] = null;
      this[dartx.result] = null;
      this[dartx.width] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      super.created();
    }
    static get supported() {
      return dart.notNull(svg$.SvgElement.isTagSupported('feComponentTransfer')) && dart.is(svg$.SvgElement.tag('feComponentTransfer'), svg$.FEComponentTransferElement);
    }
    get [dartx.in1]() {
      return this.in1;
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.result]() {
      return this.result;
    }
    get [dartx.width]() {
      return this.width;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
  };
  dart.defineNamedConstructor(svg$.FEComponentTransferElement, 'created');
  svg$.FEComponentTransferElement[dart.implements] = () => [svg$.FilterPrimitiveStandardAttributes];
  dart.setSignature(svg$.FEComponentTransferElement, {
    constructors: () => ({
      _: [svg$.FEComponentTransferElement, []],
      new: [svg$.FEComponentTransferElement, []],
      created: [svg$.FEComponentTransferElement, []]
    })
  });
  svg$.FEComponentTransferElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGFEComponentTransferElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGFEComponentTransferElement"))];
  dart.registerExtension(dart.global.SVGFEComponentTransferElement, svg$.FEComponentTransferElement);
  dart.defineExtensionNames([
    'in1',
    'in2',
    'k1',
    'k2',
    'k3',
    'k4',
    'operator',
    'height',
    'result',
    'width',
    'x',
    'y'
  ]);
  svg$.FECompositeElement = class FECompositeElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      this[dartx.in1] = null;
      this[dartx.in2] = null;
      this[dartx.k1] = null;
      this[dartx.k2] = null;
      this[dartx.k3] = null;
      this[dartx.k4] = null;
      this[dartx.operator] = null;
      this[dartx.height] = null;
      this[dartx.result] = null;
      this[dartx.width] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      super.created();
    }
    get [dartx.in1]() {
      return this.in1;
    }
    get [dartx.in2]() {
      return this.in2;
    }
    get [dartx.k1]() {
      return this.k1;
    }
    get [dartx.k2]() {
      return this.k2;
    }
    get [dartx.k3]() {
      return this.k3;
    }
    get [dartx.k4]() {
      return this.k4;
    }
    get [dartx.operator]() {
      return this.operator;
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.result]() {
      return this.result;
    }
    get [dartx.width]() {
      return this.width;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
  };
  dart.defineNamedConstructor(svg$.FECompositeElement, 'created');
  svg$.FECompositeElement[dart.implements] = () => [svg$.FilterPrimitiveStandardAttributes];
  dart.setSignature(svg$.FECompositeElement, {
    constructors: () => ({
      _: [svg$.FECompositeElement, []],
      created: [svg$.FECompositeElement, []]
    })
  });
  svg$.FECompositeElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGFECompositeElement')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGFECompositeElement"))];
  svg$.FECompositeElement.SVG_FECOMPOSITE_OPERATOR_ARITHMETIC = 6;
  svg$.FECompositeElement.SVG_FECOMPOSITE_OPERATOR_ATOP = 4;
  svg$.FECompositeElement.SVG_FECOMPOSITE_OPERATOR_IN = 2;
  svg$.FECompositeElement.SVG_FECOMPOSITE_OPERATOR_OUT = 3;
  svg$.FECompositeElement.SVG_FECOMPOSITE_OPERATOR_OVER = 1;
  svg$.FECompositeElement.SVG_FECOMPOSITE_OPERATOR_UNKNOWN = 0;
  svg$.FECompositeElement.SVG_FECOMPOSITE_OPERATOR_XOR = 5;
  dart.registerExtension(dart.global.SVGFECompositeElement, svg$.FECompositeElement);
  dart.defineExtensionNames([
    'bias',
    'divisor',
    'edgeMode',
    'in1',
    'kernelMatrix',
    'kernelUnitLengthX',
    'kernelUnitLengthY',
    'orderX',
    'orderY',
    'preserveAlpha',
    'targetX',
    'targetY',
    'height',
    'result',
    'width',
    'x',
    'y'
  ]);
  svg$.FEConvolveMatrixElement = class FEConvolveMatrixElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("feConvolveMatrix"), svg$.FEConvolveMatrixElement);
    }
    created() {
      this[dartx.bias] = null;
      this[dartx.divisor] = null;
      this[dartx.edgeMode] = null;
      this[dartx.in1] = null;
      this[dartx.kernelMatrix] = null;
      this[dartx.kernelUnitLengthX] = null;
      this[dartx.kernelUnitLengthY] = null;
      this[dartx.orderX] = null;
      this[dartx.orderY] = null;
      this[dartx.preserveAlpha] = null;
      this[dartx.targetX] = null;
      this[dartx.targetY] = null;
      this[dartx.height] = null;
      this[dartx.result] = null;
      this[dartx.width] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      super.created();
    }
    static get supported() {
      return dart.notNull(svg$.SvgElement.isTagSupported('feConvolveMatrix')) && dart.is(svg$.SvgElement.tag('feConvolveMatrix'), svg$.FEConvolveMatrixElement);
    }
    get [dartx.bias]() {
      return this.bias;
    }
    get [dartx.divisor]() {
      return this.divisor;
    }
    get [dartx.edgeMode]() {
      return this.edgeMode;
    }
    get [dartx.in1]() {
      return this.in1;
    }
    get [dartx.kernelMatrix]() {
      return this.kernelMatrix;
    }
    get [dartx.kernelUnitLengthX]() {
      return this.kernelUnitLengthX;
    }
    get [dartx.kernelUnitLengthY]() {
      return this.kernelUnitLengthY;
    }
    get [dartx.orderX]() {
      return this.orderX;
    }
    get [dartx.orderY]() {
      return this.orderY;
    }
    get [dartx.preserveAlpha]() {
      return this.preserveAlpha;
    }
    get [dartx.targetX]() {
      return this.targetX;
    }
    get [dartx.targetY]() {
      return this.targetY;
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.result]() {
      return this.result;
    }
    get [dartx.width]() {
      return this.width;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
  };
  dart.defineNamedConstructor(svg$.FEConvolveMatrixElement, 'created');
  svg$.FEConvolveMatrixElement[dart.implements] = () => [svg$.FilterPrimitiveStandardAttributes];
  dart.setSignature(svg$.FEConvolveMatrixElement, {
    constructors: () => ({
      _: [svg$.FEConvolveMatrixElement, []],
      new: [svg$.FEConvolveMatrixElement, []],
      created: [svg$.FEConvolveMatrixElement, []]
    })
  });
  svg$.FEConvolveMatrixElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGFEConvolveMatrixElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGFEConvolveMatrixElement"))];
  svg$.FEConvolveMatrixElement.SVG_EDGEMODE_DUPLICATE = 1;
  svg$.FEConvolveMatrixElement.SVG_EDGEMODE_NONE = 3;
  svg$.FEConvolveMatrixElement.SVG_EDGEMODE_UNKNOWN = 0;
  svg$.FEConvolveMatrixElement.SVG_EDGEMODE_WRAP = 2;
  dart.registerExtension(dart.global.SVGFEConvolveMatrixElement, svg$.FEConvolveMatrixElement);
  dart.defineExtensionNames([
    'diffuseConstant',
    'in1',
    'kernelUnitLengthX',
    'kernelUnitLengthY',
    'surfaceScale',
    'height',
    'result',
    'width',
    'x',
    'y'
  ]);
  svg$.FEDiffuseLightingElement = class FEDiffuseLightingElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("feDiffuseLighting"), svg$.FEDiffuseLightingElement);
    }
    created() {
      this[dartx.diffuseConstant] = null;
      this[dartx.in1] = null;
      this[dartx.kernelUnitLengthX] = null;
      this[dartx.kernelUnitLengthY] = null;
      this[dartx.surfaceScale] = null;
      this[dartx.height] = null;
      this[dartx.result] = null;
      this[dartx.width] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      super.created();
    }
    static get supported() {
      return dart.notNull(svg$.SvgElement.isTagSupported('feDiffuseLighting')) && dart.is(svg$.SvgElement.tag('feDiffuseLighting'), svg$.FEDiffuseLightingElement);
    }
    get [dartx.diffuseConstant]() {
      return this.diffuseConstant;
    }
    get [dartx.in1]() {
      return this.in1;
    }
    get [dartx.kernelUnitLengthX]() {
      return this.kernelUnitLengthX;
    }
    get [dartx.kernelUnitLengthY]() {
      return this.kernelUnitLengthY;
    }
    get [dartx.surfaceScale]() {
      return this.surfaceScale;
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.result]() {
      return this.result;
    }
    get [dartx.width]() {
      return this.width;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
  };
  dart.defineNamedConstructor(svg$.FEDiffuseLightingElement, 'created');
  svg$.FEDiffuseLightingElement[dart.implements] = () => [svg$.FilterPrimitiveStandardAttributes];
  dart.setSignature(svg$.FEDiffuseLightingElement, {
    constructors: () => ({
      _: [svg$.FEDiffuseLightingElement, []],
      new: [svg$.FEDiffuseLightingElement, []],
      created: [svg$.FEDiffuseLightingElement, []]
    })
  });
  svg$.FEDiffuseLightingElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGFEDiffuseLightingElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGFEDiffuseLightingElement"))];
  dart.registerExtension(dart.global.SVGFEDiffuseLightingElement, svg$.FEDiffuseLightingElement);
  dart.defineExtensionNames([
    'in1',
    'in2',
    'scale',
    'xChannelSelector',
    'yChannelSelector',
    'height',
    'result',
    'width',
    'x',
    'y'
  ]);
  svg$.FEDisplacementMapElement = class FEDisplacementMapElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("feDisplacementMap"), svg$.FEDisplacementMapElement);
    }
    created() {
      this[dartx.in1] = null;
      this[dartx.in2] = null;
      this[dartx.scale] = null;
      this[dartx.xChannelSelector] = null;
      this[dartx.yChannelSelector] = null;
      this[dartx.height] = null;
      this[dartx.result] = null;
      this[dartx.width] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      super.created();
    }
    static get supported() {
      return dart.notNull(svg$.SvgElement.isTagSupported('feDisplacementMap')) && dart.is(svg$.SvgElement.tag('feDisplacementMap'), svg$.FEDisplacementMapElement);
    }
    get [dartx.in1]() {
      return this.in1;
    }
    get [dartx.in2]() {
      return this.in2;
    }
    get [dartx.scale]() {
      return this.scale;
    }
    get [dartx.xChannelSelector]() {
      return this.xChannelSelector;
    }
    get [dartx.yChannelSelector]() {
      return this.yChannelSelector;
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.result]() {
      return this.result;
    }
    get [dartx.width]() {
      return this.width;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
  };
  dart.defineNamedConstructor(svg$.FEDisplacementMapElement, 'created');
  svg$.FEDisplacementMapElement[dart.implements] = () => [svg$.FilterPrimitiveStandardAttributes];
  dart.setSignature(svg$.FEDisplacementMapElement, {
    constructors: () => ({
      _: [svg$.FEDisplacementMapElement, []],
      new: [svg$.FEDisplacementMapElement, []],
      created: [svg$.FEDisplacementMapElement, []]
    })
  });
  svg$.FEDisplacementMapElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGFEDisplacementMapElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGFEDisplacementMapElement"))];
  svg$.FEDisplacementMapElement.SVG_CHANNEL_A = 4;
  svg$.FEDisplacementMapElement.SVG_CHANNEL_B = 3;
  svg$.FEDisplacementMapElement.SVG_CHANNEL_G = 2;
  svg$.FEDisplacementMapElement.SVG_CHANNEL_R = 1;
  svg$.FEDisplacementMapElement.SVG_CHANNEL_UNKNOWN = 0;
  dart.registerExtension(dart.global.SVGFEDisplacementMapElement, svg$.FEDisplacementMapElement);
  dart.defineExtensionNames([
    'azimuth',
    'elevation'
  ]);
  svg$.FEDistantLightElement = class FEDistantLightElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("feDistantLight"), svg$.FEDistantLightElement);
    }
    created() {
      this[dartx.azimuth] = null;
      this[dartx.elevation] = null;
      super.created();
    }
    static get supported() {
      return dart.notNull(svg$.SvgElement.isTagSupported('feDistantLight')) && dart.is(svg$.SvgElement.tag('feDistantLight'), svg$.FEDistantLightElement);
    }
    get [dartx.azimuth]() {
      return this.azimuth;
    }
    get [dartx.elevation]() {
      return this.elevation;
    }
  };
  dart.defineNamedConstructor(svg$.FEDistantLightElement, 'created');
  dart.setSignature(svg$.FEDistantLightElement, {
    constructors: () => ({
      _: [svg$.FEDistantLightElement, []],
      new: [svg$.FEDistantLightElement, []],
      created: [svg$.FEDistantLightElement, []]
    })
  });
  svg$.FEDistantLightElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGFEDistantLightElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGFEDistantLightElement"))];
  dart.registerExtension(dart.global.SVGFEDistantLightElement, svg$.FEDistantLightElement);
  dart.defineExtensionNames([
    'height',
    'result',
    'width',
    'x',
    'y'
  ]);
  svg$.FEFloodElement = class FEFloodElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("feFlood"), svg$.FEFloodElement);
    }
    created() {
      this[dartx.height] = null;
      this[dartx.result] = null;
      this[dartx.width] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      super.created();
    }
    static get supported() {
      return dart.notNull(svg$.SvgElement.isTagSupported('feFlood')) && dart.is(svg$.SvgElement.tag('feFlood'), svg$.FEFloodElement);
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.result]() {
      return this.result;
    }
    get [dartx.width]() {
      return this.width;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
  };
  dart.defineNamedConstructor(svg$.FEFloodElement, 'created');
  svg$.FEFloodElement[dart.implements] = () => [svg$.FilterPrimitiveStandardAttributes];
  dart.setSignature(svg$.FEFloodElement, {
    constructors: () => ({
      _: [svg$.FEFloodElement, []],
      new: [svg$.FEFloodElement, []],
      created: [svg$.FEFloodElement, []]
    })
  });
  svg$.FEFloodElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGFEFloodElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGFEFloodElement"))];
  dart.registerExtension(dart.global.SVGFEFloodElement, svg$.FEFloodElement);
  svg$._SVGComponentTransferFunctionElement = class _SVGComponentTransferFunctionElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(svg$._SVGComponentTransferFunctionElement, 'created');
  dart.setSignature(svg$._SVGComponentTransferFunctionElement, {
    constructors: () => ({
      _: [svg$._SVGComponentTransferFunctionElement, []],
      created: [svg$._SVGComponentTransferFunctionElement, []]
    })
  });
  svg$._SVGComponentTransferFunctionElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGComponentTransferFunctionElement')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGComponentTransferFunctionElement"))];
  dart.registerExtension(dart.global.SVGComponentTransferFunctionElement, svg$._SVGComponentTransferFunctionElement);
  svg$.FEFuncAElement = class FEFuncAElement extends svg$._SVGComponentTransferFunctionElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("feFuncA"), svg$.FEFuncAElement);
    }
    created() {
      super.created();
    }
    static get supported() {
      return dart.notNull(svg$.SvgElement.isTagSupported('feFuncA')) && dart.is(svg$.SvgElement.tag('feFuncA'), svg$.FEFuncAElement);
    }
  };
  dart.defineNamedConstructor(svg$.FEFuncAElement, 'created');
  dart.setSignature(svg$.FEFuncAElement, {
    constructors: () => ({
      _: [svg$.FEFuncAElement, []],
      new: [svg$.FEFuncAElement, []],
      created: [svg$.FEFuncAElement, []]
    })
  });
  svg$.FEFuncAElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGFEFuncAElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGFEFuncAElement"))];
  dart.registerExtension(dart.global.SVGFEFuncAElement, svg$.FEFuncAElement);
  svg$.FEFuncBElement = class FEFuncBElement extends svg$._SVGComponentTransferFunctionElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("feFuncB"), svg$.FEFuncBElement);
    }
    created() {
      super.created();
    }
    static get supported() {
      return dart.notNull(svg$.SvgElement.isTagSupported('feFuncB')) && dart.is(svg$.SvgElement.tag('feFuncB'), svg$.FEFuncBElement);
    }
  };
  dart.defineNamedConstructor(svg$.FEFuncBElement, 'created');
  dart.setSignature(svg$.FEFuncBElement, {
    constructors: () => ({
      _: [svg$.FEFuncBElement, []],
      new: [svg$.FEFuncBElement, []],
      created: [svg$.FEFuncBElement, []]
    })
  });
  svg$.FEFuncBElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGFEFuncBElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGFEFuncBElement"))];
  dart.registerExtension(dart.global.SVGFEFuncBElement, svg$.FEFuncBElement);
  svg$.FEFuncGElement = class FEFuncGElement extends svg$._SVGComponentTransferFunctionElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("feFuncG"), svg$.FEFuncGElement);
    }
    created() {
      super.created();
    }
    static get supported() {
      return dart.notNull(svg$.SvgElement.isTagSupported('feFuncG')) && dart.is(svg$.SvgElement.tag('feFuncG'), svg$.FEFuncGElement);
    }
  };
  dart.defineNamedConstructor(svg$.FEFuncGElement, 'created');
  dart.setSignature(svg$.FEFuncGElement, {
    constructors: () => ({
      _: [svg$.FEFuncGElement, []],
      new: [svg$.FEFuncGElement, []],
      created: [svg$.FEFuncGElement, []]
    })
  });
  svg$.FEFuncGElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGFEFuncGElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGFEFuncGElement"))];
  dart.registerExtension(dart.global.SVGFEFuncGElement, svg$.FEFuncGElement);
  svg$.FEFuncRElement = class FEFuncRElement extends svg$._SVGComponentTransferFunctionElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("feFuncR"), svg$.FEFuncRElement);
    }
    created() {
      super.created();
    }
    static get supported() {
      return dart.notNull(svg$.SvgElement.isTagSupported('feFuncR')) && dart.is(svg$.SvgElement.tag('feFuncR'), svg$.FEFuncRElement);
    }
  };
  dart.defineNamedConstructor(svg$.FEFuncRElement, 'created');
  dart.setSignature(svg$.FEFuncRElement, {
    constructors: () => ({
      _: [svg$.FEFuncRElement, []],
      new: [svg$.FEFuncRElement, []],
      created: [svg$.FEFuncRElement, []]
    })
  });
  svg$.FEFuncRElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGFEFuncRElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGFEFuncRElement"))];
  dart.registerExtension(dart.global.SVGFEFuncRElement, svg$.FEFuncRElement);
  dart.defineExtensionNames([
    'setStdDeviation',
    'in1',
    'stdDeviationX',
    'stdDeviationY',
    'height',
    'result',
    'width',
    'x',
    'y'
  ]);
  svg$.FEGaussianBlurElement = class FEGaussianBlurElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("feGaussianBlur"), svg$.FEGaussianBlurElement);
    }
    created() {
      this[dartx.in1] = null;
      this[dartx.stdDeviationX] = null;
      this[dartx.stdDeviationY] = null;
      this[dartx.height] = null;
      this[dartx.result] = null;
      this[dartx.width] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      super.created();
    }
    static get supported() {
      return dart.notNull(svg$.SvgElement.isTagSupported('feGaussianBlur')) && dart.is(svg$.SvgElement.tag('feGaussianBlur'), svg$.FEGaussianBlurElement);
    }
    get [dartx.in1]() {
      return this.in1;
    }
    get [dartx.stdDeviationX]() {
      return this.stdDeviationX;
    }
    get [dartx.stdDeviationY]() {
      return this.stdDeviationY;
    }
    [dartx.setStdDeviation](stdDeviationX, stdDeviationY) {
      return this.setStdDeviation(stdDeviationX, stdDeviationY);
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.result]() {
      return this.result;
    }
    get [dartx.width]() {
      return this.width;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
  };
  dart.defineNamedConstructor(svg$.FEGaussianBlurElement, 'created');
  svg$.FEGaussianBlurElement[dart.implements] = () => [svg$.FilterPrimitiveStandardAttributes];
  dart.setSignature(svg$.FEGaussianBlurElement, {
    constructors: () => ({
      _: [svg$.FEGaussianBlurElement, []],
      new: [svg$.FEGaussianBlurElement, []],
      created: [svg$.FEGaussianBlurElement, []]
    }),
    methods: () => ({[dartx.setStdDeviation]: [dart.void, [core.num, core.num]]})
  });
  svg$.FEGaussianBlurElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGFEGaussianBlurElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGFEGaussianBlurElement"))];
  dart.registerExtension(dart.global.SVGFEGaussianBlurElement, svg$.FEGaussianBlurElement);
  dart.defineExtensionNames([
    'preserveAspectRatio',
    'height',
    'result',
    'width',
    'x',
    'y',
    'href'
  ]);
  svg$.FEImageElement = class FEImageElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("feImage"), svg$.FEImageElement);
    }
    created() {
      this[dartx.preserveAspectRatio] = null;
      this[dartx.height] = null;
      this[dartx.result] = null;
      this[dartx.width] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      this[dartx.href] = null;
      super.created();
    }
    static get supported() {
      return dart.notNull(svg$.SvgElement.isTagSupported('feImage')) && dart.is(svg$.SvgElement.tag('feImage'), svg$.FEImageElement);
    }
    get [dartx.preserveAspectRatio]() {
      return this.preserveAspectRatio;
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.result]() {
      return this.result;
    }
    get [dartx.width]() {
      return this.width;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
    get [dartx.href]() {
      return this.href;
    }
  };
  dart.defineNamedConstructor(svg$.FEImageElement, 'created');
  svg$.FEImageElement[dart.implements] = () => [svg$.FilterPrimitiveStandardAttributes, svg$.UriReference];
  dart.setSignature(svg$.FEImageElement, {
    constructors: () => ({
      _: [svg$.FEImageElement, []],
      new: [svg$.FEImageElement, []],
      created: [svg$.FEImageElement, []]
    })
  });
  svg$.FEImageElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGFEImageElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGFEImageElement"))];
  dart.registerExtension(dart.global.SVGFEImageElement, svg$.FEImageElement);
  dart.defineExtensionNames([
    'height',
    'result',
    'width',
    'x',
    'y'
  ]);
  svg$.FEMergeElement = class FEMergeElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("feMerge"), svg$.FEMergeElement);
    }
    created() {
      this[dartx.height] = null;
      this[dartx.result] = null;
      this[dartx.width] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      super.created();
    }
    static get supported() {
      return dart.notNull(svg$.SvgElement.isTagSupported('feMerge')) && dart.is(svg$.SvgElement.tag('feMerge'), svg$.FEMergeElement);
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.result]() {
      return this.result;
    }
    get [dartx.width]() {
      return this.width;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
  };
  dart.defineNamedConstructor(svg$.FEMergeElement, 'created');
  svg$.FEMergeElement[dart.implements] = () => [svg$.FilterPrimitiveStandardAttributes];
  dart.setSignature(svg$.FEMergeElement, {
    constructors: () => ({
      _: [svg$.FEMergeElement, []],
      new: [svg$.FEMergeElement, []],
      created: [svg$.FEMergeElement, []]
    })
  });
  svg$.FEMergeElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGFEMergeElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGFEMergeElement"))];
  dart.registerExtension(dart.global.SVGFEMergeElement, svg$.FEMergeElement);
  dart.defineExtensionNames([
    'in1'
  ]);
  svg$.FEMergeNodeElement = class FEMergeNodeElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("feMergeNode"), svg$.FEMergeNodeElement);
    }
    created() {
      this[dartx.in1] = null;
      super.created();
    }
    static get supported() {
      return dart.notNull(svg$.SvgElement.isTagSupported('feMergeNode')) && dart.is(svg$.SvgElement.tag('feMergeNode'), svg$.FEMergeNodeElement);
    }
    get [dartx.in1]() {
      return this.in1;
    }
  };
  dart.defineNamedConstructor(svg$.FEMergeNodeElement, 'created');
  dart.setSignature(svg$.FEMergeNodeElement, {
    constructors: () => ({
      _: [svg$.FEMergeNodeElement, []],
      new: [svg$.FEMergeNodeElement, []],
      created: [svg$.FEMergeNodeElement, []]
    })
  });
  svg$.FEMergeNodeElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGFEMergeNodeElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGFEMergeNodeElement"))];
  dart.registerExtension(dart.global.SVGFEMergeNodeElement, svg$.FEMergeNodeElement);
  dart.defineExtensionNames([
    'in1',
    'operator',
    'radiusX',
    'radiusY',
    'height',
    'result',
    'width',
    'x',
    'y'
  ]);
  svg$.FEMorphologyElement = class FEMorphologyElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      this[dartx.in1] = null;
      this[dartx.operator] = null;
      this[dartx.radiusX] = null;
      this[dartx.radiusY] = null;
      this[dartx.height] = null;
      this[dartx.result] = null;
      this[dartx.width] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      super.created();
    }
    get [dartx.in1]() {
      return this.in1;
    }
    get [dartx.operator]() {
      return this.operator;
    }
    get [dartx.radiusX]() {
      return this.radiusX;
    }
    get [dartx.radiusY]() {
      return this.radiusY;
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.result]() {
      return this.result;
    }
    get [dartx.width]() {
      return this.width;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
  };
  dart.defineNamedConstructor(svg$.FEMorphologyElement, 'created');
  svg$.FEMorphologyElement[dart.implements] = () => [svg$.FilterPrimitiveStandardAttributes];
  dart.setSignature(svg$.FEMorphologyElement, {
    constructors: () => ({
      _: [svg$.FEMorphologyElement, []],
      created: [svg$.FEMorphologyElement, []]
    })
  });
  svg$.FEMorphologyElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGFEMorphologyElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGFEMorphologyElement"))];
  svg$.FEMorphologyElement.SVG_MORPHOLOGY_OPERATOR_DILATE = 2;
  svg$.FEMorphologyElement.SVG_MORPHOLOGY_OPERATOR_ERODE = 1;
  svg$.FEMorphologyElement.SVG_MORPHOLOGY_OPERATOR_UNKNOWN = 0;
  dart.registerExtension(dart.global.SVGFEMorphologyElement, svg$.FEMorphologyElement);
  dart.defineExtensionNames([
    'dx',
    'dy',
    'in1',
    'height',
    'result',
    'width',
    'x',
    'y'
  ]);
  svg$.FEOffsetElement = class FEOffsetElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("feOffset"), svg$.FEOffsetElement);
    }
    created() {
      this[dartx.dx] = null;
      this[dartx.dy] = null;
      this[dartx.in1] = null;
      this[dartx.height] = null;
      this[dartx.result] = null;
      this[dartx.width] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      super.created();
    }
    static get supported() {
      return dart.notNull(svg$.SvgElement.isTagSupported('feOffset')) && dart.is(svg$.SvgElement.tag('feOffset'), svg$.FEOffsetElement);
    }
    get [dartx.dx]() {
      return this.dx;
    }
    get [dartx.dy]() {
      return this.dy;
    }
    get [dartx.in1]() {
      return this.in1;
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.result]() {
      return this.result;
    }
    get [dartx.width]() {
      return this.width;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
  };
  dart.defineNamedConstructor(svg$.FEOffsetElement, 'created');
  svg$.FEOffsetElement[dart.implements] = () => [svg$.FilterPrimitiveStandardAttributes];
  dart.setSignature(svg$.FEOffsetElement, {
    constructors: () => ({
      _: [svg$.FEOffsetElement, []],
      new: [svg$.FEOffsetElement, []],
      created: [svg$.FEOffsetElement, []]
    })
  });
  svg$.FEOffsetElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGFEOffsetElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGFEOffsetElement"))];
  dart.registerExtension(dart.global.SVGFEOffsetElement, svg$.FEOffsetElement);
  dart.defineExtensionNames([
    'x',
    'y',
    'z'
  ]);
  svg$.FEPointLightElement = class FEPointLightElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("fePointLight"), svg$.FEPointLightElement);
    }
    created() {
      this[dartx.x] = null;
      this[dartx.y] = null;
      this[dartx.z] = null;
      super.created();
    }
    static get supported() {
      return dart.notNull(svg$.SvgElement.isTagSupported('fePointLight')) && dart.is(svg$.SvgElement.tag('fePointLight'), svg$.FEPointLightElement);
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
    get [dartx.z]() {
      return this.z;
    }
  };
  dart.defineNamedConstructor(svg$.FEPointLightElement, 'created');
  dart.setSignature(svg$.FEPointLightElement, {
    constructors: () => ({
      _: [svg$.FEPointLightElement, []],
      new: [svg$.FEPointLightElement, []],
      created: [svg$.FEPointLightElement, []]
    })
  });
  svg$.FEPointLightElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGFEPointLightElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGFEPointLightElement"))];
  dart.registerExtension(dart.global.SVGFEPointLightElement, svg$.FEPointLightElement);
  dart.defineExtensionNames([
    'in1',
    'kernelUnitLengthX',
    'kernelUnitLengthY',
    'specularConstant',
    'specularExponent',
    'surfaceScale',
    'height',
    'result',
    'width',
    'x',
    'y'
  ]);
  svg$.FESpecularLightingElement = class FESpecularLightingElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("feSpecularLighting"), svg$.FESpecularLightingElement);
    }
    created() {
      this[dartx.in1] = null;
      this[dartx.kernelUnitLengthX] = null;
      this[dartx.kernelUnitLengthY] = null;
      this[dartx.specularConstant] = null;
      this[dartx.specularExponent] = null;
      this[dartx.surfaceScale] = null;
      this[dartx.height] = null;
      this[dartx.result] = null;
      this[dartx.width] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      super.created();
    }
    static get supported() {
      return dart.notNull(svg$.SvgElement.isTagSupported('feSpecularLighting')) && dart.is(svg$.SvgElement.tag('feSpecularLighting'), svg$.FESpecularLightingElement);
    }
    get [dartx.in1]() {
      return this.in1;
    }
    get [dartx.kernelUnitLengthX]() {
      return this.kernelUnitLengthX;
    }
    get [dartx.kernelUnitLengthY]() {
      return this.kernelUnitLengthY;
    }
    get [dartx.specularConstant]() {
      return this.specularConstant;
    }
    get [dartx.specularExponent]() {
      return this.specularExponent;
    }
    get [dartx.surfaceScale]() {
      return this.surfaceScale;
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.result]() {
      return this.result;
    }
    get [dartx.width]() {
      return this.width;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
  };
  dart.defineNamedConstructor(svg$.FESpecularLightingElement, 'created');
  svg$.FESpecularLightingElement[dart.implements] = () => [svg$.FilterPrimitiveStandardAttributes];
  dart.setSignature(svg$.FESpecularLightingElement, {
    constructors: () => ({
      _: [svg$.FESpecularLightingElement, []],
      new: [svg$.FESpecularLightingElement, []],
      created: [svg$.FESpecularLightingElement, []]
    })
  });
  svg$.FESpecularLightingElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGFESpecularLightingElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGFESpecularLightingElement"))];
  dart.registerExtension(dart.global.SVGFESpecularLightingElement, svg$.FESpecularLightingElement);
  dart.defineExtensionNames([
    'limitingConeAngle',
    'pointsAtX',
    'pointsAtY',
    'pointsAtZ',
    'specularExponent',
    'x',
    'y',
    'z'
  ]);
  svg$.FESpotLightElement = class FESpotLightElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("feSpotLight"), svg$.FESpotLightElement);
    }
    created() {
      this[dartx.limitingConeAngle] = null;
      this[dartx.pointsAtX] = null;
      this[dartx.pointsAtY] = null;
      this[dartx.pointsAtZ] = null;
      this[dartx.specularExponent] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      this[dartx.z] = null;
      super.created();
    }
    static get supported() {
      return dart.notNull(svg$.SvgElement.isTagSupported('feSpotLight')) && dart.is(svg$.SvgElement.tag('feSpotLight'), svg$.FESpotLightElement);
    }
    get [dartx.limitingConeAngle]() {
      return this.limitingConeAngle;
    }
    get [dartx.pointsAtX]() {
      return this.pointsAtX;
    }
    get [dartx.pointsAtY]() {
      return this.pointsAtY;
    }
    get [dartx.pointsAtZ]() {
      return this.pointsAtZ;
    }
    get [dartx.specularExponent]() {
      return this.specularExponent;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
    get [dartx.z]() {
      return this.z;
    }
  };
  dart.defineNamedConstructor(svg$.FESpotLightElement, 'created');
  dart.setSignature(svg$.FESpotLightElement, {
    constructors: () => ({
      _: [svg$.FESpotLightElement, []],
      new: [svg$.FESpotLightElement, []],
      created: [svg$.FESpotLightElement, []]
    })
  });
  svg$.FESpotLightElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGFESpotLightElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGFESpotLightElement"))];
  dart.registerExtension(dart.global.SVGFESpotLightElement, svg$.FESpotLightElement);
  dart.defineExtensionNames([
    'in1',
    'height',
    'result',
    'width',
    'x',
    'y'
  ]);
  svg$.FETileElement = class FETileElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("feTile"), svg$.FETileElement);
    }
    created() {
      this[dartx.in1] = null;
      this[dartx.height] = null;
      this[dartx.result] = null;
      this[dartx.width] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      super.created();
    }
    static get supported() {
      return dart.notNull(svg$.SvgElement.isTagSupported('feTile')) && dart.is(svg$.SvgElement.tag('feTile'), svg$.FETileElement);
    }
    get [dartx.in1]() {
      return this.in1;
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.result]() {
      return this.result;
    }
    get [dartx.width]() {
      return this.width;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
  };
  dart.defineNamedConstructor(svg$.FETileElement, 'created');
  svg$.FETileElement[dart.implements] = () => [svg$.FilterPrimitiveStandardAttributes];
  dart.setSignature(svg$.FETileElement, {
    constructors: () => ({
      _: [svg$.FETileElement, []],
      new: [svg$.FETileElement, []],
      created: [svg$.FETileElement, []]
    })
  });
  svg$.FETileElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGFETileElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGFETileElement"))];
  dart.registerExtension(dart.global.SVGFETileElement, svg$.FETileElement);
  dart.defineExtensionNames([
    'baseFrequencyX',
    'baseFrequencyY',
    'numOctaves',
    'seed',
    'stitchTiles',
    'type',
    'height',
    'result',
    'width',
    'x',
    'y'
  ]);
  svg$.FETurbulenceElement = class FETurbulenceElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("feTurbulence"), svg$.FETurbulenceElement);
    }
    created() {
      this[dartx.baseFrequencyX] = null;
      this[dartx.baseFrequencyY] = null;
      this[dartx.numOctaves] = null;
      this[dartx.seed] = null;
      this[dartx.stitchTiles] = null;
      this[dartx.type] = null;
      this[dartx.height] = null;
      this[dartx.result] = null;
      this[dartx.width] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      super.created();
    }
    static get supported() {
      return dart.notNull(svg$.SvgElement.isTagSupported('feTurbulence')) && dart.is(svg$.SvgElement.tag('feTurbulence'), svg$.FETurbulenceElement);
    }
    get [dartx.baseFrequencyX]() {
      return this.baseFrequencyX;
    }
    get [dartx.baseFrequencyY]() {
      return this.baseFrequencyY;
    }
    get [dartx.numOctaves]() {
      return this.numOctaves;
    }
    get [dartx.seed]() {
      return this.seed;
    }
    get [dartx.stitchTiles]() {
      return this.stitchTiles;
    }
    get [dartx.type]() {
      return this.type;
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.result]() {
      return this.result;
    }
    get [dartx.width]() {
      return this.width;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
  };
  dart.defineNamedConstructor(svg$.FETurbulenceElement, 'created');
  svg$.FETurbulenceElement[dart.implements] = () => [svg$.FilterPrimitiveStandardAttributes];
  dart.setSignature(svg$.FETurbulenceElement, {
    constructors: () => ({
      _: [svg$.FETurbulenceElement, []],
      new: [svg$.FETurbulenceElement, []],
      created: [svg$.FETurbulenceElement, []]
    })
  });
  svg$.FETurbulenceElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGFETurbulenceElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGFETurbulenceElement"))];
  svg$.FETurbulenceElement.SVG_STITCHTYPE_NOSTITCH = 2;
  svg$.FETurbulenceElement.SVG_STITCHTYPE_STITCH = 1;
  svg$.FETurbulenceElement.SVG_STITCHTYPE_UNKNOWN = 0;
  svg$.FETurbulenceElement.SVG_TURBULENCE_TYPE_FRACTALNOISE = 1;
  svg$.FETurbulenceElement.SVG_TURBULENCE_TYPE_TURBULENCE = 2;
  svg$.FETurbulenceElement.SVG_TURBULENCE_TYPE_UNKNOWN = 0;
  dart.registerExtension(dart.global.SVGFETurbulenceElement, svg$.FETurbulenceElement);
  dart.defineExtensionNames([
    'filterUnits',
    'height',
    'primitiveUnits',
    'width',
    'x',
    'y',
    'href'
  ]);
  svg$.FilterElement = class FilterElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("filter"), svg$.FilterElement);
    }
    created() {
      this[dartx.filterUnits] = null;
      this[dartx.height] = null;
      this[dartx.primitiveUnits] = null;
      this[dartx.width] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      this[dartx.href] = null;
      super.created();
    }
    static get supported() {
      return dart.notNull(svg$.SvgElement.isTagSupported('filter')) && dart.is(svg$.SvgElement.tag('filter'), svg$.FilterElement);
    }
    get [dartx.filterUnits]() {
      return this.filterUnits;
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.primitiveUnits]() {
      return this.primitiveUnits;
    }
    get [dartx.width]() {
      return this.width;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
    get [dartx.href]() {
      return this.href;
    }
  };
  dart.defineNamedConstructor(svg$.FilterElement, 'created');
  svg$.FilterElement[dart.implements] = () => [svg$.UriReference];
  dart.setSignature(svg$.FilterElement, {
    constructors: () => ({
      _: [svg$.FilterElement, []],
      new: [svg$.FilterElement, []],
      created: [svg$.FilterElement, []]
    })
  });
  svg$.FilterElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGFilterElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGFilterElement"))];
  dart.registerExtension(dart.global.SVGFilterElement, svg$.FilterElement);
  dart.defineExtensionNames([
    'height',
    'result',
    'width',
    'x',
    'y'
  ]);
  svg$.FilterPrimitiveStandardAttributes = class FilterPrimitiveStandardAttributes extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(svg$.FilterPrimitiveStandardAttributes, {
    constructors: () => ({_: [svg$.FilterPrimitiveStandardAttributes, []]})
  });
  dart.defineExtensionMembers(svg$.FilterPrimitiveStandardAttributes, [
    'height',
    'result',
    'width',
    'x',
    'y'
  ]);
  svg$.FilterPrimitiveStandardAttributes[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGFilterPrimitiveStandardAttributes')), dart.const(new _metadata.Unstable())];
  dart.defineExtensionNames([
    'preserveAspectRatio',
    'viewBox'
  ]);
  svg$.FitToViewBox = class FitToViewBox extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(svg$.FitToViewBox, {
    constructors: () => ({_: [svg$.FitToViewBox, []]})
  });
  dart.defineExtensionMembers(svg$.FitToViewBox, ['preserveAspectRatio', 'viewBox']);
  svg$.FitToViewBox[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGFitToViewBox')), dart.const(new _metadata.Unstable())];
  dart.defineExtensionNames([
    'height',
    'width',
    'x',
    'y'
  ]);
  svg$.ForeignObjectElement = class ForeignObjectElement extends svg$.GraphicsElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("foreignObject"), svg$.ForeignObjectElement);
    }
    created() {
      this[dartx.height] = null;
      this[dartx.width] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      super.created();
    }
    static get supported() {
      return dart.notNull(svg$.SvgElement.isTagSupported('foreignObject')) && dart.is(svg$.SvgElement.tag('foreignObject'), svg$.ForeignObjectElement);
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.width]() {
      return this.width;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
  };
  dart.defineNamedConstructor(svg$.ForeignObjectElement, 'created');
  dart.setSignature(svg$.ForeignObjectElement, {
    constructors: () => ({
      _: [svg$.ForeignObjectElement, []],
      new: [svg$.ForeignObjectElement, []],
      created: [svg$.ForeignObjectElement, []]
    })
  });
  svg$.ForeignObjectElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGForeignObjectElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGForeignObjectElement"))];
  dart.registerExtension(dart.global.SVGForeignObjectElement, svg$.ForeignObjectElement);
  svg$.GElement = class GElement extends svg$.GraphicsElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("g"), svg$.GElement);
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(svg$.GElement, 'created');
  dart.setSignature(svg$.GElement, {
    constructors: () => ({
      _: [svg$.GElement, []],
      new: [svg$.GElement, []],
      created: [svg$.GElement, []]
    })
  });
  svg$.GElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGGElement')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGGElement"))];
  dart.registerExtension(dart.global.SVGGElement, svg$.GElement);
  dart.defineExtensionNames([
    'height',
    'preserveAspectRatio',
    'width',
    'x',
    'y',
    'href'
  ]);
  svg$.ImageElement = class ImageElement extends svg$.GraphicsElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("image"), svg$.ImageElement);
    }
    created() {
      this[dartx.height] = null;
      this[dartx.preserveAspectRatio] = null;
      this[dartx.width] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      this[dartx.href] = null;
      super.created();
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.preserveAspectRatio]() {
      return this.preserveAspectRatio;
    }
    get [dartx.width]() {
      return this.width;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
    get [dartx.href]() {
      return this.href;
    }
  };
  dart.defineNamedConstructor(svg$.ImageElement, 'created');
  svg$.ImageElement[dart.implements] = () => [svg$.UriReference];
  dart.setSignature(svg$.ImageElement, {
    constructors: () => ({
      _: [svg$.ImageElement, []],
      new: [svg$.ImageElement, []],
      created: [svg$.ImageElement, []]
    })
  });
  svg$.ImageElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGImageElement')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGImageElement"))];
  dart.registerExtension(dart.global.SVGImageElement, svg$.ImageElement);
  dart.defineExtensionNames([
    'convertToSpecifiedUnits',
    'newValueSpecifiedUnits',
    'unitType',
    'value',
    'valueAsString',
    'valueInSpecifiedUnits'
  ]);
  svg$.Length = class Length extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.unitType]() {
      return this.unitType;
    }
    get [dartx.value]() {
      return this.value;
    }
    set [dartx.value](value) {
      this.value = value;
    }
    get [dartx.valueAsString]() {
      return this.valueAsString;
    }
    set [dartx.valueAsString](value) {
      this.valueAsString = value;
    }
    get [dartx.valueInSpecifiedUnits]() {
      return this.valueInSpecifiedUnits;
    }
    set [dartx.valueInSpecifiedUnits](value) {
      this.valueInSpecifiedUnits = value;
    }
    [dartx.convertToSpecifiedUnits](unitType) {
      return this.convertToSpecifiedUnits(unitType);
    }
    [dartx.newValueSpecifiedUnits](unitType, valueInSpecifiedUnits) {
      return this.newValueSpecifiedUnits(unitType, valueInSpecifiedUnits);
    }
  };
  dart.setSignature(svg$.Length, {
    constructors: () => ({_: [svg$.Length, []]}),
    methods: () => ({
      [dartx.convertToSpecifiedUnits]: [dart.void, [core.int]],
      [dartx.newValueSpecifiedUnits]: [dart.void, [core.int, core.num]]
    })
  });
  svg$.Length[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGLength')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGLength"))];
  svg$.Length.SVG_LENGTHTYPE_CM = 6;
  svg$.Length.SVG_LENGTHTYPE_EMS = 3;
  svg$.Length.SVG_LENGTHTYPE_EXS = 4;
  svg$.Length.SVG_LENGTHTYPE_IN = 8;
  svg$.Length.SVG_LENGTHTYPE_MM = 7;
  svg$.Length.SVG_LENGTHTYPE_NUMBER = 1;
  svg$.Length.SVG_LENGTHTYPE_PC = 10;
  svg$.Length.SVG_LENGTHTYPE_PERCENTAGE = 2;
  svg$.Length.SVG_LENGTHTYPE_PT = 9;
  svg$.Length.SVG_LENGTHTYPE_PX = 5;
  svg$.Length.SVG_LENGTHTYPE_UNKNOWN = 0;
  dart.registerExtension(dart.global.SVGLength, svg$.Length);
  const __setter__$ = Symbol('__setter__');
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'appendItem',
    'clear',
    'getItem',
    'initialize',
    'insertItemBefore',
    'removeItem',
    'replaceItem',
    'numberOfItems'
  ]);
  svg$.LengthList = class LengthList extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(svg$.Length), html$.ImmutableListMixin$(svg$.Length)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    get [dartx.numberOfItems]() {
      return this.numberOfItems;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return this[dartx.getItem](index);
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return this[0];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return this[dart.notNull(len) - 1];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return this[0];
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [__setter__$](index, newItem) {
      return this.__setter__(index, newItem);
    }
    [dartx.appendItem](newItem) {
      return this.appendItem(newItem);
    }
    [dartx.clear]() {
      return this.clear();
    }
    [dartx.getItem](index) {
      return this.getItem(index);
    }
    [dartx.initialize](newItem) {
      return this.initialize(newItem);
    }
    [dartx.insertItemBefore](newItem, index) {
      return this.insertItemBefore(newItem, index);
    }
    [dartx.removeItem](index) {
      return this.removeItem(index);
    }
    [dartx.replaceItem](newItem, index) {
      return this.replaceItem(newItem, index);
    }
  };
  svg$.LengthList[dart.implements] = () => [core.List$(svg$.Length)];
  dart.setSignature(svg$.LengthList, {
    constructors: () => ({_: [svg$.LengthList, []]}),
    methods: () => ({
      [dartx.get]: [svg$.Length, [core.int]],
      [dartx.set]: [dart.void, [core.int, svg$.Length]],
      [dartx.elementAt]: [svg$.Length, [core.int]],
      [__setter__$]: [dart.void, [core.int, svg$.Length]],
      [dartx.appendItem]: [svg$.Length, [svg$.Length]],
      [dartx.getItem]: [svg$.Length, [core.int]],
      [dartx.initialize]: [svg$.Length, [svg$.Length]],
      [dartx.insertItemBefore]: [svg$.Length, [svg$.Length, core.int]],
      [dartx.removeItem]: [svg$.Length, [core.int]],
      [dartx.replaceItem]: [svg$.Length, [svg$.Length, core.int]]
    })
  });
  svg$.LengthList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGLengthList')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGLengthList"))];
  dart.registerExtension(dart.global.SVGLengthList, svg$.LengthList);
  dart.defineExtensionNames([
    'x1',
    'x2',
    'y1',
    'y2'
  ]);
  svg$.LineElement = class LineElement extends svg$.GeometryElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("line"), svg$.LineElement);
    }
    created() {
      this[dartx.x1] = null;
      this[dartx.x2] = null;
      this[dartx.y1] = null;
      this[dartx.y2] = null;
      super.created();
    }
    get [dartx.x1]() {
      return this.x1;
    }
    get [dartx.x2]() {
      return this.x2;
    }
    get [dartx.y1]() {
      return this.y1;
    }
    get [dartx.y2]() {
      return this.y2;
    }
  };
  dart.defineNamedConstructor(svg$.LineElement, 'created');
  dart.setSignature(svg$.LineElement, {
    constructors: () => ({
      _: [svg$.LineElement, []],
      new: [svg$.LineElement, []],
      created: [svg$.LineElement, []]
    })
  });
  svg$.LineElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGLineElement')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGLineElement"))];
  dart.registerExtension(dart.global.SVGLineElement, svg$.LineElement);
  dart.defineExtensionNames([
    'gradientTransform',
    'gradientUnits',
    'spreadMethod',
    'href'
  ]);
  svg$._GradientElement = class _GradientElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      this[dartx.gradientTransform] = null;
      this[dartx.gradientUnits] = null;
      this[dartx.spreadMethod] = null;
      this[dartx.href] = null;
      super.created();
    }
    get [dartx.gradientTransform]() {
      return this.gradientTransform;
    }
    get [dartx.gradientUnits]() {
      return this.gradientUnits;
    }
    get [dartx.spreadMethod]() {
      return this.spreadMethod;
    }
    get [dartx.href]() {
      return this.href;
    }
  };
  dart.defineNamedConstructor(svg$._GradientElement, 'created');
  svg$._GradientElement[dart.implements] = () => [svg$.UriReference];
  dart.setSignature(svg$._GradientElement, {
    constructors: () => ({
      _: [svg$._GradientElement, []],
      created: [svg$._GradientElement, []]
    })
  });
  svg$._GradientElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGGradientElement')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGGradientElement"))];
  svg$._GradientElement.SVG_SPREADMETHOD_PAD = 1;
  svg$._GradientElement.SVG_SPREADMETHOD_REFLECT = 2;
  svg$._GradientElement.SVG_SPREADMETHOD_REPEAT = 3;
  svg$._GradientElement.SVG_SPREADMETHOD_UNKNOWN = 0;
  dart.registerExtension(dart.global.SVGGradientElement, svg$._GradientElement);
  dart.defineExtensionNames([
    'x1',
    'x2',
    'y1',
    'y2'
  ]);
  svg$.LinearGradientElement = class LinearGradientElement extends svg$._GradientElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("linearGradient"), svg$.LinearGradientElement);
    }
    created() {
      this[dartx.x1] = null;
      this[dartx.x2] = null;
      this[dartx.y1] = null;
      this[dartx.y2] = null;
      super.created();
    }
    get [dartx.x1]() {
      return this.x1;
    }
    get [dartx.x2]() {
      return this.x2;
    }
    get [dartx.y1]() {
      return this.y1;
    }
    get [dartx.y2]() {
      return this.y2;
    }
  };
  dart.defineNamedConstructor(svg$.LinearGradientElement, 'created');
  dart.setSignature(svg$.LinearGradientElement, {
    constructors: () => ({
      _: [svg$.LinearGradientElement, []],
      new: [svg$.LinearGradientElement, []],
      created: [svg$.LinearGradientElement, []]
    })
  });
  svg$.LinearGradientElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGLinearGradientElement')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGLinearGradientElement"))];
  dart.registerExtension(dart.global.SVGLinearGradientElement, svg$.LinearGradientElement);
  dart.defineExtensionNames([
    'setOrientToAngle',
    'setOrientToAuto',
    'markerHeight',
    'markerUnits',
    'markerWidth',
    'orientAngle',
    'orientType',
    'refX',
    'refY',
    'preserveAspectRatio',
    'viewBox'
  ]);
  svg$.MarkerElement = class MarkerElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("marker"), svg$.MarkerElement);
    }
    created() {
      this[dartx.markerHeight] = null;
      this[dartx.markerUnits] = null;
      this[dartx.markerWidth] = null;
      this[dartx.orientAngle] = null;
      this[dartx.orientType] = null;
      this[dartx.refX] = null;
      this[dartx.refY] = null;
      this[dartx.preserveAspectRatio] = null;
      this[dartx.viewBox] = null;
      super.created();
    }
    get [dartx.markerHeight]() {
      return this.markerHeight;
    }
    get [dartx.markerUnits]() {
      return this.markerUnits;
    }
    get [dartx.markerWidth]() {
      return this.markerWidth;
    }
    get [dartx.orientAngle]() {
      return this.orientAngle;
    }
    get [dartx.orientType]() {
      return this.orientType;
    }
    get [dartx.refX]() {
      return this.refX;
    }
    get [dartx.refY]() {
      return this.refY;
    }
    [dartx.setOrientToAngle](angle) {
      return this.setOrientToAngle(angle);
    }
    [dartx.setOrientToAuto]() {
      return this.setOrientToAuto();
    }
    get [dartx.preserveAspectRatio]() {
      return this.preserveAspectRatio;
    }
    get [dartx.viewBox]() {
      return this.viewBox;
    }
  };
  dart.defineNamedConstructor(svg$.MarkerElement, 'created');
  svg$.MarkerElement[dart.implements] = () => [svg$.FitToViewBox];
  dart.setSignature(svg$.MarkerElement, {
    constructors: () => ({
      _: [svg$.MarkerElement, []],
      new: [svg$.MarkerElement, []],
      created: [svg$.MarkerElement, []]
    }),
    methods: () => ({
      [dartx.setOrientToAngle]: [dart.void, [svg$.Angle]],
      [dartx.setOrientToAuto]: [dart.void, []]
    })
  });
  svg$.MarkerElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGMarkerElement')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGMarkerElement"))];
  svg$.MarkerElement.SVG_MARKERUNITS_STROKEWIDTH = 2;
  svg$.MarkerElement.SVG_MARKERUNITS_UNKNOWN = 0;
  svg$.MarkerElement.SVG_MARKERUNITS_USERSPACEONUSE = 1;
  svg$.MarkerElement.SVG_MARKER_ORIENT_ANGLE = 2;
  svg$.MarkerElement.SVG_MARKER_ORIENT_AUTO = 1;
  svg$.MarkerElement.SVG_MARKER_ORIENT_UNKNOWN = 0;
  dart.registerExtension(dart.global.SVGMarkerElement, svg$.MarkerElement);
  dart.defineExtensionNames([
    'hasExtension',
    'height',
    'maskContentUnits',
    'maskUnits',
    'width',
    'x',
    'y',
    'requiredExtensions',
    'requiredFeatures',
    'systemLanguage'
  ]);
  svg$.MaskElement = class MaskElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("mask"), svg$.MaskElement);
    }
    created() {
      this[dartx.height] = null;
      this[dartx.maskContentUnits] = null;
      this[dartx.maskUnits] = null;
      this[dartx.width] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      this[dartx.requiredExtensions] = null;
      this[dartx.requiredFeatures] = null;
      this[dartx.systemLanguage] = null;
      super.created();
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.maskContentUnits]() {
      return this.maskContentUnits;
    }
    get [dartx.maskUnits]() {
      return this.maskUnits;
    }
    get [dartx.width]() {
      return this.width;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
    get [dartx.requiredExtensions]() {
      return this.requiredExtensions;
    }
    get [dartx.requiredFeatures]() {
      return this.requiredFeatures;
    }
    get [dartx.systemLanguage]() {
      return this.systemLanguage;
    }
    [dartx.hasExtension](extension) {
      return this.hasExtension(extension);
    }
  };
  dart.defineNamedConstructor(svg$.MaskElement, 'created');
  svg$.MaskElement[dart.implements] = () => [svg$.Tests];
  dart.setSignature(svg$.MaskElement, {
    constructors: () => ({
      _: [svg$.MaskElement, []],
      new: [svg$.MaskElement, []],
      created: [svg$.MaskElement, []]
    }),
    methods: () => ({[dartx.hasExtension]: [core.bool, [core.String]]})
  });
  svg$.MaskElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGMaskElement')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGMaskElement"))];
  dart.registerExtension(dart.global.SVGMaskElement, svg$.MaskElement);
  dart.defineExtensionNames([
    'flipX',
    'flipY',
    'inverse',
    'multiply',
    'rotate',
    'rotateFromVector',
    'scale',
    'scaleNonUniform',
    'skewX',
    'skewY',
    'translate',
    'a',
    'b',
    'c',
    'd',
    'e',
    'f'
  ]);
  svg$.Matrix = class Matrix extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.a]() {
      return this.a;
    }
    set [dartx.a](value) {
      this.a = value;
    }
    get [dartx.b]() {
      return this.b;
    }
    set [dartx.b](value) {
      this.b = value;
    }
    get [dartx.c]() {
      return this.c;
    }
    set [dartx.c](value) {
      this.c = value;
    }
    get [dartx.d]() {
      return this.d;
    }
    set [dartx.d](value) {
      this.d = value;
    }
    get [dartx.e]() {
      return this.e;
    }
    set [dartx.e](value) {
      this.e = value;
    }
    get [dartx.f]() {
      return this.f;
    }
    set [dartx.f](value) {
      this.f = value;
    }
    [dartx.flipX]() {
      return this.flipX();
    }
    [dartx.flipY]() {
      return this.flipY();
    }
    [dartx.inverse]() {
      return this.inverse();
    }
    [dartx.multiply](secondMatrix) {
      return this.multiply(secondMatrix);
    }
    [dartx.rotate](angle) {
      return this.rotate(angle);
    }
    [dartx.rotateFromVector](x, y) {
      return this.rotateFromVector(x, y);
    }
    [dartx.scale](scaleFactor) {
      return this.scale(scaleFactor);
    }
    [dartx.scaleNonUniform](scaleFactorX, scaleFactorY) {
      return this.scaleNonUniform(scaleFactorX, scaleFactorY);
    }
    [dartx.skewX](angle) {
      return this.skewX(angle);
    }
    [dartx.skewY](angle) {
      return this.skewY(angle);
    }
    [dartx.translate](x, y) {
      return this.translate(x, y);
    }
  };
  dart.setSignature(svg$.Matrix, {
    constructors: () => ({_: [svg$.Matrix, []]}),
    methods: () => ({
      [dartx.flipX]: [svg$.Matrix, []],
      [dartx.flipY]: [svg$.Matrix, []],
      [dartx.inverse]: [svg$.Matrix, []],
      [dartx.multiply]: [svg$.Matrix, [svg$.Matrix]],
      [dartx.rotate]: [svg$.Matrix, [core.num]],
      [dartx.rotateFromVector]: [svg$.Matrix, [core.num, core.num]],
      [dartx.scale]: [svg$.Matrix, [core.num]],
      [dartx.scaleNonUniform]: [svg$.Matrix, [core.num, core.num]],
      [dartx.skewX]: [svg$.Matrix, [core.num]],
      [dartx.skewY]: [svg$.Matrix, [core.num]],
      [dartx.translate]: [svg$.Matrix, [core.num, core.num]]
    })
  });
  svg$.Matrix[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGMatrix')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGMatrix"))];
  dart.registerExtension(dart.global.SVGMatrix, svg$.Matrix);
  svg$.MetadataElement = class MetadataElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(svg$.MetadataElement, 'created');
  dart.setSignature(svg$.MetadataElement, {
    constructors: () => ({
      _: [svg$.MetadataElement, []],
      created: [svg$.MetadataElement, []]
    })
  });
  svg$.MetadataElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGMetadataElement')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGMetadataElement"))];
  dart.registerExtension(dart.global.SVGMetadataElement, svg$.MetadataElement);
  dart.defineExtensionNames([
    'value'
  ]);
  svg$.Number = class Number extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.value]() {
      return this.value;
    }
    set [dartx.value](value) {
      this.value = value;
    }
  };
  dart.setSignature(svg$.Number, {
    constructors: () => ({_: [svg$.Number, []]})
  });
  svg$.Number[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGNumber')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGNumber"))];
  dart.registerExtension(dart.global.SVGNumber, svg$.Number);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'appendItem',
    'clear',
    'getItem',
    'initialize',
    'insertItemBefore',
    'removeItem',
    'replaceItem',
    'numberOfItems'
  ]);
  svg$.NumberList = class NumberList extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(svg$.Number), html$.ImmutableListMixin$(svg$.Number)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    get [dartx.numberOfItems]() {
      return this.numberOfItems;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return this[dartx.getItem](index);
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return this[0];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return this[dart.notNull(len) - 1];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return this[0];
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [__setter__$](index, newItem) {
      return this.__setter__(index, newItem);
    }
    [dartx.appendItem](newItem) {
      return this.appendItem(newItem);
    }
    [dartx.clear]() {
      return this.clear();
    }
    [dartx.getItem](index) {
      return this.getItem(index);
    }
    [dartx.initialize](newItem) {
      return this.initialize(newItem);
    }
    [dartx.insertItemBefore](newItem, index) {
      return this.insertItemBefore(newItem, index);
    }
    [dartx.removeItem](index) {
      return this.removeItem(index);
    }
    [dartx.replaceItem](newItem, index) {
      return this.replaceItem(newItem, index);
    }
  };
  svg$.NumberList[dart.implements] = () => [core.List$(svg$.Number)];
  dart.setSignature(svg$.NumberList, {
    constructors: () => ({_: [svg$.NumberList, []]}),
    methods: () => ({
      [dartx.get]: [svg$.Number, [core.int]],
      [dartx.set]: [dart.void, [core.int, svg$.Number]],
      [dartx.elementAt]: [svg$.Number, [core.int]],
      [__setter__$]: [dart.void, [core.int, svg$.Number]],
      [dartx.appendItem]: [svg$.Number, [svg$.Number]],
      [dartx.getItem]: [svg$.Number, [core.int]],
      [dartx.initialize]: [svg$.Number, [svg$.Number]],
      [dartx.insertItemBefore]: [svg$.Number, [svg$.Number, core.int]],
      [dartx.removeItem]: [svg$.Number, [core.int]],
      [dartx.replaceItem]: [svg$.Number, [svg$.Number, core.int]]
    })
  });
  svg$.NumberList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGNumberList')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGNumberList"))];
  dart.registerExtension(dart.global.SVGNumberList, svg$.NumberList);
  dart.defineExtensionNames([
    'createSvgPathSegArcAbs',
    'createSvgPathSegArcRel',
    'createSvgPathSegClosePath',
    'createSvgPathSegCurvetoCubicAbs',
    'createSvgPathSegCurvetoCubicRel',
    'createSvgPathSegCurvetoCubicSmoothAbs',
    'createSvgPathSegCurvetoCubicSmoothRel',
    'createSvgPathSegCurvetoQuadraticAbs',
    'createSvgPathSegCurvetoQuadraticRel',
    'createSvgPathSegCurvetoQuadraticSmoothAbs',
    'createSvgPathSegCurvetoQuadraticSmoothRel',
    'createSvgPathSegLinetoAbs',
    'createSvgPathSegLinetoHorizontalAbs',
    'createSvgPathSegLinetoHorizontalRel',
    'createSvgPathSegLinetoRel',
    'createSvgPathSegLinetoVerticalAbs',
    'createSvgPathSegLinetoVerticalRel',
    'createSvgPathSegMovetoAbs',
    'createSvgPathSegMovetoRel',
    'getPathSegAtLength',
    'getPointAtLength',
    'getTotalLength',
    'animatedNormalizedPathSegList',
    'animatedPathSegList',
    'normalizedPathSegList',
    'pathLength',
    'pathSegList'
  ]);
  svg$.PathElement = class PathElement extends svg$.GeometryElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("path"), svg$.PathElement);
    }
    created() {
      this[dartx.animatedNormalizedPathSegList] = null;
      this[dartx.animatedPathSegList] = null;
      this[dartx.normalizedPathSegList] = null;
      this[dartx.pathLength] = null;
      this[dartx.pathSegList] = null;
      super.created();
    }
    get [dartx.animatedNormalizedPathSegList]() {
      return this.animatedNormalizedPathSegList;
    }
    get [dartx.animatedPathSegList]() {
      return this.animatedPathSegList;
    }
    get [dartx.normalizedPathSegList]() {
      return this.normalizedPathSegList;
    }
    get [dartx.pathLength]() {
      return this.pathLength;
    }
    get [dartx.pathSegList]() {
      return this.pathSegList;
    }
    [dartx.createSvgPathSegArcAbs](x, y, r1, r2, angle, largeArcFlag, sweepFlag) {
      return this.createSVGPathSegArcAbs(x, y, r1, r2, angle, largeArcFlag, sweepFlag);
    }
    [dartx.createSvgPathSegArcRel](x, y, r1, r2, angle, largeArcFlag, sweepFlag) {
      return this.createSVGPathSegArcRel(x, y, r1, r2, angle, largeArcFlag, sweepFlag);
    }
    [dartx.createSvgPathSegClosePath]() {
      return this.createSVGPathSegClosePath();
    }
    [dartx.createSvgPathSegCurvetoCubicAbs](x, y, x1, y1, x2, y2) {
      return this.createSVGPathSegCurvetoCubicAbs(x, y, x1, y1, x2, y2);
    }
    [dartx.createSvgPathSegCurvetoCubicRel](x, y, x1, y1, x2, y2) {
      return this.createSVGPathSegCurvetoCubicRel(x, y, x1, y1, x2, y2);
    }
    [dartx.createSvgPathSegCurvetoCubicSmoothAbs](x, y, x2, y2) {
      return this.createSVGPathSegCurvetoCubicSmoothAbs(x, y, x2, y2);
    }
    [dartx.createSvgPathSegCurvetoCubicSmoothRel](x, y, x2, y2) {
      return this.createSVGPathSegCurvetoCubicSmoothRel(x, y, x2, y2);
    }
    [dartx.createSvgPathSegCurvetoQuadraticAbs](x, y, x1, y1) {
      return this.createSVGPathSegCurvetoQuadraticAbs(x, y, x1, y1);
    }
    [dartx.createSvgPathSegCurvetoQuadraticRel](x, y, x1, y1) {
      return this.createSVGPathSegCurvetoQuadraticRel(x, y, x1, y1);
    }
    [dartx.createSvgPathSegCurvetoQuadraticSmoothAbs](x, y) {
      return this.createSVGPathSegCurvetoQuadraticSmoothAbs(x, y);
    }
    [dartx.createSvgPathSegCurvetoQuadraticSmoothRel](x, y) {
      return this.createSVGPathSegCurvetoQuadraticSmoothRel(x, y);
    }
    [dartx.createSvgPathSegLinetoAbs](x, y) {
      return this.createSVGPathSegLinetoAbs(x, y);
    }
    [dartx.createSvgPathSegLinetoHorizontalAbs](x) {
      return this.createSVGPathSegLinetoHorizontalAbs(x);
    }
    [dartx.createSvgPathSegLinetoHorizontalRel](x) {
      return this.createSVGPathSegLinetoHorizontalRel(x);
    }
    [dartx.createSvgPathSegLinetoRel](x, y) {
      return this.createSVGPathSegLinetoRel(x, y);
    }
    [dartx.createSvgPathSegLinetoVerticalAbs](y) {
      return this.createSVGPathSegLinetoVerticalAbs(y);
    }
    [dartx.createSvgPathSegLinetoVerticalRel](y) {
      return this.createSVGPathSegLinetoVerticalRel(y);
    }
    [dartx.createSvgPathSegMovetoAbs](x, y) {
      return this.createSVGPathSegMovetoAbs(x, y);
    }
    [dartx.createSvgPathSegMovetoRel](x, y) {
      return this.createSVGPathSegMovetoRel(x, y);
    }
    [dartx.getPathSegAtLength](distance) {
      return this.getPathSegAtLength(distance);
    }
    [dartx.getPointAtLength](distance) {
      return this.getPointAtLength(distance);
    }
    [dartx.getTotalLength]() {
      return this.getTotalLength();
    }
  };
  dart.defineNamedConstructor(svg$.PathElement, 'created');
  dart.setSignature(svg$.PathElement, {
    constructors: () => ({
      _: [svg$.PathElement, []],
      new: [svg$.PathElement, []],
      created: [svg$.PathElement, []]
    }),
    methods: () => ({
      [dartx.createSvgPathSegArcAbs]: [svg$.PathSegArcAbs, [core.num, core.num, core.num, core.num, core.num, core.bool, core.bool]],
      [dartx.createSvgPathSegArcRel]: [svg$.PathSegArcRel, [core.num, core.num, core.num, core.num, core.num, core.bool, core.bool]],
      [dartx.createSvgPathSegClosePath]: [svg$.PathSegClosePath, []],
      [dartx.createSvgPathSegCurvetoCubicAbs]: [svg$.PathSegCurvetoCubicAbs, [core.num, core.num, core.num, core.num, core.num, core.num]],
      [dartx.createSvgPathSegCurvetoCubicRel]: [svg$.PathSegCurvetoCubicRel, [core.num, core.num, core.num, core.num, core.num, core.num]],
      [dartx.createSvgPathSegCurvetoCubicSmoothAbs]: [svg$.PathSegCurvetoCubicSmoothAbs, [core.num, core.num, core.num, core.num]],
      [dartx.createSvgPathSegCurvetoCubicSmoothRel]: [svg$.PathSegCurvetoCubicSmoothRel, [core.num, core.num, core.num, core.num]],
      [dartx.createSvgPathSegCurvetoQuadraticAbs]: [svg$.PathSegCurvetoQuadraticAbs, [core.num, core.num, core.num, core.num]],
      [dartx.createSvgPathSegCurvetoQuadraticRel]: [svg$.PathSegCurvetoQuadraticRel, [core.num, core.num, core.num, core.num]],
      [dartx.createSvgPathSegCurvetoQuadraticSmoothAbs]: [svg$.PathSegCurvetoQuadraticSmoothAbs, [core.num, core.num]],
      [dartx.createSvgPathSegCurvetoQuadraticSmoothRel]: [svg$.PathSegCurvetoQuadraticSmoothRel, [core.num, core.num]],
      [dartx.createSvgPathSegLinetoAbs]: [svg$.PathSegLinetoAbs, [core.num, core.num]],
      [dartx.createSvgPathSegLinetoHorizontalAbs]: [svg$.PathSegLinetoHorizontalAbs, [core.num]],
      [dartx.createSvgPathSegLinetoHorizontalRel]: [svg$.PathSegLinetoHorizontalRel, [core.num]],
      [dartx.createSvgPathSegLinetoRel]: [svg$.PathSegLinetoRel, [core.num, core.num]],
      [dartx.createSvgPathSegLinetoVerticalAbs]: [svg$.PathSegLinetoVerticalAbs, [core.num]],
      [dartx.createSvgPathSegLinetoVerticalRel]: [svg$.PathSegLinetoVerticalRel, [core.num]],
      [dartx.createSvgPathSegMovetoAbs]: [svg$.PathSegMovetoAbs, [core.num, core.num]],
      [dartx.createSvgPathSegMovetoRel]: [svg$.PathSegMovetoRel, [core.num, core.num]],
      [dartx.getPathSegAtLength]: [core.int, [core.num]],
      [dartx.getPointAtLength]: [svg$.Point, [core.num]],
      [dartx.getTotalLength]: [core.double, []]
    })
  });
  svg$.PathElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGPathElement')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGPathElement"))];
  dart.registerExtension(dart.global.SVGPathElement, svg$.PathElement);
  dart.defineExtensionNames([
    'pathSegType',
    'pathSegTypeAsLetter'
  ]);
  svg$.PathSeg = class PathSeg extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.pathSegType]() {
      return this.pathSegType;
    }
    get [dartx.pathSegTypeAsLetter]() {
      return this.pathSegTypeAsLetter;
    }
  };
  dart.setSignature(svg$.PathSeg, {
    constructors: () => ({_: [svg$.PathSeg, []]})
  });
  svg$.PathSeg[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGPathSeg')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGPathSeg"))];
  svg$.PathSeg.PATHSEG_ARC_ABS = 10;
  svg$.PathSeg.PATHSEG_ARC_REL = 11;
  svg$.PathSeg.PATHSEG_CLOSEPATH = 1;
  svg$.PathSeg.PATHSEG_CURVETO_CUBIC_ABS = 6;
  svg$.PathSeg.PATHSEG_CURVETO_CUBIC_REL = 7;
  svg$.PathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS = 16;
  svg$.PathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL = 17;
  svg$.PathSeg.PATHSEG_CURVETO_QUADRATIC_ABS = 8;
  svg$.PathSeg.PATHSEG_CURVETO_QUADRATIC_REL = 9;
  svg$.PathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS = 18;
  svg$.PathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL = 19;
  svg$.PathSeg.PATHSEG_LINETO_ABS = 4;
  svg$.PathSeg.PATHSEG_LINETO_HORIZONTAL_ABS = 12;
  svg$.PathSeg.PATHSEG_LINETO_HORIZONTAL_REL = 13;
  svg$.PathSeg.PATHSEG_LINETO_REL = 5;
  svg$.PathSeg.PATHSEG_LINETO_VERTICAL_ABS = 14;
  svg$.PathSeg.PATHSEG_LINETO_VERTICAL_REL = 15;
  svg$.PathSeg.PATHSEG_MOVETO_ABS = 2;
  svg$.PathSeg.PATHSEG_MOVETO_REL = 3;
  svg$.PathSeg.PATHSEG_UNKNOWN = 0;
  dart.registerExtension(dart.global.SVGPathSeg, svg$.PathSeg);
  dart.defineExtensionNames([
    'angle',
    'largeArcFlag',
    'r1',
    'r2',
    'sweepFlag',
    'x',
    'y'
  ]);
  svg$.PathSegArcAbs = class PathSegArcAbs extends svg$.PathSeg {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.angle]() {
      return this.angle;
    }
    set [dartx.angle](value) {
      this.angle = value;
    }
    get [dartx.largeArcFlag]() {
      return this.largeArcFlag;
    }
    set [dartx.largeArcFlag](value) {
      this.largeArcFlag = value;
    }
    get [dartx.r1]() {
      return this.r1;
    }
    set [dartx.r1](value) {
      this.r1 = value;
    }
    get [dartx.r2]() {
      return this.r2;
    }
    set [dartx.r2](value) {
      this.r2 = value;
    }
    get [dartx.sweepFlag]() {
      return this.sweepFlag;
    }
    set [dartx.sweepFlag](value) {
      this.sweepFlag = value;
    }
    get [dartx.x]() {
      return this.x;
    }
    set [dartx.x](value) {
      this.x = value;
    }
    get [dartx.y]() {
      return this.y;
    }
    set [dartx.y](value) {
      this.y = value;
    }
  };
  dart.setSignature(svg$.PathSegArcAbs, {
    constructors: () => ({_: [svg$.PathSegArcAbs, []]})
  });
  svg$.PathSegArcAbs[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGPathSegArcAbs')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGPathSegArcAbs"))];
  dart.registerExtension(dart.global.SVGPathSegArcAbs, svg$.PathSegArcAbs);
  dart.defineExtensionNames([
    'angle',
    'largeArcFlag',
    'r1',
    'r2',
    'sweepFlag',
    'x',
    'y'
  ]);
  svg$.PathSegArcRel = class PathSegArcRel extends svg$.PathSeg {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.angle]() {
      return this.angle;
    }
    set [dartx.angle](value) {
      this.angle = value;
    }
    get [dartx.largeArcFlag]() {
      return this.largeArcFlag;
    }
    set [dartx.largeArcFlag](value) {
      this.largeArcFlag = value;
    }
    get [dartx.r1]() {
      return this.r1;
    }
    set [dartx.r1](value) {
      this.r1 = value;
    }
    get [dartx.r2]() {
      return this.r2;
    }
    set [dartx.r2](value) {
      this.r2 = value;
    }
    get [dartx.sweepFlag]() {
      return this.sweepFlag;
    }
    set [dartx.sweepFlag](value) {
      this.sweepFlag = value;
    }
    get [dartx.x]() {
      return this.x;
    }
    set [dartx.x](value) {
      this.x = value;
    }
    get [dartx.y]() {
      return this.y;
    }
    set [dartx.y](value) {
      this.y = value;
    }
  };
  dart.setSignature(svg$.PathSegArcRel, {
    constructors: () => ({_: [svg$.PathSegArcRel, []]})
  });
  svg$.PathSegArcRel[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGPathSegArcRel')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGPathSegArcRel"))];
  dart.registerExtension(dart.global.SVGPathSegArcRel, svg$.PathSegArcRel);
  svg$.PathSegClosePath = class PathSegClosePath extends svg$.PathSeg {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(svg$.PathSegClosePath, {
    constructors: () => ({_: [svg$.PathSegClosePath, []]})
  });
  svg$.PathSegClosePath[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGPathSegClosePath')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGPathSegClosePath"))];
  dart.registerExtension(dart.global.SVGPathSegClosePath, svg$.PathSegClosePath);
  dart.defineExtensionNames([
    'x',
    'x1',
    'x2',
    'y',
    'y1',
    'y2'
  ]);
  svg$.PathSegCurvetoCubicAbs = class PathSegCurvetoCubicAbs extends svg$.PathSeg {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.x]() {
      return this.x;
    }
    set [dartx.x](value) {
      this.x = value;
    }
    get [dartx.x1]() {
      return this.x1;
    }
    set [dartx.x1](value) {
      this.x1 = value;
    }
    get [dartx.x2]() {
      return this.x2;
    }
    set [dartx.x2](value) {
      this.x2 = value;
    }
    get [dartx.y]() {
      return this.y;
    }
    set [dartx.y](value) {
      this.y = value;
    }
    get [dartx.y1]() {
      return this.y1;
    }
    set [dartx.y1](value) {
      this.y1 = value;
    }
    get [dartx.y2]() {
      return this.y2;
    }
    set [dartx.y2](value) {
      this.y2 = value;
    }
  };
  dart.setSignature(svg$.PathSegCurvetoCubicAbs, {
    constructors: () => ({_: [svg$.PathSegCurvetoCubicAbs, []]})
  });
  svg$.PathSegCurvetoCubicAbs[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGPathSegCurvetoCubicAbs')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGPathSegCurvetoCubicAbs"))];
  dart.registerExtension(dart.global.SVGPathSegCurvetoCubicAbs, svg$.PathSegCurvetoCubicAbs);
  dart.defineExtensionNames([
    'x',
    'x1',
    'x2',
    'y',
    'y1',
    'y2'
  ]);
  svg$.PathSegCurvetoCubicRel = class PathSegCurvetoCubicRel extends svg$.PathSeg {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.x]() {
      return this.x;
    }
    set [dartx.x](value) {
      this.x = value;
    }
    get [dartx.x1]() {
      return this.x1;
    }
    set [dartx.x1](value) {
      this.x1 = value;
    }
    get [dartx.x2]() {
      return this.x2;
    }
    set [dartx.x2](value) {
      this.x2 = value;
    }
    get [dartx.y]() {
      return this.y;
    }
    set [dartx.y](value) {
      this.y = value;
    }
    get [dartx.y1]() {
      return this.y1;
    }
    set [dartx.y1](value) {
      this.y1 = value;
    }
    get [dartx.y2]() {
      return this.y2;
    }
    set [dartx.y2](value) {
      this.y2 = value;
    }
  };
  dart.setSignature(svg$.PathSegCurvetoCubicRel, {
    constructors: () => ({_: [svg$.PathSegCurvetoCubicRel, []]})
  });
  svg$.PathSegCurvetoCubicRel[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGPathSegCurvetoCubicRel')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGPathSegCurvetoCubicRel"))];
  dart.registerExtension(dart.global.SVGPathSegCurvetoCubicRel, svg$.PathSegCurvetoCubicRel);
  dart.defineExtensionNames([
    'x',
    'x2',
    'y',
    'y2'
  ]);
  svg$.PathSegCurvetoCubicSmoothAbs = class PathSegCurvetoCubicSmoothAbs extends svg$.PathSeg {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.x]() {
      return this.x;
    }
    set [dartx.x](value) {
      this.x = value;
    }
    get [dartx.x2]() {
      return this.x2;
    }
    set [dartx.x2](value) {
      this.x2 = value;
    }
    get [dartx.y]() {
      return this.y;
    }
    set [dartx.y](value) {
      this.y = value;
    }
    get [dartx.y2]() {
      return this.y2;
    }
    set [dartx.y2](value) {
      this.y2 = value;
    }
  };
  dart.setSignature(svg$.PathSegCurvetoCubicSmoothAbs, {
    constructors: () => ({_: [svg$.PathSegCurvetoCubicSmoothAbs, []]})
  });
  svg$.PathSegCurvetoCubicSmoothAbs[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGPathSegCurvetoCubicSmoothAbs')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGPathSegCurvetoCubicSmoothAbs"))];
  dart.registerExtension(dart.global.SVGPathSegCurvetoCubicSmoothAbs, svg$.PathSegCurvetoCubicSmoothAbs);
  dart.defineExtensionNames([
    'x',
    'x2',
    'y',
    'y2'
  ]);
  svg$.PathSegCurvetoCubicSmoothRel = class PathSegCurvetoCubicSmoothRel extends svg$.PathSeg {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.x]() {
      return this.x;
    }
    set [dartx.x](value) {
      this.x = value;
    }
    get [dartx.x2]() {
      return this.x2;
    }
    set [dartx.x2](value) {
      this.x2 = value;
    }
    get [dartx.y]() {
      return this.y;
    }
    set [dartx.y](value) {
      this.y = value;
    }
    get [dartx.y2]() {
      return this.y2;
    }
    set [dartx.y2](value) {
      this.y2 = value;
    }
  };
  dart.setSignature(svg$.PathSegCurvetoCubicSmoothRel, {
    constructors: () => ({_: [svg$.PathSegCurvetoCubicSmoothRel, []]})
  });
  svg$.PathSegCurvetoCubicSmoothRel[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGPathSegCurvetoCubicSmoothRel')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGPathSegCurvetoCubicSmoothRel"))];
  dart.registerExtension(dart.global.SVGPathSegCurvetoCubicSmoothRel, svg$.PathSegCurvetoCubicSmoothRel);
  dart.defineExtensionNames([
    'x',
    'x1',
    'y',
    'y1'
  ]);
  svg$.PathSegCurvetoQuadraticAbs = class PathSegCurvetoQuadraticAbs extends svg$.PathSeg {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.x]() {
      return this.x;
    }
    set [dartx.x](value) {
      this.x = value;
    }
    get [dartx.x1]() {
      return this.x1;
    }
    set [dartx.x1](value) {
      this.x1 = value;
    }
    get [dartx.y]() {
      return this.y;
    }
    set [dartx.y](value) {
      this.y = value;
    }
    get [dartx.y1]() {
      return this.y1;
    }
    set [dartx.y1](value) {
      this.y1 = value;
    }
  };
  dart.setSignature(svg$.PathSegCurvetoQuadraticAbs, {
    constructors: () => ({_: [svg$.PathSegCurvetoQuadraticAbs, []]})
  });
  svg$.PathSegCurvetoQuadraticAbs[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGPathSegCurvetoQuadraticAbs')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGPathSegCurvetoQuadraticAbs"))];
  dart.registerExtension(dart.global.SVGPathSegCurvetoQuadraticAbs, svg$.PathSegCurvetoQuadraticAbs);
  dart.defineExtensionNames([
    'x',
    'x1',
    'y',
    'y1'
  ]);
  svg$.PathSegCurvetoQuadraticRel = class PathSegCurvetoQuadraticRel extends svg$.PathSeg {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.x]() {
      return this.x;
    }
    set [dartx.x](value) {
      this.x = value;
    }
    get [dartx.x1]() {
      return this.x1;
    }
    set [dartx.x1](value) {
      this.x1 = value;
    }
    get [dartx.y]() {
      return this.y;
    }
    set [dartx.y](value) {
      this.y = value;
    }
    get [dartx.y1]() {
      return this.y1;
    }
    set [dartx.y1](value) {
      this.y1 = value;
    }
  };
  dart.setSignature(svg$.PathSegCurvetoQuadraticRel, {
    constructors: () => ({_: [svg$.PathSegCurvetoQuadraticRel, []]})
  });
  svg$.PathSegCurvetoQuadraticRel[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGPathSegCurvetoQuadraticRel')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGPathSegCurvetoQuadraticRel"))];
  dart.registerExtension(dart.global.SVGPathSegCurvetoQuadraticRel, svg$.PathSegCurvetoQuadraticRel);
  dart.defineExtensionNames([
    'x',
    'y'
  ]);
  svg$.PathSegCurvetoQuadraticSmoothAbs = class PathSegCurvetoQuadraticSmoothAbs extends svg$.PathSeg {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.x]() {
      return this.x;
    }
    set [dartx.x](value) {
      this.x = value;
    }
    get [dartx.y]() {
      return this.y;
    }
    set [dartx.y](value) {
      this.y = value;
    }
  };
  dart.setSignature(svg$.PathSegCurvetoQuadraticSmoothAbs, {
    constructors: () => ({_: [svg$.PathSegCurvetoQuadraticSmoothAbs, []]})
  });
  svg$.PathSegCurvetoQuadraticSmoothAbs[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGPathSegCurvetoQuadraticSmoothAbs')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGPathSegCurvetoQuadraticSmoothAbs"))];
  dart.registerExtension(dart.global.SVGPathSegCurvetoQuadraticSmoothAbs, svg$.PathSegCurvetoQuadraticSmoothAbs);
  dart.defineExtensionNames([
    'x',
    'y'
  ]);
  svg$.PathSegCurvetoQuadraticSmoothRel = class PathSegCurvetoQuadraticSmoothRel extends svg$.PathSeg {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.x]() {
      return this.x;
    }
    set [dartx.x](value) {
      this.x = value;
    }
    get [dartx.y]() {
      return this.y;
    }
    set [dartx.y](value) {
      this.y = value;
    }
  };
  dart.setSignature(svg$.PathSegCurvetoQuadraticSmoothRel, {
    constructors: () => ({_: [svg$.PathSegCurvetoQuadraticSmoothRel, []]})
  });
  svg$.PathSegCurvetoQuadraticSmoothRel[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGPathSegCurvetoQuadraticSmoothRel')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGPathSegCurvetoQuadraticSmoothRel"))];
  dart.registerExtension(dart.global.SVGPathSegCurvetoQuadraticSmoothRel, svg$.PathSegCurvetoQuadraticSmoothRel);
  dart.defineExtensionNames([
    'x',
    'y'
  ]);
  svg$.PathSegLinetoAbs = class PathSegLinetoAbs extends svg$.PathSeg {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.x]() {
      return this.x;
    }
    set [dartx.x](value) {
      this.x = value;
    }
    get [dartx.y]() {
      return this.y;
    }
    set [dartx.y](value) {
      this.y = value;
    }
  };
  dart.setSignature(svg$.PathSegLinetoAbs, {
    constructors: () => ({_: [svg$.PathSegLinetoAbs, []]})
  });
  svg$.PathSegLinetoAbs[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGPathSegLinetoAbs')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGPathSegLinetoAbs"))];
  dart.registerExtension(dart.global.SVGPathSegLinetoAbs, svg$.PathSegLinetoAbs);
  dart.defineExtensionNames([
    'x'
  ]);
  svg$.PathSegLinetoHorizontalAbs = class PathSegLinetoHorizontalAbs extends svg$.PathSeg {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.x]() {
      return this.x;
    }
    set [dartx.x](value) {
      this.x = value;
    }
  };
  dart.setSignature(svg$.PathSegLinetoHorizontalAbs, {
    constructors: () => ({_: [svg$.PathSegLinetoHorizontalAbs, []]})
  });
  svg$.PathSegLinetoHorizontalAbs[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGPathSegLinetoHorizontalAbs')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGPathSegLinetoHorizontalAbs"))];
  dart.registerExtension(dart.global.SVGPathSegLinetoHorizontalAbs, svg$.PathSegLinetoHorizontalAbs);
  dart.defineExtensionNames([
    'x'
  ]);
  svg$.PathSegLinetoHorizontalRel = class PathSegLinetoHorizontalRel extends svg$.PathSeg {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.x]() {
      return this.x;
    }
    set [dartx.x](value) {
      this.x = value;
    }
  };
  dart.setSignature(svg$.PathSegLinetoHorizontalRel, {
    constructors: () => ({_: [svg$.PathSegLinetoHorizontalRel, []]})
  });
  svg$.PathSegLinetoHorizontalRel[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGPathSegLinetoHorizontalRel')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGPathSegLinetoHorizontalRel"))];
  dart.registerExtension(dart.global.SVGPathSegLinetoHorizontalRel, svg$.PathSegLinetoHorizontalRel);
  dart.defineExtensionNames([
    'x',
    'y'
  ]);
  svg$.PathSegLinetoRel = class PathSegLinetoRel extends svg$.PathSeg {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.x]() {
      return this.x;
    }
    set [dartx.x](value) {
      this.x = value;
    }
    get [dartx.y]() {
      return this.y;
    }
    set [dartx.y](value) {
      this.y = value;
    }
  };
  dart.setSignature(svg$.PathSegLinetoRel, {
    constructors: () => ({_: [svg$.PathSegLinetoRel, []]})
  });
  svg$.PathSegLinetoRel[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGPathSegLinetoRel')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGPathSegLinetoRel"))];
  dart.registerExtension(dart.global.SVGPathSegLinetoRel, svg$.PathSegLinetoRel);
  dart.defineExtensionNames([
    'y'
  ]);
  svg$.PathSegLinetoVerticalAbs = class PathSegLinetoVerticalAbs extends svg$.PathSeg {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.y]() {
      return this.y;
    }
    set [dartx.y](value) {
      this.y = value;
    }
  };
  dart.setSignature(svg$.PathSegLinetoVerticalAbs, {
    constructors: () => ({_: [svg$.PathSegLinetoVerticalAbs, []]})
  });
  svg$.PathSegLinetoVerticalAbs[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGPathSegLinetoVerticalAbs')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGPathSegLinetoVerticalAbs"))];
  dart.registerExtension(dart.global.SVGPathSegLinetoVerticalAbs, svg$.PathSegLinetoVerticalAbs);
  dart.defineExtensionNames([
    'y'
  ]);
  svg$.PathSegLinetoVerticalRel = class PathSegLinetoVerticalRel extends svg$.PathSeg {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.y]() {
      return this.y;
    }
    set [dartx.y](value) {
      this.y = value;
    }
  };
  dart.setSignature(svg$.PathSegLinetoVerticalRel, {
    constructors: () => ({_: [svg$.PathSegLinetoVerticalRel, []]})
  });
  svg$.PathSegLinetoVerticalRel[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGPathSegLinetoVerticalRel')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGPathSegLinetoVerticalRel"))];
  dart.registerExtension(dart.global.SVGPathSegLinetoVerticalRel, svg$.PathSegLinetoVerticalRel);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'appendItem',
    'clear',
    'getItem',
    'initialize',
    'insertItemBefore',
    'removeItem',
    'replaceItem',
    'numberOfItems'
  ]);
  svg$.PathSegList = class PathSegList extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(svg$.PathSeg), html$.ImmutableListMixin$(svg$.PathSeg)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    get [dartx.numberOfItems]() {
      return this.numberOfItems;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return this[dartx.getItem](index);
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return this[0];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return this[dart.notNull(len) - 1];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return this[0];
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [__setter__$](index, newItem) {
      return this.__setter__(index, newItem);
    }
    [dartx.appendItem](newItem) {
      return this.appendItem(newItem);
    }
    [dartx.clear]() {
      return this.clear();
    }
    [dartx.getItem](index) {
      return this.getItem(index);
    }
    [dartx.initialize](newItem) {
      return this.initialize(newItem);
    }
    [dartx.insertItemBefore](newItem, index) {
      return this.insertItemBefore(newItem, index);
    }
    [dartx.removeItem](index) {
      return this.removeItem(index);
    }
    [dartx.replaceItem](newItem, index) {
      return this.replaceItem(newItem, index);
    }
  };
  svg$.PathSegList[dart.implements] = () => [core.List$(svg$.PathSeg)];
  dart.setSignature(svg$.PathSegList, {
    constructors: () => ({_: [svg$.PathSegList, []]}),
    methods: () => ({
      [dartx.get]: [svg$.PathSeg, [core.int]],
      [dartx.set]: [dart.void, [core.int, svg$.PathSeg]],
      [dartx.elementAt]: [svg$.PathSeg, [core.int]],
      [__setter__$]: [dart.void, [core.int, svg$.PathSeg]],
      [dartx.appendItem]: [svg$.PathSeg, [svg$.PathSeg]],
      [dartx.getItem]: [svg$.PathSeg, [core.int]],
      [dartx.initialize]: [svg$.PathSeg, [svg$.PathSeg]],
      [dartx.insertItemBefore]: [svg$.PathSeg, [svg$.PathSeg, core.int]],
      [dartx.removeItem]: [svg$.PathSeg, [core.int]],
      [dartx.replaceItem]: [svg$.PathSeg, [svg$.PathSeg, core.int]]
    })
  });
  svg$.PathSegList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGPathSegList')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGPathSegList"))];
  dart.registerExtension(dart.global.SVGPathSegList, svg$.PathSegList);
  dart.defineExtensionNames([
    'x',
    'y'
  ]);
  svg$.PathSegMovetoAbs = class PathSegMovetoAbs extends svg$.PathSeg {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.x]() {
      return this.x;
    }
    set [dartx.x](value) {
      this.x = value;
    }
    get [dartx.y]() {
      return this.y;
    }
    set [dartx.y](value) {
      this.y = value;
    }
  };
  dart.setSignature(svg$.PathSegMovetoAbs, {
    constructors: () => ({_: [svg$.PathSegMovetoAbs, []]})
  });
  svg$.PathSegMovetoAbs[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGPathSegMovetoAbs')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGPathSegMovetoAbs"))];
  dart.registerExtension(dart.global.SVGPathSegMovetoAbs, svg$.PathSegMovetoAbs);
  dart.defineExtensionNames([
    'x',
    'y'
  ]);
  svg$.PathSegMovetoRel = class PathSegMovetoRel extends svg$.PathSeg {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.x]() {
      return this.x;
    }
    set [dartx.x](value) {
      this.x = value;
    }
    get [dartx.y]() {
      return this.y;
    }
    set [dartx.y](value) {
      this.y = value;
    }
  };
  dart.setSignature(svg$.PathSegMovetoRel, {
    constructors: () => ({_: [svg$.PathSegMovetoRel, []]})
  });
  svg$.PathSegMovetoRel[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGPathSegMovetoRel')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGPathSegMovetoRel"))];
  dart.registerExtension(dart.global.SVGPathSegMovetoRel, svg$.PathSegMovetoRel);
  dart.defineExtensionNames([
    'hasExtension',
    'height',
    'patternContentUnits',
    'patternTransform',
    'patternUnits',
    'width',
    'x',
    'y',
    'preserveAspectRatio',
    'viewBox',
    'requiredExtensions',
    'requiredFeatures',
    'systemLanguage',
    'href'
  ]);
  svg$.PatternElement = class PatternElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("pattern"), svg$.PatternElement);
    }
    created() {
      this[dartx.height] = null;
      this[dartx.patternContentUnits] = null;
      this[dartx.patternTransform] = null;
      this[dartx.patternUnits] = null;
      this[dartx.width] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      this[dartx.preserveAspectRatio] = null;
      this[dartx.viewBox] = null;
      this[dartx.requiredExtensions] = null;
      this[dartx.requiredFeatures] = null;
      this[dartx.systemLanguage] = null;
      this[dartx.href] = null;
      super.created();
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.patternContentUnits]() {
      return this.patternContentUnits;
    }
    get [dartx.patternTransform]() {
      return this.patternTransform;
    }
    get [dartx.patternUnits]() {
      return this.patternUnits;
    }
    get [dartx.width]() {
      return this.width;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
    get [dartx.preserveAspectRatio]() {
      return this.preserveAspectRatio;
    }
    get [dartx.viewBox]() {
      return this.viewBox;
    }
    get [dartx.requiredExtensions]() {
      return this.requiredExtensions;
    }
    get [dartx.requiredFeatures]() {
      return this.requiredFeatures;
    }
    get [dartx.systemLanguage]() {
      return this.systemLanguage;
    }
    [dartx.hasExtension](extension) {
      return this.hasExtension(extension);
    }
    get [dartx.href]() {
      return this.href;
    }
  };
  dart.defineNamedConstructor(svg$.PatternElement, 'created');
  svg$.PatternElement[dart.implements] = () => [svg$.FitToViewBox, svg$.UriReference, svg$.Tests];
  dart.setSignature(svg$.PatternElement, {
    constructors: () => ({
      _: [svg$.PatternElement, []],
      new: [svg$.PatternElement, []],
      created: [svg$.PatternElement, []]
    }),
    methods: () => ({[dartx.hasExtension]: [core.bool, [core.String]]})
  });
  svg$.PatternElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGPatternElement')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGPatternElement"))];
  dart.registerExtension(dart.global.SVGPatternElement, svg$.PatternElement);
  dart.defineExtensionNames([
    'matrixTransform',
    'x',
    'y'
  ]);
  svg$.Point = class Point extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.x]() {
      return this.x;
    }
    set [dartx.x](value) {
      this.x = value;
    }
    get [dartx.y]() {
      return this.y;
    }
    set [dartx.y](value) {
      this.y = value;
    }
    [dartx.matrixTransform](matrix) {
      return this.matrixTransform(matrix);
    }
  };
  dart.setSignature(svg$.Point, {
    constructors: () => ({_: [svg$.Point, []]}),
    methods: () => ({[dartx.matrixTransform]: [svg$.Point, [svg$.Matrix]]})
  });
  svg$.Point[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGPoint')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGPoint"))];
  dart.registerExtension(dart.global.SVGPoint, svg$.Point);
  dart.defineExtensionNames([
    'appendItem',
    'clear',
    'getItem',
    'initialize',
    'insertItemBefore',
    'removeItem',
    'replaceItem',
    'length',
    'numberOfItems'
  ]);
  svg$.PointList = class PointList extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    get [dartx.numberOfItems]() {
      return this.numberOfItems;
    }
    [__setter__$](index, newItem) {
      return this.__setter__(index, newItem);
    }
    [dartx.appendItem](newItem) {
      return this.appendItem(newItem);
    }
    [dartx.clear]() {
      return this.clear();
    }
    [dartx.getItem](index) {
      return this.getItem(index);
    }
    [dartx.initialize](newItem) {
      return this.initialize(newItem);
    }
    [dartx.insertItemBefore](newItem, index) {
      return this.insertItemBefore(newItem, index);
    }
    [dartx.removeItem](index) {
      return this.removeItem(index);
    }
    [dartx.replaceItem](newItem, index) {
      return this.replaceItem(newItem, index);
    }
  };
  dart.setSignature(svg$.PointList, {
    constructors: () => ({_: [svg$.PointList, []]}),
    methods: () => ({
      [__setter__$]: [dart.void, [core.int, svg$.Point]],
      [dartx.appendItem]: [svg$.Point, [svg$.Point]],
      [dartx.clear]: [dart.void, []],
      [dartx.getItem]: [svg$.Point, [core.int]],
      [dartx.initialize]: [svg$.Point, [svg$.Point]],
      [dartx.insertItemBefore]: [svg$.Point, [svg$.Point, core.int]],
      [dartx.removeItem]: [svg$.Point, [core.int]],
      [dartx.replaceItem]: [svg$.Point, [svg$.Point, core.int]]
    })
  });
  svg$.PointList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGPointList')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGPointList"))];
  dart.registerExtension(dart.global.SVGPointList, svg$.PointList);
  dart.defineExtensionNames([
    'animatedPoints',
    'points'
  ]);
  svg$.PolygonElement = class PolygonElement extends svg$.GeometryElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("polygon"), svg$.PolygonElement);
    }
    created() {
      this[dartx.animatedPoints] = null;
      this[dartx.points] = null;
      super.created();
    }
    get [dartx.animatedPoints]() {
      return this.animatedPoints;
    }
    get [dartx.points]() {
      return this.points;
    }
  };
  dart.defineNamedConstructor(svg$.PolygonElement, 'created');
  dart.setSignature(svg$.PolygonElement, {
    constructors: () => ({
      _: [svg$.PolygonElement, []],
      new: [svg$.PolygonElement, []],
      created: [svg$.PolygonElement, []]
    })
  });
  svg$.PolygonElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGPolygonElement')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGPolygonElement"))];
  dart.registerExtension(dart.global.SVGPolygonElement, svg$.PolygonElement);
  dart.defineExtensionNames([
    'animatedPoints',
    'points'
  ]);
  svg$.PolylineElement = class PolylineElement extends svg$.GeometryElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("polyline"), svg$.PolylineElement);
    }
    created() {
      this[dartx.animatedPoints] = null;
      this[dartx.points] = null;
      super.created();
    }
    get [dartx.animatedPoints]() {
      return this.animatedPoints;
    }
    get [dartx.points]() {
      return this.points;
    }
  };
  dart.defineNamedConstructor(svg$.PolylineElement, 'created');
  dart.setSignature(svg$.PolylineElement, {
    constructors: () => ({
      _: [svg$.PolylineElement, []],
      new: [svg$.PolylineElement, []],
      created: [svg$.PolylineElement, []]
    })
  });
  svg$.PolylineElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGPolylineElement')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGPolylineElement"))];
  dart.registerExtension(dart.global.SVGPolylineElement, svg$.PolylineElement);
  dart.defineExtensionNames([
    'align',
    'meetOrSlice'
  ]);
  svg$.PreserveAspectRatio = class PreserveAspectRatio extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.align]() {
      return this.align;
    }
    set [dartx.align](value) {
      this.align = value;
    }
    get [dartx.meetOrSlice]() {
      return this.meetOrSlice;
    }
    set [dartx.meetOrSlice](value) {
      this.meetOrSlice = value;
    }
  };
  dart.setSignature(svg$.PreserveAspectRatio, {
    constructors: () => ({_: [svg$.PreserveAspectRatio, []]})
  });
  svg$.PreserveAspectRatio[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGPreserveAspectRatio')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGPreserveAspectRatio"))];
  svg$.PreserveAspectRatio.SVG_MEETORSLICE_MEET = 1;
  svg$.PreserveAspectRatio.SVG_MEETORSLICE_SLICE = 2;
  svg$.PreserveAspectRatio.SVG_MEETORSLICE_UNKNOWN = 0;
  svg$.PreserveAspectRatio.SVG_PRESERVEASPECTRATIO_NONE = 1;
  svg$.PreserveAspectRatio.SVG_PRESERVEASPECTRATIO_UNKNOWN = 0;
  svg$.PreserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMAXYMAX = 10;
  svg$.PreserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMAXYMID = 7;
  svg$.PreserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMAXYMIN = 4;
  svg$.PreserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMIDYMAX = 9;
  svg$.PreserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMIDYMID = 6;
  svg$.PreserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMIDYMIN = 3;
  svg$.PreserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMINYMAX = 8;
  svg$.PreserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMINYMID = 5;
  svg$.PreserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMINYMIN = 2;
  dart.registerExtension(dart.global.SVGPreserveAspectRatio, svg$.PreserveAspectRatio);
  dart.defineExtensionNames([
    'cx',
    'cy',
    'fr',
    'fx',
    'fy',
    'r'
  ]);
  svg$.RadialGradientElement = class RadialGradientElement extends svg$._GradientElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("radialGradient"), svg$.RadialGradientElement);
    }
    created() {
      this[dartx.cx] = null;
      this[dartx.cy] = null;
      this[dartx.fr] = null;
      this[dartx.fx] = null;
      this[dartx.fy] = null;
      this[dartx.r] = null;
      super.created();
    }
    get [dartx.cx]() {
      return this.cx;
    }
    get [dartx.cy]() {
      return this.cy;
    }
    get [dartx.fr]() {
      return this.fr;
    }
    get [dartx.fx]() {
      return this.fx;
    }
    get [dartx.fy]() {
      return this.fy;
    }
    get [dartx.r]() {
      return this.r;
    }
  };
  dart.defineNamedConstructor(svg$.RadialGradientElement, 'created');
  dart.setSignature(svg$.RadialGradientElement, {
    constructors: () => ({
      _: [svg$.RadialGradientElement, []],
      new: [svg$.RadialGradientElement, []],
      created: [svg$.RadialGradientElement, []]
    })
  });
  svg$.RadialGradientElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGRadialGradientElement')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGRadialGradientElement"))];
  dart.registerExtension(dart.global.SVGRadialGradientElement, svg$.RadialGradientElement);
  dart.defineExtensionNames([
    'height',
    'width',
    'x',
    'y'
  ]);
  svg$.Rect = class Rect extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.height]() {
      return this.height;
    }
    set [dartx.height](value) {
      this.height = value;
    }
    get [dartx.width]() {
      return this.width;
    }
    set [dartx.width](value) {
      this.width = value;
    }
    get [dartx.x]() {
      return this.x;
    }
    set [dartx.x](value) {
      this.x = value;
    }
    get [dartx.y]() {
      return this.y;
    }
    set [dartx.y](value) {
      this.y = value;
    }
  };
  dart.setSignature(svg$.Rect, {
    constructors: () => ({_: [svg$.Rect, []]})
  });
  svg$.Rect[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGRect')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGRect"))];
  dart.registerExtension(dart.global.SVGRect, svg$.Rect);
  dart.defineExtensionNames([
    'height',
    'rx',
    'ry',
    'width',
    'x',
    'y'
  ]);
  svg$.RectElement = class RectElement extends svg$.GeometryElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("rect"), svg$.RectElement);
    }
    created() {
      this[dartx.height] = null;
      this[dartx.rx] = null;
      this[dartx.ry] = null;
      this[dartx.width] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      super.created();
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.rx]() {
      return this.rx;
    }
    get [dartx.ry]() {
      return this.ry;
    }
    get [dartx.width]() {
      return this.width;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
  };
  dart.defineNamedConstructor(svg$.RectElement, 'created');
  dart.setSignature(svg$.RectElement, {
    constructors: () => ({
      _: [svg$.RectElement, []],
      new: [svg$.RectElement, []],
      created: [svg$.RectElement, []]
    })
  });
  svg$.RectElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGRectElement')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGRectElement"))];
  dart.registerExtension(dart.global.SVGRectElement, svg$.RectElement);
  dart.defineExtensionNames([
    'type',
    'href'
  ]);
  svg$.ScriptElement = class ScriptElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("script"), svg$.ScriptElement);
    }
    created() {
      this[dartx.type] = null;
      this[dartx.href] = null;
      super.created();
    }
    get [dartx.type]() {
      return this.type;
    }
    set [dartx.type](value) {
      this.type = value;
    }
    get [dartx.href]() {
      return this.href;
    }
  };
  dart.defineNamedConstructor(svg$.ScriptElement, 'created');
  svg$.ScriptElement[dart.implements] = () => [svg$.UriReference];
  dart.setSignature(svg$.ScriptElement, {
    constructors: () => ({
      _: [svg$.ScriptElement, []],
      new: [svg$.ScriptElement, []],
      created: [svg$.ScriptElement, []]
    })
  });
  svg$.ScriptElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGScriptElement')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGScriptElement"))];
  dart.registerExtension(dart.global.SVGScriptElement, svg$.ScriptElement);
  svg$.SetElement = class SetElement extends svg$.AnimationElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("set"), svg$.SetElement);
    }
    created() {
      super.created();
    }
    static get supported() {
      return dart.notNull(svg$.SvgElement.isTagSupported('set')) && dart.is(svg$.SvgElement.tag('set'), svg$.SetElement);
    }
  };
  dart.defineNamedConstructor(svg$.SetElement, 'created');
  dart.setSignature(svg$.SetElement, {
    constructors: () => ({
      _: [svg$.SetElement, []],
      new: [svg$.SetElement, []],
      created: [svg$.SetElement, []]
    })
  });
  svg$.SetElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGSetElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGSetElement"))];
  dart.registerExtension(dart.global.SVGSetElement, svg$.SetElement);
  dart.defineExtensionNames([
    'gradientOffset'
  ]);
  svg$.StopElement = class StopElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("stop"), svg$.StopElement);
    }
    created() {
      this[dartx.gradientOffset] = null;
      super.created();
    }
    get [dartx.gradientOffset]() {
      return this.offset;
    }
  };
  dart.defineNamedConstructor(svg$.StopElement, 'created');
  dart.setSignature(svg$.StopElement, {
    constructors: () => ({
      _: [svg$.StopElement, []],
      new: [svg$.StopElement, []],
      created: [svg$.StopElement, []]
    })
  });
  svg$.StopElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGStopElement')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGStopElement"))];
  dart.registerExtension(dart.global.SVGStopElement, svg$.StopElement);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'appendItem',
    'clear',
    'getItem',
    'initialize',
    'insertItemBefore',
    'removeItem',
    'replaceItem',
    'numberOfItems'
  ]);
  svg$.StringList = class StringList extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(core.String), html$.ImmutableListMixin$(core.String)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    get [dartx.numberOfItems]() {
      return this.numberOfItems;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return this[dartx.getItem](index);
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return this[0];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return this[dart.notNull(len) - 1];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return this[0];
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [__setter__$](index, newItem) {
      return this.__setter__(index, newItem);
    }
    [dartx.appendItem](newItem) {
      return this.appendItem(newItem);
    }
    [dartx.clear]() {
      return this.clear();
    }
    [dartx.getItem](index) {
      return this.getItem(index);
    }
    [dartx.initialize](newItem) {
      return this.initialize(newItem);
    }
    [dartx.insertItemBefore](item, index) {
      return this.insertItemBefore(item, index);
    }
    [dartx.removeItem](index) {
      return this.removeItem(index);
    }
    [dartx.replaceItem](newItem, index) {
      return this.replaceItem(newItem, index);
    }
  };
  svg$.StringList[dart.implements] = () => [core.List$(core.String)];
  dart.setSignature(svg$.StringList, {
    constructors: () => ({_: [svg$.StringList, []]}),
    methods: () => ({
      [dartx.get]: [core.String, [core.int]],
      [dartx.set]: [dart.void, [core.int, core.String]],
      [dartx.elementAt]: [core.String, [core.int]],
      [__setter__$]: [dart.void, [core.int, core.String]],
      [dartx.appendItem]: [core.String, [core.String]],
      [dartx.getItem]: [core.String, [core.int]],
      [dartx.initialize]: [core.String, [core.String]],
      [dartx.insertItemBefore]: [core.String, [core.String, core.int]],
      [dartx.removeItem]: [core.String, [core.int]],
      [dartx.replaceItem]: [core.String, [core.String, core.int]]
    })
  });
  svg$.StringList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGStringList')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGStringList"))];
  dart.registerExtension(dart.global.SVGStringList, svg$.StringList);
  dart.defineExtensionNames([
    'disabled',
    'media',
    'sheet',
    'type'
  ]);
  svg$.StyleElement = class StyleElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("style"), svg$.StyleElement);
    }
    created() {
      this[dartx.disabled] = null;
      this[dartx.media] = null;
      this[dartx.sheet] = null;
      this[dartx.type] = null;
      super.created();
    }
    get [dartx.disabled]() {
      return this.disabled;
    }
    set [dartx.disabled](value) {
      this.disabled = value;
    }
    get [dartx.media]() {
      return this.media;
    }
    set [dartx.media](value) {
      this.media = value;
    }
    get [dartx.sheet]() {
      return this.sheet;
    }
    get [dartx.type]() {
      return this.type;
    }
    set [dartx.type](value) {
      this.type = value;
    }
  };
  dart.defineNamedConstructor(svg$.StyleElement, 'created');
  dart.setSignature(svg$.StyleElement, {
    constructors: () => ({
      _: [svg$.StyleElement, []],
      new: [svg$.StyleElement, []],
      created: [svg$.StyleElement, []]
    })
  });
  svg$.StyleElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGStyleElement')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("SVGStyleElement"))];
  dart.registerExtension(dart.global.SVGStyleElement, svg$.StyleElement);
  const _element$0 = Symbol('_element');
  svg$._AttributeClassSet = class _AttributeClassSet extends html_common.CssClassSetImpl {
    _AttributeClassSet(element) {
      this[_element$0] = element;
    }
    readClasses() {
      let classname = this[_element$0][dartx.attributes][dartx.get]('class');
      let s = collection.LinkedHashSet$(core.String).new();
      if (classname == null) {
        return s;
      }
      for (let name of classname[dartx.split](' ')) {
        let trimmed = name[dartx.trim]();
        if (!dart.notNull(trimmed[dartx.isEmpty])) {
          s.add(trimmed);
        }
      }
      return s;
    }
    writeClasses(s) {
      this[_element$0][dartx.attributes][dartx.set]('class', s.join(' '));
    }
  };
  dart.setSignature(svg$._AttributeClassSet, {
    constructors: () => ({_AttributeClassSet: [svg$._AttributeClassSet, [html$.Element]]}),
    methods: () => ({
      readClasses: [core.Set$(core.String), []],
      writeClasses: [dart.void, [core.Set]]
    })
  });
  dart.defineExtensionNames([
    'animationsPaused',
    'checkEnclosure',
    'checkIntersection',
    'createSvgAngle',
    'createSvgLength',
    'createSvgMatrix',
    'createSvgNumber',
    'createSvgPoint',
    'createSvgRect',
    'createSvgTransform',
    'createSvgTransformFromMatrix',
    'deselectAll',
    'forceRedraw',
    'getCurrentTime',
    'getElementById',
    'getEnclosureList',
    'getIntersectionList',
    'pauseAnimations',
    'setCurrentTime',
    'suspendRedraw',
    'unpauseAnimations',
    'unsuspendRedraw',
    'unsuspendRedrawAll',
    'currentScale',
    'currentTranslate',
    'currentView',
    'height',
    'pixelUnitToMillimeterX',
    'pixelUnitToMillimeterY',
    'screenPixelToMillimeterX',
    'screenPixelToMillimeterY',
    'useCurrentView',
    'viewport',
    'width',
    'x',
    'y',
    'preserveAspectRatio',
    'viewBox',
    'zoomAndPan'
  ]);
  svg$.SvgSvgElement = class SvgSvgElement extends svg$.GraphicsElement {
    static new() {
      let el = svg$.SvgElement.tag("svg");
      el[dartx.attributes][dartx.set]('version', "1.1");
      return dart.as(el, svg$.SvgSvgElement);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      this[dartx.currentScale] = null;
      this[dartx.currentTranslate] = null;
      this[dartx.currentView] = null;
      this[dartx.height] = null;
      this[dartx.pixelUnitToMillimeterX] = null;
      this[dartx.pixelUnitToMillimeterY] = null;
      this[dartx.screenPixelToMillimeterX] = null;
      this[dartx.screenPixelToMillimeterY] = null;
      this[dartx.useCurrentView] = null;
      this[dartx.viewport] = null;
      this[dartx.width] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      this[dartx.preserveAspectRatio] = null;
      this[dartx.viewBox] = null;
      this[dartx.zoomAndPan] = null;
      super.created();
    }
    get [dartx.currentScale]() {
      return this.currentScale;
    }
    set [dartx.currentScale](value) {
      this.currentScale = value;
    }
    get [dartx.currentTranslate]() {
      return this.currentTranslate;
    }
    get [dartx.currentView]() {
      return this.currentView;
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.pixelUnitToMillimeterX]() {
      return this.pixelUnitToMillimeterX;
    }
    get [dartx.pixelUnitToMillimeterY]() {
      return this.pixelUnitToMillimeterY;
    }
    get [dartx.screenPixelToMillimeterX]() {
      return this.screenPixelToMillimeterX;
    }
    get [dartx.screenPixelToMillimeterY]() {
      return this.screenPixelToMillimeterY;
    }
    get [dartx.useCurrentView]() {
      return this.useCurrentView;
    }
    get [dartx.viewport]() {
      return this.viewport;
    }
    get [dartx.width]() {
      return this.width;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
    [dartx.animationsPaused]() {
      return this.animationsPaused();
    }
    [dartx.checkEnclosure](element, rect) {
      return this.checkEnclosure(element, rect);
    }
    [dartx.checkIntersection](element, rect) {
      return this.checkIntersection(element, rect);
    }
    [dartx.createSvgAngle]() {
      return this.createSVGAngle();
    }
    [dartx.createSvgLength]() {
      return this.createSVGLength();
    }
    [dartx.createSvgMatrix]() {
      return this.createSVGMatrix();
    }
    [dartx.createSvgNumber]() {
      return this.createSVGNumber();
    }
    [dartx.createSvgPoint]() {
      return this.createSVGPoint();
    }
    [dartx.createSvgRect]() {
      return this.createSVGRect();
    }
    [dartx.createSvgTransform]() {
      return this.createSVGTransform();
    }
    [dartx.createSvgTransformFromMatrix](matrix) {
      return this.createSVGTransformFromMatrix(matrix);
    }
    [dartx.deselectAll]() {
      return this.deselectAll();
    }
    [dartx.forceRedraw]() {
      return this.forceRedraw();
    }
    [dartx.getCurrentTime]() {
      return this.getCurrentTime();
    }
    [dartx.getElementById](elementId) {
      return this.getElementById(elementId);
    }
    [dartx.getEnclosureList](rect, referenceElement) {
      return this.getEnclosureList(rect, referenceElement);
    }
    [dartx.getIntersectionList](rect, referenceElement) {
      return this.getIntersectionList(rect, referenceElement);
    }
    [dartx.pauseAnimations]() {
      return this.pauseAnimations();
    }
    [dartx.setCurrentTime](seconds) {
      return this.setCurrentTime(seconds);
    }
    [dartx.suspendRedraw](maxWaitMilliseconds) {
      return this.suspendRedraw(maxWaitMilliseconds);
    }
    [dartx.unpauseAnimations]() {
      return this.unpauseAnimations();
    }
    [dartx.unsuspendRedraw](suspendHandleId) {
      return this.unsuspendRedraw(suspendHandleId);
    }
    [dartx.unsuspendRedrawAll]() {
      return this.unsuspendRedrawAll();
    }
    get [dartx.preserveAspectRatio]() {
      return this.preserveAspectRatio;
    }
    get [dartx.viewBox]() {
      return this.viewBox;
    }
    get [dartx.zoomAndPan]() {
      return this.zoomAndPan;
    }
    set [dartx.zoomAndPan](value) {
      this.zoomAndPan = value;
    }
  };
  dart.defineNamedConstructor(svg$.SvgSvgElement, 'created');
  svg$.SvgSvgElement[dart.implements] = () => [svg$.FitToViewBox, svg$.ZoomAndPan];
  dart.setSignature(svg$.SvgSvgElement, {
    constructors: () => ({
      new: [svg$.SvgSvgElement, []],
      _: [svg$.SvgSvgElement, []],
      created: [svg$.SvgSvgElement, []]
    }),
    methods: () => ({
      [dartx.animationsPaused]: [core.bool, []],
      [dartx.checkEnclosure]: [core.bool, [svg$.SvgElement, svg$.Rect]],
      [dartx.checkIntersection]: [core.bool, [svg$.SvgElement, svg$.Rect]],
      [dartx.createSvgAngle]: [svg$.Angle, []],
      [dartx.createSvgLength]: [svg$.Length, []],
      [dartx.createSvgMatrix]: [svg$.Matrix, []],
      [dartx.createSvgNumber]: [svg$.Number, []],
      [dartx.createSvgPoint]: [svg$.Point, []],
      [dartx.createSvgRect]: [svg$.Rect, []],
      [dartx.createSvgTransform]: [svg$.Transform, []],
      [dartx.createSvgTransformFromMatrix]: [svg$.Transform, [svg$.Matrix]],
      [dartx.deselectAll]: [dart.void, []],
      [dartx.forceRedraw]: [dart.void, []],
      [dartx.getCurrentTime]: [core.double, []],
      [dartx.getElementById]: [html$.Element, [core.String]],
      [dartx.getEnclosureList]: [core.List$(html$.Node), [svg$.Rect, svg$.SvgElement]],
      [dartx.getIntersectionList]: [core.List$(html$.Node), [svg$.Rect, svg$.SvgElement]],
      [dartx.pauseAnimations]: [dart.void, []],
      [dartx.setCurrentTime]: [dart.void, [core.num]],
      [dartx.suspendRedraw]: [core.int, [core.int]],
      [dartx.unpauseAnimations]: [dart.void, []],
      [dartx.unsuspendRedraw]: [dart.void, [core.int]],
      [dartx.unsuspendRedrawAll]: [dart.void, []]
    })
  });
  svg$.SvgSvgElement[dart.metadata] = () => [dart.const(new _metadata.DomName('SVGSVGElement')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGSVGElement"))];
  dart.registerExtension(dart.global.SVGSVGElement, svg$.SvgSvgElement);
  svg$.SwitchElement = class SwitchElement extends svg$.GraphicsElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("switch"), svg$.SwitchElement);
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(svg$.SwitchElement, 'created');
  dart.setSignature(svg$.SwitchElement, {
    constructors: () => ({
      _: [svg$.SwitchElement, []],
      new: [svg$.SwitchElement, []],
      created: [svg$.SwitchElement, []]
    })
  });
  svg$.SwitchElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGSwitchElement')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGSwitchElement"))];
  dart.registerExtension(dart.global.SVGSwitchElement, svg$.SwitchElement);
  dart.defineExtensionNames([
    'preserveAspectRatio',
    'viewBox'
  ]);
  svg$.SymbolElement = class SymbolElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("symbol"), svg$.SymbolElement);
    }
    created() {
      this[dartx.preserveAspectRatio] = null;
      this[dartx.viewBox] = null;
      super.created();
    }
    get [dartx.preserveAspectRatio]() {
      return this.preserveAspectRatio;
    }
    get [dartx.viewBox]() {
      return this.viewBox;
    }
  };
  dart.defineNamedConstructor(svg$.SymbolElement, 'created');
  svg$.SymbolElement[dart.implements] = () => [svg$.FitToViewBox];
  dart.setSignature(svg$.SymbolElement, {
    constructors: () => ({
      _: [svg$.SymbolElement, []],
      new: [svg$.SymbolElement, []],
      created: [svg$.SymbolElement, []]
    })
  });
  svg$.SymbolElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGSymbolElement')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGSymbolElement"))];
  dart.registerExtension(dart.global.SVGSymbolElement, svg$.SymbolElement);
  dart.defineExtensionNames([
    'getCharNumAtPosition',
    'getComputedTextLength',
    'getEndPositionOfChar',
    'getExtentOfChar',
    'getNumberOfChars',
    'getRotationOfChar',
    'getStartPositionOfChar',
    'getSubStringLength',
    'selectSubString',
    'lengthAdjust',
    'textLength'
  ]);
  svg$.TextContentElement = class TextContentElement extends svg$.GraphicsElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      this[dartx.lengthAdjust] = null;
      this[dartx.textLength] = null;
      super.created();
    }
    get [dartx.lengthAdjust]() {
      return this.lengthAdjust;
    }
    get [dartx.textLength]() {
      return this.textLength;
    }
    [dartx.getCharNumAtPosition](point) {
      return this.getCharNumAtPosition(point);
    }
    [dartx.getComputedTextLength]() {
      return this.getComputedTextLength();
    }
    [dartx.getEndPositionOfChar](charnum) {
      return this.getEndPositionOfChar(charnum);
    }
    [dartx.getExtentOfChar](charnum) {
      return this.getExtentOfChar(charnum);
    }
    [dartx.getNumberOfChars]() {
      return this.getNumberOfChars();
    }
    [dartx.getRotationOfChar](charnum) {
      return this.getRotationOfChar(charnum);
    }
    [dartx.getStartPositionOfChar](charnum) {
      return this.getStartPositionOfChar(charnum);
    }
    [dartx.getSubStringLength](charnum, nchars) {
      return this.getSubStringLength(charnum, nchars);
    }
    [dartx.selectSubString](charnum, nchars) {
      return this.selectSubString(charnum, nchars);
    }
  };
  dart.defineNamedConstructor(svg$.TextContentElement, 'created');
  dart.setSignature(svg$.TextContentElement, {
    constructors: () => ({
      _: [svg$.TextContentElement, []],
      created: [svg$.TextContentElement, []]
    }),
    methods: () => ({
      [dartx.getCharNumAtPosition]: [core.int, [svg$.Point]],
      [dartx.getComputedTextLength]: [core.double, []],
      [dartx.getEndPositionOfChar]: [svg$.Point, [core.int]],
      [dartx.getExtentOfChar]: [svg$.Rect, [core.int]],
      [dartx.getNumberOfChars]: [core.int, []],
      [dartx.getRotationOfChar]: [core.double, [core.int]],
      [dartx.getStartPositionOfChar]: [svg$.Point, [core.int]],
      [dartx.getSubStringLength]: [core.double, [core.int, core.int]],
      [dartx.selectSubString]: [dart.void, [core.int, core.int]]
    })
  });
  svg$.TextContentElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGTextContentElement')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGTextContentElement"))];
  svg$.TextContentElement.LENGTHADJUST_SPACING = 1;
  svg$.TextContentElement.LENGTHADJUST_SPACINGANDGLYPHS = 2;
  svg$.TextContentElement.LENGTHADJUST_UNKNOWN = 0;
  dart.registerExtension(dart.global.SVGTextContentElement, svg$.TextContentElement);
  dart.defineExtensionNames([
    'dx',
    'dy',
    'rotate',
    'x',
    'y'
  ]);
  svg$.TextPositioningElement = class TextPositioningElement extends svg$.TextContentElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      this[dartx.dx] = null;
      this[dartx.dy] = null;
      this[dartx.rotate] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      super.created();
    }
    get [dartx.dx]() {
      return this.dx;
    }
    get [dartx.dy]() {
      return this.dy;
    }
    get [dartx.rotate]() {
      return this.rotate;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
  };
  dart.defineNamedConstructor(svg$.TextPositioningElement, 'created');
  dart.setSignature(svg$.TextPositioningElement, {
    constructors: () => ({
      _: [svg$.TextPositioningElement, []],
      created: [svg$.TextPositioningElement, []]
    })
  });
  svg$.TextPositioningElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGTextPositioningElement')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGTextPositioningElement"))];
  dart.registerExtension(dart.global.SVGTextPositioningElement, svg$.TextPositioningElement);
  svg$.TSpanElement = class TSpanElement extends svg$.TextPositioningElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("tspan"), svg$.TSpanElement);
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(svg$.TSpanElement, 'created');
  dart.setSignature(svg$.TSpanElement, {
    constructors: () => ({
      _: [svg$.TSpanElement, []],
      new: [svg$.TSpanElement, []],
      created: [svg$.TSpanElement, []]
    })
  });
  svg$.TSpanElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGTSpanElement')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGTSpanElement"))];
  dart.registerExtension(dart.global.SVGTSpanElement, svg$.TSpanElement);
  dart.defineExtensionNames([
    'requiredExtensions',
    'requiredFeatures',
    'systemLanguage'
  ]);
  svg$.Tests = class Tests extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(svg$.Tests, {
    constructors: () => ({_: [svg$.Tests, []]})
  });
  dart.defineExtensionMembers(svg$.Tests, ['requiredExtensions', 'requiredFeatures', 'systemLanguage']);
  svg$.Tests[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGTests')), dart.const(new _metadata.Unstable())];
  svg$.TextElement = class TextElement extends svg$.TextPositioningElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("text"), svg$.TextElement);
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(svg$.TextElement, 'created');
  dart.setSignature(svg$.TextElement, {
    constructors: () => ({
      _: [svg$.TextElement, []],
      new: [svg$.TextElement, []],
      created: [svg$.TextElement, []]
    })
  });
  svg$.TextElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGTextElement')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGTextElement"))];
  dart.registerExtension(dart.global.SVGTextElement, svg$.TextElement);
  dart.defineExtensionNames([
    'method',
    'spacing',
    'startOffset',
    'href'
  ]);
  svg$.TextPathElement = class TextPathElement extends svg$.TextContentElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      this[dartx.method] = null;
      this[dartx.spacing] = null;
      this[dartx.startOffset] = null;
      this[dartx.href] = null;
      super.created();
    }
    get [dartx.method]() {
      return this.method;
    }
    get [dartx.spacing]() {
      return this.spacing;
    }
    get [dartx.startOffset]() {
      return this.startOffset;
    }
    get [dartx.href]() {
      return this.href;
    }
  };
  dart.defineNamedConstructor(svg$.TextPathElement, 'created');
  svg$.TextPathElement[dart.implements] = () => [svg$.UriReference];
  dart.setSignature(svg$.TextPathElement, {
    constructors: () => ({
      _: [svg$.TextPathElement, []],
      created: [svg$.TextPathElement, []]
    })
  });
  svg$.TextPathElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGTextPathElement')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGTextPathElement"))];
  svg$.TextPathElement.TEXTPATH_METHODTYPE_ALIGN = 1;
  svg$.TextPathElement.TEXTPATH_METHODTYPE_STRETCH = 2;
  svg$.TextPathElement.TEXTPATH_METHODTYPE_UNKNOWN = 0;
  svg$.TextPathElement.TEXTPATH_SPACINGTYPE_AUTO = 1;
  svg$.TextPathElement.TEXTPATH_SPACINGTYPE_EXACT = 2;
  svg$.TextPathElement.TEXTPATH_SPACINGTYPE_UNKNOWN = 0;
  dart.registerExtension(dart.global.SVGTextPathElement, svg$.TextPathElement);
  svg$.TitleElement = class TitleElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("title"), svg$.TitleElement);
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(svg$.TitleElement, 'created');
  dart.setSignature(svg$.TitleElement, {
    constructors: () => ({
      _: [svg$.TitleElement, []],
      new: [svg$.TitleElement, []],
      created: [svg$.TitleElement, []]
    })
  });
  svg$.TitleElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGTitleElement')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGTitleElement"))];
  dart.registerExtension(dart.global.SVGTitleElement, svg$.TitleElement);
  dart.defineExtensionNames([
    'setMatrix',
    'setRotate',
    'setScale',
    'setSkewX',
    'setSkewY',
    'setTranslate',
    'angle',
    'matrix',
    'type'
  ]);
  svg$.Transform = class Transform extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.angle]() {
      return this.angle;
    }
    get [dartx.matrix]() {
      return this.matrix;
    }
    get [dartx.type]() {
      return this.type;
    }
    [dartx.setMatrix](matrix) {
      return this.setMatrix(matrix);
    }
    [dartx.setRotate](angle, cx, cy) {
      return this.setRotate(angle, cx, cy);
    }
    [dartx.setScale](sx, sy) {
      return this.setScale(sx, sy);
    }
    [dartx.setSkewX](angle) {
      return this.setSkewX(angle);
    }
    [dartx.setSkewY](angle) {
      return this.setSkewY(angle);
    }
    [dartx.setTranslate](tx, ty) {
      return this.setTranslate(tx, ty);
    }
  };
  dart.setSignature(svg$.Transform, {
    constructors: () => ({_: [svg$.Transform, []]}),
    methods: () => ({
      [dartx.setMatrix]: [dart.void, [svg$.Matrix]],
      [dartx.setRotate]: [dart.void, [core.num, core.num, core.num]],
      [dartx.setScale]: [dart.void, [core.num, core.num]],
      [dartx.setSkewX]: [dart.void, [core.num]],
      [dartx.setSkewY]: [dart.void, [core.num]],
      [dartx.setTranslate]: [dart.void, [core.num, core.num]]
    })
  });
  svg$.Transform[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGTransform')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGTransform"))];
  svg$.Transform.SVG_TRANSFORM_MATRIX = 1;
  svg$.Transform.SVG_TRANSFORM_ROTATE = 4;
  svg$.Transform.SVG_TRANSFORM_SCALE = 3;
  svg$.Transform.SVG_TRANSFORM_SKEWX = 5;
  svg$.Transform.SVG_TRANSFORM_SKEWY = 6;
  svg$.Transform.SVG_TRANSFORM_TRANSLATE = 2;
  svg$.Transform.SVG_TRANSFORM_UNKNOWN = 0;
  dart.registerExtension(dart.global.SVGTransform, svg$.Transform);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'appendItem',
    'clear',
    'consolidate',
    'createSvgTransformFromMatrix',
    'getItem',
    'initialize',
    'insertItemBefore',
    'removeItem',
    'replaceItem',
    'numberOfItems'
  ]);
  svg$.TransformList = class TransformList extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(svg$.Transform), html$.ImmutableListMixin$(svg$.Transform)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    get [dartx.numberOfItems]() {
      return this.numberOfItems;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return this[dartx.getItem](index);
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return this[0];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return this[dart.notNull(len) - 1];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return this[0];
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [__setter__$](index, newItem) {
      return this.__setter__(index, newItem);
    }
    [dartx.appendItem](newItem) {
      return this.appendItem(newItem);
    }
    [dartx.clear]() {
      return this.clear();
    }
    [dartx.consolidate]() {
      return this.consolidate();
    }
    [dartx.createSvgTransformFromMatrix](matrix) {
      return this.createSVGTransformFromMatrix(matrix);
    }
    [dartx.getItem](index) {
      return this.getItem(index);
    }
    [dartx.initialize](newItem) {
      return this.initialize(newItem);
    }
    [dartx.insertItemBefore](newItem, index) {
      return this.insertItemBefore(newItem, index);
    }
    [dartx.removeItem](index) {
      return this.removeItem(index);
    }
    [dartx.replaceItem](newItem, index) {
      return this.replaceItem(newItem, index);
    }
  };
  svg$.TransformList[dart.implements] = () => [core.List$(svg$.Transform)];
  dart.setSignature(svg$.TransformList, {
    constructors: () => ({_: [svg$.TransformList, []]}),
    methods: () => ({
      [dartx.get]: [svg$.Transform, [core.int]],
      [dartx.set]: [dart.void, [core.int, svg$.Transform]],
      [dartx.elementAt]: [svg$.Transform, [core.int]],
      [__setter__$]: [dart.void, [core.int, svg$.Transform]],
      [dartx.appendItem]: [svg$.Transform, [svg$.Transform]],
      [dartx.consolidate]: [svg$.Transform, []],
      [dartx.createSvgTransformFromMatrix]: [svg$.Transform, [svg$.Matrix]],
      [dartx.getItem]: [svg$.Transform, [core.int]],
      [dartx.initialize]: [svg$.Transform, [svg$.Transform]],
      [dartx.insertItemBefore]: [svg$.Transform, [svg$.Transform, core.int]],
      [dartx.removeItem]: [svg$.Transform, [core.int]],
      [dartx.replaceItem]: [svg$.Transform, [svg$.Transform, core.int]]
    })
  });
  svg$.TransformList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGTransformList')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGTransformList"))];
  dart.registerExtension(dart.global.SVGTransformList, svg$.TransformList);
  svg$.UnitTypes = class UnitTypes extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(svg$.UnitTypes, {
    constructors: () => ({_: [svg$.UnitTypes, []]})
  });
  svg$.UnitTypes[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGUnitTypes')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGUnitTypes"))];
  svg$.UnitTypes.SVG_UNIT_TYPE_OBJECTBOUNDINGBOX = 2;
  svg$.UnitTypes.SVG_UNIT_TYPE_UNKNOWN = 0;
  svg$.UnitTypes.SVG_UNIT_TYPE_USERSPACEONUSE = 1;
  dart.registerExtension(dart.global.SVGUnitTypes, svg$.UnitTypes);
  dart.defineExtensionNames([
    'href'
  ]);
  svg$.UriReference = class UriReference extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(svg$.UriReference, {
    constructors: () => ({_: [svg$.UriReference, []]})
  });
  dart.defineExtensionMembers(svg$.UriReference, ['href']);
  svg$.UriReference[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGURIReference')), dart.const(new _metadata.Unstable())];
  dart.defineExtensionNames([
    'height',
    'width',
    'x',
    'y',
    'href'
  ]);
  svg$.UseElement = class UseElement extends svg$.GraphicsElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("use"), svg$.UseElement);
    }
    created() {
      this[dartx.height] = null;
      this[dartx.width] = null;
      this[dartx.x] = null;
      this[dartx.y] = null;
      this[dartx.href] = null;
      super.created();
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.width]() {
      return this.width;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
    get [dartx.href]() {
      return this.href;
    }
  };
  dart.defineNamedConstructor(svg$.UseElement, 'created');
  svg$.UseElement[dart.implements] = () => [svg$.UriReference];
  dart.setSignature(svg$.UseElement, {
    constructors: () => ({
      _: [svg$.UseElement, []],
      new: [svg$.UseElement, []],
      created: [svg$.UseElement, []]
    })
  });
  svg$.UseElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGUseElement')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGUseElement"))];
  dart.registerExtension(dart.global.SVGUseElement, svg$.UseElement);
  dart.defineExtensionNames([
    'viewTarget',
    'preserveAspectRatio',
    'viewBox',
    'zoomAndPan'
  ]);
  svg$.ViewElement = class ViewElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("view"), svg$.ViewElement);
    }
    created() {
      this[dartx.viewTarget] = null;
      this[dartx.preserveAspectRatio] = null;
      this[dartx.viewBox] = null;
      this[dartx.zoomAndPan] = null;
      super.created();
    }
    get [dartx.viewTarget]() {
      return this.viewTarget;
    }
    get [dartx.preserveAspectRatio]() {
      return this.preserveAspectRatio;
    }
    get [dartx.viewBox]() {
      return this.viewBox;
    }
    get [dartx.zoomAndPan]() {
      return this.zoomAndPan;
    }
    set [dartx.zoomAndPan](value) {
      this.zoomAndPan = value;
    }
  };
  dart.defineNamedConstructor(svg$.ViewElement, 'created');
  svg$.ViewElement[dart.implements] = () => [svg$.FitToViewBox, svg$.ZoomAndPan];
  dart.setSignature(svg$.ViewElement, {
    constructors: () => ({
      _: [svg$.ViewElement, []],
      new: [svg$.ViewElement, []],
      created: [svg$.ViewElement, []]
    })
  });
  svg$.ViewElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGViewElement')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGViewElement"))];
  dart.registerExtension(dart.global.SVGViewElement, svg$.ViewElement);
  dart.defineExtensionNames([
    'preserveAspectRatioString',
    'transform',
    'transformString',
    'viewBoxString',
    'viewTarget',
    'viewTargetString',
    'preserveAspectRatio',
    'viewBox',
    'zoomAndPan'
  ]);
  svg$.ViewSpec = class ViewSpec extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.preserveAspectRatioString]() {
      return this.preserveAspectRatioString;
    }
    get [dartx.transform]() {
      return this.transform;
    }
    get [dartx.transformString]() {
      return this.transformString;
    }
    get [dartx.viewBoxString]() {
      return this.viewBoxString;
    }
    get [dartx.viewTarget]() {
      return this.viewTarget;
    }
    get [dartx.viewTargetString]() {
      return this.viewTargetString;
    }
    get [dartx.preserveAspectRatio]() {
      return this.preserveAspectRatio;
    }
    get [dartx.viewBox]() {
      return this.viewBox;
    }
    get [dartx.zoomAndPan]() {
      return this.zoomAndPan;
    }
    set [dartx.zoomAndPan](value) {
      this.zoomAndPan = value;
    }
  };
  svg$.ViewSpec[dart.implements] = () => [svg$.FitToViewBox, svg$.ZoomAndPan];
  dart.setSignature(svg$.ViewSpec, {
    constructors: () => ({_: [svg$.ViewSpec, []]})
  });
  svg$.ViewSpec[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGViewSpec')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGViewSpec"))];
  dart.registerExtension(dart.global.SVGViewSpec, svg$.ViewSpec);
  dart.defineExtensionNames([
    'zoomAndPan'
  ]);
  svg$.ZoomAndPan = class ZoomAndPan extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(svg$.ZoomAndPan, {
    constructors: () => ({_: [svg$.ZoomAndPan, []]})
  });
  dart.defineExtensionMembers(svg$.ZoomAndPan, ['zoomAndPan', 'zoomAndPan']);
  svg$.ZoomAndPan[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGZoomAndPan')), dart.const(new _metadata.Unstable())];
  svg$.ZoomAndPan.SVG_ZOOMANDPAN_DISABLE = 1;
  svg$.ZoomAndPan.SVG_ZOOMANDPAN_MAGNIFY = 2;
  svg$.ZoomAndPan.SVG_ZOOMANDPAN_UNKNOWN = 0;
  dart.defineExtensionNames([
    'newScale',
    'newTranslate',
    'previousScale',
    'previousTranslate',
    'zoomRectScreen'
  ]);
  svg$.ZoomEvent = class ZoomEvent extends html$.UIEvent {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.newScale]() {
      return this.newScale;
    }
    get [dartx.newTranslate]() {
      return this.newTranslate;
    }
    get [dartx.previousScale]() {
      return this.previousScale;
    }
    get [dartx.previousTranslate]() {
      return this.previousTranslate;
    }
    get [dartx.zoomRectScreen]() {
      return this.zoomRectScreen;
    }
  };
  dart.setSignature(svg$.ZoomEvent, {
    constructors: () => ({_: [svg$.ZoomEvent, []]})
  });
  svg$.ZoomEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGZoomEvent')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGZoomEvent"))];
  dart.registerExtension(dart.global.SVGZoomEvent, svg$.ZoomEvent);
  svg$._SVGCursorElement = class _SVGCursorElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("cursor"), svg$._SVGCursorElement);
    }
    created() {
      super.created();
    }
    static get supported() {
      return dart.notNull(svg$.SvgElement.isTagSupported('cursor')) && dart.is(svg$.SvgElement.tag('cursor'), svg$._SVGCursorElement);
    }
  };
  dart.defineNamedConstructor(svg$._SVGCursorElement, 'created');
  svg$._SVGCursorElement[dart.implements] = () => [svg$.UriReference, svg$.Tests];
  dart.setSignature(svg$._SVGCursorElement, {
    constructors: () => ({
      _: [svg$._SVGCursorElement, []],
      new: [svg$._SVGCursorElement, []],
      created: [svg$._SVGCursorElement, []]
    })
  });
  svg$._SVGCursorElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGCursorElement')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("SVGCursorElement"))];
  dart.registerExtension(dart.global.SVGCursorElement, svg$._SVGCursorElement);
  svg$._SVGFEDropShadowElement = class _SVGFEDropShadowElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(svg$._SVGFEDropShadowElement, 'created');
  svg$._SVGFEDropShadowElement[dart.implements] = () => [svg$.FilterPrimitiveStandardAttributes];
  dart.setSignature(svg$._SVGFEDropShadowElement, {
    constructors: () => ({
      _: [svg$._SVGFEDropShadowElement, []],
      created: [svg$._SVGFEDropShadowElement, []]
    })
  });
  svg$._SVGFEDropShadowElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGFEDropShadowElement')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("SVGFEDropShadowElement"))];
  dart.registerExtension(dart.global.SVGFEDropShadowElement, svg$._SVGFEDropShadowElement);
  svg$._SVGMPathElement = class _SVGMPathElement extends svg$.SvgElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(svg$._SvgElementFactoryProvider.createSvgElement_tag("mpath"), svg$._SVGMPathElement);
    }
    created() {
      super.created();
    }
  };
  dart.defineNamedConstructor(svg$._SVGMPathElement, 'created');
  svg$._SVGMPathElement[dart.implements] = () => [svg$.UriReference];
  dart.setSignature(svg$._SVGMPathElement, {
    constructors: () => ({
      _: [svg$._SVGMPathElement, []],
      new: [svg$._SVGMPathElement, []],
      created: [svg$._SVGMPathElement, []]
    })
  });
  svg$._SVGMPathElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SVGMPathElement')), dart.const(new _js_helper.Native("SVGMPathElement"))];
  dart.registerExtension(dart.global.SVGMPathElement, svg$._SVGMPathElement);
  const _connect = Symbol('_connect');
  dart.defineExtensionNames([
    'disconnect',
    'connectNode',
    'connectParam',
    'channelCount',
    'channelCountMode',
    'channelInterpretation',
    'context',
    'numberOfInputs',
    'numberOfOutputs'
  ]);
  web_audio.AudioNode = class AudioNode extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.channelCount]() {
      return this.channelCount;
    }
    set [dartx.channelCount](value) {
      this.channelCount = value;
    }
    get [dartx.channelCountMode]() {
      return this.channelCountMode;
    }
    set [dartx.channelCountMode](value) {
      this.channelCountMode = value;
    }
    get [dartx.channelInterpretation]() {
      return this.channelInterpretation;
    }
    set [dartx.channelInterpretation](value) {
      this.channelInterpretation = value;
    }
    get [dartx.context]() {
      return this.context;
    }
    get [dartx.numberOfInputs]() {
      return this.numberOfInputs;
    }
    get [dartx.numberOfOutputs]() {
      return this.numberOfOutputs;
    }
    [_connect](destination, output, input) {
      return this.connect(destination, output, input);
    }
    [dartx.disconnect](output) {
      return this.disconnect(output);
    }
    [dartx.connectNode](destination, output, input) {
      if (output === void 0) output = 0;
      if (input === void 0) input = 0;
      return this[_connect](destination, output, input);
    }
    [dartx.connectParam](destination, output) {
      if (output === void 0) output = 0;
      return this[_connect](destination, output);
    }
  };
  dart.setSignature(web_audio.AudioNode, {
    constructors: () => ({_: [web_audio.AudioNode, []]}),
    methods: () => ({
      [_connect]: [dart.void, [dart.dynamic, core.int], [core.int]],
      [dartx.disconnect]: [dart.void, [core.int]],
      [dartx.connectNode]: [dart.void, [web_audio.AudioNode], [core.int, core.int]],
      [dartx.connectParam]: [dart.void, [web_audio.AudioParam], [core.int]]
    })
  });
  web_audio.AudioNode[dart.metadata] = () => [dart.const(new _metadata.DomName('AudioNode')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("AudioNode"))];
  dart.registerExtension(dart.global.AudioNode, web_audio.AudioNode);
  dart.defineExtensionNames([
    'getByteFrequencyData',
    'getByteTimeDomainData',
    'getFloatFrequencyData',
    'getFloatTimeDomainData',
    'fftSize',
    'frequencyBinCount',
    'maxDecibels',
    'minDecibels',
    'smoothingTimeConstant'
  ]);
  web_audio.AnalyserNode = class AnalyserNode extends web_audio.AudioNode {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.fftSize]() {
      return this.fftSize;
    }
    set [dartx.fftSize](value) {
      this.fftSize = value;
    }
    get [dartx.frequencyBinCount]() {
      return this.frequencyBinCount;
    }
    get [dartx.maxDecibels]() {
      return this.maxDecibels;
    }
    set [dartx.maxDecibels](value) {
      this.maxDecibels = value;
    }
    get [dartx.minDecibels]() {
      return this.minDecibels;
    }
    set [dartx.minDecibels](value) {
      this.minDecibels = value;
    }
    get [dartx.smoothingTimeConstant]() {
      return this.smoothingTimeConstant;
    }
    set [dartx.smoothingTimeConstant](value) {
      this.smoothingTimeConstant = value;
    }
    [dartx.getByteFrequencyData](array) {
      return this.getByteFrequencyData(array);
    }
    [dartx.getByteTimeDomainData](array) {
      return this.getByteTimeDomainData(array);
    }
    [dartx.getFloatFrequencyData](array) {
      return this.getFloatFrequencyData(array);
    }
    [dartx.getFloatTimeDomainData](array) {
      return this.getFloatTimeDomainData(array);
    }
  };
  dart.setSignature(web_audio.AnalyserNode, {
    constructors: () => ({_: [web_audio.AnalyserNode, []]}),
    methods: () => ({
      [dartx.getByteFrequencyData]: [dart.void, [typed_data.Uint8List]],
      [dartx.getByteTimeDomainData]: [dart.void, [typed_data.Uint8List]],
      [dartx.getFloatFrequencyData]: [dart.void, [typed_data.Float32List]],
      [dartx.getFloatTimeDomainData]: [dart.void, [typed_data.Float32List]]
    })
  });
  web_audio.AnalyserNode[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('AnalyserNode')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("AnalyserNode,RealtimeAnalyserNode"))];
  dart.registerExtension(dart.global.AnalyserNode, web_audio.AnalyserNode);
  dart.defineExtensionNames([
    'getChannelData',
    'duration',
    'length',
    'numberOfChannels',
    'sampleRate'
  ]);
  web_audio.AudioBuffer = class AudioBuffer extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.duration]() {
      return this.duration;
    }
    get [dartx.length]() {
      return this.length;
    }
    get [dartx.numberOfChannels]() {
      return this.numberOfChannels;
    }
    get [dartx.sampleRate]() {
      return this.sampleRate;
    }
    [dartx.getChannelData](channelIndex) {
      return this.getChannelData(channelIndex);
    }
  };
  dart.setSignature(web_audio.AudioBuffer, {
    constructors: () => ({_: [web_audio.AudioBuffer, []]}),
    methods: () => ({[dartx.getChannelData]: [typed_data.Float32List, [core.int]]})
  });
  web_audio.AudioBuffer[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('AudioBuffer')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("AudioBuffer"))];
  dart.registerExtension(dart.global.AudioBuffer, web_audio.AudioBuffer);
  web_audio.AudioBufferCallback = dart.typedef('AudioBufferCallback', () => dart.functionType(dart.void, [web_audio.AudioBuffer]));
  web_audio.AudioSourceNode = class AudioSourceNode extends web_audio.AudioNode {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_audio.AudioSourceNode, {
    constructors: () => ({_: [web_audio.AudioSourceNode, []]})
  });
  web_audio.AudioSourceNode[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('AudioSourceNode')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("AudioSourceNode"))];
  dart.registerExtension(dart.global.AudioSourceNode, web_audio.AudioSourceNode);
  dart.defineExtensionNames([
    'start',
    'stop',
    'onEnded',
    'buffer',
    'loop',
    'loopEnd',
    'loopStart',
    'playbackRate'
  ]);
  web_audio.AudioBufferSourceNode = class AudioBufferSourceNode extends web_audio.AudioSourceNode {
    [dartx.start](when, grainOffset, grainDuration) {
      if (grainOffset === void 0) grainOffset = null;
      if (grainDuration === void 0) grainDuration = null;
      if (!!this.start) {
        if (grainDuration != null) {
          this.start(when, grainOffset, grainDuration);
        } else if (grainOffset != null) {
          this.start(when, grainOffset);
        } else {
          this.start(when);
        }
      } else {
        if (grainDuration != null) {
          this.noteOn(when, grainOffset, grainDuration);
        } else if (grainOffset != null) {
          this.noteOn(when, grainOffset);
        } else {
          this.noteOn(when);
        }
      }
    }
    [dartx.stop](when) {
      if (!!this.stop) {
        this.stop(when);
      } else {
        this.noteOff(when);
      }
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.buffer]() {
      return this.buffer;
    }
    set [dartx.buffer](value) {
      this.buffer = value;
    }
    get [dartx.loop]() {
      return this.loop;
    }
    set [dartx.loop](value) {
      this.loop = value;
    }
    get [dartx.loopEnd]() {
      return this.loopEnd;
    }
    set [dartx.loopEnd](value) {
      this.loopEnd = value;
    }
    get [dartx.loopStart]() {
      return this.loopStart;
    }
    set [dartx.loopStart](value) {
      this.loopStart = value;
    }
    get [dartx.playbackRate]() {
      return this.playbackRate;
    }
    get [dartx.onEnded]() {
      return web_audio.AudioBufferSourceNode.endedEvent.forTarget(this);
    }
  };
  dart.setSignature(web_audio.AudioBufferSourceNode, {
    constructors: () => ({_: [web_audio.AudioBufferSourceNode, []]}),
    methods: () => ({
      [dartx.start]: [dart.void, [core.num], [core.num, core.num]],
      [dartx.stop]: [dart.void, [core.num]]
    })
  });
  web_audio.AudioBufferSourceNode[dart.metadata] = () => [dart.const(new _metadata.DomName('AudioBufferSourceNode')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("AudioBufferSourceNode"))];
  web_audio.AudioBufferSourceNode.endedEvent = dart.const(new (html$.EventStreamProvider$(html$.Event))('ended'));
  dart.registerExtension(dart.global.AudioBufferSourceNode, web_audio.AudioBufferSourceNode);
  const _decodeAudioData = Symbol('_decodeAudioData');
  dart.defineExtensionNames([
    'createAnalyser',
    'createBiquadFilter',
    'createBuffer',
    'createBufferSource',
    'createChannelMerger',
    'createChannelSplitter',
    'createConvolver',
    'createDelay',
    'createDynamicsCompressor',
    'createMediaElementSource',
    'createMediaStreamDestination',
    'createMediaStreamSource',
    'createOscillator',
    'createPanner',
    'createPeriodicWave',
    'createWaveShaper',
    'startRendering',
    'onComplete',
    'createGain',
    'createScriptProcessor',
    'decodeAudioData',
    'currentTime',
    'destination',
    'listener',
    'sampleRate'
  ]);
  web_audio.AudioContext = class AudioContext extends html$.EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static get supported() {
      return !!(window.AudioContext || window.webkitAudioContext);
    }
    get [dartx.currentTime]() {
      return this.currentTime;
    }
    get [dartx.destination]() {
      return this.destination;
    }
    get [dartx.listener]() {
      return this.listener;
    }
    get [dartx.sampleRate]() {
      return this.sampleRate;
    }
    [dartx.createAnalyser]() {
      return this.createAnalyser();
    }
    [dartx.createBiquadFilter]() {
      return this.createBiquadFilter();
    }
    [dartx.createBuffer](numberOfChannels, numberOfFrames, sampleRate) {
      return this.createBuffer(numberOfChannels, numberOfFrames, sampleRate);
    }
    [dartx.createBufferSource]() {
      return this.createBufferSource();
    }
    [dartx.createChannelMerger](numberOfInputs) {
      return this.createChannelMerger(numberOfInputs);
    }
    [dartx.createChannelSplitter](numberOfOutputs) {
      return this.createChannelSplitter(numberOfOutputs);
    }
    [dartx.createConvolver]() {
      return this.createConvolver();
    }
    [dartx.createDelay](maxDelayTime) {
      return this.createDelay(maxDelayTime);
    }
    [dartx.createDynamicsCompressor]() {
      return this.createDynamicsCompressor();
    }
    [dartx.createMediaElementSource](mediaElement) {
      return this.createMediaElementSource(mediaElement);
    }
    [dartx.createMediaStreamDestination]() {
      return this.createMediaStreamDestination();
    }
    [dartx.createMediaStreamSource](mediaStream) {
      return this.createMediaStreamSource(mediaStream);
    }
    [dartx.createOscillator]() {
      return this.createOscillator();
    }
    [dartx.createPanner]() {
      return this.createPanner();
    }
    [dartx.createPeriodicWave](real, imag) {
      return this.createPeriodicWave(real, imag);
    }
    [dartx.createWaveShaper]() {
      return this.createWaveShaper();
    }
    [_decodeAudioData](audioData, successCallback, errorCallback) {
      return this.decodeAudioData(audioData, successCallback, errorCallback);
    }
    [dartx.startRendering]() {
      return this.startRendering();
    }
    get [dartx.onComplete]() {
      return web_audio.AudioContext.completeEvent.forTarget(this);
    }
    static new() {
      return new (window.AudioContext || window.webkitAudioContext)();
    }
    [dartx.createGain]() {
      if (this.createGain !== undefined) {
        return this.createGain();
      } else {
        return this.createGainNode();
      }
    }
    [dartx.createScriptProcessor](bufferSize, numberOfInputChannels, numberOfOutputChannels) {
      if (numberOfInputChannels === void 0) numberOfInputChannels = null;
      if (numberOfOutputChannels === void 0) numberOfOutputChannels = null;
      let func = this.createScriptProcessor || this.createJavaScriptNode;
      if (numberOfOutputChannels != null) {
        return func.call(this, bufferSize, numberOfInputChannels, numberOfOutputChannels);
      } else if (numberOfInputChannels != null) {
        return func.call(this, bufferSize, numberOfInputChannels);
      } else {
        return func.call(this, bufferSize);
      }
    }
    [dartx.decodeAudioData](audioData) {
      let completer = async.Completer$(web_audio.AudioBuffer).new();
      this[_decodeAudioData](audioData, dart.fn(value => {
        completer.complete(value);
      }, dart.void, [web_audio.AudioBuffer]), dart.fn(error => {
        if (error == null) {
          completer.completeError('');
        } else {
          completer.completeError(error);
        }
      }, dart.void, [web_audio.AudioBuffer]));
      return completer.future;
    }
  };
  dart.setSignature(web_audio.AudioContext, {
    constructors: () => ({
      _: [web_audio.AudioContext, []],
      new: [web_audio.AudioContext, []]
    }),
    methods: () => ({
      [dartx.createAnalyser]: [web_audio.AnalyserNode, []],
      [dartx.createBiquadFilter]: [web_audio.BiquadFilterNode, []],
      [dartx.createBuffer]: [web_audio.AudioBuffer, [core.int, core.int, core.num]],
      [dartx.createBufferSource]: [web_audio.AudioBufferSourceNode, []],
      [dartx.createChannelMerger]: [web_audio.ChannelMergerNode, [], [core.int]],
      [dartx.createChannelSplitter]: [web_audio.ChannelSplitterNode, [], [core.int]],
      [dartx.createConvolver]: [web_audio.ConvolverNode, []],
      [dartx.createDelay]: [web_audio.DelayNode, [], [core.num]],
      [dartx.createDynamicsCompressor]: [web_audio.DynamicsCompressorNode, []],
      [dartx.createMediaElementSource]: [web_audio.MediaElementAudioSourceNode, [html$.MediaElement]],
      [dartx.createMediaStreamDestination]: [web_audio.MediaStreamAudioDestinationNode, []],
      [dartx.createMediaStreamSource]: [web_audio.MediaStreamAudioSourceNode, [html$.MediaStream]],
      [dartx.createOscillator]: [web_audio.OscillatorNode, []],
      [dartx.createPanner]: [web_audio.PannerNode, []],
      [dartx.createPeriodicWave]: [web_audio.PeriodicWave, [typed_data.Float32List, typed_data.Float32List]],
      [dartx.createWaveShaper]: [web_audio.WaveShaperNode, []],
      [_decodeAudioData]: [dart.void, [typed_data.ByteBuffer, web_audio.AudioBufferCallback], [web_audio.AudioBufferCallback]],
      [dartx.startRendering]: [dart.void, []],
      [dartx.createGain]: [web_audio.GainNode, []],
      [dartx.createScriptProcessor]: [web_audio.ScriptProcessorNode, [core.int], [core.int, core.int]],
      [dartx.decodeAudioData]: [async.Future$(web_audio.AudioBuffer), [typed_data.ByteBuffer]]
    })
  });
  web_audio.AudioContext[dart.metadata] = () => [dart.const(new _metadata.DomName('AudioContext')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("AudioContext,webkitAudioContext"))];
  web_audio.AudioContext.completeEvent = dart.const(new (html$.EventStreamProvider$(html$.Event))('complete'));
  dart.registerExtension(dart.global.AudioContext, web_audio.AudioContext);
  dart.defineExtensionNames([
    'maxChannelCount'
  ]);
  web_audio.AudioDestinationNode = class AudioDestinationNode extends web_audio.AudioNode {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.maxChannelCount]() {
      return this.maxChannelCount;
    }
  };
  dart.setSignature(web_audio.AudioDestinationNode, {
    constructors: () => ({_: [web_audio.AudioDestinationNode, []]})
  });
  web_audio.AudioDestinationNode[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('AudioDestinationNode')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("AudioDestinationNode"))];
  dart.registerExtension(dart.global.AudioDestinationNode, web_audio.AudioDestinationNode);
  dart.defineExtensionNames([
    'setOrientation',
    'setPosition',
    'setVelocity',
    'dopplerFactor',
    'speedOfSound'
  ]);
  web_audio.AudioListener = class AudioListener extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.dopplerFactor]() {
      return this.dopplerFactor;
    }
    set [dartx.dopplerFactor](value) {
      this.dopplerFactor = value;
    }
    get [dartx.speedOfSound]() {
      return this.speedOfSound;
    }
    set [dartx.speedOfSound](value) {
      this.speedOfSound = value;
    }
    [dartx.setOrientation](x, y, z, xUp, yUp, zUp) {
      return this.setOrientation(x, y, z, xUp, yUp, zUp);
    }
    [dartx.setPosition](x, y, z) {
      return this.setPosition(x, y, z);
    }
    [dartx.setVelocity](x, y, z) {
      return this.setVelocity(x, y, z);
    }
  };
  dart.setSignature(web_audio.AudioListener, {
    constructors: () => ({_: [web_audio.AudioListener, []]}),
    methods: () => ({
      [dartx.setOrientation]: [dart.void, [core.num, core.num, core.num, core.num, core.num, core.num]],
      [dartx.setPosition]: [dart.void, [core.num, core.num, core.num]],
      [dartx.setVelocity]: [dart.void, [core.num, core.num, core.num]]
    })
  });
  web_audio.AudioListener[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('AudioListener')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("AudioListener"))];
  dart.registerExtension(dart.global.AudioListener, web_audio.AudioListener);
  dart.defineExtensionNames([
    'cancelScheduledValues',
    'exponentialRampToValueAtTime',
    'linearRampToValueAtTime',
    'setTargetAtTime',
    'setValueAtTime',
    'setValueCurveAtTime',
    'defaultValue',
    'value'
  ]);
  web_audio.AudioParam = class AudioParam extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.defaultValue]() {
      return this.defaultValue;
    }
    get [dartx.value]() {
      return this.value;
    }
    set [dartx.value](value) {
      this.value = value;
    }
    [dartx.cancelScheduledValues](startTime) {
      return this.cancelScheduledValues(startTime);
    }
    [dartx.exponentialRampToValueAtTime](value, time) {
      return this.exponentialRampToValueAtTime(value, time);
    }
    [dartx.linearRampToValueAtTime](value, time) {
      return this.linearRampToValueAtTime(value, time);
    }
    [dartx.setTargetAtTime](target, time, timeConstant) {
      return this.setTargetAtTime(target, time, timeConstant);
    }
    [dartx.setValueAtTime](value, time) {
      return this.setValueAtTime(value, time);
    }
    [dartx.setValueCurveAtTime](values, time, duration) {
      return this.setValueCurveAtTime(values, time, duration);
    }
  };
  dart.setSignature(web_audio.AudioParam, {
    constructors: () => ({_: [web_audio.AudioParam, []]}),
    methods: () => ({
      [dartx.cancelScheduledValues]: [dart.void, [core.num]],
      [dartx.exponentialRampToValueAtTime]: [dart.void, [core.num, core.num]],
      [dartx.linearRampToValueAtTime]: [dart.void, [core.num, core.num]],
      [dartx.setTargetAtTime]: [dart.void, [core.num, core.num, core.num]],
      [dartx.setValueAtTime]: [dart.void, [core.num, core.num]],
      [dartx.setValueCurveAtTime]: [dart.void, [typed_data.Float32List, core.num, core.num]]
    })
  });
  web_audio.AudioParam[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('AudioParam')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("AudioParam"))];
  dart.registerExtension(dart.global.AudioParam, web_audio.AudioParam);
  dart.defineExtensionNames([
    'inputBuffer',
    'outputBuffer',
    'playbackTime'
  ]);
  web_audio.AudioProcessingEvent = class AudioProcessingEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.inputBuffer]() {
      return this.inputBuffer;
    }
    get [dartx.outputBuffer]() {
      return this.outputBuffer;
    }
    get [dartx.playbackTime]() {
      return this.playbackTime;
    }
  };
  dart.setSignature(web_audio.AudioProcessingEvent, {
    constructors: () => ({_: [web_audio.AudioProcessingEvent, []]})
  });
  web_audio.AudioProcessingEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('AudioProcessingEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("AudioProcessingEvent"))];
  dart.registerExtension(dart.global.AudioProcessingEvent, web_audio.AudioProcessingEvent);
  dart.defineExtensionNames([
    'getFrequencyResponse',
    'Q',
    'detune',
    'frequency',
    'gain',
    'type'
  ]);
  web_audio.BiquadFilterNode = class BiquadFilterNode extends web_audio.AudioNode {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.Q]() {
      return this.Q;
    }
    get [dartx.detune]() {
      return this.detune;
    }
    get [dartx.frequency]() {
      return this.frequency;
    }
    get [dartx.gain]() {
      return this.gain;
    }
    get [dartx.type]() {
      return this.type;
    }
    set [dartx.type](value) {
      this.type = value;
    }
    [dartx.getFrequencyResponse](frequencyHz, magResponse, phaseResponse) {
      return this.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);
    }
  };
  dart.setSignature(web_audio.BiquadFilterNode, {
    constructors: () => ({_: [web_audio.BiquadFilterNode, []]}),
    methods: () => ({[dartx.getFrequencyResponse]: [dart.void, [typed_data.Float32List, typed_data.Float32List, typed_data.Float32List]]})
  });
  web_audio.BiquadFilterNode[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('BiquadFilterNode')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("BiquadFilterNode"))];
  dart.registerExtension(dart.global.BiquadFilterNode, web_audio.BiquadFilterNode);
  web_audio.ChannelMergerNode = class ChannelMergerNode extends web_audio.AudioNode {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_audio.ChannelMergerNode, {
    constructors: () => ({_: [web_audio.ChannelMergerNode, []]})
  });
  web_audio.ChannelMergerNode[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ChannelMergerNode')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("ChannelMergerNode,AudioChannelMerger"))];
  dart.registerExtension(dart.global.ChannelMergerNode, web_audio.ChannelMergerNode);
  web_audio.ChannelSplitterNode = class ChannelSplitterNode extends web_audio.AudioNode {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_audio.ChannelSplitterNode, {
    constructors: () => ({_: [web_audio.ChannelSplitterNode, []]})
  });
  web_audio.ChannelSplitterNode[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ChannelSplitterNode')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("ChannelSplitterNode,AudioChannelSplitter"))];
  dart.registerExtension(dart.global.ChannelSplitterNode, web_audio.ChannelSplitterNode);
  dart.defineExtensionNames([
    'buffer',
    'normalize'
  ]);
  web_audio.ConvolverNode = class ConvolverNode extends web_audio.AudioNode {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.buffer]() {
      return this.buffer;
    }
    set [dartx.buffer](value) {
      this.buffer = value;
    }
    get [dartx.normalize]() {
      return this.normalize;
    }
    set [dartx.normalize](value) {
      this.normalize = value;
    }
  };
  dart.setSignature(web_audio.ConvolverNode, {
    constructors: () => ({_: [web_audio.ConvolverNode, []]})
  });
  web_audio.ConvolverNode[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ConvolverNode')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("ConvolverNode"))];
  dart.registerExtension(dart.global.ConvolverNode, web_audio.ConvolverNode);
  dart.defineExtensionNames([
    'delayTime'
  ]);
  web_audio.DelayNode = class DelayNode extends web_audio.AudioNode {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.delayTime]() {
      return this.delayTime;
    }
  };
  dart.setSignature(web_audio.DelayNode, {
    constructors: () => ({_: [web_audio.DelayNode, []]})
  });
  web_audio.DelayNode[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DelayNode')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("DelayNode"))];
  dart.registerExtension(dart.global.DelayNode, web_audio.DelayNode);
  dart.defineExtensionNames([
    'attack',
    'knee',
    'ratio',
    'reduction',
    'release',
    'threshold'
  ]);
  web_audio.DynamicsCompressorNode = class DynamicsCompressorNode extends web_audio.AudioNode {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.attack]() {
      return this.attack;
    }
    get [dartx.knee]() {
      return this.knee;
    }
    get [dartx.ratio]() {
      return this.ratio;
    }
    get [dartx.reduction]() {
      return this.reduction;
    }
    get [dartx.release]() {
      return this.release;
    }
    get [dartx.threshold]() {
      return this.threshold;
    }
  };
  dart.setSignature(web_audio.DynamicsCompressorNode, {
    constructors: () => ({_: [web_audio.DynamicsCompressorNode, []]})
  });
  web_audio.DynamicsCompressorNode[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DynamicsCompressorNode')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("DynamicsCompressorNode"))];
  dart.registerExtension(dart.global.DynamicsCompressorNode, web_audio.DynamicsCompressorNode);
  dart.defineExtensionNames([
    'gain'
  ]);
  web_audio.GainNode = class GainNode extends web_audio.AudioNode {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.gain]() {
      return this.gain;
    }
  };
  dart.setSignature(web_audio.GainNode, {
    constructors: () => ({_: [web_audio.GainNode, []]})
  });
  web_audio.GainNode[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('GainNode')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("GainNode,AudioGainNode"))];
  dart.registerExtension(dart.global.GainNode, web_audio.GainNode);
  dart.defineExtensionNames([
    'mediaElement'
  ]);
  web_audio.MediaElementAudioSourceNode = class MediaElementAudioSourceNode extends web_audio.AudioSourceNode {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.mediaElement]() {
      return this.mediaElement;
    }
  };
  dart.setSignature(web_audio.MediaElementAudioSourceNode, {
    constructors: () => ({_: [web_audio.MediaElementAudioSourceNode, []]})
  });
  web_audio.MediaElementAudioSourceNode[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MediaElementAudioSourceNode')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MediaElementAudioSourceNode"))];
  dart.registerExtension(dart.global.MediaElementAudioSourceNode, web_audio.MediaElementAudioSourceNode);
  dart.defineExtensionNames([
    'stream'
  ]);
  web_audio.MediaStreamAudioDestinationNode = class MediaStreamAudioDestinationNode extends web_audio.AudioNode {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.stream]() {
      return this.stream;
    }
  };
  dart.setSignature(web_audio.MediaStreamAudioDestinationNode, {
    constructors: () => ({_: [web_audio.MediaStreamAudioDestinationNode, []]})
  });
  web_audio.MediaStreamAudioDestinationNode[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MediaStreamAudioDestinationNode')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MediaStreamAudioDestinationNode"))];
  dart.registerExtension(dart.global.MediaStreamAudioDestinationNode, web_audio.MediaStreamAudioDestinationNode);
  dart.defineExtensionNames([
    'mediaStream'
  ]);
  web_audio.MediaStreamAudioSourceNode = class MediaStreamAudioSourceNode extends web_audio.AudioSourceNode {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.mediaStream]() {
      return this.mediaStream;
    }
  };
  dart.setSignature(web_audio.MediaStreamAudioSourceNode, {
    constructors: () => ({_: [web_audio.MediaStreamAudioSourceNode, []]})
  });
  web_audio.MediaStreamAudioSourceNode[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MediaStreamAudioSourceNode')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MediaStreamAudioSourceNode"))];
  dart.registerExtension(dart.global.MediaStreamAudioSourceNode, web_audio.MediaStreamAudioSourceNode);
  dart.defineExtensionNames([
    'renderedBuffer'
  ]);
  web_audio.OfflineAudioCompletionEvent = class OfflineAudioCompletionEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.renderedBuffer]() {
      return this.renderedBuffer;
    }
  };
  dart.setSignature(web_audio.OfflineAudioCompletionEvent, {
    constructors: () => ({_: [web_audio.OfflineAudioCompletionEvent, []]})
  });
  web_audio.OfflineAudioCompletionEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('OfflineAudioCompletionEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("OfflineAudioCompletionEvent"))];
  dart.registerExtension(dart.global.OfflineAudioCompletionEvent, web_audio.OfflineAudioCompletionEvent);
  web_audio.OfflineAudioContext = class OfflineAudioContext extends web_audio.AudioContext {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(numberOfChannels, numberOfFrames, sampleRate) {
      return web_audio.OfflineAudioContext._create_1(numberOfChannels, numberOfFrames, sampleRate);
    }
    static _create_1(numberOfChannels, numberOfFrames, sampleRate) {
      return new OfflineAudioContext(numberOfChannels, numberOfFrames, sampleRate);
    }
  };
  dart.setSignature(web_audio.OfflineAudioContext, {
    constructors: () => ({
      _: [web_audio.OfflineAudioContext, []],
      new: [web_audio.OfflineAudioContext, [core.int, core.int, core.num]]
    }),
    statics: () => ({_create_1: [web_audio.OfflineAudioContext, [dart.dynamic, dart.dynamic, dart.dynamic]]}),
    names: ['_create_1']
  });
  web_audio.OfflineAudioContext[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('OfflineAudioContext')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("OfflineAudioContext"))];
  dart.registerExtension(dart.global.OfflineAudioContext, web_audio.OfflineAudioContext);
  dart.defineExtensionNames([
    'noteOff',
    'noteOn',
    'setPeriodicWave',
    'start',
    'stop',
    'onEnded',
    'detune',
    'frequency',
    'type'
  ]);
  web_audio.OscillatorNode = class OscillatorNode extends web_audio.AudioSourceNode {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.detune]() {
      return this.detune;
    }
    get [dartx.frequency]() {
      return this.frequency;
    }
    get [dartx.type]() {
      return this.type;
    }
    set [dartx.type](value) {
      this.type = value;
    }
    [dartx.noteOff](when) {
      return this.noteOff(when);
    }
    [dartx.noteOn](when) {
      return this.noteOn(when);
    }
    [dartx.setPeriodicWave](periodicWave) {
      return this.setPeriodicWave(periodicWave);
    }
    [dartx.start](when) {
      return this.start(when);
    }
    [dartx.stop](when) {
      return this.stop(when);
    }
    get [dartx.onEnded]() {
      return web_audio.OscillatorNode.endedEvent.forTarget(this);
    }
  };
  dart.setSignature(web_audio.OscillatorNode, {
    constructors: () => ({_: [web_audio.OscillatorNode, []]}),
    methods: () => ({
      [dartx.noteOff]: [dart.void, [core.num]],
      [dartx.noteOn]: [dart.void, [core.num]],
      [dartx.setPeriodicWave]: [dart.void, [web_audio.PeriodicWave]],
      [dartx.start]: [dart.void, [], [core.num]],
      [dartx.stop]: [dart.void, [], [core.num]]
    })
  });
  web_audio.OscillatorNode[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('OscillatorNode')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("OscillatorNode,Oscillator"))];
  web_audio.OscillatorNode.endedEvent = dart.const(new (html$.EventStreamProvider$(html$.Event))('ended'));
  dart.registerExtension(dart.global.OscillatorNode, web_audio.OscillatorNode);
  dart.defineExtensionNames([
    'setOrientation',
    'setPosition',
    'setVelocity',
    'coneInnerAngle',
    'coneOuterAngle',
    'coneOuterGain',
    'distanceModel',
    'maxDistance',
    'panningModel',
    'refDistance',
    'rolloffFactor'
  ]);
  web_audio.PannerNode = class PannerNode extends web_audio.AudioNode {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.coneInnerAngle]() {
      return this.coneInnerAngle;
    }
    set [dartx.coneInnerAngle](value) {
      this.coneInnerAngle = value;
    }
    get [dartx.coneOuterAngle]() {
      return this.coneOuterAngle;
    }
    set [dartx.coneOuterAngle](value) {
      this.coneOuterAngle = value;
    }
    get [dartx.coneOuterGain]() {
      return this.coneOuterGain;
    }
    set [dartx.coneOuterGain](value) {
      this.coneOuterGain = value;
    }
    get [dartx.distanceModel]() {
      return this.distanceModel;
    }
    set [dartx.distanceModel](value) {
      this.distanceModel = value;
    }
    get [dartx.maxDistance]() {
      return this.maxDistance;
    }
    set [dartx.maxDistance](value) {
      this.maxDistance = value;
    }
    get [dartx.panningModel]() {
      return this.panningModel;
    }
    set [dartx.panningModel](value) {
      this.panningModel = value;
    }
    get [dartx.refDistance]() {
      return this.refDistance;
    }
    set [dartx.refDistance](value) {
      this.refDistance = value;
    }
    get [dartx.rolloffFactor]() {
      return this.rolloffFactor;
    }
    set [dartx.rolloffFactor](value) {
      this.rolloffFactor = value;
    }
    [dartx.setOrientation](x, y, z) {
      return this.setOrientation(x, y, z);
    }
    [dartx.setPosition](x, y, z) {
      return this.setPosition(x, y, z);
    }
    [dartx.setVelocity](x, y, z) {
      return this.setVelocity(x, y, z);
    }
  };
  dart.setSignature(web_audio.PannerNode, {
    constructors: () => ({_: [web_audio.PannerNode, []]}),
    methods: () => ({
      [dartx.setOrientation]: [dart.void, [core.num, core.num, core.num]],
      [dartx.setPosition]: [dart.void, [core.num, core.num, core.num]],
      [dartx.setVelocity]: [dart.void, [core.num, core.num, core.num]]
    })
  });
  web_audio.PannerNode[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('PannerNode')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("PannerNode,AudioPannerNode,webkitAudioPannerNode"))];
  dart.registerExtension(dart.global.PannerNode, web_audio.PannerNode);
  web_audio.PeriodicWave = class PeriodicWave extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_audio.PeriodicWave, {
    constructors: () => ({_: [web_audio.PeriodicWave, []]})
  });
  web_audio.PeriodicWave[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('PeriodicWave')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("PeriodicWave"))];
  dart.registerExtension(dart.global.PeriodicWave, web_audio.PeriodicWave);
  dart.defineExtensionNames([
    'setEventListener',
    'onAudioProcess',
    'bufferSize'
  ]);
  web_audio.ScriptProcessorNode = class ScriptProcessorNode extends web_audio.AudioNode {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.bufferSize]() {
      return this.bufferSize;
    }
    [dartx.setEventListener](eventListener) {
      return this.setEventListener(eventListener);
    }
    get [dartx.onAudioProcess]() {
      return web_audio.ScriptProcessorNode.audioProcessEvent.forTarget(this);
    }
  };
  dart.setSignature(web_audio.ScriptProcessorNode, {
    constructors: () => ({_: [web_audio.ScriptProcessorNode, []]}),
    methods: () => ({[dartx.setEventListener]: [dart.void, [html$.EventListener]]})
  });
  web_audio.ScriptProcessorNode[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ScriptProcessorNode')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("ScriptProcessorNode,JavaScriptAudioNode"))];
  web_audio.ScriptProcessorNode.audioProcessEvent = dart.const(new (html$.EventStreamProvider$(web_audio.AudioProcessingEvent))('audioprocess'));
  dart.registerExtension(dart.global.ScriptProcessorNode, web_audio.ScriptProcessorNode);
  dart.defineExtensionNames([
    'curve',
    'oversample'
  ]);
  web_audio.WaveShaperNode = class WaveShaperNode extends web_audio.AudioNode {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.curve]() {
      return this.curve;
    }
    set [dartx.curve](value) {
      this.curve = value;
    }
    get [dartx.oversample]() {
      return this.oversample;
    }
    set [dartx.oversample](value) {
      this.oversample = value;
    }
  };
  dart.setSignature(web_audio.WaveShaperNode, {
    constructors: () => ({_: [web_audio.WaveShaperNode, []]})
  });
  web_audio.WaveShaperNode[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('WaveShaperNode')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("WaveShaperNode"))];
  dart.registerExtension(dart.global.WaveShaperNode, web_audio.WaveShaperNode);
  const _getContextAttributes_1$ = Symbol('_getContextAttributes_1');
  const _texImage2D_1 = Symbol('_texImage2D_1');
  const _texImage2D_2 = Symbol('_texImage2D_2');
  const _texImage2D_3 = Symbol('_texImage2D_3');
  const _texImage2D_4 = Symbol('_texImage2D_4');
  const _texImage2D_5 = Symbol('_texImage2D_5');
  const _texImage2DImageData_1 = Symbol('_texImage2DImageData_1');
  const _texSubImage2D_1 = Symbol('_texSubImage2D_1');
  const _texSubImage2D_2 = Symbol('_texSubImage2D_2');
  const _texSubImage2D_3 = Symbol('_texSubImage2D_3');
  const _texSubImage2D_4 = Symbol('_texSubImage2D_4');
  const _texSubImage2D_5 = Symbol('_texSubImage2D_5');
  const _texSubImage2DImageData_1 = Symbol('_texSubImage2DImageData_1');
  dart.defineExtensionNames([
    'activeTexture',
    'attachShader',
    'bindAttribLocation',
    'bindBuffer',
    'bindFramebuffer',
    'bindRenderbuffer',
    'bindTexture',
    'blendColor',
    'blendEquation',
    'blendEquationSeparate',
    'blendFunc',
    'blendFuncSeparate',
    'bufferByteData',
    'bufferData',
    'bufferDataTyped',
    'bufferSubByteData',
    'bufferSubData',
    'bufferSubDataTyped',
    'checkFramebufferStatus',
    'clear',
    'clearColor',
    'clearDepth',
    'clearStencil',
    'colorMask',
    'compileShader',
    'compressedTexImage2D',
    'compressedTexSubImage2D',
    'copyTexImage2D',
    'copyTexSubImage2D',
    'createBuffer',
    'createFramebuffer',
    'createProgram',
    'createRenderbuffer',
    'createShader',
    'createTexture',
    'cullFace',
    'deleteBuffer',
    'deleteFramebuffer',
    'deleteProgram',
    'deleteRenderbuffer',
    'deleteShader',
    'deleteTexture',
    'depthFunc',
    'depthMask',
    'depthRange',
    'detachShader',
    'disable',
    'disableVertexAttribArray',
    'drawArrays',
    'drawElements',
    'enable',
    'enableVertexAttribArray',
    'finish',
    'flush',
    'framebufferRenderbuffer',
    'framebufferTexture2D',
    'frontFace',
    'generateMipmap',
    'getActiveAttrib',
    'getActiveUniform',
    'getAttachedShaders',
    'getAttribLocation',
    'getBufferParameter',
    'getContextAttributes',
    'getError',
    'getExtension',
    'getFramebufferAttachmentParameter',
    'getParameter',
    'getProgramInfoLog',
    'getProgramParameter',
    'getRenderbufferParameter',
    'getShaderInfoLog',
    'getShaderParameter',
    'getShaderPrecisionFormat',
    'getShaderSource',
    'getSupportedExtensions',
    'getTexParameter',
    'getUniform',
    'getUniformLocation',
    'getVertexAttrib',
    'getVertexAttribOffset',
    'hint',
    'isBuffer',
    'isContextLost',
    'isEnabled',
    'isFramebuffer',
    'isProgram',
    'isRenderbuffer',
    'isShader',
    'isTexture',
    'lineWidth',
    'linkProgram',
    'pixelStorei',
    'polygonOffset',
    'readPixels',
    'renderbufferStorage',
    'sampleCoverage',
    'scissor',
    'shaderSource',
    'stencilFunc',
    'stencilFuncSeparate',
    'stencilMask',
    'stencilMaskSeparate',
    'stencilOp',
    'stencilOpSeparate',
    'texImage2D',
    'texImage2DCanvas',
    'texImage2DImage',
    'texImage2DImageData',
    'texImage2DVideo',
    'texParameterf',
    'texParameteri',
    'texSubImage2D',
    'texSubImage2DCanvas',
    'texSubImage2DImage',
    'texSubImage2DImageData',
    'texSubImage2DVideo',
    'uniform1f',
    'uniform1fv',
    'uniform1i',
    'uniform1iv',
    'uniform2f',
    'uniform2fv',
    'uniform2i',
    'uniform2iv',
    'uniform3f',
    'uniform3fv',
    'uniform3i',
    'uniform3iv',
    'uniform4f',
    'uniform4fv',
    'uniform4i',
    'uniform4iv',
    'uniformMatrix2fv',
    'uniformMatrix3fv',
    'uniformMatrix4fv',
    'useProgram',
    'validateProgram',
    'vertexAttrib1f',
    'vertexAttrib1fv',
    'vertexAttrib2f',
    'vertexAttrib2fv',
    'vertexAttrib3f',
    'vertexAttrib3fv',
    'vertexAttrib4f',
    'vertexAttrib4fv',
    'vertexAttribPointer',
    'viewport',
    'texImage2DUntyped',
    'texImage2DTyped',
    'texSubImage2DUntyped',
    'texSubImage2DTyped',
    'canvas',
    'drawingBufferHeight',
    'drawingBufferWidth'
  ]);
  web_gl.RenderingContext = class RenderingContext extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static get supported() {
      return !!window.WebGLRenderingContext;
    }
    get [dartx.canvas]() {
      return this.canvas;
    }
    get [dartx.drawingBufferHeight]() {
      return this.drawingBufferHeight;
    }
    get [dartx.drawingBufferWidth]() {
      return this.drawingBufferWidth;
    }
    [dartx.activeTexture](texture) {
      return this.activeTexture(texture);
    }
    [dartx.attachShader](program, shader) {
      return this.attachShader(program, shader);
    }
    [dartx.bindAttribLocation](program, index, name) {
      return this.bindAttribLocation(program, index, name);
    }
    [dartx.bindBuffer](target, buffer) {
      return this.bindBuffer(target, buffer);
    }
    [dartx.bindFramebuffer](target, framebuffer) {
      return this.bindFramebuffer(target, framebuffer);
    }
    [dartx.bindRenderbuffer](target, renderbuffer) {
      return this.bindRenderbuffer(target, renderbuffer);
    }
    [dartx.bindTexture](target, texture) {
      return this.bindTexture(target, texture);
    }
    [dartx.blendColor](red, green, blue, alpha) {
      return this.blendColor(red, green, blue, alpha);
    }
    [dartx.blendEquation](mode) {
      return this.blendEquation(mode);
    }
    [dartx.blendEquationSeparate](modeRGB, modeAlpha) {
      return this.blendEquationSeparate(modeRGB, modeAlpha);
    }
    [dartx.blendFunc](sfactor, dfactor) {
      return this.blendFunc(sfactor, dfactor);
    }
    [dartx.blendFuncSeparate](srcRGB, dstRGB, srcAlpha, dstAlpha) {
      return this.blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
    }
    [dartx.bufferByteData](target, data, usage) {
      return this.bufferData(target, data, usage);
    }
    [dartx.bufferData](target, data_OR_size, usage) {
      return this.bufferData(target, data_OR_size, usage);
    }
    [dartx.bufferDataTyped](target, data, usage) {
      return this.bufferData(target, data, usage);
    }
    [dartx.bufferSubByteData](target, offset, data) {
      return this.bufferSubData(target, offset, data);
    }
    [dartx.bufferSubData](target, offset, data) {
      return this.bufferSubData(target, offset, data);
    }
    [dartx.bufferSubDataTyped](target, offset, data) {
      return this.bufferSubData(target, offset, data);
    }
    [dartx.checkFramebufferStatus](target) {
      return this.checkFramebufferStatus(target);
    }
    [dartx.clear](mask) {
      return this.clear(mask);
    }
    [dartx.clearColor](red, green, blue, alpha) {
      return this.clearColor(red, green, blue, alpha);
    }
    [dartx.clearDepth](depth) {
      return this.clearDepth(depth);
    }
    [dartx.clearStencil](s) {
      return this.clearStencil(s);
    }
    [dartx.colorMask](red, green, blue, alpha) {
      return this.colorMask(red, green, blue, alpha);
    }
    [dartx.compileShader](shader) {
      return this.compileShader(shader);
    }
    [dartx.compressedTexImage2D](target, level, internalformat, width, height, border, data) {
      return this.compressedTexImage2D(target, level, internalformat, width, height, border, data);
    }
    [dartx.compressedTexSubImage2D](target, level, xoffset, yoffset, width, height, format, data) {
      return this.compressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, data);
    }
    [dartx.copyTexImage2D](target, level, internalformat, x, y, width, height, border) {
      return this.copyTexImage2D(target, level, internalformat, x, y, width, height, border);
    }
    [dartx.copyTexSubImage2D](target, level, xoffset, yoffset, x, y, width, height) {
      return this.copyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
    }
    [dartx.createBuffer]() {
      return this.createBuffer();
    }
    [dartx.createFramebuffer]() {
      return this.createFramebuffer();
    }
    [dartx.createProgram]() {
      return this.createProgram();
    }
    [dartx.createRenderbuffer]() {
      return this.createRenderbuffer();
    }
    [dartx.createShader](type) {
      return this.createShader(type);
    }
    [dartx.createTexture]() {
      return this.createTexture();
    }
    [dartx.cullFace](mode) {
      return this.cullFace(mode);
    }
    [dartx.deleteBuffer](buffer) {
      return this.deleteBuffer(buffer);
    }
    [dartx.deleteFramebuffer](framebuffer) {
      return this.deleteFramebuffer(framebuffer);
    }
    [dartx.deleteProgram](program) {
      return this.deleteProgram(program);
    }
    [dartx.deleteRenderbuffer](renderbuffer) {
      return this.deleteRenderbuffer(renderbuffer);
    }
    [dartx.deleteShader](shader) {
      return this.deleteShader(shader);
    }
    [dartx.deleteTexture](texture) {
      return this.deleteTexture(texture);
    }
    [dartx.depthFunc](func) {
      return this.depthFunc(func);
    }
    [dartx.depthMask](flag) {
      return this.depthMask(flag);
    }
    [dartx.depthRange](zNear, zFar) {
      return this.depthRange(zNear, zFar);
    }
    [dartx.detachShader](program, shader) {
      return this.detachShader(program, shader);
    }
    [dartx.disable](cap) {
      return this.disable(cap);
    }
    [dartx.disableVertexAttribArray](index) {
      return this.disableVertexAttribArray(index);
    }
    [dartx.drawArrays](mode, first, count) {
      return this.drawArrays(mode, first, count);
    }
    [dartx.drawElements](mode, count, type, offset) {
      return this.drawElements(mode, count, type, offset);
    }
    [dartx.enable](cap) {
      return this.enable(cap);
    }
    [dartx.enableVertexAttribArray](index) {
      return this.enableVertexAttribArray(index);
    }
    [dartx.finish]() {
      return this.finish();
    }
    [dartx.flush]() {
      return this.flush();
    }
    [dartx.framebufferRenderbuffer](target, attachment, renderbuffertarget, renderbuffer) {
      return this.framebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer);
    }
    [dartx.framebufferTexture2D](target, attachment, textarget, texture, level) {
      return this.framebufferTexture2D(target, attachment, textarget, texture, level);
    }
    [dartx.frontFace](mode) {
      return this.frontFace(mode);
    }
    [dartx.generateMipmap](target) {
      return this.generateMipmap(target);
    }
    [dartx.getActiveAttrib](program, index) {
      return this.getActiveAttrib(program, index);
    }
    [dartx.getActiveUniform](program, index) {
      return this.getActiveUniform(program, index);
    }
    [dartx.getAttachedShaders](program) {
      return this.getAttachedShaders(program);
    }
    [dartx.getAttribLocation](program, name) {
      return this.getAttribLocation(program, name);
    }
    [dartx.getBufferParameter](target, pname) {
      return this.getBufferParameter(target, pname);
    }
    [dartx.getContextAttributes]() {
      return dart.as(html_common.convertNativeToDart_ContextAttributes(this[_getContextAttributes_1$]()), web_gl.ContextAttributes);
    }
    [_getContextAttributes_1$]() {
      return this.getContextAttributes();
    }
    [dartx.getError]() {
      return this.getError();
    }
    [dartx.getExtension](name) {
      return this.getExtension(name);
    }
    [dartx.getFramebufferAttachmentParameter](target, attachment, pname) {
      return this.getFramebufferAttachmentParameter(target, attachment, pname);
    }
    [dartx.getParameter](pname) {
      return this.getParameter(pname);
    }
    [dartx.getProgramInfoLog](program) {
      return this.getProgramInfoLog(program);
    }
    [dartx.getProgramParameter](program, pname) {
      return this.getProgramParameter(program, pname);
    }
    [dartx.getRenderbufferParameter](target, pname) {
      return this.getRenderbufferParameter(target, pname);
    }
    [dartx.getShaderInfoLog](shader) {
      return this.getShaderInfoLog(shader);
    }
    [dartx.getShaderParameter](shader, pname) {
      return this.getShaderParameter(shader, pname);
    }
    [dartx.getShaderPrecisionFormat](shadertype, precisiontype) {
      return this.getShaderPrecisionFormat(shadertype, precisiontype);
    }
    [dartx.getShaderSource](shader) {
      return this.getShaderSource(shader);
    }
    [dartx.getSupportedExtensions]() {
      return this.getSupportedExtensions();
    }
    [dartx.getTexParameter](target, pname) {
      return this.getTexParameter(target, pname);
    }
    [dartx.getUniform](program, location) {
      return this.getUniform(program, location);
    }
    [dartx.getUniformLocation](program, name) {
      return this.getUniformLocation(program, name);
    }
    [dartx.getVertexAttrib](index, pname) {
      return this.getVertexAttrib(index, pname);
    }
    [dartx.getVertexAttribOffset](index, pname) {
      return this.getVertexAttribOffset(index, pname);
    }
    [dartx.hint](target, mode) {
      return this.hint(target, mode);
    }
    [dartx.isBuffer](buffer) {
      return this.isBuffer(buffer);
    }
    [dartx.isContextLost]() {
      return this.isContextLost();
    }
    [dartx.isEnabled](cap) {
      return this.isEnabled(cap);
    }
    [dartx.isFramebuffer](framebuffer) {
      return this.isFramebuffer(framebuffer);
    }
    [dartx.isProgram](program) {
      return this.isProgram(program);
    }
    [dartx.isRenderbuffer](renderbuffer) {
      return this.isRenderbuffer(renderbuffer);
    }
    [dartx.isShader](shader) {
      return this.isShader(shader);
    }
    [dartx.isTexture](texture) {
      return this.isTexture(texture);
    }
    [dartx.lineWidth](width) {
      return this.lineWidth(width);
    }
    [dartx.linkProgram](program) {
      return this.linkProgram(program);
    }
    [dartx.pixelStorei](pname, param) {
      return this.pixelStorei(pname, param);
    }
    [dartx.polygonOffset](factor, units) {
      return this.polygonOffset(factor, units);
    }
    [dartx.readPixels](x, y, width, height, format, type, pixels) {
      return this.readPixels(x, y, width, height, format, type, pixels);
    }
    [dartx.renderbufferStorage](target, internalformat, width, height) {
      return this.renderbufferStorage(target, internalformat, width, height);
    }
    [dartx.sampleCoverage](value, invert) {
      return this.sampleCoverage(value, invert);
    }
    [dartx.scissor](x, y, width, height) {
      return this.scissor(x, y, width, height);
    }
    [dartx.shaderSource](shader, string) {
      return this.shaderSource(shader, string);
    }
    [dartx.stencilFunc](func, ref, mask) {
      return this.stencilFunc(func, ref, mask);
    }
    [dartx.stencilFuncSeparate](face, func, ref, mask) {
      return this.stencilFuncSeparate(face, func, ref, mask);
    }
    [dartx.stencilMask](mask) {
      return this.stencilMask(mask);
    }
    [dartx.stencilMaskSeparate](face, mask) {
      return this.stencilMaskSeparate(face, mask);
    }
    [dartx.stencilOp](fail, zfail, zpass) {
      return this.stencilOp(fail, zfail, zpass);
    }
    [dartx.stencilOpSeparate](face, fail, zfail, zpass) {
      return this.stencilOpSeparate(face, fail, zfail, zpass);
    }
    [dartx.texImage2D](target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video, format, type, pixels) {
      if (format === void 0) format = null;
      if (type === void 0) type = null;
      if (pixels === void 0) pixels = null;
      if (pixels != null && type != null && format != null && typeof border_OR_canvas_OR_image_OR_pixels_OR_video == 'number') {
        this[_texImage2D_1](target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video, format, type, pixels);
        return;
      }
      if ((dart.is(border_OR_canvas_OR_image_OR_pixels_OR_video, html$.ImageData) || border_OR_canvas_OR_image_OR_pixels_OR_video == null) && format == null && type == null && pixels == null) {
        let pixels_1 = html_common.convertDartToNative_ImageData(dart.as(border_OR_canvas_OR_image_OR_pixels_OR_video, html$.ImageData));
        this[_texImage2D_2](target, level, internalformat, format_OR_width, height_OR_type, pixels_1);
        return;
      }
      if (dart.is(border_OR_canvas_OR_image_OR_pixels_OR_video, html$.ImageElement) && format == null && type == null && pixels == null) {
        this[_texImage2D_3](target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video);
        return;
      }
      if (dart.is(border_OR_canvas_OR_image_OR_pixels_OR_video, html$.CanvasElement) && format == null && type == null && pixels == null) {
        this[_texImage2D_4](target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video);
        return;
      }
      if (dart.is(border_OR_canvas_OR_image_OR_pixels_OR_video, html$.VideoElement) && format == null && type == null && pixels == null) {
        this[_texImage2D_5](target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video);
        return;
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    [_texImage2D_1](target, level, internalformat, width, height, border, format, type, pixels) {
      return this.texImage2D(target, level, internalformat, width, height, border, format, type, pixels);
    }
    [_texImage2D_2](target, level, internalformat, format, type, pixels) {
      return this.texImage2D(target, level, internalformat, format, type, pixels);
    }
    [_texImage2D_3](target, level, internalformat, format, type, image) {
      return this.texImage2D(target, level, internalformat, format, type, image);
    }
    [_texImage2D_4](target, level, internalformat, format, type, canvas) {
      return this.texImage2D(target, level, internalformat, format, type, canvas);
    }
    [_texImage2D_5](target, level, internalformat, format, type, video) {
      return this.texImage2D(target, level, internalformat, format, type, video);
    }
    [dartx.texImage2DCanvas](target, level, internalformat, format, type, canvas) {
      return this.texImage2D(target, level, internalformat, format, type, canvas);
    }
    [dartx.texImage2DImage](target, level, internalformat, format, type, image) {
      return this.texImage2D(target, level, internalformat, format, type, image);
    }
    [dartx.texImage2DImageData](target, level, internalformat, format, type, pixels) {
      let pixels_1 = html_common.convertDartToNative_ImageData(pixels);
      this[_texImage2DImageData_1](target, level, internalformat, format, type, pixels_1);
      return;
    }
    [_texImage2DImageData_1](target, level, internalformat, format, type, pixels) {
      return this.texImage2D(target, level, internalformat, format, type, pixels);
    }
    [dartx.texImage2DVideo](target, level, internalformat, format, type, video) {
      return this.texImage2D(target, level, internalformat, format, type, video);
    }
    [dartx.texParameterf](target, pname, param) {
      return this.texParameterf(target, pname, param);
    }
    [dartx.texParameteri](target, pname, param) {
      return this.texParameteri(target, pname, param);
    }
    [dartx.texSubImage2D](target, level, xoffset, yoffset, format_OR_width, height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video, type, pixels) {
      if (type === void 0) type = null;
      if (pixels === void 0) pixels = null;
      if (pixels != null && type != null && typeof canvas_OR_format_OR_image_OR_pixels_OR_video == 'number') {
        this[_texSubImage2D_1](target, level, xoffset, yoffset, format_OR_width, height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video, type, pixels);
        return;
      }
      if ((dart.is(canvas_OR_format_OR_image_OR_pixels_OR_video, html$.ImageData) || canvas_OR_format_OR_image_OR_pixels_OR_video == null) && type == null && pixels == null) {
        let pixels_1 = html_common.convertDartToNative_ImageData(dart.as(canvas_OR_format_OR_image_OR_pixels_OR_video, html$.ImageData));
        this[_texSubImage2D_2](target, level, xoffset, yoffset, format_OR_width, height_OR_type, pixels_1);
        return;
      }
      if (dart.is(canvas_OR_format_OR_image_OR_pixels_OR_video, html$.ImageElement) && type == null && pixels == null) {
        this[_texSubImage2D_3](target, level, xoffset, yoffset, format_OR_width, height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video);
        return;
      }
      if (dart.is(canvas_OR_format_OR_image_OR_pixels_OR_video, html$.CanvasElement) && type == null && pixels == null) {
        this[_texSubImage2D_4](target, level, xoffset, yoffset, format_OR_width, height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video);
        return;
      }
      if (dart.is(canvas_OR_format_OR_image_OR_pixels_OR_video, html$.VideoElement) && type == null && pixels == null) {
        this[_texSubImage2D_5](target, level, xoffset, yoffset, format_OR_width, height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video);
        return;
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    [_texSubImage2D_1](target, level, xoffset, yoffset, width, height, format, type, pixels) {
      return this.texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels);
    }
    [_texSubImage2D_2](target, level, xoffset, yoffset, format, type, pixels) {
      return this.texSubImage2D(target, level, xoffset, yoffset, format, type, pixels);
    }
    [_texSubImage2D_3](target, level, xoffset, yoffset, format, type, image) {
      return this.texSubImage2D(target, level, xoffset, yoffset, format, type, image);
    }
    [_texSubImage2D_4](target, level, xoffset, yoffset, format, type, canvas) {
      return this.texSubImage2D(target, level, xoffset, yoffset, format, type, canvas);
    }
    [_texSubImage2D_5](target, level, xoffset, yoffset, format, type, video) {
      return this.texSubImage2D(target, level, xoffset, yoffset, format, type, video);
    }
    [dartx.texSubImage2DCanvas](target, level, xoffset, yoffset, format, type, canvas) {
      return this.texSubImage2D(target, level, xoffset, yoffset, format, type, canvas);
    }
    [dartx.texSubImage2DImage](target, level, xoffset, yoffset, format, type, image) {
      return this.texSubImage2D(target, level, xoffset, yoffset, format, type, image);
    }
    [dartx.texSubImage2DImageData](target, level, xoffset, yoffset, format, type, pixels) {
      let pixels_1 = html_common.convertDartToNative_ImageData(pixels);
      this[_texSubImage2DImageData_1](target, level, xoffset, yoffset, format, type, pixels_1);
      return;
    }
    [_texSubImage2DImageData_1](target, level, xoffset, yoffset, format, type, pixels) {
      return this.texSubImage2D(target, level, xoffset, yoffset, format, type, pixels);
    }
    [dartx.texSubImage2DVideo](target, level, xoffset, yoffset, format, type, video) {
      return this.texSubImage2D(target, level, xoffset, yoffset, format, type, video);
    }
    [dartx.uniform1f](location, x) {
      return this.uniform1f(location, x);
    }
    [dartx.uniform1fv](location, v) {
      return this.uniform1fv(location, v);
    }
    [dartx.uniform1i](location, x) {
      return this.uniform1i(location, x);
    }
    [dartx.uniform1iv](location, v) {
      return this.uniform1iv(location, v);
    }
    [dartx.uniform2f](location, x, y) {
      return this.uniform2f(location, x, y);
    }
    [dartx.uniform2fv](location, v) {
      return this.uniform2fv(location, v);
    }
    [dartx.uniform2i](location, x, y) {
      return this.uniform2i(location, x, y);
    }
    [dartx.uniform2iv](location, v) {
      return this.uniform2iv(location, v);
    }
    [dartx.uniform3f](location, x, y, z) {
      return this.uniform3f(location, x, y, z);
    }
    [dartx.uniform3fv](location, v) {
      return this.uniform3fv(location, v);
    }
    [dartx.uniform3i](location, x, y, z) {
      return this.uniform3i(location, x, y, z);
    }
    [dartx.uniform3iv](location, v) {
      return this.uniform3iv(location, v);
    }
    [dartx.uniform4f](location, x, y, z, w) {
      return this.uniform4f(location, x, y, z, w);
    }
    [dartx.uniform4fv](location, v) {
      return this.uniform4fv(location, v);
    }
    [dartx.uniform4i](location, x, y, z, w) {
      return this.uniform4i(location, x, y, z, w);
    }
    [dartx.uniform4iv](location, v) {
      return this.uniform4iv(location, v);
    }
    [dartx.uniformMatrix2fv](location, transpose, array) {
      return this.uniformMatrix2fv(location, transpose, array);
    }
    [dartx.uniformMatrix3fv](location, transpose, array) {
      return this.uniformMatrix3fv(location, transpose, array);
    }
    [dartx.uniformMatrix4fv](location, transpose, array) {
      return this.uniformMatrix4fv(location, transpose, array);
    }
    [dartx.useProgram](program) {
      return this.useProgram(program);
    }
    [dartx.validateProgram](program) {
      return this.validateProgram(program);
    }
    [dartx.vertexAttrib1f](indx, x) {
      return this.vertexAttrib1f(indx, x);
    }
    [dartx.vertexAttrib1fv](indx, values) {
      return this.vertexAttrib1fv(indx, values);
    }
    [dartx.vertexAttrib2f](indx, x, y) {
      return this.vertexAttrib2f(indx, x, y);
    }
    [dartx.vertexAttrib2fv](indx, values) {
      return this.vertexAttrib2fv(indx, values);
    }
    [dartx.vertexAttrib3f](indx, x, y, z) {
      return this.vertexAttrib3f(indx, x, y, z);
    }
    [dartx.vertexAttrib3fv](indx, values) {
      return this.vertexAttrib3fv(indx, values);
    }
    [dartx.vertexAttrib4f](indx, x, y, z, w) {
      return this.vertexAttrib4f(indx, x, y, z, w);
    }
    [dartx.vertexAttrib4fv](indx, values) {
      return this.vertexAttrib4fv(indx, values);
    }
    [dartx.vertexAttribPointer](indx, size, type, normalized, stride, offset) {
      return this.vertexAttribPointer(indx, size, type, normalized, stride, offset);
    }
    [dartx.viewport](x, y, width, height) {
      return this.viewport(x, y, width, height);
    }
    [dartx.texImage2DUntyped](targetTexture, levelOfDetail, internalFormat, format, type, data) {
      return this.texImage2D(targetTexture, levelOfDetail, internalFormat, format, type, data);
    }
    [dartx.texImage2DTyped](targetTexture, levelOfDetail, internalFormat, width, height, border, format, type, data) {
      return this.texImage2D(targetTexture, levelOfDetail, internalFormat, width, height, border, format, type, data);
    }
    [dartx.texSubImage2DUntyped](targetTexture, levelOfDetail, xOffset, yOffset, format, type, data) {
      return this.texSubImage2D(targetTexture, levelOfDetail, xOffset, yOffset, format, type, data);
    }
    [dartx.texSubImage2DTyped](targetTexture, levelOfDetail, xOffset, yOffset, width, height, border, format, type, data) {
      return this.texSubImage2D(targetTexture, levelOfDetail, xOffset, yOffset, width, height, border, format, type, data);
    }
  };
  web_gl.RenderingContext[dart.implements] = () => [html$.CanvasRenderingContext];
  dart.setSignature(web_gl.RenderingContext, {
    constructors: () => ({_: [web_gl.RenderingContext, []]}),
    methods: () => ({
      [dartx.activeTexture]: [dart.void, [core.int]],
      [dartx.attachShader]: [dart.void, [web_gl.Program, web_gl.Shader]],
      [dartx.bindAttribLocation]: [dart.void, [web_gl.Program, core.int, core.String]],
      [dartx.bindBuffer]: [dart.void, [core.int, web_gl.Buffer]],
      [dartx.bindFramebuffer]: [dart.void, [core.int, web_gl.Framebuffer]],
      [dartx.bindRenderbuffer]: [dart.void, [core.int, web_gl.Renderbuffer]],
      [dartx.bindTexture]: [dart.void, [core.int, web_gl.Texture]],
      [dartx.blendColor]: [dart.void, [core.num, core.num, core.num, core.num]],
      [dartx.blendEquation]: [dart.void, [core.int]],
      [dartx.blendEquationSeparate]: [dart.void, [core.int, core.int]],
      [dartx.blendFunc]: [dart.void, [core.int, core.int]],
      [dartx.blendFuncSeparate]: [dart.void, [core.int, core.int, core.int, core.int]],
      [dartx.bufferByteData]: [dart.void, [core.int, typed_data.ByteBuffer, core.int]],
      [dartx.bufferData]: [dart.void, [core.int, dart.dynamic, core.int]],
      [dartx.bufferDataTyped]: [dart.void, [core.int, typed_data.TypedData, core.int]],
      [dartx.bufferSubByteData]: [dart.void, [core.int, core.int, typed_data.ByteBuffer]],
      [dartx.bufferSubData]: [dart.void, [core.int, core.int, dart.dynamic]],
      [dartx.bufferSubDataTyped]: [dart.void, [core.int, core.int, typed_data.TypedData]],
      [dartx.checkFramebufferStatus]: [core.int, [core.int]],
      [dartx.clear]: [dart.void, [core.int]],
      [dartx.clearColor]: [dart.void, [core.num, core.num, core.num, core.num]],
      [dartx.clearDepth]: [dart.void, [core.num]],
      [dartx.clearStencil]: [dart.void, [core.int]],
      [dartx.colorMask]: [dart.void, [core.bool, core.bool, core.bool, core.bool]],
      [dartx.compileShader]: [dart.void, [web_gl.Shader]],
      [dartx.compressedTexImage2D]: [dart.void, [core.int, core.int, core.int, core.int, core.int, core.int, typed_data.TypedData]],
      [dartx.compressedTexSubImage2D]: [dart.void, [core.int, core.int, core.int, core.int, core.int, core.int, core.int, typed_data.TypedData]],
      [dartx.copyTexImage2D]: [dart.void, [core.int, core.int, core.int, core.int, core.int, core.int, core.int, core.int]],
      [dartx.copyTexSubImage2D]: [dart.void, [core.int, core.int, core.int, core.int, core.int, core.int, core.int, core.int]],
      [dartx.createBuffer]: [web_gl.Buffer, []],
      [dartx.createFramebuffer]: [web_gl.Framebuffer, []],
      [dartx.createProgram]: [web_gl.Program, []],
      [dartx.createRenderbuffer]: [web_gl.Renderbuffer, []],
      [dartx.createShader]: [web_gl.Shader, [core.int]],
      [dartx.createTexture]: [web_gl.Texture, []],
      [dartx.cullFace]: [dart.void, [core.int]],
      [dartx.deleteBuffer]: [dart.void, [web_gl.Buffer]],
      [dartx.deleteFramebuffer]: [dart.void, [web_gl.Framebuffer]],
      [dartx.deleteProgram]: [dart.void, [web_gl.Program]],
      [dartx.deleteRenderbuffer]: [dart.void, [web_gl.Renderbuffer]],
      [dartx.deleteShader]: [dart.void, [web_gl.Shader]],
      [dartx.deleteTexture]: [dart.void, [web_gl.Texture]],
      [dartx.depthFunc]: [dart.void, [core.int]],
      [dartx.depthMask]: [dart.void, [core.bool]],
      [dartx.depthRange]: [dart.void, [core.num, core.num]],
      [dartx.detachShader]: [dart.void, [web_gl.Program, web_gl.Shader]],
      [dartx.disable]: [dart.void, [core.int]],
      [dartx.disableVertexAttribArray]: [dart.void, [core.int]],
      [dartx.drawArrays]: [dart.void, [core.int, core.int, core.int]],
      [dartx.drawElements]: [dart.void, [core.int, core.int, core.int, core.int]],
      [dartx.enable]: [dart.void, [core.int]],
      [dartx.enableVertexAttribArray]: [dart.void, [core.int]],
      [dartx.finish]: [dart.void, []],
      [dartx.flush]: [dart.void, []],
      [dartx.framebufferRenderbuffer]: [dart.void, [core.int, core.int, core.int, web_gl.Renderbuffer]],
      [dartx.framebufferTexture2D]: [dart.void, [core.int, core.int, core.int, web_gl.Texture, core.int]],
      [dartx.frontFace]: [dart.void, [core.int]],
      [dartx.generateMipmap]: [dart.void, [core.int]],
      [dartx.getActiveAttrib]: [web_gl.ActiveInfo, [web_gl.Program, core.int]],
      [dartx.getActiveUniform]: [web_gl.ActiveInfo, [web_gl.Program, core.int]],
      [dartx.getAttachedShaders]: [core.List$(web_gl.Shader), [web_gl.Program]],
      [dartx.getAttribLocation]: [core.int, [web_gl.Program, core.String]],
      [dartx.getBufferParameter]: [core.Object, [core.int, core.int]],
      [dartx.getContextAttributes]: [web_gl.ContextAttributes, []],
      [_getContextAttributes_1$]: [dart.dynamic, []],
      [dartx.getError]: [core.int, []],
      [dartx.getExtension]: [core.Object, [core.String]],
      [dartx.getFramebufferAttachmentParameter]: [core.Object, [core.int, core.int, core.int]],
      [dartx.getParameter]: [core.Object, [core.int]],
      [dartx.getProgramInfoLog]: [core.String, [web_gl.Program]],
      [dartx.getProgramParameter]: [core.Object, [web_gl.Program, core.int]],
      [dartx.getRenderbufferParameter]: [core.Object, [core.int, core.int]],
      [dartx.getShaderInfoLog]: [core.String, [web_gl.Shader]],
      [dartx.getShaderParameter]: [core.Object, [web_gl.Shader, core.int]],
      [dartx.getShaderPrecisionFormat]: [web_gl.ShaderPrecisionFormat, [core.int, core.int]],
      [dartx.getShaderSource]: [core.String, [web_gl.Shader]],
      [dartx.getSupportedExtensions]: [core.List$(core.String), []],
      [dartx.getTexParameter]: [core.Object, [core.int, core.int]],
      [dartx.getUniform]: [core.Object, [web_gl.Program, web_gl.UniformLocation]],
      [dartx.getUniformLocation]: [web_gl.UniformLocation, [web_gl.Program, core.String]],
      [dartx.getVertexAttrib]: [core.Object, [core.int, core.int]],
      [dartx.getVertexAttribOffset]: [core.int, [core.int, core.int]],
      [dartx.hint]: [dart.void, [core.int, core.int]],
      [dartx.isBuffer]: [core.bool, [web_gl.Buffer]],
      [dartx.isContextLost]: [core.bool, []],
      [dartx.isEnabled]: [core.bool, [core.int]],
      [dartx.isFramebuffer]: [core.bool, [web_gl.Framebuffer]],
      [dartx.isProgram]: [core.bool, [web_gl.Program]],
      [dartx.isRenderbuffer]: [core.bool, [web_gl.Renderbuffer]],
      [dartx.isShader]: [core.bool, [web_gl.Shader]],
      [dartx.isTexture]: [core.bool, [web_gl.Texture]],
      [dartx.lineWidth]: [dart.void, [core.num]],
      [dartx.linkProgram]: [dart.void, [web_gl.Program]],
      [dartx.pixelStorei]: [dart.void, [core.int, core.int]],
      [dartx.polygonOffset]: [dart.void, [core.num, core.num]],
      [dartx.readPixels]: [dart.void, [core.int, core.int, core.int, core.int, core.int, core.int, typed_data.TypedData]],
      [dartx.renderbufferStorage]: [dart.void, [core.int, core.int, core.int, core.int]],
      [dartx.sampleCoverage]: [dart.void, [core.num, core.bool]],
      [dartx.scissor]: [dart.void, [core.int, core.int, core.int, core.int]],
      [dartx.shaderSource]: [dart.void, [web_gl.Shader, core.String]],
      [dartx.stencilFunc]: [dart.void, [core.int, core.int, core.int]],
      [dartx.stencilFuncSeparate]: [dart.void, [core.int, core.int, core.int, core.int]],
      [dartx.stencilMask]: [dart.void, [core.int]],
      [dartx.stencilMaskSeparate]: [dart.void, [core.int, core.int]],
      [dartx.stencilOp]: [dart.void, [core.int, core.int, core.int]],
      [dartx.stencilOpSeparate]: [dart.void, [core.int, core.int, core.int, core.int]],
      [dartx.texImage2D]: [dart.void, [core.int, core.int, core.int, core.int, core.int, dart.dynamic], [core.int, core.int, typed_data.TypedData]],
      [_texImage2D_1]: [dart.void, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, core.int, dart.dynamic, dart.dynamic, typed_data.TypedData]],
      [_texImage2D_2]: [dart.void, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]],
      [_texImage2D_3]: [dart.void, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, html$.ImageElement]],
      [_texImage2D_4]: [dart.void, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, html$.CanvasElement]],
      [_texImage2D_5]: [dart.void, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, html$.VideoElement]],
      [dartx.texImage2DCanvas]: [dart.void, [core.int, core.int, core.int, core.int, core.int, html$.CanvasElement]],
      [dartx.texImage2DImage]: [dart.void, [core.int, core.int, core.int, core.int, core.int, html$.ImageElement]],
      [dartx.texImage2DImageData]: [dart.void, [core.int, core.int, core.int, core.int, core.int, html$.ImageData]],
      [_texImage2DImageData_1]: [dart.void, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]],
      [dartx.texImage2DVideo]: [dart.void, [core.int, core.int, core.int, core.int, core.int, html$.VideoElement]],
      [dartx.texParameterf]: [dart.void, [core.int, core.int, core.num]],
      [dartx.texParameteri]: [dart.void, [core.int, core.int, core.int]],
      [dartx.texSubImage2D]: [dart.void, [core.int, core.int, core.int, core.int, core.int, core.int, dart.dynamic], [core.int, typed_data.TypedData]],
      [_texSubImage2D_1]: [dart.void, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, core.int, dart.dynamic, typed_data.TypedData]],
      [_texSubImage2D_2]: [dart.void, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]],
      [_texSubImage2D_3]: [dart.void, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, html$.ImageElement]],
      [_texSubImage2D_4]: [dart.void, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, html$.CanvasElement]],
      [_texSubImage2D_5]: [dart.void, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, html$.VideoElement]],
      [dartx.texSubImage2DCanvas]: [dart.void, [core.int, core.int, core.int, core.int, core.int, core.int, html$.CanvasElement]],
      [dartx.texSubImage2DImage]: [dart.void, [core.int, core.int, core.int, core.int, core.int, core.int, html$.ImageElement]],
      [dartx.texSubImage2DImageData]: [dart.void, [core.int, core.int, core.int, core.int, core.int, core.int, html$.ImageData]],
      [_texSubImage2DImageData_1]: [dart.void, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]],
      [dartx.texSubImage2DVideo]: [dart.void, [core.int, core.int, core.int, core.int, core.int, core.int, html$.VideoElement]],
      [dartx.uniform1f]: [dart.void, [web_gl.UniformLocation, core.num]],
      [dartx.uniform1fv]: [dart.void, [web_gl.UniformLocation, typed_data.Float32List]],
      [dartx.uniform1i]: [dart.void, [web_gl.UniformLocation, core.int]],
      [dartx.uniform1iv]: [dart.void, [web_gl.UniformLocation, typed_data.Int32List]],
      [dartx.uniform2f]: [dart.void, [web_gl.UniformLocation, core.num, core.num]],
      [dartx.uniform2fv]: [dart.void, [web_gl.UniformLocation, typed_data.Float32List]],
      [dartx.uniform2i]: [dart.void, [web_gl.UniformLocation, core.int, core.int]],
      [dartx.uniform2iv]: [dart.void, [web_gl.UniformLocation, typed_data.Int32List]],
      [dartx.uniform3f]: [dart.void, [web_gl.UniformLocation, core.num, core.num, core.num]],
      [dartx.uniform3fv]: [dart.void, [web_gl.UniformLocation, typed_data.Float32List]],
      [dartx.uniform3i]: [dart.void, [web_gl.UniformLocation, core.int, core.int, core.int]],
      [dartx.uniform3iv]: [dart.void, [web_gl.UniformLocation, typed_data.Int32List]],
      [dartx.uniform4f]: [dart.void, [web_gl.UniformLocation, core.num, core.num, core.num, core.num]],
      [dartx.uniform4fv]: [dart.void, [web_gl.UniformLocation, typed_data.Float32List]],
      [dartx.uniform4i]: [dart.void, [web_gl.UniformLocation, core.int, core.int, core.int, core.int]],
      [dartx.uniform4iv]: [dart.void, [web_gl.UniformLocation, typed_data.Int32List]],
      [dartx.uniformMatrix2fv]: [dart.void, [web_gl.UniformLocation, core.bool, typed_data.Float32List]],
      [dartx.uniformMatrix3fv]: [dart.void, [web_gl.UniformLocation, core.bool, typed_data.Float32List]],
      [dartx.uniformMatrix4fv]: [dart.void, [web_gl.UniformLocation, core.bool, typed_data.Float32List]],
      [dartx.useProgram]: [dart.void, [web_gl.Program]],
      [dartx.validateProgram]: [dart.void, [web_gl.Program]],
      [dartx.vertexAttrib1f]: [dart.void, [core.int, core.num]],
      [dartx.vertexAttrib1fv]: [dart.void, [core.int, typed_data.Float32List]],
      [dartx.vertexAttrib2f]: [dart.void, [core.int, core.num, core.num]],
      [dartx.vertexAttrib2fv]: [dart.void, [core.int, typed_data.Float32List]],
      [dartx.vertexAttrib3f]: [dart.void, [core.int, core.num, core.num, core.num]],
      [dartx.vertexAttrib3fv]: [dart.void, [core.int, typed_data.Float32List]],
      [dartx.vertexAttrib4f]: [dart.void, [core.int, core.num, core.num, core.num, core.num]],
      [dartx.vertexAttrib4fv]: [dart.void, [core.int, typed_data.Float32List]],
      [dartx.vertexAttribPointer]: [dart.void, [core.int, core.int, core.int, core.bool, core.int, core.int]],
      [dartx.viewport]: [dart.void, [core.int, core.int, core.int, core.int]],
      [dartx.texImage2DUntyped]: [dart.void, [core.int, core.int, core.int, core.int, core.int, dart.dynamic]],
      [dartx.texImage2DTyped]: [dart.void, [core.int, core.int, core.int, core.int, core.int, core.int, core.int, core.int, typed_data.TypedData]],
      [dartx.texSubImage2DUntyped]: [dart.void, [core.int, core.int, core.int, core.int, core.int, core.int, dart.dynamic]],
      [dartx.texSubImage2DTyped]: [dart.void, [core.int, core.int, core.int, core.int, core.int, core.int, core.int, core.int, core.int, typed_data.TypedData]]
    })
  });
  web_gl.RenderingContext[dart.metadata] = () => [dart.const(new _metadata.DomName('WebGLRenderingContext')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.Experimental()), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("WebGLRenderingContext"))];
  web_gl.RenderingContext.ACTIVE_ATTRIBUTES = 35721;
  web_gl.RenderingContext.ACTIVE_TEXTURE = 34016;
  web_gl.RenderingContext.ACTIVE_UNIFORMS = 35718;
  web_gl.RenderingContext.ALIASED_LINE_WIDTH_RANGE = 33902;
  web_gl.RenderingContext.ALIASED_POINT_SIZE_RANGE = 33901;
  web_gl.RenderingContext.ALPHA = 6406;
  web_gl.RenderingContext.ALPHA_BITS = 3413;
  web_gl.RenderingContext.ALWAYS = 519;
  web_gl.RenderingContext.ARRAY_BUFFER = 34962;
  web_gl.RenderingContext.ARRAY_BUFFER_BINDING = 34964;
  web_gl.RenderingContext.ATTACHED_SHADERS = 35717;
  web_gl.RenderingContext.BACK = 1029;
  web_gl.RenderingContext.BLEND = 3042;
  web_gl.RenderingContext.BLEND_COLOR = 32773;
  web_gl.RenderingContext.BLEND_DST_ALPHA = 32970;
  web_gl.RenderingContext.BLEND_DST_RGB = 32968;
  web_gl.RenderingContext.BLEND_EQUATION = 32777;
  web_gl.RenderingContext.BLEND_EQUATION_ALPHA = 34877;
  web_gl.RenderingContext.BLEND_EQUATION_RGB = 32777;
  web_gl.RenderingContext.BLEND_SRC_ALPHA = 32971;
  web_gl.RenderingContext.BLEND_SRC_RGB = 32969;
  web_gl.RenderingContext.BLUE_BITS = 3412;
  web_gl.RenderingContext.BOOL = 35670;
  web_gl.RenderingContext.BOOL_VEC2 = 35671;
  web_gl.RenderingContext.BOOL_VEC3 = 35672;
  web_gl.RenderingContext.BOOL_VEC4 = 35673;
  web_gl.RenderingContext.BROWSER_DEFAULT_WEBGL = 37444;
  web_gl.RenderingContext.BUFFER_SIZE = 34660;
  web_gl.RenderingContext.BUFFER_USAGE = 34661;
  web_gl.RenderingContext.BYTE = 5120;
  web_gl.RenderingContext.CCW = 2305;
  web_gl.RenderingContext.CLAMP_TO_EDGE = 33071;
  web_gl.RenderingContext.COLOR_ATTACHMENT0 = 36064;
  web_gl.RenderingContext.COLOR_BUFFER_BIT = 16384;
  web_gl.RenderingContext.COLOR_CLEAR_VALUE = 3106;
  web_gl.RenderingContext.COLOR_WRITEMASK = 3107;
  web_gl.RenderingContext.COMPILE_STATUS = 35713;
  web_gl.RenderingContext.COMPRESSED_TEXTURE_FORMATS = 34467;
  web_gl.RenderingContext.CONSTANT_ALPHA = 32771;
  web_gl.RenderingContext.CONSTANT_COLOR = 32769;
  web_gl.RenderingContext.CONTEXT_LOST_WEBGL = 37442;
  web_gl.RenderingContext.CULL_FACE = 2884;
  web_gl.RenderingContext.CULL_FACE_MODE = 2885;
  web_gl.RenderingContext.CURRENT_PROGRAM = 35725;
  web_gl.RenderingContext.CURRENT_VERTEX_ATTRIB = 34342;
  web_gl.RenderingContext.CW = 2304;
  web_gl.RenderingContext.DECR = 7683;
  web_gl.RenderingContext.DECR_WRAP = 34056;
  web_gl.RenderingContext.DELETE_STATUS = 35712;
  web_gl.RenderingContext.DEPTH_ATTACHMENT = 36096;
  web_gl.RenderingContext.DEPTH_BITS = 3414;
  web_gl.RenderingContext.DEPTH_BUFFER_BIT = 256;
  web_gl.RenderingContext.DEPTH_CLEAR_VALUE = 2931;
  web_gl.RenderingContext.DEPTH_COMPONENT = 6402;
  web_gl.RenderingContext.DEPTH_COMPONENT16 = 33189;
  web_gl.RenderingContext.DEPTH_FUNC = 2932;
  web_gl.RenderingContext.DEPTH_RANGE = 2928;
  web_gl.RenderingContext.DEPTH_STENCIL = 34041;
  web_gl.RenderingContext.DEPTH_STENCIL_ATTACHMENT = 33306;
  web_gl.RenderingContext.DEPTH_TEST = 2929;
  web_gl.RenderingContext.DEPTH_WRITEMASK = 2930;
  web_gl.RenderingContext.DITHER = 3024;
  web_gl.RenderingContext.DONT_CARE = 4352;
  web_gl.RenderingContext.DST_ALPHA = 772;
  web_gl.RenderingContext.DST_COLOR = 774;
  web_gl.RenderingContext.DYNAMIC_DRAW = 35048;
  web_gl.RenderingContext.ELEMENT_ARRAY_BUFFER = 34963;
  web_gl.RenderingContext.ELEMENT_ARRAY_BUFFER_BINDING = 34965;
  web_gl.RenderingContext.EQUAL = 514;
  web_gl.RenderingContext.FASTEST = 4353;
  web_gl.RenderingContext.FLOAT = 5126;
  web_gl.RenderingContext.FLOAT_MAT2 = 35674;
  web_gl.RenderingContext.FLOAT_MAT3 = 35675;
  web_gl.RenderingContext.FLOAT_MAT4 = 35676;
  web_gl.RenderingContext.FLOAT_VEC2 = 35664;
  web_gl.RenderingContext.FLOAT_VEC3 = 35665;
  web_gl.RenderingContext.FLOAT_VEC4 = 35666;
  web_gl.RenderingContext.FRAGMENT_SHADER = 35632;
  web_gl.RenderingContext.FRAMEBUFFER = 36160;
  web_gl.RenderingContext.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 36049;
  web_gl.RenderingContext.FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 36048;
  web_gl.RenderingContext.FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 36051;
  web_gl.RenderingContext.FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 36050;
  web_gl.RenderingContext.FRAMEBUFFER_BINDING = 36006;
  web_gl.RenderingContext.FRAMEBUFFER_COMPLETE = 36053;
  web_gl.RenderingContext.FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 36054;
  web_gl.RenderingContext.FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 36057;
  web_gl.RenderingContext.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 36055;
  web_gl.RenderingContext.FRAMEBUFFER_UNSUPPORTED = 36061;
  web_gl.RenderingContext.FRONT = 1028;
  web_gl.RenderingContext.FRONT_AND_BACK = 1032;
  web_gl.RenderingContext.FRONT_FACE = 2886;
  web_gl.RenderingContext.FUNC_ADD = 32774;
  web_gl.RenderingContext.FUNC_REVERSE_SUBTRACT = 32779;
  web_gl.RenderingContext.FUNC_SUBTRACT = 32778;
  web_gl.RenderingContext.GENERATE_MIPMAP_HINT = 33170;
  web_gl.RenderingContext.GEQUAL = 518;
  web_gl.RenderingContext.GREATER = 516;
  web_gl.RenderingContext.GREEN_BITS = 3411;
  web_gl.RenderingContext.HIGH_FLOAT = 36338;
  web_gl.RenderingContext.HIGH_INT = 36341;
  web_gl.RenderingContext.IMPLEMENTATION_COLOR_READ_FORMAT = 35739;
  web_gl.RenderingContext.IMPLEMENTATION_COLOR_READ_TYPE = 35738;
  web_gl.RenderingContext.INCR = 7682;
  web_gl.RenderingContext.INCR_WRAP = 34055;
  web_gl.RenderingContext.INT = 5124;
  web_gl.RenderingContext.INT_VEC2 = 35667;
  web_gl.RenderingContext.INT_VEC3 = 35668;
  web_gl.RenderingContext.INT_VEC4 = 35669;
  web_gl.RenderingContext.INVALID_ENUM = 1280;
  web_gl.RenderingContext.INVALID_FRAMEBUFFER_OPERATION = 1286;
  web_gl.RenderingContext.INVALID_OPERATION = 1282;
  web_gl.RenderingContext.INVALID_VALUE = 1281;
  web_gl.RenderingContext.INVERT = 5386;
  web_gl.RenderingContext.KEEP = 7680;
  web_gl.RenderingContext.LEQUAL = 515;
  web_gl.RenderingContext.LESS = 513;
  web_gl.RenderingContext.LINEAR = 9729;
  web_gl.RenderingContext.LINEAR_MIPMAP_LINEAR = 9987;
  web_gl.RenderingContext.LINEAR_MIPMAP_NEAREST = 9985;
  web_gl.RenderingContext.LINES = 1;
  web_gl.RenderingContext.LINE_LOOP = 2;
  web_gl.RenderingContext.LINE_STRIP = 3;
  web_gl.RenderingContext.LINE_WIDTH = 2849;
  web_gl.RenderingContext.LINK_STATUS = 35714;
  web_gl.RenderingContext.LOW_FLOAT = 36336;
  web_gl.RenderingContext.LOW_INT = 36339;
  web_gl.RenderingContext.LUMINANCE = 6409;
  web_gl.RenderingContext.LUMINANCE_ALPHA = 6410;
  web_gl.RenderingContext.MAX_COMBINED_TEXTURE_IMAGE_UNITS = 35661;
  web_gl.RenderingContext.MAX_CUBE_MAP_TEXTURE_SIZE = 34076;
  web_gl.RenderingContext.MAX_FRAGMENT_UNIFORM_VECTORS = 36349;
  web_gl.RenderingContext.MAX_RENDERBUFFER_SIZE = 34024;
  web_gl.RenderingContext.MAX_TEXTURE_IMAGE_UNITS = 34930;
  web_gl.RenderingContext.MAX_TEXTURE_SIZE = 3379;
  web_gl.RenderingContext.MAX_VARYING_VECTORS = 36348;
  web_gl.RenderingContext.MAX_VERTEX_ATTRIBS = 34921;
  web_gl.RenderingContext.MAX_VERTEX_TEXTURE_IMAGE_UNITS = 35660;
  web_gl.RenderingContext.MAX_VERTEX_UNIFORM_VECTORS = 36347;
  web_gl.RenderingContext.MAX_VIEWPORT_DIMS = 3386;
  web_gl.RenderingContext.MEDIUM_FLOAT = 36337;
  web_gl.RenderingContext.MEDIUM_INT = 36340;
  web_gl.RenderingContext.MIRRORED_REPEAT = 33648;
  web_gl.RenderingContext.NEAREST = 9728;
  web_gl.RenderingContext.NEAREST_MIPMAP_LINEAR = 9986;
  web_gl.RenderingContext.NEAREST_MIPMAP_NEAREST = 9984;
  web_gl.RenderingContext.NEVER = 512;
  web_gl.RenderingContext.NICEST = 4354;
  web_gl.RenderingContext.NONE = 0;
  web_gl.RenderingContext.NOTEQUAL = 517;
  web_gl.RenderingContext.NO_ERROR = 0;
  web_gl.RenderingContext.ONE = 1;
  web_gl.RenderingContext.ONE_MINUS_CONSTANT_ALPHA = 32772;
  web_gl.RenderingContext.ONE_MINUS_CONSTANT_COLOR = 32770;
  web_gl.RenderingContext.ONE_MINUS_DST_ALPHA = 773;
  web_gl.RenderingContext.ONE_MINUS_DST_COLOR = 775;
  web_gl.RenderingContext.ONE_MINUS_SRC_ALPHA = 771;
  web_gl.RenderingContext.ONE_MINUS_SRC_COLOR = 769;
  web_gl.RenderingContext.OUT_OF_MEMORY = 1285;
  web_gl.RenderingContext.PACK_ALIGNMENT = 3333;
  web_gl.RenderingContext.POINTS = 0;
  web_gl.RenderingContext.POLYGON_OFFSET_FACTOR = 32824;
  web_gl.RenderingContext.POLYGON_OFFSET_FILL = 32823;
  web_gl.RenderingContext.POLYGON_OFFSET_UNITS = 10752;
  web_gl.RenderingContext.RED_BITS = 3410;
  web_gl.RenderingContext.RENDERBUFFER = 36161;
  web_gl.RenderingContext.RENDERBUFFER_ALPHA_SIZE = 36179;
  web_gl.RenderingContext.RENDERBUFFER_BINDING = 36007;
  web_gl.RenderingContext.RENDERBUFFER_BLUE_SIZE = 36178;
  web_gl.RenderingContext.RENDERBUFFER_DEPTH_SIZE = 36180;
  web_gl.RenderingContext.RENDERBUFFER_GREEN_SIZE = 36177;
  web_gl.RenderingContext.RENDERBUFFER_HEIGHT = 36163;
  web_gl.RenderingContext.RENDERBUFFER_INTERNAL_FORMAT = 36164;
  web_gl.RenderingContext.RENDERBUFFER_RED_SIZE = 36176;
  web_gl.RenderingContext.RENDERBUFFER_STENCIL_SIZE = 36181;
  web_gl.RenderingContext.RENDERBUFFER_WIDTH = 36162;
  web_gl.RenderingContext.RENDERER = 7937;
  web_gl.RenderingContext.REPEAT = 10497;
  web_gl.RenderingContext.REPLACE = 7681;
  web_gl.RenderingContext.RGB = 6407;
  web_gl.RenderingContext.RGB565 = 36194;
  web_gl.RenderingContext.RGB5_A1 = 32855;
  web_gl.RenderingContext.RGBA = 6408;
  web_gl.RenderingContext.RGBA4 = 32854;
  web_gl.RenderingContext.SAMPLER_2D = 35678;
  web_gl.RenderingContext.SAMPLER_CUBE = 35680;
  web_gl.RenderingContext.SAMPLES = 32937;
  web_gl.RenderingContext.SAMPLE_ALPHA_TO_COVERAGE = 32926;
  web_gl.RenderingContext.SAMPLE_BUFFERS = 32936;
  web_gl.RenderingContext.SAMPLE_COVERAGE = 32928;
  web_gl.RenderingContext.SAMPLE_COVERAGE_INVERT = 32939;
  web_gl.RenderingContext.SAMPLE_COVERAGE_VALUE = 32938;
  web_gl.RenderingContext.SCISSOR_BOX = 3088;
  web_gl.RenderingContext.SCISSOR_TEST = 3089;
  web_gl.RenderingContext.SHADER_TYPE = 35663;
  web_gl.RenderingContext.SHADING_LANGUAGE_VERSION = 35724;
  web_gl.RenderingContext.SHORT = 5122;
  web_gl.RenderingContext.SRC_ALPHA = 770;
  web_gl.RenderingContext.SRC_ALPHA_SATURATE = 776;
  web_gl.RenderingContext.SRC_COLOR = 768;
  web_gl.RenderingContext.STATIC_DRAW = 35044;
  web_gl.RenderingContext.STENCIL_ATTACHMENT = 36128;
  web_gl.RenderingContext.STENCIL_BACK_FAIL = 34817;
  web_gl.RenderingContext.STENCIL_BACK_FUNC = 34816;
  web_gl.RenderingContext.STENCIL_BACK_PASS_DEPTH_FAIL = 34818;
  web_gl.RenderingContext.STENCIL_BACK_PASS_DEPTH_PASS = 34819;
  web_gl.RenderingContext.STENCIL_BACK_REF = 36003;
  web_gl.RenderingContext.STENCIL_BACK_VALUE_MASK = 36004;
  web_gl.RenderingContext.STENCIL_BACK_WRITEMASK = 36005;
  web_gl.RenderingContext.STENCIL_BITS = 3415;
  web_gl.RenderingContext.STENCIL_BUFFER_BIT = 1024;
  web_gl.RenderingContext.STENCIL_CLEAR_VALUE = 2961;
  web_gl.RenderingContext.STENCIL_FAIL = 2964;
  web_gl.RenderingContext.STENCIL_FUNC = 2962;
  web_gl.RenderingContext.STENCIL_INDEX = 6401;
  web_gl.RenderingContext.STENCIL_INDEX8 = 36168;
  web_gl.RenderingContext.STENCIL_PASS_DEPTH_FAIL = 2965;
  web_gl.RenderingContext.STENCIL_PASS_DEPTH_PASS = 2966;
  web_gl.RenderingContext.STENCIL_REF = 2967;
  web_gl.RenderingContext.STENCIL_TEST = 2960;
  web_gl.RenderingContext.STENCIL_VALUE_MASK = 2963;
  web_gl.RenderingContext.STENCIL_WRITEMASK = 2968;
  web_gl.RenderingContext.STREAM_DRAW = 35040;
  web_gl.RenderingContext.SUBPIXEL_BITS = 3408;
  web_gl.RenderingContext.TEXTURE = 5890;
  web_gl.RenderingContext.TEXTURE0 = 33984;
  web_gl.RenderingContext.TEXTURE1 = 33985;
  web_gl.RenderingContext.TEXTURE10 = 33994;
  web_gl.RenderingContext.TEXTURE11 = 33995;
  web_gl.RenderingContext.TEXTURE12 = 33996;
  web_gl.RenderingContext.TEXTURE13 = 33997;
  web_gl.RenderingContext.TEXTURE14 = 33998;
  web_gl.RenderingContext.TEXTURE15 = 33999;
  web_gl.RenderingContext.TEXTURE16 = 34000;
  web_gl.RenderingContext.TEXTURE17 = 34001;
  web_gl.RenderingContext.TEXTURE18 = 34002;
  web_gl.RenderingContext.TEXTURE19 = 34003;
  web_gl.RenderingContext.TEXTURE2 = 33986;
  web_gl.RenderingContext.TEXTURE20 = 34004;
  web_gl.RenderingContext.TEXTURE21 = 34005;
  web_gl.RenderingContext.TEXTURE22 = 34006;
  web_gl.RenderingContext.TEXTURE23 = 34007;
  web_gl.RenderingContext.TEXTURE24 = 34008;
  web_gl.RenderingContext.TEXTURE25 = 34009;
  web_gl.RenderingContext.TEXTURE26 = 34010;
  web_gl.RenderingContext.TEXTURE27 = 34011;
  web_gl.RenderingContext.TEXTURE28 = 34012;
  web_gl.RenderingContext.TEXTURE29 = 34013;
  web_gl.RenderingContext.TEXTURE3 = 33987;
  web_gl.RenderingContext.TEXTURE30 = 34014;
  web_gl.RenderingContext.TEXTURE31 = 34015;
  web_gl.RenderingContext.TEXTURE4 = 33988;
  web_gl.RenderingContext.TEXTURE5 = 33989;
  web_gl.RenderingContext.TEXTURE6 = 33990;
  web_gl.RenderingContext.TEXTURE7 = 33991;
  web_gl.RenderingContext.TEXTURE8 = 33992;
  web_gl.RenderingContext.TEXTURE9 = 33993;
  web_gl.RenderingContext.TEXTURE_2D = 3553;
  web_gl.RenderingContext.TEXTURE_BINDING_2D = 32873;
  web_gl.RenderingContext.TEXTURE_BINDING_CUBE_MAP = 34068;
  web_gl.RenderingContext.TEXTURE_CUBE_MAP = 34067;
  web_gl.RenderingContext.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070;
  web_gl.RenderingContext.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072;
  web_gl.RenderingContext.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074;
  web_gl.RenderingContext.TEXTURE_CUBE_MAP_POSITIVE_X = 34069;
  web_gl.RenderingContext.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071;
  web_gl.RenderingContext.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073;
  web_gl.RenderingContext.TEXTURE_MAG_FILTER = 10240;
  web_gl.RenderingContext.TEXTURE_MIN_FILTER = 10241;
  web_gl.RenderingContext.TEXTURE_WRAP_S = 10242;
  web_gl.RenderingContext.TEXTURE_WRAP_T = 10243;
  web_gl.RenderingContext.TRIANGLES = 4;
  web_gl.RenderingContext.TRIANGLE_FAN = 6;
  web_gl.RenderingContext.TRIANGLE_STRIP = 5;
  web_gl.RenderingContext.UNPACK_ALIGNMENT = 3317;
  web_gl.RenderingContext.UNPACK_COLORSPACE_CONVERSION_WEBGL = 37443;
  web_gl.RenderingContext.UNPACK_FLIP_Y_WEBGL = 37440;
  web_gl.RenderingContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL = 37441;
  web_gl.RenderingContext.UNSIGNED_BYTE = 5121;
  web_gl.RenderingContext.UNSIGNED_INT = 5125;
  web_gl.RenderingContext.UNSIGNED_SHORT = 5123;
  web_gl.RenderingContext.UNSIGNED_SHORT_4_4_4_4 = 32819;
  web_gl.RenderingContext.UNSIGNED_SHORT_5_5_5_1 = 32820;
  web_gl.RenderingContext.UNSIGNED_SHORT_5_6_5 = 33635;
  web_gl.RenderingContext.VALIDATE_STATUS = 35715;
  web_gl.RenderingContext.VENDOR = 7936;
  web_gl.RenderingContext.VERSION = 7938;
  web_gl.RenderingContext.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 34975;
  web_gl.RenderingContext.VERTEX_ATTRIB_ARRAY_ENABLED = 34338;
  web_gl.RenderingContext.VERTEX_ATTRIB_ARRAY_NORMALIZED = 34922;
  web_gl.RenderingContext.VERTEX_ATTRIB_ARRAY_POINTER = 34373;
  web_gl.RenderingContext.VERTEX_ATTRIB_ARRAY_SIZE = 34339;
  web_gl.RenderingContext.VERTEX_ATTRIB_ARRAY_STRIDE = 34340;
  web_gl.RenderingContext.VERTEX_ATTRIB_ARRAY_TYPE = 34341;
  web_gl.RenderingContext.VERTEX_SHADER = 35633;
  web_gl.RenderingContext.VIEWPORT = 2978;
  web_gl.RenderingContext.ZERO = 0;
  dart.registerExtension(dart.global.WebGLRenderingContext, web_gl.RenderingContext);
  web_gl.ACTIVE_ATTRIBUTES = web_gl.RenderingContext.ACTIVE_ATTRIBUTES;
  web_gl.ACTIVE_TEXTURE = web_gl.RenderingContext.ACTIVE_TEXTURE;
  web_gl.ACTIVE_UNIFORMS = web_gl.RenderingContext.ACTIVE_UNIFORMS;
  web_gl.ALIASED_LINE_WIDTH_RANGE = web_gl.RenderingContext.ALIASED_LINE_WIDTH_RANGE;
  web_gl.ALIASED_POINT_SIZE_RANGE = web_gl.RenderingContext.ALIASED_POINT_SIZE_RANGE;
  web_gl.ALPHA = web_gl.RenderingContext.ALPHA;
  web_gl.ALPHA_BITS = web_gl.RenderingContext.ALPHA_BITS;
  web_gl.ALWAYS = web_gl.RenderingContext.ALWAYS;
  web_gl.ARRAY_BUFFER = web_gl.RenderingContext.ARRAY_BUFFER;
  web_gl.ARRAY_BUFFER_BINDING = web_gl.RenderingContext.ARRAY_BUFFER_BINDING;
  web_gl.ATTACHED_SHADERS = web_gl.RenderingContext.ATTACHED_SHADERS;
  web_gl.BACK = web_gl.RenderingContext.BACK;
  web_gl.BLEND = web_gl.RenderingContext.BLEND;
  web_gl.BLEND_COLOR = web_gl.RenderingContext.BLEND_COLOR;
  web_gl.BLEND_DST_ALPHA = web_gl.RenderingContext.BLEND_DST_ALPHA;
  web_gl.BLEND_DST_RGB = web_gl.RenderingContext.BLEND_DST_RGB;
  web_gl.BLEND_EQUATION = web_gl.RenderingContext.BLEND_EQUATION;
  web_gl.BLEND_EQUATION_ALPHA = web_gl.RenderingContext.BLEND_EQUATION_ALPHA;
  web_gl.BLEND_EQUATION_RGB = web_gl.RenderingContext.BLEND_EQUATION_RGB;
  web_gl.BLEND_SRC_ALPHA = web_gl.RenderingContext.BLEND_SRC_ALPHA;
  web_gl.BLEND_SRC_RGB = web_gl.RenderingContext.BLEND_SRC_RGB;
  web_gl.BLUE_BITS = web_gl.RenderingContext.BLUE_BITS;
  web_gl.BOOL = web_gl.RenderingContext.BOOL;
  web_gl.BOOL_VEC2 = web_gl.RenderingContext.BOOL_VEC2;
  web_gl.BOOL_VEC3 = web_gl.RenderingContext.BOOL_VEC3;
  web_gl.BOOL_VEC4 = web_gl.RenderingContext.BOOL_VEC4;
  web_gl.BROWSER_DEFAULT_WEBGL = web_gl.RenderingContext.BROWSER_DEFAULT_WEBGL;
  web_gl.BUFFER_SIZE = web_gl.RenderingContext.BUFFER_SIZE;
  web_gl.BUFFER_USAGE = web_gl.RenderingContext.BUFFER_USAGE;
  web_gl.BYTE = web_gl.RenderingContext.BYTE;
  web_gl.CCW = web_gl.RenderingContext.CCW;
  web_gl.CLAMP_TO_EDGE = web_gl.RenderingContext.CLAMP_TO_EDGE;
  web_gl.COLOR_ATTACHMENT0 = web_gl.RenderingContext.COLOR_ATTACHMENT0;
  web_gl.COLOR_BUFFER_BIT = web_gl.RenderingContext.COLOR_BUFFER_BIT;
  web_gl.COLOR_CLEAR_VALUE = web_gl.RenderingContext.COLOR_CLEAR_VALUE;
  web_gl.COLOR_WRITEMASK = web_gl.RenderingContext.COLOR_WRITEMASK;
  web_gl.COMPILE_STATUS = web_gl.RenderingContext.COMPILE_STATUS;
  web_gl.COMPRESSED_TEXTURE_FORMATS = web_gl.RenderingContext.COMPRESSED_TEXTURE_FORMATS;
  web_gl.CONSTANT_ALPHA = web_gl.RenderingContext.CONSTANT_ALPHA;
  web_gl.CONSTANT_COLOR = web_gl.RenderingContext.CONSTANT_COLOR;
  web_gl.CONTEXT_LOST_WEBGL = web_gl.RenderingContext.CONTEXT_LOST_WEBGL;
  web_gl.CULL_FACE = web_gl.RenderingContext.CULL_FACE;
  web_gl.CULL_FACE_MODE = web_gl.RenderingContext.CULL_FACE_MODE;
  web_gl.CURRENT_PROGRAM = web_gl.RenderingContext.CURRENT_PROGRAM;
  web_gl.CURRENT_VERTEX_ATTRIB = web_gl.RenderingContext.CURRENT_VERTEX_ATTRIB;
  web_gl.CW = web_gl.RenderingContext.CW;
  web_gl.DECR = web_gl.RenderingContext.DECR;
  web_gl.DECR_WRAP = web_gl.RenderingContext.DECR_WRAP;
  web_gl.DELETE_STATUS = web_gl.RenderingContext.DELETE_STATUS;
  web_gl.DEPTH_ATTACHMENT = web_gl.RenderingContext.DEPTH_ATTACHMENT;
  web_gl.DEPTH_BITS = web_gl.RenderingContext.DEPTH_BITS;
  web_gl.DEPTH_BUFFER_BIT = web_gl.RenderingContext.DEPTH_BUFFER_BIT;
  web_gl.DEPTH_CLEAR_VALUE = web_gl.RenderingContext.DEPTH_CLEAR_VALUE;
  web_gl.DEPTH_COMPONENT = web_gl.RenderingContext.DEPTH_COMPONENT;
  web_gl.DEPTH_COMPONENT16 = web_gl.RenderingContext.DEPTH_COMPONENT16;
  web_gl.DEPTH_FUNC = web_gl.RenderingContext.DEPTH_FUNC;
  web_gl.DEPTH_RANGE = web_gl.RenderingContext.DEPTH_RANGE;
  web_gl.DEPTH_STENCIL = web_gl.RenderingContext.DEPTH_STENCIL;
  web_gl.DEPTH_STENCIL_ATTACHMENT = web_gl.RenderingContext.DEPTH_STENCIL_ATTACHMENT;
  web_gl.DEPTH_TEST = web_gl.RenderingContext.DEPTH_TEST;
  web_gl.DEPTH_WRITEMASK = web_gl.RenderingContext.DEPTH_WRITEMASK;
  web_gl.DITHER = web_gl.RenderingContext.DITHER;
  web_gl.DONT_CARE = web_gl.RenderingContext.DONT_CARE;
  web_gl.DST_ALPHA = web_gl.RenderingContext.DST_ALPHA;
  web_gl.DST_COLOR = web_gl.RenderingContext.DST_COLOR;
  web_gl.DYNAMIC_DRAW = web_gl.RenderingContext.DYNAMIC_DRAW;
  web_gl.ELEMENT_ARRAY_BUFFER = web_gl.RenderingContext.ELEMENT_ARRAY_BUFFER;
  web_gl.ELEMENT_ARRAY_BUFFER_BINDING = web_gl.RenderingContext.ELEMENT_ARRAY_BUFFER_BINDING;
  web_gl.EQUAL = web_gl.RenderingContext.EQUAL;
  web_gl.FASTEST = web_gl.RenderingContext.FASTEST;
  web_gl.FLOAT = web_gl.RenderingContext.FLOAT;
  web_gl.FLOAT_MAT2 = web_gl.RenderingContext.FLOAT_MAT2;
  web_gl.FLOAT_MAT3 = web_gl.RenderingContext.FLOAT_MAT3;
  web_gl.FLOAT_MAT4 = web_gl.RenderingContext.FLOAT_MAT4;
  web_gl.FLOAT_VEC2 = web_gl.RenderingContext.FLOAT_VEC2;
  web_gl.FLOAT_VEC3 = web_gl.RenderingContext.FLOAT_VEC3;
  web_gl.FLOAT_VEC4 = web_gl.RenderingContext.FLOAT_VEC4;
  web_gl.FRAGMENT_SHADER = web_gl.RenderingContext.FRAGMENT_SHADER;
  web_gl.FRAMEBUFFER = web_gl.RenderingContext.FRAMEBUFFER;
  web_gl.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = web_gl.RenderingContext.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME;
  web_gl.FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = web_gl.RenderingContext.FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE;
  web_gl.FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = web_gl.RenderingContext.FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE;
  web_gl.FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = web_gl.RenderingContext.FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL;
  web_gl.FRAMEBUFFER_BINDING = web_gl.RenderingContext.FRAMEBUFFER_BINDING;
  web_gl.FRAMEBUFFER_COMPLETE = web_gl.RenderingContext.FRAMEBUFFER_COMPLETE;
  web_gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT = web_gl.RenderingContext.FRAMEBUFFER_INCOMPLETE_ATTACHMENT;
  web_gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS = web_gl.RenderingContext.FRAMEBUFFER_INCOMPLETE_DIMENSIONS;
  web_gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = web_gl.RenderingContext.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT;
  web_gl.FRAMEBUFFER_UNSUPPORTED = web_gl.RenderingContext.FRAMEBUFFER_UNSUPPORTED;
  web_gl.FRONT = web_gl.RenderingContext.FRONT;
  web_gl.FRONT_AND_BACK = web_gl.RenderingContext.FRONT_AND_BACK;
  web_gl.FRONT_FACE = web_gl.RenderingContext.FRONT_FACE;
  web_gl.FUNC_ADD = web_gl.RenderingContext.FUNC_ADD;
  web_gl.FUNC_REVERSE_SUBTRACT = web_gl.RenderingContext.FUNC_REVERSE_SUBTRACT;
  web_gl.FUNC_SUBTRACT = web_gl.RenderingContext.FUNC_SUBTRACT;
  web_gl.GENERATE_MIPMAP_HINT = web_gl.RenderingContext.GENERATE_MIPMAP_HINT;
  web_gl.GEQUAL = web_gl.RenderingContext.GEQUAL;
  web_gl.GREATER = web_gl.RenderingContext.GREATER;
  web_gl.GREEN_BITS = web_gl.RenderingContext.GREEN_BITS;
  web_gl.OesTextureHalfFloat = class OesTextureHalfFloat extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_gl.OesTextureHalfFloat, {
    constructors: () => ({_: [web_gl.OesTextureHalfFloat, []]})
  });
  web_gl.OesTextureHalfFloat[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('OESTextureHalfFloat')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("OESTextureHalfFloat"))];
  web_gl.OesTextureHalfFloat.HALF_FLOAT_OES = 36193;
  dart.registerExtension(dart.global.OESTextureHalfFloat, web_gl.OesTextureHalfFloat);
  web_gl.HALF_FLOAT_OES = web_gl.OesTextureHalfFloat.HALF_FLOAT_OES;
  web_gl.HIGH_FLOAT = web_gl.RenderingContext.HIGH_FLOAT;
  web_gl.HIGH_INT = web_gl.RenderingContext.HIGH_INT;
  web_gl.INCR = web_gl.RenderingContext.INCR;
  web_gl.INCR_WRAP = web_gl.RenderingContext.INCR_WRAP;
  web_gl.INT = web_gl.RenderingContext.INT;
  web_gl.INT_VEC2 = web_gl.RenderingContext.INT_VEC2;
  web_gl.INT_VEC3 = web_gl.RenderingContext.INT_VEC3;
  web_gl.INT_VEC4 = web_gl.RenderingContext.INT_VEC4;
  web_gl.INVALID_ENUM = web_gl.RenderingContext.INVALID_ENUM;
  web_gl.INVALID_FRAMEBUFFER_OPERATION = web_gl.RenderingContext.INVALID_FRAMEBUFFER_OPERATION;
  web_gl.INVALID_OPERATION = web_gl.RenderingContext.INVALID_OPERATION;
  web_gl.INVALID_VALUE = web_gl.RenderingContext.INVALID_VALUE;
  web_gl.INVERT = web_gl.RenderingContext.INVERT;
  web_gl.KEEP = web_gl.RenderingContext.KEEP;
  web_gl.LEQUAL = web_gl.RenderingContext.LEQUAL;
  web_gl.LESS = web_gl.RenderingContext.LESS;
  web_gl.LINEAR = web_gl.RenderingContext.LINEAR;
  web_gl.LINEAR_MIPMAP_LINEAR = web_gl.RenderingContext.LINEAR_MIPMAP_LINEAR;
  web_gl.LINEAR_MIPMAP_NEAREST = web_gl.RenderingContext.LINEAR_MIPMAP_NEAREST;
  web_gl.LINES = web_gl.RenderingContext.LINES;
  web_gl.LINE_LOOP = web_gl.RenderingContext.LINE_LOOP;
  web_gl.LINE_STRIP = web_gl.RenderingContext.LINE_STRIP;
  web_gl.LINE_WIDTH = web_gl.RenderingContext.LINE_WIDTH;
  web_gl.LINK_STATUS = web_gl.RenderingContext.LINK_STATUS;
  web_gl.LOW_FLOAT = web_gl.RenderingContext.LOW_FLOAT;
  web_gl.LOW_INT = web_gl.RenderingContext.LOW_INT;
  web_gl.LUMINANCE = web_gl.RenderingContext.LUMINANCE;
  web_gl.LUMINANCE_ALPHA = web_gl.RenderingContext.LUMINANCE_ALPHA;
  web_gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS = web_gl.RenderingContext.MAX_COMBINED_TEXTURE_IMAGE_UNITS;
  web_gl.MAX_CUBE_MAP_TEXTURE_SIZE = web_gl.RenderingContext.MAX_CUBE_MAP_TEXTURE_SIZE;
  web_gl.MAX_FRAGMENT_UNIFORM_VECTORS = web_gl.RenderingContext.MAX_FRAGMENT_UNIFORM_VECTORS;
  web_gl.MAX_RENDERBUFFER_SIZE = web_gl.RenderingContext.MAX_RENDERBUFFER_SIZE;
  web_gl.MAX_TEXTURE_IMAGE_UNITS = web_gl.RenderingContext.MAX_TEXTURE_IMAGE_UNITS;
  web_gl.MAX_TEXTURE_SIZE = web_gl.RenderingContext.MAX_TEXTURE_SIZE;
  web_gl.MAX_VARYING_VECTORS = web_gl.RenderingContext.MAX_VARYING_VECTORS;
  web_gl.MAX_VERTEX_ATTRIBS = web_gl.RenderingContext.MAX_VERTEX_ATTRIBS;
  web_gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS = web_gl.RenderingContext.MAX_VERTEX_TEXTURE_IMAGE_UNITS;
  web_gl.MAX_VERTEX_UNIFORM_VECTORS = web_gl.RenderingContext.MAX_VERTEX_UNIFORM_VECTORS;
  web_gl.MAX_VIEWPORT_DIMS = web_gl.RenderingContext.MAX_VIEWPORT_DIMS;
  web_gl.MEDIUM_FLOAT = web_gl.RenderingContext.MEDIUM_FLOAT;
  web_gl.MEDIUM_INT = web_gl.RenderingContext.MEDIUM_INT;
  web_gl.MIRRORED_REPEAT = web_gl.RenderingContext.MIRRORED_REPEAT;
  web_gl.NEAREST = web_gl.RenderingContext.NEAREST;
  web_gl.NEAREST_MIPMAP_LINEAR = web_gl.RenderingContext.NEAREST_MIPMAP_LINEAR;
  web_gl.NEAREST_MIPMAP_NEAREST = web_gl.RenderingContext.NEAREST_MIPMAP_NEAREST;
  web_gl.NEVER = web_gl.RenderingContext.NEVER;
  web_gl.NICEST = web_gl.RenderingContext.NICEST;
  web_gl.NONE = web_gl.RenderingContext.NONE;
  web_gl.NOTEQUAL = web_gl.RenderingContext.NOTEQUAL;
  web_gl.NO_ERROR = web_gl.RenderingContext.NO_ERROR;
  web_gl.ONE = web_gl.RenderingContext.ONE;
  web_gl.ONE_MINUS_CONSTANT_ALPHA = web_gl.RenderingContext.ONE_MINUS_CONSTANT_ALPHA;
  web_gl.ONE_MINUS_CONSTANT_COLOR = web_gl.RenderingContext.ONE_MINUS_CONSTANT_COLOR;
  web_gl.ONE_MINUS_DST_ALPHA = web_gl.RenderingContext.ONE_MINUS_DST_ALPHA;
  web_gl.ONE_MINUS_DST_COLOR = web_gl.RenderingContext.ONE_MINUS_DST_COLOR;
  web_gl.ONE_MINUS_SRC_ALPHA = web_gl.RenderingContext.ONE_MINUS_SRC_ALPHA;
  web_gl.ONE_MINUS_SRC_COLOR = web_gl.RenderingContext.ONE_MINUS_SRC_COLOR;
  web_gl.OUT_OF_MEMORY = web_gl.RenderingContext.OUT_OF_MEMORY;
  web_gl.PACK_ALIGNMENT = web_gl.RenderingContext.PACK_ALIGNMENT;
  web_gl.POINTS = web_gl.RenderingContext.POINTS;
  web_gl.POLYGON_OFFSET_FACTOR = web_gl.RenderingContext.POLYGON_OFFSET_FACTOR;
  web_gl.POLYGON_OFFSET_FILL = web_gl.RenderingContext.POLYGON_OFFSET_FILL;
  web_gl.POLYGON_OFFSET_UNITS = web_gl.RenderingContext.POLYGON_OFFSET_UNITS;
  web_gl.RED_BITS = web_gl.RenderingContext.RED_BITS;
  web_gl.RENDERBUFFER = web_gl.RenderingContext.RENDERBUFFER;
  web_gl.RENDERBUFFER_ALPHA_SIZE = web_gl.RenderingContext.RENDERBUFFER_ALPHA_SIZE;
  web_gl.RENDERBUFFER_BINDING = web_gl.RenderingContext.RENDERBUFFER_BINDING;
  web_gl.RENDERBUFFER_BLUE_SIZE = web_gl.RenderingContext.RENDERBUFFER_BLUE_SIZE;
  web_gl.RENDERBUFFER_DEPTH_SIZE = web_gl.RenderingContext.RENDERBUFFER_DEPTH_SIZE;
  web_gl.RENDERBUFFER_GREEN_SIZE = web_gl.RenderingContext.RENDERBUFFER_GREEN_SIZE;
  web_gl.RENDERBUFFER_HEIGHT = web_gl.RenderingContext.RENDERBUFFER_HEIGHT;
  web_gl.RENDERBUFFER_INTERNAL_FORMAT = web_gl.RenderingContext.RENDERBUFFER_INTERNAL_FORMAT;
  web_gl.RENDERBUFFER_RED_SIZE = web_gl.RenderingContext.RENDERBUFFER_RED_SIZE;
  web_gl.RENDERBUFFER_STENCIL_SIZE = web_gl.RenderingContext.RENDERBUFFER_STENCIL_SIZE;
  web_gl.RENDERBUFFER_WIDTH = web_gl.RenderingContext.RENDERBUFFER_WIDTH;
  web_gl.RENDERER = web_gl.RenderingContext.RENDERER;
  web_gl.REPEAT = web_gl.RenderingContext.REPEAT;
  web_gl.REPLACE = web_gl.RenderingContext.REPLACE;
  web_gl.RGB = web_gl.RenderingContext.RGB;
  web_gl.RGB565 = web_gl.RenderingContext.RGB565;
  web_gl.RGB5_A1 = web_gl.RenderingContext.RGB5_A1;
  web_gl.RGBA = web_gl.RenderingContext.RGBA;
  web_gl.RGBA4 = web_gl.RenderingContext.RGBA4;
  web_gl.SAMPLER_2D = web_gl.RenderingContext.SAMPLER_2D;
  web_gl.SAMPLER_CUBE = web_gl.RenderingContext.SAMPLER_CUBE;
  web_gl.SAMPLES = web_gl.RenderingContext.SAMPLES;
  web_gl.SAMPLE_ALPHA_TO_COVERAGE = web_gl.RenderingContext.SAMPLE_ALPHA_TO_COVERAGE;
  web_gl.SAMPLE_BUFFERS = web_gl.RenderingContext.SAMPLE_BUFFERS;
  web_gl.SAMPLE_COVERAGE = web_gl.RenderingContext.SAMPLE_COVERAGE;
  web_gl.SAMPLE_COVERAGE_INVERT = web_gl.RenderingContext.SAMPLE_COVERAGE_INVERT;
  web_gl.SAMPLE_COVERAGE_VALUE = web_gl.RenderingContext.SAMPLE_COVERAGE_VALUE;
  web_gl.SCISSOR_BOX = web_gl.RenderingContext.SCISSOR_BOX;
  web_gl.SCISSOR_TEST = web_gl.RenderingContext.SCISSOR_TEST;
  web_gl.SHADER_TYPE = web_gl.RenderingContext.SHADER_TYPE;
  web_gl.SHADING_LANGUAGE_VERSION = web_gl.RenderingContext.SHADING_LANGUAGE_VERSION;
  web_gl.SHORT = web_gl.RenderingContext.SHORT;
  web_gl.SRC_ALPHA = web_gl.RenderingContext.SRC_ALPHA;
  web_gl.SRC_ALPHA_SATURATE = web_gl.RenderingContext.SRC_ALPHA_SATURATE;
  web_gl.SRC_COLOR = web_gl.RenderingContext.SRC_COLOR;
  web_gl.STATIC_DRAW = web_gl.RenderingContext.STATIC_DRAW;
  web_gl.STENCIL_ATTACHMENT = web_gl.RenderingContext.STENCIL_ATTACHMENT;
  web_gl.STENCIL_BACK_FAIL = web_gl.RenderingContext.STENCIL_BACK_FAIL;
  web_gl.STENCIL_BACK_FUNC = web_gl.RenderingContext.STENCIL_BACK_FUNC;
  web_gl.STENCIL_BACK_PASS_DEPTH_FAIL = web_gl.RenderingContext.STENCIL_BACK_PASS_DEPTH_FAIL;
  web_gl.STENCIL_BACK_PASS_DEPTH_PASS = web_gl.RenderingContext.STENCIL_BACK_PASS_DEPTH_PASS;
  web_gl.STENCIL_BACK_REF = web_gl.RenderingContext.STENCIL_BACK_REF;
  web_gl.STENCIL_BACK_VALUE_MASK = web_gl.RenderingContext.STENCIL_BACK_VALUE_MASK;
  web_gl.STENCIL_BACK_WRITEMASK = web_gl.RenderingContext.STENCIL_BACK_WRITEMASK;
  web_gl.STENCIL_BITS = web_gl.RenderingContext.STENCIL_BITS;
  web_gl.STENCIL_BUFFER_BIT = web_gl.RenderingContext.STENCIL_BUFFER_BIT;
  web_gl.STENCIL_CLEAR_VALUE = web_gl.RenderingContext.STENCIL_CLEAR_VALUE;
  web_gl.STENCIL_FAIL = web_gl.RenderingContext.STENCIL_FAIL;
  web_gl.STENCIL_FUNC = web_gl.RenderingContext.STENCIL_FUNC;
  web_gl.STENCIL_INDEX = web_gl.RenderingContext.STENCIL_INDEX;
  web_gl.STENCIL_INDEX8 = web_gl.RenderingContext.STENCIL_INDEX8;
  web_gl.STENCIL_PASS_DEPTH_FAIL = web_gl.RenderingContext.STENCIL_PASS_DEPTH_FAIL;
  web_gl.STENCIL_PASS_DEPTH_PASS = web_gl.RenderingContext.STENCIL_PASS_DEPTH_PASS;
  web_gl.STENCIL_REF = web_gl.RenderingContext.STENCIL_REF;
  web_gl.STENCIL_TEST = web_gl.RenderingContext.STENCIL_TEST;
  web_gl.STENCIL_VALUE_MASK = web_gl.RenderingContext.STENCIL_VALUE_MASK;
  web_gl.STENCIL_WRITEMASK = web_gl.RenderingContext.STENCIL_WRITEMASK;
  web_gl.STREAM_DRAW = web_gl.RenderingContext.STREAM_DRAW;
  web_gl.SUBPIXEL_BITS = web_gl.RenderingContext.SUBPIXEL_BITS;
  web_gl.TEXTURE = web_gl.RenderingContext.TEXTURE;
  web_gl.TEXTURE0 = web_gl.RenderingContext.TEXTURE0;
  web_gl.TEXTURE1 = web_gl.RenderingContext.TEXTURE1;
  web_gl.TEXTURE10 = web_gl.RenderingContext.TEXTURE10;
  web_gl.TEXTURE11 = web_gl.RenderingContext.TEXTURE11;
  web_gl.TEXTURE12 = web_gl.RenderingContext.TEXTURE12;
  web_gl.TEXTURE13 = web_gl.RenderingContext.TEXTURE13;
  web_gl.TEXTURE14 = web_gl.RenderingContext.TEXTURE14;
  web_gl.TEXTURE15 = web_gl.RenderingContext.TEXTURE15;
  web_gl.TEXTURE16 = web_gl.RenderingContext.TEXTURE16;
  web_gl.TEXTURE17 = web_gl.RenderingContext.TEXTURE17;
  web_gl.TEXTURE18 = web_gl.RenderingContext.TEXTURE18;
  web_gl.TEXTURE19 = web_gl.RenderingContext.TEXTURE19;
  web_gl.TEXTURE2 = web_gl.RenderingContext.TEXTURE2;
  web_gl.TEXTURE20 = web_gl.RenderingContext.TEXTURE20;
  web_gl.TEXTURE21 = web_gl.RenderingContext.TEXTURE21;
  web_gl.TEXTURE22 = web_gl.RenderingContext.TEXTURE22;
  web_gl.TEXTURE23 = web_gl.RenderingContext.TEXTURE23;
  web_gl.TEXTURE24 = web_gl.RenderingContext.TEXTURE24;
  web_gl.TEXTURE25 = web_gl.RenderingContext.TEXTURE25;
  web_gl.TEXTURE26 = web_gl.RenderingContext.TEXTURE26;
  web_gl.TEXTURE27 = web_gl.RenderingContext.TEXTURE27;
  web_gl.TEXTURE28 = web_gl.RenderingContext.TEXTURE28;
  web_gl.TEXTURE29 = web_gl.RenderingContext.TEXTURE29;
  web_gl.TEXTURE3 = web_gl.RenderingContext.TEXTURE3;
  web_gl.TEXTURE30 = web_gl.RenderingContext.TEXTURE30;
  web_gl.TEXTURE31 = web_gl.RenderingContext.TEXTURE31;
  web_gl.TEXTURE4 = web_gl.RenderingContext.TEXTURE4;
  web_gl.TEXTURE5 = web_gl.RenderingContext.TEXTURE5;
  web_gl.TEXTURE6 = web_gl.RenderingContext.TEXTURE6;
  web_gl.TEXTURE7 = web_gl.RenderingContext.TEXTURE7;
  web_gl.TEXTURE8 = web_gl.RenderingContext.TEXTURE8;
  web_gl.TEXTURE9 = web_gl.RenderingContext.TEXTURE9;
  web_gl.TEXTURE_2D = web_gl.RenderingContext.TEXTURE_2D;
  web_gl.TEXTURE_BINDING_2D = web_gl.RenderingContext.TEXTURE_BINDING_2D;
  web_gl.TEXTURE_BINDING_CUBE_MAP = web_gl.RenderingContext.TEXTURE_BINDING_CUBE_MAP;
  web_gl.TEXTURE_CUBE_MAP = web_gl.RenderingContext.TEXTURE_CUBE_MAP;
  web_gl.TEXTURE_CUBE_MAP_NEGATIVE_X = web_gl.RenderingContext.TEXTURE_CUBE_MAP_NEGATIVE_X;
  web_gl.TEXTURE_CUBE_MAP_NEGATIVE_Y = web_gl.RenderingContext.TEXTURE_CUBE_MAP_NEGATIVE_Y;
  web_gl.TEXTURE_CUBE_MAP_NEGATIVE_Z = web_gl.RenderingContext.TEXTURE_CUBE_MAP_NEGATIVE_Z;
  web_gl.TEXTURE_CUBE_MAP_POSITIVE_X = web_gl.RenderingContext.TEXTURE_CUBE_MAP_POSITIVE_X;
  web_gl.TEXTURE_CUBE_MAP_POSITIVE_Y = web_gl.RenderingContext.TEXTURE_CUBE_MAP_POSITIVE_Y;
  web_gl.TEXTURE_CUBE_MAP_POSITIVE_Z = web_gl.RenderingContext.TEXTURE_CUBE_MAP_POSITIVE_Z;
  web_gl.TEXTURE_MAG_FILTER = web_gl.RenderingContext.TEXTURE_MAG_FILTER;
  web_gl.TEXTURE_MIN_FILTER = web_gl.RenderingContext.TEXTURE_MIN_FILTER;
  web_gl.TEXTURE_WRAP_S = web_gl.RenderingContext.TEXTURE_WRAP_S;
  web_gl.TEXTURE_WRAP_T = web_gl.RenderingContext.TEXTURE_WRAP_T;
  web_gl.TRIANGLES = web_gl.RenderingContext.TRIANGLES;
  web_gl.TRIANGLE_FAN = web_gl.RenderingContext.TRIANGLE_FAN;
  web_gl.TRIANGLE_STRIP = web_gl.RenderingContext.TRIANGLE_STRIP;
  web_gl.UNPACK_ALIGNMENT = web_gl.RenderingContext.UNPACK_ALIGNMENT;
  web_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL = web_gl.RenderingContext.UNPACK_COLORSPACE_CONVERSION_WEBGL;
  web_gl.UNPACK_FLIP_Y_WEBGL = web_gl.RenderingContext.UNPACK_FLIP_Y_WEBGL;
  web_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL = web_gl.RenderingContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL;
  web_gl.UNSIGNED_BYTE = web_gl.RenderingContext.UNSIGNED_BYTE;
  web_gl.UNSIGNED_INT = web_gl.RenderingContext.UNSIGNED_INT;
  web_gl.UNSIGNED_SHORT = web_gl.RenderingContext.UNSIGNED_SHORT;
  web_gl.UNSIGNED_SHORT_4_4_4_4 = web_gl.RenderingContext.UNSIGNED_SHORT_4_4_4_4;
  web_gl.UNSIGNED_SHORT_5_5_5_1 = web_gl.RenderingContext.UNSIGNED_SHORT_5_5_5_1;
  web_gl.UNSIGNED_SHORT_5_6_5 = web_gl.RenderingContext.UNSIGNED_SHORT_5_6_5;
  web_gl.VALIDATE_STATUS = web_gl.RenderingContext.VALIDATE_STATUS;
  web_gl.VENDOR = web_gl.RenderingContext.VENDOR;
  web_gl.VERSION = web_gl.RenderingContext.VERSION;
  web_gl.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = web_gl.RenderingContext.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING;
  web_gl.VERTEX_ATTRIB_ARRAY_ENABLED = web_gl.RenderingContext.VERTEX_ATTRIB_ARRAY_ENABLED;
  web_gl.VERTEX_ATTRIB_ARRAY_NORMALIZED = web_gl.RenderingContext.VERTEX_ATTRIB_ARRAY_NORMALIZED;
  web_gl.VERTEX_ATTRIB_ARRAY_POINTER = web_gl.RenderingContext.VERTEX_ATTRIB_ARRAY_POINTER;
  web_gl.VERTEX_ATTRIB_ARRAY_SIZE = web_gl.RenderingContext.VERTEX_ATTRIB_ARRAY_SIZE;
  web_gl.VERTEX_ATTRIB_ARRAY_STRIDE = web_gl.RenderingContext.VERTEX_ATTRIB_ARRAY_STRIDE;
  web_gl.VERTEX_ATTRIB_ARRAY_TYPE = web_gl.RenderingContext.VERTEX_ATTRIB_ARRAY_TYPE;
  web_gl.VERTEX_SHADER = web_gl.RenderingContext.VERTEX_SHADER;
  web_gl.VIEWPORT = web_gl.RenderingContext.VIEWPORT;
  web_gl.ZERO = web_gl.RenderingContext.ZERO;
  dart.defineExtensionNames([
    'name',
    'size',
    'type'
  ]);
  web_gl.ActiveInfo = class ActiveInfo extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.name]() {
      return this.name;
    }
    get [dartx.size]() {
      return this.size;
    }
    get [dartx.type]() {
      return this.type;
    }
  };
  dart.setSignature(web_gl.ActiveInfo, {
    constructors: () => ({_: [web_gl.ActiveInfo, []]})
  });
  web_gl.ActiveInfo[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('WebGLActiveInfo')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("WebGLActiveInfo"))];
  dart.registerExtension(dart.global.WebGLActiveInfo, web_gl.ActiveInfo);
  dart.defineExtensionNames([
    'drawArraysInstancedAngle',
    'drawElementsInstancedAngle',
    'vertexAttribDivisorAngle'
  ]);
  web_gl.AngleInstancedArrays = class AngleInstancedArrays extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.drawArraysInstancedAngle](mode, first, count, primcount) {
      return this.drawArraysInstancedANGLE(mode, first, count, primcount);
    }
    [dartx.drawElementsInstancedAngle](mode, count, type, offset, primcount) {
      return this.drawElementsInstancedANGLE(mode, count, type, offset, primcount);
    }
    [dartx.vertexAttribDivisorAngle](index, divisor) {
      return this.vertexAttribDivisorANGLE(index, divisor);
    }
  };
  dart.setSignature(web_gl.AngleInstancedArrays, {
    constructors: () => ({_: [web_gl.AngleInstancedArrays, []]}),
    methods: () => ({
      [dartx.drawArraysInstancedAngle]: [dart.void, [core.int, core.int, core.int, core.int]],
      [dartx.drawElementsInstancedAngle]: [dart.void, [core.int, core.int, core.int, core.int, core.int]],
      [dartx.vertexAttribDivisorAngle]: [dart.void, [core.int, core.int]]
    })
  });
  web_gl.AngleInstancedArrays[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ANGLEInstancedArrays')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("ANGLEInstancedArrays"))];
  web_gl.AngleInstancedArrays.VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE = 35070;
  dart.registerExtension(dart.global.ANGLEInstancedArrays, web_gl.AngleInstancedArrays);
  web_gl.Buffer = class Buffer extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_gl.Buffer, {
    constructors: () => ({_: [web_gl.Buffer, []]})
  });
  web_gl.Buffer[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('WebGLBuffer')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("WebGLBuffer"))];
  dart.registerExtension(dart.global.WebGLBuffer, web_gl.Buffer);
  web_gl.CompressedTextureAtc = class CompressedTextureAtc extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_gl.CompressedTextureAtc, {
    constructors: () => ({_: [web_gl.CompressedTextureAtc, []]})
  });
  web_gl.CompressedTextureAtc[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('WebGLCompressedTextureATC')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("WebGLCompressedTextureATC"))];
  web_gl.CompressedTextureAtc.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35987;
  web_gl.CompressedTextureAtc.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798;
  web_gl.CompressedTextureAtc.COMPRESSED_RGB_ATC_WEBGL = 35986;
  dart.registerExtension(dart.global.WebGLCompressedTextureATC, web_gl.CompressedTextureAtc);
  web_gl.CompressedTextureETC1 = class CompressedTextureETC1 extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_gl.CompressedTextureETC1, {
    constructors: () => ({_: [web_gl.CompressedTextureETC1, []]})
  });
  web_gl.CompressedTextureETC1[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('WebGLCompressedTextureETC1')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("WebGLCompressedTextureETC1"))];
  web_gl.CompressedTextureETC1.COMPRESSED_RGB_ETC1_WEBGL = 36196;
  dart.registerExtension(dart.global.WebGLCompressedTextureETC1, web_gl.CompressedTextureETC1);
  web_gl.CompressedTexturePvrtc = class CompressedTexturePvrtc extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_gl.CompressedTexturePvrtc, {
    constructors: () => ({_: [web_gl.CompressedTexturePvrtc, []]})
  });
  web_gl.CompressedTexturePvrtc[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('WebGLCompressedTexturePVRTC')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("WebGLCompressedTexturePVRTC"))];
  web_gl.CompressedTexturePvrtc.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843;
  web_gl.CompressedTexturePvrtc.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842;
  web_gl.CompressedTexturePvrtc.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841;
  web_gl.CompressedTexturePvrtc.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840;
  dart.registerExtension(dart.global.WebGLCompressedTexturePVRTC, web_gl.CompressedTexturePvrtc);
  web_gl.CompressedTextureS3TC = class CompressedTextureS3TC extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_gl.CompressedTextureS3TC, {
    constructors: () => ({_: [web_gl.CompressedTextureS3TC, []]})
  });
  web_gl.CompressedTextureS3TC[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('WebGLCompressedTextureS3TC')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("WebGLCompressedTextureS3TC"))];
  web_gl.CompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777;
  web_gl.CompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778;
  web_gl.CompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779;
  web_gl.CompressedTextureS3TC.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776;
  dart.registerExtension(dart.global.WebGLCompressedTextureS3TC, web_gl.CompressedTextureS3TC);
  dart.defineExtensionNames([
    'alpha',
    'antialias',
    'depth',
    'failIfMajorPerformanceCaveat',
    'premultipliedAlpha',
    'preserveDrawingBuffer',
    'stencil'
  ]);
  web_gl.ContextAttributes = class ContextAttributes extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.alpha]() {
      return this.alpha;
    }
    set [dartx.alpha](value) {
      this.alpha = value;
    }
    get [dartx.antialias]() {
      return this.antialias;
    }
    set [dartx.antialias](value) {
      this.antialias = value;
    }
    get [dartx.depth]() {
      return this.depth;
    }
    set [dartx.depth](value) {
      this.depth = value;
    }
    get [dartx.failIfMajorPerformanceCaveat]() {
      return this.failIfMajorPerformanceCaveat;
    }
    set [dartx.failIfMajorPerformanceCaveat](value) {
      this.failIfMajorPerformanceCaveat = value;
    }
    get [dartx.premultipliedAlpha]() {
      return this.premultipliedAlpha;
    }
    set [dartx.premultipliedAlpha](value) {
      this.premultipliedAlpha = value;
    }
    get [dartx.preserveDrawingBuffer]() {
      return this.preserveDrawingBuffer;
    }
    set [dartx.preserveDrawingBuffer](value) {
      this.preserveDrawingBuffer = value;
    }
    get [dartx.stencil]() {
      return this.stencil;
    }
    set [dartx.stencil](value) {
      this.stencil = value;
    }
  };
  dart.setSignature(web_gl.ContextAttributes, {
    constructors: () => ({_: [web_gl.ContextAttributes, []]})
  });
  web_gl.ContextAttributes[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('WebGLContextAttributes')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("WebGLContextAttributes"))];
  dart.registerExtension(dart.global.WebGLContextAttributes, web_gl.ContextAttributes);
  dart.defineExtensionNames([
    'statusMessage'
  ]);
  web_gl.ContextEvent = class ContextEvent extends html$.Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.statusMessage]() {
      return this.statusMessage;
    }
  };
  dart.setSignature(web_gl.ContextEvent, {
    constructors: () => ({_: [web_gl.ContextEvent, []]})
  });
  web_gl.ContextEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('WebGLContextEvent')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("WebGLContextEvent"))];
  dart.registerExtension(dart.global.WebGLContextEvent, web_gl.ContextEvent);
  web_gl.DebugRendererInfo = class DebugRendererInfo extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_gl.DebugRendererInfo, {
    constructors: () => ({_: [web_gl.DebugRendererInfo, []]})
  });
  web_gl.DebugRendererInfo[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('WebGLDebugRendererInfo')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("WebGLDebugRendererInfo"))];
  web_gl.DebugRendererInfo.UNMASKED_RENDERER_WEBGL = 37446;
  web_gl.DebugRendererInfo.UNMASKED_VENDOR_WEBGL = 37445;
  dart.registerExtension(dart.global.WebGLDebugRendererInfo, web_gl.DebugRendererInfo);
  dart.defineExtensionNames([
    'getTranslatedShaderSource'
  ]);
  web_gl.DebugShaders = class DebugShaders extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.getTranslatedShaderSource](shader) {
      return this.getTranslatedShaderSource(shader);
    }
  };
  dart.setSignature(web_gl.DebugShaders, {
    constructors: () => ({_: [web_gl.DebugShaders, []]}),
    methods: () => ({[dartx.getTranslatedShaderSource]: [core.String, [web_gl.Shader]]})
  });
  web_gl.DebugShaders[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('WebGLDebugShaders')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("WebGLDebugShaders"))];
  dart.registerExtension(dart.global.WebGLDebugShaders, web_gl.DebugShaders);
  web_gl.DepthTexture = class DepthTexture extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_gl.DepthTexture, {
    constructors: () => ({_: [web_gl.DepthTexture, []]})
  });
  web_gl.DepthTexture[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('WebGLDepthTexture')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("WebGLDepthTexture"))];
  web_gl.DepthTexture.UNSIGNED_INT_24_8_WEBGL = 34042;
  dart.registerExtension(dart.global.WebGLDepthTexture, web_gl.DepthTexture);
  dart.defineExtensionNames([
    'drawBuffersWebgl'
  ]);
  web_gl.DrawBuffers = class DrawBuffers extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.drawBuffersWebgl](buffers) {
      return this.drawBuffersWEBGL(buffers);
    }
  };
  dart.setSignature(web_gl.DrawBuffers, {
    constructors: () => ({_: [web_gl.DrawBuffers, []]}),
    methods: () => ({[dartx.drawBuffersWebgl]: [dart.void, [core.List$(core.int)]]})
  });
  web_gl.DrawBuffers[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('WebGLDrawBuffers')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("WebGLDrawBuffers"))];
  web_gl.DrawBuffers.COLOR_ATTACHMENT0_WEBGL = 36064;
  web_gl.DrawBuffers.COLOR_ATTACHMENT10_WEBGL = 36074;
  web_gl.DrawBuffers.COLOR_ATTACHMENT11_WEBGL = 36075;
  web_gl.DrawBuffers.COLOR_ATTACHMENT12_WEBGL = 36076;
  web_gl.DrawBuffers.COLOR_ATTACHMENT13_WEBGL = 36077;
  web_gl.DrawBuffers.COLOR_ATTACHMENT14_WEBGL = 36078;
  web_gl.DrawBuffers.COLOR_ATTACHMENT15_WEBGL = 36079;
  web_gl.DrawBuffers.COLOR_ATTACHMENT1_WEBGL = 36065;
  web_gl.DrawBuffers.COLOR_ATTACHMENT2_WEBGL = 36066;
  web_gl.DrawBuffers.COLOR_ATTACHMENT3_WEBGL = 36067;
  web_gl.DrawBuffers.COLOR_ATTACHMENT4_WEBGL = 36068;
  web_gl.DrawBuffers.COLOR_ATTACHMENT5_WEBGL = 36069;
  web_gl.DrawBuffers.COLOR_ATTACHMENT6_WEBGL = 36070;
  web_gl.DrawBuffers.COLOR_ATTACHMENT7_WEBGL = 36071;
  web_gl.DrawBuffers.COLOR_ATTACHMENT8_WEBGL = 36072;
  web_gl.DrawBuffers.COLOR_ATTACHMENT9_WEBGL = 36073;
  web_gl.DrawBuffers.DRAW_BUFFER0_WEBGL = 34853;
  web_gl.DrawBuffers.DRAW_BUFFER10_WEBGL = 34863;
  web_gl.DrawBuffers.DRAW_BUFFER11_WEBGL = 34864;
  web_gl.DrawBuffers.DRAW_BUFFER12_WEBGL = 34865;
  web_gl.DrawBuffers.DRAW_BUFFER13_WEBGL = 34866;
  web_gl.DrawBuffers.DRAW_BUFFER14_WEBGL = 34867;
  web_gl.DrawBuffers.DRAW_BUFFER15_WEBGL = 34868;
  web_gl.DrawBuffers.DRAW_BUFFER1_WEBGL = 34854;
  web_gl.DrawBuffers.DRAW_BUFFER2_WEBGL = 34855;
  web_gl.DrawBuffers.DRAW_BUFFER3_WEBGL = 34856;
  web_gl.DrawBuffers.DRAW_BUFFER4_WEBGL = 34857;
  web_gl.DrawBuffers.DRAW_BUFFER5_WEBGL = 34858;
  web_gl.DrawBuffers.DRAW_BUFFER6_WEBGL = 34859;
  web_gl.DrawBuffers.DRAW_BUFFER7_WEBGL = 34860;
  web_gl.DrawBuffers.DRAW_BUFFER8_WEBGL = 34861;
  web_gl.DrawBuffers.DRAW_BUFFER9_WEBGL = 34862;
  web_gl.DrawBuffers.MAX_COLOR_ATTACHMENTS_WEBGL = 36063;
  web_gl.DrawBuffers.MAX_DRAW_BUFFERS_WEBGL = 34852;
  dart.registerExtension(dart.global.WebGLDrawBuffers, web_gl.DrawBuffers);
  web_gl.ExtBlendMinMax = class ExtBlendMinMax extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_gl.ExtBlendMinMax, {
    constructors: () => ({_: [web_gl.ExtBlendMinMax, []]})
  });
  web_gl.ExtBlendMinMax[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('EXTBlendMinMax')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("EXTBlendMinMax"))];
  web_gl.ExtBlendMinMax.MAX_EXT = 32776;
  web_gl.ExtBlendMinMax.MIN_EXT = 32775;
  dart.registerExtension(dart.global.EXTBlendMinMax, web_gl.ExtBlendMinMax);
  web_gl.ExtFragDepth = class ExtFragDepth extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_gl.ExtFragDepth, {
    constructors: () => ({_: [web_gl.ExtFragDepth, []]})
  });
  web_gl.ExtFragDepth[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('EXTFragDepth')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("EXTFragDepth"))];
  dart.registerExtension(dart.global.EXTFragDepth, web_gl.ExtFragDepth);
  web_gl.ExtShaderTextureLod = class ExtShaderTextureLod extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_gl.ExtShaderTextureLod, {
    constructors: () => ({_: [web_gl.ExtShaderTextureLod, []]})
  });
  web_gl.ExtShaderTextureLod[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('EXTShaderTextureLOD')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("EXTShaderTextureLOD"))];
  dart.registerExtension(dart.global.EXTShaderTextureLOD, web_gl.ExtShaderTextureLod);
  web_gl.ExtTextureFilterAnisotropic = class ExtTextureFilterAnisotropic extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_gl.ExtTextureFilterAnisotropic, {
    constructors: () => ({_: [web_gl.ExtTextureFilterAnisotropic, []]})
  });
  web_gl.ExtTextureFilterAnisotropic[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('EXTTextureFilterAnisotropic')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("EXTTextureFilterAnisotropic"))];
  web_gl.ExtTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT = 34047;
  web_gl.ExtTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT = 34046;
  dart.registerExtension(dart.global.EXTTextureFilterAnisotropic, web_gl.ExtTextureFilterAnisotropic);
  web_gl.Framebuffer = class Framebuffer extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_gl.Framebuffer, {
    constructors: () => ({_: [web_gl.Framebuffer, []]})
  });
  web_gl.Framebuffer[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('WebGLFramebuffer')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("WebGLFramebuffer"))];
  dart.registerExtension(dart.global.WebGLFramebuffer, web_gl.Framebuffer);
  dart.defineExtensionNames([
    'loseContext',
    'restoreContext'
  ]);
  web_gl.LoseContext = class LoseContext extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.loseContext]() {
      return this.loseContext();
    }
    [dartx.restoreContext]() {
      return this.restoreContext();
    }
  };
  dart.setSignature(web_gl.LoseContext, {
    constructors: () => ({_: [web_gl.LoseContext, []]}),
    methods: () => ({
      [dartx.loseContext]: [dart.void, []],
      [dartx.restoreContext]: [dart.void, []]
    })
  });
  web_gl.LoseContext[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('WebGLLoseContext')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("WebGLLoseContext,WebGLExtensionLoseContext"))];
  dart.registerExtension(dart.global.WebGLLoseContext, web_gl.LoseContext);
  web_gl.OesElementIndexUint = class OesElementIndexUint extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_gl.OesElementIndexUint, {
    constructors: () => ({_: [web_gl.OesElementIndexUint, []]})
  });
  web_gl.OesElementIndexUint[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('OESElementIndexUint')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("OESElementIndexUint"))];
  dart.registerExtension(dart.global.OESElementIndexUint, web_gl.OesElementIndexUint);
  web_gl.OesStandardDerivatives = class OesStandardDerivatives extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_gl.OesStandardDerivatives, {
    constructors: () => ({_: [web_gl.OesStandardDerivatives, []]})
  });
  web_gl.OesStandardDerivatives[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('OESStandardDerivatives')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("OESStandardDerivatives"))];
  web_gl.OesStandardDerivatives.FRAGMENT_SHADER_DERIVATIVE_HINT_OES = 35723;
  dart.registerExtension(dart.global.OESStandardDerivatives, web_gl.OesStandardDerivatives);
  web_gl.OesTextureFloat = class OesTextureFloat extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_gl.OesTextureFloat, {
    constructors: () => ({_: [web_gl.OesTextureFloat, []]})
  });
  web_gl.OesTextureFloat[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('OESTextureFloat')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("OESTextureFloat"))];
  dart.registerExtension(dart.global.OESTextureFloat, web_gl.OesTextureFloat);
  web_gl.OesTextureFloatLinear = class OesTextureFloatLinear extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_gl.OesTextureFloatLinear, {
    constructors: () => ({_: [web_gl.OesTextureFloatLinear, []]})
  });
  web_gl.OesTextureFloatLinear[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('OESTextureFloatLinear')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("OESTextureFloatLinear"))];
  dart.registerExtension(dart.global.OESTextureFloatLinear, web_gl.OesTextureFloatLinear);
  web_gl.OesTextureHalfFloatLinear = class OesTextureHalfFloatLinear extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_gl.OesTextureHalfFloatLinear, {
    constructors: () => ({_: [web_gl.OesTextureHalfFloatLinear, []]})
  });
  web_gl.OesTextureHalfFloatLinear[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('OESTextureHalfFloatLinear')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("OESTextureHalfFloatLinear"))];
  dart.registerExtension(dart.global.OESTextureHalfFloatLinear, web_gl.OesTextureHalfFloatLinear);
  dart.defineExtensionNames([
    'bindVertexArray',
    'createVertexArray',
    'deleteVertexArray',
    'isVertexArray'
  ]);
  web_gl.OesVertexArrayObject = class OesVertexArrayObject extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.bindVertexArray](arrayObject) {
      return this.bindVertexArrayOES(arrayObject);
    }
    [dartx.createVertexArray]() {
      return this.createVertexArrayOES();
    }
    [dartx.deleteVertexArray](arrayObject) {
      return this.deleteVertexArrayOES(arrayObject);
    }
    [dartx.isVertexArray](arrayObject) {
      return this.isVertexArrayOES(arrayObject);
    }
  };
  dart.setSignature(web_gl.OesVertexArrayObject, {
    constructors: () => ({_: [web_gl.OesVertexArrayObject, []]}),
    methods: () => ({
      [dartx.bindVertexArray]: [dart.void, [web_gl.VertexArrayObject]],
      [dartx.createVertexArray]: [web_gl.VertexArrayObject, []],
      [dartx.deleteVertexArray]: [dart.void, [web_gl.VertexArrayObject]],
      [dartx.isVertexArray]: [core.bool, [web_gl.VertexArrayObject]]
    })
  });
  web_gl.OesVertexArrayObject[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('OESVertexArrayObject')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("OESVertexArrayObject"))];
  web_gl.OesVertexArrayObject.VERTEX_ARRAY_BINDING_OES = 34229;
  dart.registerExtension(dart.global.OESVertexArrayObject, web_gl.OesVertexArrayObject);
  web_gl.Program = class Program extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_gl.Program, {
    constructors: () => ({_: [web_gl.Program, []]})
  });
  web_gl.Program[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('WebGLProgram')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("WebGLProgram"))];
  dart.registerExtension(dart.global.WebGLProgram, web_gl.Program);
  web_gl.Renderbuffer = class Renderbuffer extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_gl.Renderbuffer, {
    constructors: () => ({_: [web_gl.Renderbuffer, []]})
  });
  web_gl.Renderbuffer[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('WebGLRenderbuffer')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("WebGLRenderbuffer"))];
  dart.registerExtension(dart.global.WebGLRenderbuffer, web_gl.Renderbuffer);
  web_gl.Shader = class Shader extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_gl.Shader, {
    constructors: () => ({_: [web_gl.Shader, []]})
  });
  web_gl.Shader[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('WebGLShader')), dart.const(new _js_helper.Native("WebGLShader"))];
  dart.registerExtension(dart.global.WebGLShader, web_gl.Shader);
  dart.defineExtensionNames([
    'precision',
    'rangeMax',
    'rangeMin'
  ]);
  web_gl.ShaderPrecisionFormat = class ShaderPrecisionFormat extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.precision]() {
      return this.precision;
    }
    get [dartx.rangeMax]() {
      return this.rangeMax;
    }
    get [dartx.rangeMin]() {
      return this.rangeMin;
    }
  };
  dart.setSignature(web_gl.ShaderPrecisionFormat, {
    constructors: () => ({_: [web_gl.ShaderPrecisionFormat, []]})
  });
  web_gl.ShaderPrecisionFormat[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('WebGLShaderPrecisionFormat')), dart.const(new _js_helper.Native("WebGLShaderPrecisionFormat"))];
  dart.registerExtension(dart.global.WebGLShaderPrecisionFormat, web_gl.ShaderPrecisionFormat);
  web_gl.Texture = class Texture extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_gl.Texture, {
    constructors: () => ({_: [web_gl.Texture, []]})
  });
  web_gl.Texture[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('WebGLTexture')), dart.const(new _js_helper.Native("WebGLTexture"))];
  dart.registerExtension(dart.global.WebGLTexture, web_gl.Texture);
  web_gl.UniformLocation = class UniformLocation extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_gl.UniformLocation, {
    constructors: () => ({_: [web_gl.UniformLocation, []]})
  });
  web_gl.UniformLocation[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('WebGLUniformLocation')), dart.const(new _js_helper.Native("WebGLUniformLocation"))];
  dart.registerExtension(dart.global.WebGLUniformLocation, web_gl.UniformLocation);
  web_gl.VertexArrayObject = class VertexArrayObject extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_gl.VertexArrayObject, {
    constructors: () => ({_: [web_gl.VertexArrayObject, []]})
  });
  web_gl.VertexArrayObject[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('WebGLVertexArrayObjectOES')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("WebGLVertexArrayObjectOES"))];
  dart.registerExtension(dart.global.WebGLVertexArrayObjectOES, web_gl.VertexArrayObject);
  web_gl._WebGLRenderingContextBase = class _WebGLRenderingContextBase extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  };
  dart.setSignature(web_gl._WebGLRenderingContextBase, {
    constructors: () => ({_: [web_gl._WebGLRenderingContextBase, []]})
  });
  web_gl._WebGLRenderingContextBase[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('WebGLRenderingContextBase')), dart.const(new _metadata.Experimental())];
  web_sql.SqlStatementCallback = dart.typedef('SqlStatementCallback', () => dart.functionType(dart.void, [web_sql.SqlTransaction, web_sql.SqlResultSet]));
  web_sql.SqlStatementErrorCallback = dart.typedef('SqlStatementErrorCallback', () => dart.functionType(dart.void, [web_sql.SqlTransaction, web_sql.SqlError]));
  web_sql.SqlTransactionCallback = dart.typedef('SqlTransactionCallback', () => dart.functionType(dart.void, [web_sql.SqlTransaction]));
  web_sql.SqlTransactionErrorCallback = dart.typedef('SqlTransactionErrorCallback', () => dart.functionType(dart.void, [web_sql.SqlError]));
  dart.defineExtensionNames([
    'changeVersion',
    'readTransaction',
    'transaction',
    'version'
  ]);
  web_sql.SqlDatabase = class SqlDatabase extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static get supported() {
      return !!window.openDatabase;
    }
    get [dartx.version]() {
      return this.version;
    }
    [dartx.changeVersion](oldVersion, newVersion, callback, errorCallback, successCallback) {
      return this.changeVersion(oldVersion, newVersion, callback, errorCallback, successCallback);
    }
    [dartx.readTransaction](callback, errorCallback, successCallback) {
      return this.readTransaction(callback, errorCallback, successCallback);
    }
    [dartx.transaction](callback, errorCallback, successCallback) {
      return this.transaction(callback, errorCallback, successCallback);
    }
  };
  dart.setSignature(web_sql.SqlDatabase, {
    constructors: () => ({_: [web_sql.SqlDatabase, []]}),
    methods: () => ({
      [dartx.changeVersion]: [dart.void, [core.String, core.String], [web_sql.SqlTransactionCallback, web_sql.SqlTransactionErrorCallback, html$.VoidCallback]],
      [dartx.readTransaction]: [dart.void, [web_sql.SqlTransactionCallback], [web_sql.SqlTransactionErrorCallback, html$.VoidCallback]],
      [dartx.transaction]: [dart.void, [web_sql.SqlTransactionCallback], [web_sql.SqlTransactionErrorCallback, html$.VoidCallback]]
    })
  });
  web_sql.SqlDatabase[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Database')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Experimental()), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("Database"))];
  dart.registerExtension(dart.global.Database, web_sql.SqlDatabase);
  dart.defineExtensionNames([
    'code',
    'message'
  ]);
  web_sql.SqlError = class SqlError extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.code]() {
      return this.code;
    }
    get [dartx.message]() {
      return this.message;
    }
  };
  dart.setSignature(web_sql.SqlError, {
    constructors: () => ({_: [web_sql.SqlError, []]})
  });
  web_sql.SqlError[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SQLError')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("SQLError"))];
  web_sql.SqlError.CONSTRAINT_ERR = 6;
  web_sql.SqlError.DATABASE_ERR = 1;
  web_sql.SqlError.QUOTA_ERR = 4;
  web_sql.SqlError.SYNTAX_ERR = 5;
  web_sql.SqlError.TIMEOUT_ERR = 7;
  web_sql.SqlError.TOO_LARGE_ERR = 3;
  web_sql.SqlError.UNKNOWN_ERR = 0;
  web_sql.SqlError.VERSION_ERR = 2;
  dart.registerExtension(dart.global.SQLError, web_sql.SqlError);
  dart.defineExtensionNames([
    'insertId',
    'rows',
    'rowsAffected'
  ]);
  web_sql.SqlResultSet = class SqlResultSet extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.insertId]() {
      return this.insertId;
    }
    get [dartx.rows]() {
      return this.rows;
    }
    get [dartx.rowsAffected]() {
      return this.rowsAffected;
    }
  };
  dart.setSignature(web_sql.SqlResultSet, {
    constructors: () => ({_: [web_sql.SqlResultSet, []]})
  });
  web_sql.SqlResultSet[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SQLResultSet')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("SQLResultSet"))];
  dart.registerExtension(dart.global.SQLResultSet, web_sql.SqlResultSet);
  const _item_1 = Symbol('_item_1');
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'item'
  ]);
  web_sql.SqlResultSetRowList = class SqlResultSetRowList extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(core.Map), html$.ImmutableListMixin$(core.Map)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return this[dartx.item](index);
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return this[0];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return this[dart.notNull(len) - 1];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return this[0];
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [dartx.item](index) {
      return html_common.convertNativeToDart_Dictionary(this[_item_1](index));
    }
    [_item_1](index) {
      return this.item(index);
    }
  };
  web_sql.SqlResultSetRowList[dart.implements] = () => [core.List$(core.Map)];
  dart.setSignature(web_sql.SqlResultSetRowList, {
    constructors: () => ({_: [web_sql.SqlResultSetRowList, []]}),
    methods: () => ({
      [dartx.get]: [core.Map, [core.int]],
      [dartx.set]: [dart.void, [core.int, core.Map]],
      [dartx.elementAt]: [core.Map, [core.int]],
      [dartx.item]: [core.Map, [core.int]],
      [_item_1]: [dart.dynamic, [dart.dynamic]]
    })
  });
  web_sql.SqlResultSetRowList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SQLResultSetRowList')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("SQLResultSetRowList"))];
  dart.registerExtension(dart.global.SQLResultSetRowList, web_sql.SqlResultSetRowList);
  dart.defineExtensionNames([
    'executeSql'
  ]);
  web_sql.SqlTransaction = class SqlTransaction extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.executeSql](sqlStatement, arguments$, callback, errorCallback) {
      return this.executeSql(sqlStatement, arguments$, callback, errorCallback);
    }
  };
  dart.setSignature(web_sql.SqlTransaction, {
    constructors: () => ({_: [web_sql.SqlTransaction, []]}),
    methods: () => ({[dartx.executeSql]: [dart.void, [core.String, core.List$(core.Object)], [web_sql.SqlStatementCallback, web_sql.SqlStatementErrorCallback]]})
  });
  web_sql.SqlTransaction[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SQLTransaction')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Experimental()), core.deprecated, dart.const(new _js_helper.Native("SQLTransaction"))];
  dart.registerExtension(dart.global.SQLTransaction, web_sql.SqlTransaction);
  // Exports:
  exports.dart = dart;
  exports.dartx = dartx;
  exports._debugger = _debugger;
  exports._foreign_helper = _foreign_helper;
  exports._interceptors = _interceptors;
  exports._internal = _internal;
  exports._isolate_helper = _isolate_helper;
  exports._js_embedded_names = _js_embedded_names;
  exports._js_helper = _js_helper;
  exports._js_mirrors = _js_mirrors;
  exports._js_primitives = _js_primitives;
  exports._metadata = _metadata;
  exports._native_typed_data = _native_typed_data;
  exports.async = async;
  exports.collection = collection;
  exports.convert = convert;
  exports.core = core;
  exports.isolate = isolate;
  exports.js = js;
  exports.math = math;
  exports.mirrors = mirrors;
  exports.typed_data = typed_data;
  exports.indexed_db = indexed_db;
  exports.html = html$;
  exports.html_common = html_common;
  exports.svg = svg$;
  exports.web_audio = web_audio;
  exports.web_gl = web_gl;
  exports.web_sql = web_sql;
});
